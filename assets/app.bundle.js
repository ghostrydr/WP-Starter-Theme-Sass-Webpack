/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 1);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

eval("/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\nmodule.exports = function(src) {\r\n\tif (typeof execScript !== \"undefined\")\r\n\t\texecScript(src);\r\n\telse\r\n\t\teval.call(null, src);\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2NyaXB0LWxvYWRlci9hZGRTY3JpcHQuanM/M2ZlNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihzcmMpIHtcclxuXHRpZiAodHlwZW9mIGV4ZWNTY3JpcHQgIT09IFwidW5kZWZpbmVkXCIpXHJcblx0XHRleGVjU2NyaXB0KHNyYyk7XHJcblx0ZWxzZVxyXG5cdFx0ZXZhbC5jYWxsKG51bGwsIHNyYyk7XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvc2NyaXB0LWxvYWRlci9hZGRTY3JpcHQuanNcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///0\n");

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("__webpack_require__(2);__webpack_require__(4);var _app=__webpack_require__(6);var _app2=_interopRequireDefault(_app);__webpack_require__(7);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}// Foundation init\n// Import the apps styles\n// Import Foundation \n$(function(){$(document).foundation();});// Import our modules//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9hcHAuanM/Yzk5ZSJdLCJuYW1lcyI6WyIkIiwiZG9jdW1lbnQiLCJmb3VuZGF0aW9uIl0sIm1hcHBpbmdzIjoiQUFDQSx1QkFDQSx1QkFHQSxnQyx1Q0FHQSx1QixtRkFFQTtBQU5BO0FBSkE7QUFXQUEsRUFBRSxVQUFXLENBQ1hBLEVBQUVDLFFBQUYsRUFBWUMsVUFBWixHQUNELENBRkQsRUFKQSIsImZpbGUiOiIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gSW1wb3J0IEZvdW5kYXRpb24gXG5pbXBvcnQgJ3NjcmlwdC1sb2FkZXIhd2hhdC1pbnB1dC9kaXN0L3doYXQtaW5wdXQnO1xuaW1wb3J0ICdzY3JpcHQtbG9hZGVyIWZvdW5kYXRpb24tc2l0ZXMvZGlzdC9qcy9mb3VuZGF0aW9uJztcblxuLy8gSW1wb3J0IHRoZSBhcHBzIHN0eWxlc1xuaW1wb3J0IHNhc3MgZnJvbSAnLi4vc2Nzcy9hcHAuc2NzcydcblxuLy8gSW1wb3J0IG91ciBtb2R1bGVzXG5pbXBvcnQgJy4vbW9kdWxlcy9faGVhZGVyLmpzJ1xuXG4vLyBGb3VuZGF0aW9uIGluaXRcbiQoZnVuY3Rpb24oKSB7XG4gICQoZG9jdW1lbnQpLmZvdW5kYXRpb24oKTtcbn0pO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2pzL2FwcC5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1\n");

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

eval("__webpack_require__(0)(__webpack_require__(3))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvd2hhdC1pbnB1dC9kaXN0L3doYXQtaW5wdXQuanM/OGYyYiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIyLmpzIiwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZShcIiEhL1VzZXJzL1NhbURhdmlkb2ZmL0Rlc2t0b3AvV1AtU3RhcnRlci1UaGVtZS1TYXNzLVdlYnBhY2svc3JjL25vZGVfbW9kdWxlcy9zY3JpcHQtbG9hZGVyL2FkZFNjcmlwdC5qc1wiKShyZXF1aXJlKFwiISEvVXNlcnMvU2FtRGF2aWRvZmYvRGVza3RvcC9XUC1TdGFydGVyLVRoZW1lLVNhc3MtV2VicGFjay9zcmMvbm9kZV9tb2R1bGVzL3Jhdy1sb2FkZXIvaW5kZXguanMhL1VzZXJzL1NhbURhdmlkb2ZmL0Rlc2t0b3AvV1AtU3RhcnRlci1UaGVtZS1TYXNzLVdlYnBhY2svc3JjL25vZGVfbW9kdWxlcy93aGF0LWlucHV0L2Rpc3Qvd2hhdC1pbnB1dC5qc1wiKSlcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9zY3JpcHQtbG9hZGVyIS4vbm9kZV9tb2R1bGVzL3doYXQtaW5wdXQvZGlzdC93aGF0LWlucHV0LmpzXG4vLyBtb2R1bGUgaWQgPSAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2\n");

/***/ }),
/* 3 */
/***/ (function(module, exports) {

eval("module.exports = \"/**\\n * what-input - A global utility for tracking the current input method (mouse, keyboard or touch).\\n * @version v4.3.0\\n * @link https://github.com/ten1seven/what-input\\n * @license MIT\\n */\\n(function webpackUniversalModuleDefinition(root, factory) {\\n\\tif(typeof exports === 'object' && typeof module === 'object')\\n\\t\\tmodule.exports = factory();\\n\\telse if(typeof define === 'function' && define.amd)\\n\\t\\tdefine(\\\"whatInput\\\", [], factory);\\n\\telse if(typeof exports === 'object')\\n\\t\\texports[\\\"whatInput\\\"] = factory();\\n\\telse\\n\\t\\troot[\\\"whatInput\\\"] = factory();\\n})(this, function() {\\nreturn /******/ (function(modules) { // webpackBootstrap\\n/******/ \\t// The module cache\\n/******/ \\tvar installedModules = {};\\n\\n/******/ \\t// The require function\\n/******/ \\tfunction __webpack_require__(moduleId) {\\n\\n/******/ \\t\\t// Check if module is in cache\\n/******/ \\t\\tif(installedModules[moduleId])\\n/******/ \\t\\t\\treturn installedModules[moduleId].exports;\\n\\n/******/ \\t\\t// Create a new module (and put it into the cache)\\n/******/ \\t\\tvar module = installedModules[moduleId] = {\\n/******/ \\t\\t\\texports: {},\\n/******/ \\t\\t\\tid: moduleId,\\n/******/ \\t\\t\\tloaded: false\\n/******/ \\t\\t};\\n\\n/******/ \\t\\t// Execute the module function\\n/******/ \\t\\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\\n\\n/******/ \\t\\t// Flag the module as loaded\\n/******/ \\t\\tmodule.loaded = true;\\n\\n/******/ \\t\\t// Return the exports of the module\\n/******/ \\t\\treturn module.exports;\\n/******/ \\t}\\n\\n\\n/******/ \\t// expose the modules object (__webpack_modules__)\\n/******/ \\t__webpack_require__.m = modules;\\n\\n/******/ \\t// expose the module cache\\n/******/ \\t__webpack_require__.c = installedModules;\\n\\n/******/ \\t// __webpack_public_path__\\n/******/ \\t__webpack_require__.p = \\\"\\\";\\n\\n/******/ \\t// Load entry module and return exports\\n/******/ \\treturn __webpack_require__(0);\\n/******/ })\\n/************************************************************************/\\n/******/ ([\\n/* 0 */\\n/***/ (function(module, exports) {\\n\\n\\t'use strict';\\n\\n\\tmodule.exports = function () {\\n\\t  /*\\n\\t   * variables\\n\\t   */\\n\\n\\t  // last used input type\\n\\t  var currentInput = 'initial';\\n\\n\\t  // last used input intent\\n\\t  var currentIntent = null;\\n\\n\\t  // cache document.documentElement\\n\\t  var doc = document.documentElement;\\n\\n\\t  // form input types\\n\\t  var formInputs = ['input', 'select', 'textarea'];\\n\\n\\t  var functionList = [];\\n\\n\\t  // list of modifier keys commonly used with the mouse and\\n\\t  // can be safely ignored to prevent false keyboard detection\\n\\t  var ignoreMap = [16, // shift\\n\\t  17, // control\\n\\t  18, // alt\\n\\t  91, // Windows key / left Apple cmd\\n\\t  93 // Windows menu / right Apple cmd\\n\\t  ];\\n\\n\\t  // list of keys for which we change intent even for form inputs\\n\\t  var changeIntentMap = [9 // tab\\n\\t  ];\\n\\n\\t  // mapping of events to input types\\n\\t  var inputMap = {\\n\\t    keydown: 'keyboard',\\n\\t    keyup: 'keyboard',\\n\\t    mousedown: 'mouse',\\n\\t    mousemove: 'mouse',\\n\\t    MSPointerDown: 'pointer',\\n\\t    MSPointerMove: 'pointer',\\n\\t    pointerdown: 'pointer',\\n\\t    pointermove: 'pointer',\\n\\t    touchstart: 'touch'\\n\\t  };\\n\\n\\t  // array of all used input types\\n\\t  var inputTypes = [];\\n\\n\\t  // boolean: true if touch buffer is active\\n\\t  var isBuffering = false;\\n\\n\\t  // boolean: true if the page is being scrolled\\n\\t  var isScrolling = false;\\n\\n\\t  // store current mouse position\\n\\t  var mousePos = {\\n\\t    x: null,\\n\\t    y: null\\n\\t  };\\n\\n\\t  // map of IE 10 pointer events\\n\\t  var pointerMap = {\\n\\t    2: 'touch',\\n\\t    3: 'touch', // treat pen like touch\\n\\t    4: 'mouse'\\n\\t  };\\n\\n\\t  var supportsPassive = false;\\n\\n\\t  try {\\n\\t    var opts = Object.defineProperty({}, 'passive', {\\n\\t      get: function get() {\\n\\t        supportsPassive = true;\\n\\t      }\\n\\t    });\\n\\n\\t    window.addEventListener('test', null, opts);\\n\\t  } catch (e) {}\\n\\n\\t  /*\\n\\t   * set up\\n\\t   */\\n\\n\\t  var setUp = function setUp() {\\n\\t    // add correct mouse wheel event mapping to `inputMap`\\n\\t    inputMap[detectWheel()] = 'mouse';\\n\\n\\t    addListeners();\\n\\t    setInput();\\n\\t  };\\n\\n\\t  /*\\n\\t   * events\\n\\t   */\\n\\n\\t  var addListeners = function addListeners() {\\n\\t    // `pointermove`, `MSPointerMove`, `mousemove` and mouse wheel event binding\\n\\t    // can only demonstrate potential, but not actual, interaction\\n\\t    // and are treated separately\\n\\n\\t    // pointer events (mouse, pen, touch)\\n\\t    if (window.PointerEvent) {\\n\\t      doc.addEventListener('pointerdown', updateInput);\\n\\t      doc.addEventListener('pointermove', setIntent);\\n\\t    } else if (window.MSPointerEvent) {\\n\\t      doc.addEventListener('MSPointerDown', updateInput);\\n\\t      doc.addEventListener('MSPointerMove', setIntent);\\n\\t    } else {\\n\\t      // mouse events\\n\\t      doc.addEventListener('mousedown', updateInput);\\n\\t      doc.addEventListener('mousemove', setIntent);\\n\\n\\t      // touch events\\n\\t      if ('ontouchstart' in window) {\\n\\t        doc.addEventListener('touchstart', touchBuffer);\\n\\t        doc.addEventListener('touchend', touchBuffer);\\n\\t      }\\n\\t    }\\n\\n\\t    // mouse wheel\\n\\t    doc.addEventListener(detectWheel(), setIntent, supportsPassive ? { passive: true } : false);\\n\\n\\t    // keyboard events\\n\\t    doc.addEventListener('keydown', updateInput);\\n\\t    doc.addEventListener('keyup', updateInput);\\n\\t  };\\n\\n\\t  // checks conditions before updating new input\\n\\t  var updateInput = function updateInput(event) {\\n\\t    // only execute if the touch buffer timer isn't running\\n\\t    if (!isBuffering) {\\n\\t      var eventKey = event.which;\\n\\t      var value = inputMap[event.type];\\n\\t      if (value === 'pointer') value = pointerType(event);\\n\\n\\t      if (currentInput !== value || currentIntent !== value) {\\n\\t        var activeElem = document.activeElement;\\n\\t        var activeInput = false;\\n\\t        var notFormInput = activeElem && activeElem.nodeName && formInputs.indexOf(activeElem.nodeName.toLowerCase()) === -1;\\n\\n\\t        if (notFormInput || changeIntentMap.indexOf(eventKey) !== -1) {\\n\\t          activeInput = true;\\n\\t        }\\n\\n\\t        if (value === 'touch' ||\\n\\t        // ignore mouse modifier keys\\n\\t        value === 'mouse' ||\\n\\t        // don't switch if the current element is a form input\\n\\t        value === 'keyboard' && eventKey && activeInput && ignoreMap.indexOf(eventKey) === -1) {\\n\\t          // set the current and catch-all variable\\n\\t          currentInput = currentIntent = value;\\n\\n\\t          setInput();\\n\\t        }\\n\\t      }\\n\\t    }\\n\\t  };\\n\\n\\t  // updates the doc and `inputTypes` array with new input\\n\\t  var setInput = function setInput() {\\n\\t    doc.setAttribute('data-whatinput', currentInput);\\n\\t    doc.setAttribute('data-whatintent', currentInput);\\n\\n\\t    if (inputTypes.indexOf(currentInput) === -1) {\\n\\t      inputTypes.push(currentInput);\\n\\t      doc.className += ' whatinput-types-' + currentInput;\\n\\t    }\\n\\n\\t    fireFunctions('input');\\n\\t  };\\n\\n\\t  // updates input intent for `mousemove` and `pointermove`\\n\\t  var setIntent = function setIntent(event) {\\n\\t    // test to see if `mousemove` happened relative to the screen\\n\\t    // to detect scrolling versus mousemove\\n\\t    if (mousePos['x'] !== event.screenX || mousePos['y'] !== event.screenY) {\\n\\t      isScrolling = false;\\n\\n\\t      mousePos['x'] = event.screenX;\\n\\t      mousePos['y'] = event.screenY;\\n\\t    } else {\\n\\t      isScrolling = true;\\n\\t    }\\n\\n\\t    // only execute if the touch buffer timer isn't running\\n\\t    // or scrolling isn't happening\\n\\t    if (!isBuffering && !isScrolling) {\\n\\t      var value = inputMap[event.type];\\n\\t      if (value === 'pointer') value = pointerType(event);\\n\\n\\t      if (currentIntent !== value) {\\n\\t        currentIntent = value;\\n\\n\\t        doc.setAttribute('data-whatintent', currentIntent);\\n\\n\\t        fireFunctions('intent');\\n\\t      }\\n\\t    }\\n\\t  };\\n\\n\\t  // buffers touch events because they frequently also fire mouse events\\n\\t  var touchBuffer = function touchBuffer(event) {\\n\\t    if (event.type === 'touchstart') {\\n\\t      isBuffering = false;\\n\\n\\t      // set the current input\\n\\t      updateInput(event);\\n\\t    } else {\\n\\t      isBuffering = true;\\n\\t    }\\n\\t  };\\n\\n\\t  var fireFunctions = function fireFunctions(type) {\\n\\t    for (var i = 0, len = functionList.length; i < len; i++) {\\n\\t      if (functionList[i].type === type) {\\n\\t        functionList[i].fn.call(undefined, currentIntent);\\n\\t      }\\n\\t    }\\n\\t  };\\n\\n\\t  /*\\n\\t   * utilities\\n\\t   */\\n\\n\\t  var pointerType = function pointerType(event) {\\n\\t    if (typeof event.pointerType === 'number') {\\n\\t      return pointerMap[event.pointerType];\\n\\t    } else {\\n\\t      // treat pen like touch\\n\\t      return event.pointerType === 'pen' ? 'touch' : event.pointerType;\\n\\t    }\\n\\t  };\\n\\n\\t  // detect version of mouse wheel event to use\\n\\t  // via https://developer.mozilla.org/en-US/docs/Web/Events/wheel\\n\\t  var detectWheel = function detectWheel() {\\n\\t    var wheelType = void 0;\\n\\n\\t    // Modern browsers support \\\"wheel\\\"\\n\\t    if ('onwheel' in document.createElement('div')) {\\n\\t      wheelType = 'wheel';\\n\\t    } else {\\n\\t      // Webkit and IE support at least \\\"mousewheel\\\"\\n\\t      // or assume that remaining browsers are older Firefox\\n\\t      wheelType = document.onmousewheel !== undefined ? 'mousewheel' : 'DOMMouseScroll';\\n\\t    }\\n\\n\\t    return wheelType;\\n\\t  };\\n\\n\\t  var objPos = function objPos(match) {\\n\\t    for (var i = 0, len = functionList.length; i < len; i++) {\\n\\t      if (functionList[i].fn === match) {\\n\\t        return i;\\n\\t      }\\n\\t    }\\n\\t  };\\n\\n\\t  /*\\n\\t   * init\\n\\t   */\\n\\n\\t  // don't start script unless browser cuts the mustard\\n\\t  // (also passes if polyfills are used)\\n\\t  if ('addEventListener' in window && Array.prototype.indexOf) {\\n\\t    setUp();\\n\\t  }\\n\\n\\t  /*\\n\\t   * api\\n\\t   */\\n\\n\\t  return {\\n\\t    // returns string: the current input type\\n\\t    // opt: 'loose'|'strict'\\n\\t    // 'strict' (default): returns the same value as the `data-whatinput` attribute\\n\\t    // 'loose': includes `data-whatintent` value if it's more current than `data-whatinput`\\n\\t    ask: function ask(opt) {\\n\\t      return opt === 'loose' ? currentIntent : currentInput;\\n\\t    },\\n\\n\\t    // returns array: all the detected input types\\n\\t    types: function types() {\\n\\t      return inputTypes;\\n\\t    },\\n\\n\\t    // overwrites ignored keys with provided array\\n\\t    ignoreKeys: function ignoreKeys(arr) {\\n\\t      ignoreMap = arr;\\n\\t    },\\n\\n\\t    // attach functions to input and intent \\\"events\\\"\\n\\t    // funct: function to fire on change\\n\\t    // eventType: 'input'|'intent'\\n\\t    registerOnChange: function registerOnChange(fn, eventType) {\\n\\t      functionList.push({\\n\\t        fn: fn,\\n\\t        type: eventType || 'input'\\n\\t      });\\n\\t    },\\n\\n\\t    unRegisterOnChange: function unRegisterOnChange(fn) {\\n\\t      var position = objPos(fn);\\n\\n\\t      if (position) {\\n\\t        functionList.splice(position, 1);\\n\\t      }\\n\\t    }\\n\\t  };\\n\\t}();\\n\\n/***/ })\\n/******/ ])\\n});\\n;\"//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvd2hhdC1pbnB1dC9kaXN0L3doYXQtaW5wdXQuanM/NGYzZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxrUkFBa1Isa0dBQWtHLGdHQUFnRyxpRkFBaUYsOENBQThDLEdBQUcsb0JBQW9CLHNDQUFzQywyRkFBMkYsMkZBQTJGLHVKQUF1Siw2SEFBNkgsNEJBQTRCLDhFQUE4RSxrSkFBa0osaUZBQWlGLHlGQUF5RixjQUFjLGdIQUFnSCwrRkFBK0YsbUZBQW1GLGlHQUFpRyxZQUFZLHVJQUF1SSxtQkFBbUIsb0NBQW9DLHFHQUFxRyxnRUFBZ0Usa0ZBQWtGLGtGQUFrRiw4QkFBOEIscVNBQXFTLG9IQUFvSCxpRUFBaUUsK1FBQStRLGtFQUFrRSxnRkFBZ0Ysb0ZBQW9GLDZEQUE2RCx1Q0FBdUMsOERBQThELHdGQUF3RixvQ0FBb0MsYUFBYSwyQ0FBMkMsY0FBYywrQkFBK0IsbUNBQW1DLFdBQVcsU0FBUyxFQUFFLHNEQUFzRCxPQUFPLGFBQWEsd0VBQXdFLHdHQUF3Ryx5QkFBeUIsbUJBQW1CLFFBQVEsc0ZBQXNGLGdSQUFnUiwyREFBMkQseURBQXlELFNBQVMsa0NBQWtDLDZEQUE2RCwyREFBMkQsU0FBUyxPQUFPLGtGQUFrRix1REFBdUQsb0VBQW9FLDREQUE0RCwwREFBMEQsV0FBVyxTQUFTLGtHQUFrRyxnQkFBZ0IsVUFBVSxpRkFBaUYsbURBQW1ELFFBQVEsMkdBQTJHLDBGQUEwRixxQ0FBcUMsMkNBQTJDLDhEQUE4RCxvRUFBb0Usb0RBQW9ELG9DQUFvQyxpSUFBaUksNkVBQTZFLGlDQUFpQyxhQUFhLHFSQUFxUiwwR0FBMEcsMkJBQTJCLGFBQWEsV0FBVyxTQUFTLFFBQVEsMEdBQTBHLHlEQUF5RCwwREFBMEQsd0RBQXdELHdDQUF3Qyw4REFBOEQsU0FBUyxpQ0FBaUMsUUFBUSxrSEFBa0gscU1BQXFNLDhCQUE4QiwwQ0FBMEMsd0NBQXdDLFNBQVMsT0FBTyw2QkFBNkIsU0FBUyxtSkFBbUosMkNBQTJDLDhEQUE4RCwwQ0FBMEMsa0NBQWtDLGlFQUFpRSxzQ0FBc0MsV0FBVyxTQUFTLFFBQVEsbUlBQW1JLDBDQUEwQyw4QkFBOEIsaUVBQWlFLFNBQVMsT0FBTyw2QkFBNkIsU0FBUyxRQUFRLDBEQUEwRCxrREFBa0QsU0FBUyxPQUFPLDhDQUE4Qyw4REFBOEQsV0FBVyxTQUFTLFFBQVEsNEZBQTRGLG9EQUFvRCwrQ0FBK0MsU0FBUyxPQUFPLDRHQUE0RyxTQUFTLFFBQVEsMktBQTJLLCtCQUErQix1R0FBdUcsOEJBQThCLFNBQVMsT0FBTyxzTkFBc04sU0FBUywyQkFBMkIsUUFBUSw2Q0FBNkMsa0RBQWtELFNBQVMsT0FBTyw2Q0FBNkMscUJBQXFCLFdBQVcsU0FBUyxRQUFRLDZNQUE2TSxnQkFBZ0IsT0FBTywrQ0FBK0MsdVNBQXVTLGdFQUFnRSxTQUFTLDBGQUEwRiw0QkFBNEIsU0FBUyx1R0FBdUcsMEJBQTBCLFNBQVMsbU5BQW1OLDZCQUE2QixvRUFBb0UsRUFBRSxTQUFTLGdFQUFnRSxvQ0FBb0MsMkJBQTJCLDZDQUE2QyxXQUFXLFNBQVMsUUFBUSxLQUFLLEdBQUcsV0FBVyxpQkFBaUIsRUFBRSxHQUFHIiwiZmlsZSI6IjMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiLyoqXFxuICogd2hhdC1pbnB1dCAtIEEgZ2xvYmFsIHV0aWxpdHkgZm9yIHRyYWNraW5nIHRoZSBjdXJyZW50IGlucHV0IG1ldGhvZCAobW91c2UsIGtleWJvYXJkIG9yIHRvdWNoKS5cXG4gKiBAdmVyc2lvbiB2NC4zLjBcXG4gKiBAbGluayBodHRwczovL2dpdGh1Yi5jb20vdGVuMXNldmVuL3doYXQtaW5wdXRcXG4gKiBAbGljZW5zZSBNSVRcXG4gKi9cXG4oZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xcblxcdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JylcXG5cXHRcXHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcXG5cXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcXG5cXHRcXHRkZWZpbmUoXFxcIndoYXRJbnB1dFxcXCIsIFtdLCBmYWN0b3J5KTtcXG5cXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JylcXG5cXHRcXHRleHBvcnRzW1xcXCJ3aGF0SW5wdXRcXFwiXSA9IGZhY3RvcnkoKTtcXG5cXHRlbHNlXFxuXFx0XFx0cm9vdFtcXFwid2hhdElucHV0XFxcIl0gPSBmYWN0b3J5KCk7XFxufSkodGhpcywgZnVuY3Rpb24oKSB7XFxucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcXG4vKioqKioqLyBcXHQvLyBUaGUgbW9kdWxlIGNhY2hlXFxuLyoqKioqKi8gXFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcXG5cXG4vKioqKioqLyBcXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxcbi8qKioqKiovIFxcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcXG5cXG4vKioqKioqLyBcXHRcXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcXG4vKioqKioqLyBcXHRcXHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcXG4vKioqKioqLyBcXHRcXHRcXHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcXG5cXG4vKioqKioqLyBcXHRcXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxcbi8qKioqKiovIFxcdFxcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcXG4vKioqKioqLyBcXHRcXHRcXHRleHBvcnRzOiB7fSxcXG4vKioqKioqLyBcXHRcXHRcXHRpZDogbW9kdWxlSWQsXFxuLyoqKioqKi8gXFx0XFx0XFx0bG9hZGVkOiBmYWxzZVxcbi8qKioqKiovIFxcdFxcdH07XFxuXFxuLyoqKioqKi8gXFx0XFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXFxuLyoqKioqKi8gXFx0XFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XFxuXFxuLyoqKioqKi8gXFx0XFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxcbi8qKioqKiovIFxcdFxcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xcblxcbi8qKioqKiovIFxcdFxcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXFxuLyoqKioqKi8gXFx0XFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xcbi8qKioqKiovIFxcdH1cXG5cXG5cXG4vKioqKioqLyBcXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxcbi8qKioqKiovIFxcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XFxuXFxuLyoqKioqKi8gXFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcXG4vKioqKioqLyBcXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xcblxcbi8qKioqKiovIFxcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXFxuLyoqKioqKi8gXFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXFxcIlxcXCI7XFxuXFxuLyoqKioqKi8gXFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXFxuLyoqKioqKi8gXFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XFxuLyoqKioqKi8gfSlcXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qKioqKiovIChbXFxuLyogMCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcXG5cXG5cXHQndXNlIHN0cmljdCc7XFxuXFxuXFx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XFxuXFx0ICAvKlxcblxcdCAgICogdmFyaWFibGVzXFxuXFx0ICAgKi9cXG5cXG5cXHQgIC8vIGxhc3QgdXNlZCBpbnB1dCB0eXBlXFxuXFx0ICB2YXIgY3VycmVudElucHV0ID0gJ2luaXRpYWwnO1xcblxcblxcdCAgLy8gbGFzdCB1c2VkIGlucHV0IGludGVudFxcblxcdCAgdmFyIGN1cnJlbnRJbnRlbnQgPSBudWxsO1xcblxcblxcdCAgLy8gY2FjaGUgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50XFxuXFx0ICB2YXIgZG9jID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xcblxcblxcdCAgLy8gZm9ybSBpbnB1dCB0eXBlc1xcblxcdCAgdmFyIGZvcm1JbnB1dHMgPSBbJ2lucHV0JywgJ3NlbGVjdCcsICd0ZXh0YXJlYSddO1xcblxcblxcdCAgdmFyIGZ1bmN0aW9uTGlzdCA9IFtdO1xcblxcblxcdCAgLy8gbGlzdCBvZiBtb2RpZmllciBrZXlzIGNvbW1vbmx5IHVzZWQgd2l0aCB0aGUgbW91c2UgYW5kXFxuXFx0ICAvLyBjYW4gYmUgc2FmZWx5IGlnbm9yZWQgdG8gcHJldmVudCBmYWxzZSBrZXlib2FyZCBkZXRlY3Rpb25cXG5cXHQgIHZhciBpZ25vcmVNYXAgPSBbMTYsIC8vIHNoaWZ0XFxuXFx0ICAxNywgLy8gY29udHJvbFxcblxcdCAgMTgsIC8vIGFsdFxcblxcdCAgOTEsIC8vIFdpbmRvd3Mga2V5IC8gbGVmdCBBcHBsZSBjbWRcXG5cXHQgIDkzIC8vIFdpbmRvd3MgbWVudSAvIHJpZ2h0IEFwcGxlIGNtZFxcblxcdCAgXTtcXG5cXG5cXHQgIC8vIGxpc3Qgb2Yga2V5cyBmb3Igd2hpY2ggd2UgY2hhbmdlIGludGVudCBldmVuIGZvciBmb3JtIGlucHV0c1xcblxcdCAgdmFyIGNoYW5nZUludGVudE1hcCA9IFs5IC8vIHRhYlxcblxcdCAgXTtcXG5cXG5cXHQgIC8vIG1hcHBpbmcgb2YgZXZlbnRzIHRvIGlucHV0IHR5cGVzXFxuXFx0ICB2YXIgaW5wdXRNYXAgPSB7XFxuXFx0ICAgIGtleWRvd246ICdrZXlib2FyZCcsXFxuXFx0ICAgIGtleXVwOiAna2V5Ym9hcmQnLFxcblxcdCAgICBtb3VzZWRvd246ICdtb3VzZScsXFxuXFx0ICAgIG1vdXNlbW92ZTogJ21vdXNlJyxcXG5cXHQgICAgTVNQb2ludGVyRG93bjogJ3BvaW50ZXInLFxcblxcdCAgICBNU1BvaW50ZXJNb3ZlOiAncG9pbnRlcicsXFxuXFx0ICAgIHBvaW50ZXJkb3duOiAncG9pbnRlcicsXFxuXFx0ICAgIHBvaW50ZXJtb3ZlOiAncG9pbnRlcicsXFxuXFx0ICAgIHRvdWNoc3RhcnQ6ICd0b3VjaCdcXG5cXHQgIH07XFxuXFxuXFx0ICAvLyBhcnJheSBvZiBhbGwgdXNlZCBpbnB1dCB0eXBlc1xcblxcdCAgdmFyIGlucHV0VHlwZXMgPSBbXTtcXG5cXG5cXHQgIC8vIGJvb2xlYW46IHRydWUgaWYgdG91Y2ggYnVmZmVyIGlzIGFjdGl2ZVxcblxcdCAgdmFyIGlzQnVmZmVyaW5nID0gZmFsc2U7XFxuXFxuXFx0ICAvLyBib29sZWFuOiB0cnVlIGlmIHRoZSBwYWdlIGlzIGJlaW5nIHNjcm9sbGVkXFxuXFx0ICB2YXIgaXNTY3JvbGxpbmcgPSBmYWxzZTtcXG5cXG5cXHQgIC8vIHN0b3JlIGN1cnJlbnQgbW91c2UgcG9zaXRpb25cXG5cXHQgIHZhciBtb3VzZVBvcyA9IHtcXG5cXHQgICAgeDogbnVsbCxcXG5cXHQgICAgeTogbnVsbFxcblxcdCAgfTtcXG5cXG5cXHQgIC8vIG1hcCBvZiBJRSAxMCBwb2ludGVyIGV2ZW50c1xcblxcdCAgdmFyIHBvaW50ZXJNYXAgPSB7XFxuXFx0ICAgIDI6ICd0b3VjaCcsXFxuXFx0ICAgIDM6ICd0b3VjaCcsIC8vIHRyZWF0IHBlbiBsaWtlIHRvdWNoXFxuXFx0ICAgIDQ6ICdtb3VzZSdcXG5cXHQgIH07XFxuXFxuXFx0ICB2YXIgc3VwcG9ydHNQYXNzaXZlID0gZmFsc2U7XFxuXFxuXFx0ICB0cnkge1xcblxcdCAgICB2YXIgb3B0cyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3Bhc3NpdmUnLCB7XFxuXFx0ICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XFxuXFx0ICAgICAgICBzdXBwb3J0c1Bhc3NpdmUgPSB0cnVlO1xcblxcdCAgICAgIH1cXG5cXHQgICAgfSk7XFxuXFxuXFx0ICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0JywgbnVsbCwgb3B0cyk7XFxuXFx0ICB9IGNhdGNoIChlKSB7fVxcblxcblxcdCAgLypcXG5cXHQgICAqIHNldCB1cFxcblxcdCAgICovXFxuXFxuXFx0ICB2YXIgc2V0VXAgPSBmdW5jdGlvbiBzZXRVcCgpIHtcXG5cXHQgICAgLy8gYWRkIGNvcnJlY3QgbW91c2Ugd2hlZWwgZXZlbnQgbWFwcGluZyB0byBgaW5wdXRNYXBgXFxuXFx0ICAgIGlucHV0TWFwW2RldGVjdFdoZWVsKCldID0gJ21vdXNlJztcXG5cXG5cXHQgICAgYWRkTGlzdGVuZXJzKCk7XFxuXFx0ICAgIHNldElucHV0KCk7XFxuXFx0ICB9O1xcblxcblxcdCAgLypcXG5cXHQgICAqIGV2ZW50c1xcblxcdCAgICovXFxuXFxuXFx0ICB2YXIgYWRkTGlzdGVuZXJzID0gZnVuY3Rpb24gYWRkTGlzdGVuZXJzKCkge1xcblxcdCAgICAvLyBgcG9pbnRlcm1vdmVgLCBgTVNQb2ludGVyTW92ZWAsIGBtb3VzZW1vdmVgIGFuZCBtb3VzZSB3aGVlbCBldmVudCBiaW5kaW5nXFxuXFx0ICAgIC8vIGNhbiBvbmx5IGRlbW9uc3RyYXRlIHBvdGVudGlhbCwgYnV0IG5vdCBhY3R1YWwsIGludGVyYWN0aW9uXFxuXFx0ICAgIC8vIGFuZCBhcmUgdHJlYXRlZCBzZXBhcmF0ZWx5XFxuXFxuXFx0ICAgIC8vIHBvaW50ZXIgZXZlbnRzIChtb3VzZSwgcGVuLCB0b3VjaClcXG5cXHQgICAgaWYgKHdpbmRvdy5Qb2ludGVyRXZlbnQpIHtcXG5cXHQgICAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmRvd24nLCB1cGRhdGVJbnB1dCk7XFxuXFx0ICAgICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJtb3ZlJywgc2V0SW50ZW50KTtcXG5cXHQgICAgfSBlbHNlIGlmICh3aW5kb3cuTVNQb2ludGVyRXZlbnQpIHtcXG5cXHQgICAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignTVNQb2ludGVyRG93bicsIHVwZGF0ZUlucHV0KTtcXG5cXHQgICAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignTVNQb2ludGVyTW92ZScsIHNldEludGVudCk7XFxuXFx0ICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgLy8gbW91c2UgZXZlbnRzXFxuXFx0ICAgICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHVwZGF0ZUlucHV0KTtcXG5cXHQgICAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgc2V0SW50ZW50KTtcXG5cXG5cXHQgICAgICAvLyB0b3VjaCBldmVudHNcXG5cXHQgICAgICBpZiAoJ29udG91Y2hzdGFydCcgaW4gd2luZG93KSB7XFxuXFx0ICAgICAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRvdWNoQnVmZmVyKTtcXG5cXHQgICAgICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRvdWNoQnVmZmVyKTtcXG5cXHQgICAgICB9XFxuXFx0ICAgIH1cXG5cXG5cXHQgICAgLy8gbW91c2Ugd2hlZWxcXG5cXHQgICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoZGV0ZWN0V2hlZWwoKSwgc2V0SW50ZW50LCBzdXBwb3J0c1Bhc3NpdmUgPyB7IHBhc3NpdmU6IHRydWUgfSA6IGZhbHNlKTtcXG5cXG5cXHQgICAgLy8ga2V5Ym9hcmQgZXZlbnRzXFxuXFx0ICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdXBkYXRlSW5wdXQpO1xcblxcdCAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB1cGRhdGVJbnB1dCk7XFxuXFx0ICB9O1xcblxcblxcdCAgLy8gY2hlY2tzIGNvbmRpdGlvbnMgYmVmb3JlIHVwZGF0aW5nIG5ldyBpbnB1dFxcblxcdCAgdmFyIHVwZGF0ZUlucHV0ID0gZnVuY3Rpb24gdXBkYXRlSW5wdXQoZXZlbnQpIHtcXG5cXHQgICAgLy8gb25seSBleGVjdXRlIGlmIHRoZSB0b3VjaCBidWZmZXIgdGltZXIgaXNuJ3QgcnVubmluZ1xcblxcdCAgICBpZiAoIWlzQnVmZmVyaW5nKSB7XFxuXFx0ICAgICAgdmFyIGV2ZW50S2V5ID0gZXZlbnQud2hpY2g7XFxuXFx0ICAgICAgdmFyIHZhbHVlID0gaW5wdXRNYXBbZXZlbnQudHlwZV07XFxuXFx0ICAgICAgaWYgKHZhbHVlID09PSAncG9pbnRlcicpIHZhbHVlID0gcG9pbnRlclR5cGUoZXZlbnQpO1xcblxcblxcdCAgICAgIGlmIChjdXJyZW50SW5wdXQgIT09IHZhbHVlIHx8IGN1cnJlbnRJbnRlbnQgIT09IHZhbHVlKSB7XFxuXFx0ICAgICAgICB2YXIgYWN0aXZlRWxlbSA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XFxuXFx0ICAgICAgICB2YXIgYWN0aXZlSW5wdXQgPSBmYWxzZTtcXG5cXHQgICAgICAgIHZhciBub3RGb3JtSW5wdXQgPSBhY3RpdmVFbGVtICYmIGFjdGl2ZUVsZW0ubm9kZU5hbWUgJiYgZm9ybUlucHV0cy5pbmRleE9mKGFjdGl2ZUVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSkgPT09IC0xO1xcblxcblxcdCAgICAgICAgaWYgKG5vdEZvcm1JbnB1dCB8fCBjaGFuZ2VJbnRlbnRNYXAuaW5kZXhPZihldmVudEtleSkgIT09IC0xKSB7XFxuXFx0ICAgICAgICAgIGFjdGl2ZUlucHV0ID0gdHJ1ZTtcXG5cXHQgICAgICAgIH1cXG5cXG5cXHQgICAgICAgIGlmICh2YWx1ZSA9PT0gJ3RvdWNoJyB8fFxcblxcdCAgICAgICAgLy8gaWdub3JlIG1vdXNlIG1vZGlmaWVyIGtleXNcXG5cXHQgICAgICAgIHZhbHVlID09PSAnbW91c2UnIHx8XFxuXFx0ICAgICAgICAvLyBkb24ndCBzd2l0Y2ggaWYgdGhlIGN1cnJlbnQgZWxlbWVudCBpcyBhIGZvcm0gaW5wdXRcXG5cXHQgICAgICAgIHZhbHVlID09PSAna2V5Ym9hcmQnICYmIGV2ZW50S2V5ICYmIGFjdGl2ZUlucHV0ICYmIGlnbm9yZU1hcC5pbmRleE9mKGV2ZW50S2V5KSA9PT0gLTEpIHtcXG5cXHQgICAgICAgICAgLy8gc2V0IHRoZSBjdXJyZW50IGFuZCBjYXRjaC1hbGwgdmFyaWFibGVcXG5cXHQgICAgICAgICAgY3VycmVudElucHV0ID0gY3VycmVudEludGVudCA9IHZhbHVlO1xcblxcblxcdCAgICAgICAgICBzZXRJbnB1dCgpO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgIH1cXG5cXHQgICAgfVxcblxcdCAgfTtcXG5cXG5cXHQgIC8vIHVwZGF0ZXMgdGhlIGRvYyBhbmQgYGlucHV0VHlwZXNgIGFycmF5IHdpdGggbmV3IGlucHV0XFxuXFx0ICB2YXIgc2V0SW5wdXQgPSBmdW5jdGlvbiBzZXRJbnB1dCgpIHtcXG5cXHQgICAgZG9jLnNldEF0dHJpYnV0ZSgnZGF0YS13aGF0aW5wdXQnLCBjdXJyZW50SW5wdXQpO1xcblxcdCAgICBkb2Muc2V0QXR0cmlidXRlKCdkYXRhLXdoYXRpbnRlbnQnLCBjdXJyZW50SW5wdXQpO1xcblxcblxcdCAgICBpZiAoaW5wdXRUeXBlcy5pbmRleE9mKGN1cnJlbnRJbnB1dCkgPT09IC0xKSB7XFxuXFx0ICAgICAgaW5wdXRUeXBlcy5wdXNoKGN1cnJlbnRJbnB1dCk7XFxuXFx0ICAgICAgZG9jLmNsYXNzTmFtZSArPSAnIHdoYXRpbnB1dC10eXBlcy0nICsgY3VycmVudElucHV0O1xcblxcdCAgICB9XFxuXFxuXFx0ICAgIGZpcmVGdW5jdGlvbnMoJ2lucHV0Jyk7XFxuXFx0ICB9O1xcblxcblxcdCAgLy8gdXBkYXRlcyBpbnB1dCBpbnRlbnQgZm9yIGBtb3VzZW1vdmVgIGFuZCBgcG9pbnRlcm1vdmVgXFxuXFx0ICB2YXIgc2V0SW50ZW50ID0gZnVuY3Rpb24gc2V0SW50ZW50KGV2ZW50KSB7XFxuXFx0ICAgIC8vIHRlc3QgdG8gc2VlIGlmIGBtb3VzZW1vdmVgIGhhcHBlbmVkIHJlbGF0aXZlIHRvIHRoZSBzY3JlZW5cXG5cXHQgICAgLy8gdG8gZGV0ZWN0IHNjcm9sbGluZyB2ZXJzdXMgbW91c2Vtb3ZlXFxuXFx0ICAgIGlmIChtb3VzZVBvc1sneCddICE9PSBldmVudC5zY3JlZW5YIHx8IG1vdXNlUG9zWyd5J10gIT09IGV2ZW50LnNjcmVlblkpIHtcXG5cXHQgICAgICBpc1Njcm9sbGluZyA9IGZhbHNlO1xcblxcblxcdCAgICAgIG1vdXNlUG9zWyd4J10gPSBldmVudC5zY3JlZW5YO1xcblxcdCAgICAgIG1vdXNlUG9zWyd5J10gPSBldmVudC5zY3JlZW5ZO1xcblxcdCAgICB9IGVsc2Uge1xcblxcdCAgICAgIGlzU2Nyb2xsaW5nID0gdHJ1ZTtcXG5cXHQgICAgfVxcblxcblxcdCAgICAvLyBvbmx5IGV4ZWN1dGUgaWYgdGhlIHRvdWNoIGJ1ZmZlciB0aW1lciBpc24ndCBydW5uaW5nXFxuXFx0ICAgIC8vIG9yIHNjcm9sbGluZyBpc24ndCBoYXBwZW5pbmdcXG5cXHQgICAgaWYgKCFpc0J1ZmZlcmluZyAmJiAhaXNTY3JvbGxpbmcpIHtcXG5cXHQgICAgICB2YXIgdmFsdWUgPSBpbnB1dE1hcFtldmVudC50eXBlXTtcXG5cXHQgICAgICBpZiAodmFsdWUgPT09ICdwb2ludGVyJykgdmFsdWUgPSBwb2ludGVyVHlwZShldmVudCk7XFxuXFxuXFx0ICAgICAgaWYgKGN1cnJlbnRJbnRlbnQgIT09IHZhbHVlKSB7XFxuXFx0ICAgICAgICBjdXJyZW50SW50ZW50ID0gdmFsdWU7XFxuXFxuXFx0ICAgICAgICBkb2Muc2V0QXR0cmlidXRlKCdkYXRhLXdoYXRpbnRlbnQnLCBjdXJyZW50SW50ZW50KTtcXG5cXG5cXHQgICAgICAgIGZpcmVGdW5jdGlvbnMoJ2ludGVudCcpO1xcblxcdCAgICAgIH1cXG5cXHQgICAgfVxcblxcdCAgfTtcXG5cXG5cXHQgIC8vIGJ1ZmZlcnMgdG91Y2ggZXZlbnRzIGJlY2F1c2UgdGhleSBmcmVxdWVudGx5IGFsc28gZmlyZSBtb3VzZSBldmVudHNcXG5cXHQgIHZhciB0b3VjaEJ1ZmZlciA9IGZ1bmN0aW9uIHRvdWNoQnVmZmVyKGV2ZW50KSB7XFxuXFx0ICAgIGlmIChldmVudC50eXBlID09PSAndG91Y2hzdGFydCcpIHtcXG5cXHQgICAgICBpc0J1ZmZlcmluZyA9IGZhbHNlO1xcblxcblxcdCAgICAgIC8vIHNldCB0aGUgY3VycmVudCBpbnB1dFxcblxcdCAgICAgIHVwZGF0ZUlucHV0KGV2ZW50KTtcXG5cXHQgICAgfSBlbHNlIHtcXG5cXHQgICAgICBpc0J1ZmZlcmluZyA9IHRydWU7XFxuXFx0ICAgIH1cXG5cXHQgIH07XFxuXFxuXFx0ICB2YXIgZmlyZUZ1bmN0aW9ucyA9IGZ1bmN0aW9uIGZpcmVGdW5jdGlvbnModHlwZSkge1xcblxcdCAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZnVuY3Rpb25MaXN0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XFxuXFx0ICAgICAgaWYgKGZ1bmN0aW9uTGlzdFtpXS50eXBlID09PSB0eXBlKSB7XFxuXFx0ICAgICAgICBmdW5jdGlvbkxpc3RbaV0uZm4uY2FsbCh1bmRlZmluZWQsIGN1cnJlbnRJbnRlbnQpO1xcblxcdCAgICAgIH1cXG5cXHQgICAgfVxcblxcdCAgfTtcXG5cXG5cXHQgIC8qXFxuXFx0ICAgKiB1dGlsaXRpZXNcXG5cXHQgICAqL1xcblxcblxcdCAgdmFyIHBvaW50ZXJUeXBlID0gZnVuY3Rpb24gcG9pbnRlclR5cGUoZXZlbnQpIHtcXG5cXHQgICAgaWYgKHR5cGVvZiBldmVudC5wb2ludGVyVHlwZSA9PT0gJ251bWJlcicpIHtcXG5cXHQgICAgICByZXR1cm4gcG9pbnRlck1hcFtldmVudC5wb2ludGVyVHlwZV07XFxuXFx0ICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgLy8gdHJlYXQgcGVuIGxpa2UgdG91Y2hcXG5cXHQgICAgICByZXR1cm4gZXZlbnQucG9pbnRlclR5cGUgPT09ICdwZW4nID8gJ3RvdWNoJyA6IGV2ZW50LnBvaW50ZXJUeXBlO1xcblxcdCAgICB9XFxuXFx0ICB9O1xcblxcblxcdCAgLy8gZGV0ZWN0IHZlcnNpb24gb2YgbW91c2Ugd2hlZWwgZXZlbnQgdG8gdXNlXFxuXFx0ICAvLyB2aWEgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvRXZlbnRzL3doZWVsXFxuXFx0ICB2YXIgZGV0ZWN0V2hlZWwgPSBmdW5jdGlvbiBkZXRlY3RXaGVlbCgpIHtcXG5cXHQgICAgdmFyIHdoZWVsVHlwZSA9IHZvaWQgMDtcXG5cXG5cXHQgICAgLy8gTW9kZXJuIGJyb3dzZXJzIHN1cHBvcnQgXFxcIndoZWVsXFxcIlxcblxcdCAgICBpZiAoJ29ud2hlZWwnIGluIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpKSB7XFxuXFx0ICAgICAgd2hlZWxUeXBlID0gJ3doZWVsJztcXG5cXHQgICAgfSBlbHNlIHtcXG5cXHQgICAgICAvLyBXZWJraXQgYW5kIElFIHN1cHBvcnQgYXQgbGVhc3QgXFxcIm1vdXNld2hlZWxcXFwiXFxuXFx0ICAgICAgLy8gb3IgYXNzdW1lIHRoYXQgcmVtYWluaW5nIGJyb3dzZXJzIGFyZSBvbGRlciBGaXJlZm94XFxuXFx0ICAgICAgd2hlZWxUeXBlID0gZG9jdW1lbnQub25tb3VzZXdoZWVsICE9PSB1bmRlZmluZWQgPyAnbW91c2V3aGVlbCcgOiAnRE9NTW91c2VTY3JvbGwnO1xcblxcdCAgICB9XFxuXFxuXFx0ICAgIHJldHVybiB3aGVlbFR5cGU7XFxuXFx0ICB9O1xcblxcblxcdCAgdmFyIG9ialBvcyA9IGZ1bmN0aW9uIG9ialBvcyhtYXRjaCkge1xcblxcdCAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZnVuY3Rpb25MaXN0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XFxuXFx0ICAgICAgaWYgKGZ1bmN0aW9uTGlzdFtpXS5mbiA9PT0gbWF0Y2gpIHtcXG5cXHQgICAgICAgIHJldHVybiBpO1xcblxcdCAgICAgIH1cXG5cXHQgICAgfVxcblxcdCAgfTtcXG5cXG5cXHQgIC8qXFxuXFx0ICAgKiBpbml0XFxuXFx0ICAgKi9cXG5cXG5cXHQgIC8vIGRvbid0IHN0YXJ0IHNjcmlwdCB1bmxlc3MgYnJvd3NlciBjdXRzIHRoZSBtdXN0YXJkXFxuXFx0ICAvLyAoYWxzbyBwYXNzZXMgaWYgcG9seWZpbGxzIGFyZSB1c2VkKVxcblxcdCAgaWYgKCdhZGRFdmVudExpc3RlbmVyJyBpbiB3aW5kb3cgJiYgQXJyYXkucHJvdG90eXBlLmluZGV4T2YpIHtcXG5cXHQgICAgc2V0VXAoKTtcXG5cXHQgIH1cXG5cXG5cXHQgIC8qXFxuXFx0ICAgKiBhcGlcXG5cXHQgICAqL1xcblxcblxcdCAgcmV0dXJuIHtcXG5cXHQgICAgLy8gcmV0dXJucyBzdHJpbmc6IHRoZSBjdXJyZW50IGlucHV0IHR5cGVcXG5cXHQgICAgLy8gb3B0OiAnbG9vc2UnfCdzdHJpY3QnXFxuXFx0ICAgIC8vICdzdHJpY3QnIChkZWZhdWx0KTogcmV0dXJucyB0aGUgc2FtZSB2YWx1ZSBhcyB0aGUgYGRhdGEtd2hhdGlucHV0YCBhdHRyaWJ1dGVcXG5cXHQgICAgLy8gJ2xvb3NlJzogaW5jbHVkZXMgYGRhdGEtd2hhdGludGVudGAgdmFsdWUgaWYgaXQncyBtb3JlIGN1cnJlbnQgdGhhbiBgZGF0YS13aGF0aW5wdXRgXFxuXFx0ICAgIGFzazogZnVuY3Rpb24gYXNrKG9wdCkge1xcblxcdCAgICAgIHJldHVybiBvcHQgPT09ICdsb29zZScgPyBjdXJyZW50SW50ZW50IDogY3VycmVudElucHV0O1xcblxcdCAgICB9LFxcblxcblxcdCAgICAvLyByZXR1cm5zIGFycmF5OiBhbGwgdGhlIGRldGVjdGVkIGlucHV0IHR5cGVzXFxuXFx0ICAgIHR5cGVzOiBmdW5jdGlvbiB0eXBlcygpIHtcXG5cXHQgICAgICByZXR1cm4gaW5wdXRUeXBlcztcXG5cXHQgICAgfSxcXG5cXG5cXHQgICAgLy8gb3ZlcndyaXRlcyBpZ25vcmVkIGtleXMgd2l0aCBwcm92aWRlZCBhcnJheVxcblxcdCAgICBpZ25vcmVLZXlzOiBmdW5jdGlvbiBpZ25vcmVLZXlzKGFycikge1xcblxcdCAgICAgIGlnbm9yZU1hcCA9IGFycjtcXG5cXHQgICAgfSxcXG5cXG5cXHQgICAgLy8gYXR0YWNoIGZ1bmN0aW9ucyB0byBpbnB1dCBhbmQgaW50ZW50IFxcXCJldmVudHNcXFwiXFxuXFx0ICAgIC8vIGZ1bmN0OiBmdW5jdGlvbiB0byBmaXJlIG9uIGNoYW5nZVxcblxcdCAgICAvLyBldmVudFR5cGU6ICdpbnB1dCd8J2ludGVudCdcXG5cXHQgICAgcmVnaXN0ZXJPbkNoYW5nZTogZnVuY3Rpb24gcmVnaXN0ZXJPbkNoYW5nZShmbiwgZXZlbnRUeXBlKSB7XFxuXFx0ICAgICAgZnVuY3Rpb25MaXN0LnB1c2goe1xcblxcdCAgICAgICAgZm46IGZuLFxcblxcdCAgICAgICAgdHlwZTogZXZlbnRUeXBlIHx8ICdpbnB1dCdcXG5cXHQgICAgICB9KTtcXG5cXHQgICAgfSxcXG5cXG5cXHQgICAgdW5SZWdpc3Rlck9uQ2hhbmdlOiBmdW5jdGlvbiB1blJlZ2lzdGVyT25DaGFuZ2UoZm4pIHtcXG5cXHQgICAgICB2YXIgcG9zaXRpb24gPSBvYmpQb3MoZm4pO1xcblxcblxcdCAgICAgIGlmIChwb3NpdGlvbikge1xcblxcdCAgICAgICAgZnVuY3Rpb25MaXN0LnNwbGljZShwb3NpdGlvbiwgMSk7XFxuXFx0ICAgICAgfVxcblxcdCAgICB9XFxuXFx0ICB9O1xcblxcdH0oKTtcXG5cXG4vKioqLyB9KVxcbi8qKioqKiovIF0pXFxufSk7XFxuO1wiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmF3LWxvYWRlciEuL25vZGVfbW9kdWxlcy93aGF0LWlucHV0L2Rpc3Qvd2hhdC1pbnB1dC5qc1xuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3\n");

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

eval("__webpack_require__(0)(__webpack_require__(5))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZm91bmRhdGlvbi1zaXRlcy9kaXN0L2pzL2ZvdW5kYXRpb24uanM/YWM1OSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiI0LmpzIiwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZShcIiEhL1VzZXJzL1NhbURhdmlkb2ZmL0Rlc2t0b3AvV1AtU3RhcnRlci1UaGVtZS1TYXNzLVdlYnBhY2svc3JjL25vZGVfbW9kdWxlcy9zY3JpcHQtbG9hZGVyL2FkZFNjcmlwdC5qc1wiKShyZXF1aXJlKFwiISEvVXNlcnMvU2FtRGF2aWRvZmYvRGVza3RvcC9XUC1TdGFydGVyLVRoZW1lLVNhc3MtV2VicGFjay9zcmMvbm9kZV9tb2R1bGVzL3Jhdy1sb2FkZXIvaW5kZXguanMhL1VzZXJzL1NhbURhdmlkb2ZmL0Rlc2t0b3AvV1AtU3RhcnRlci1UaGVtZS1TYXNzLVdlYnBhY2svc3JjL25vZGVfbW9kdWxlcy9mb3VuZGF0aW9uLXNpdGVzL2Rpc3QvanMvZm91bmRhdGlvbi5qc1wiKSlcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9zY3JpcHQtbG9hZGVyIS4vbm9kZV9tb2R1bGVzL2ZvdW5kYXRpb24tc2l0ZXMvZGlzdC9qcy9mb3VuZGF0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4\n");

/***/ }),
/* 5 */
/***/ (function(module, exports) {

eval("module.exports = \"/******/ (function(modules) { // webpackBootstrap\\n/******/ \\t// The module cache\\n/******/ \\tvar installedModules = {};\\n/******/\\n/******/ \\t// The require function\\n/******/ \\tfunction __webpack_require__(moduleId) {\\n/******/\\n/******/ \\t\\t// Check if module is in cache\\n/******/ \\t\\tif(installedModules[moduleId]) {\\n/******/ \\t\\t\\treturn installedModules[moduleId].exports;\\n/******/ \\t\\t}\\n/******/ \\t\\t// Create a new module (and put it into the cache)\\n/******/ \\t\\tvar module = installedModules[moduleId] = {\\n/******/ \\t\\t\\ti: moduleId,\\n/******/ \\t\\t\\tl: false,\\n/******/ \\t\\t\\texports: {}\\n/******/ \\t\\t};\\n/******/\\n/******/ \\t\\t// Execute the module function\\n/******/ \\t\\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\\n/******/\\n/******/ \\t\\t// Flag the module as loaded\\n/******/ \\t\\tmodule.l = true;\\n/******/\\n/******/ \\t\\t// Return the exports of the module\\n/******/ \\t\\treturn module.exports;\\n/******/ \\t}\\n/******/\\n/******/\\n/******/ \\t// expose the modules object (__webpack_modules__)\\n/******/ \\t__webpack_require__.m = modules;\\n/******/\\n/******/ \\t// expose the module cache\\n/******/ \\t__webpack_require__.c = installedModules;\\n/******/\\n/******/ \\t// identity function for calling harmony imports with the correct context\\n/******/ \\t__webpack_require__.i = function(value) { return value; };\\n/******/\\n/******/ \\t// define getter function for harmony exports\\n/******/ \\t__webpack_require__.d = function(exports, name, getter) {\\n/******/ \\t\\tif(!__webpack_require__.o(exports, name)) {\\n/******/ \\t\\t\\tObject.defineProperty(exports, name, {\\n/******/ \\t\\t\\t\\tconfigurable: false,\\n/******/ \\t\\t\\t\\tenumerable: true,\\n/******/ \\t\\t\\t\\tget: getter\\n/******/ \\t\\t\\t});\\n/******/ \\t\\t}\\n/******/ \\t};\\n/******/\\n/******/ \\t// getDefaultExport function for compatibility with non-harmony modules\\n/******/ \\t__webpack_require__.n = function(module) {\\n/******/ \\t\\tvar getter = module && module.__esModule ?\\n/******/ \\t\\t\\tfunction getDefault() { return module['default']; } :\\n/******/ \\t\\t\\tfunction getModuleExports() { return module; };\\n/******/ \\t\\t__webpack_require__.d(getter, 'a', getter);\\n/******/ \\t\\treturn getter;\\n/******/ \\t};\\n/******/\\n/******/ \\t// Object.prototype.hasOwnProperty.call\\n/******/ \\t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\\n/******/\\n/******/ \\t// __webpack_public_path__\\n/******/ \\t__webpack_require__.p = \\\"\\\";\\n/******/\\n/******/ \\t// Load entry module and return exports\\n/******/ \\treturn __webpack_require__(__webpack_require__.s = 36);\\n/******/ })\\n/************************************************************************/\\n/******/ ([\\n/* 0 */\\n/***/ (function(module, exports) {\\n\\nmodule.exports = jQuery;\\n\\n/***/ }),\\n/* 1 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return rtl; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"b\\\", function() { return GetYoDigits; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"c\\\", function() { return transitionend; });\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jquery__);\\n\\n\\n\\n\\n// Core Foundation Utilities, utilized in a number of places.\\n\\n/**\\n * Returns a boolean for RTL support\\n */\\nfunction rtl() {\\n  return __WEBPACK_IMPORTED_MODULE_0_jquery___default()('html').attr('dir') === 'rtl';\\n}\\n\\n/**\\n * returns a random base-36 uid with namespacing\\n * @function\\n * @param {Number} length - number of random base-36 digits desired. Increase for more random strings.\\n * @param {String} namespace - name of plugin to be incorporated in uid, optional.\\n * @default {String} '' - if no plugin name is provided, nothing is appended to the uid.\\n * @returns {String} - unique id\\n */\\nfunction GetYoDigits(length, namespace) {\\n  length = length || 6;\\n  return Math.round(Math.pow(36, length + 1) - Math.random() * Math.pow(36, length)).toString(36).slice(1) + (namespace ? '-' + namespace : '');\\n}\\n\\nfunction transitionend($elem) {\\n  var transitions = {\\n    'transition': 'transitionend',\\n    'WebkitTransition': 'webkitTransitionEnd',\\n    'MozTransition': 'transitionend',\\n    'OTransition': 'otransitionend'\\n  };\\n  var elem = document.createElement('div'),\\n      end;\\n\\n  for (var t in transitions) {\\n    if (typeof elem.style[t] !== 'undefined') {\\n      end = transitions[t];\\n    }\\n  }\\n  if (end) {\\n    return end;\\n  } else {\\n    end = setTimeout(function () {\\n      $elem.triggerHandler('transitionend', [$elem]);\\n    }, 1);\\n    return 'transitionend';\\n  }\\n}\\n\\n\\n\\n/***/ }),\\n/* 2 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return Plugin; });\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jquery__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__foundation_util_core__ = __webpack_require__(1);\\n\\n\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\n\\n\\n\\n// Abstract class for providing lifecycle hooks. Expect plugins to define AT LEAST\\n// {function} _setup (replaces previous constructor),\\n// {function} _destroy (replaces previous destroy)\\n\\nvar Plugin = function () {\\n  function Plugin(element, options) {\\n    _classCallCheck(this, Plugin);\\n\\n    this._setup(element, options);\\n    var pluginName = getPluginName(this);\\n    this.uuid = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__foundation_util_core__[\\\"b\\\" /* GetYoDigits */])(6, pluginName);\\n\\n    if (!this.$element.attr('data-' + pluginName)) {\\n      this.$element.attr('data-' + pluginName, this.uuid);\\n    }\\n    if (!this.$element.data('zfPlugin')) {\\n      this.$element.data('zfPlugin', this);\\n    }\\n    /**\\n     * Fires when the plugin has initialized.\\n     * @event Plugin#init\\n     */\\n    this.$element.trigger('init.zf.' + pluginName);\\n  }\\n\\n  _createClass(Plugin, [{\\n    key: 'destroy',\\n    value: function destroy() {\\n      this._destroy();\\n      var pluginName = getPluginName(this);\\n      this.$element.removeAttr('data-' + pluginName).removeData('zfPlugin')\\n      /**\\n       * Fires when the plugin has been destroyed.\\n       * @event Plugin#destroyed\\n       */\\n      .trigger('destroyed.zf.' + pluginName);\\n      for (var prop in this) {\\n        this[prop] = null; //clean up script to prep for garbage collection.\\n      }\\n    }\\n  }]);\\n\\n  return Plugin;\\n}();\\n\\n// Convert PascalCase to kebab-case\\n// Thank you: http://stackoverflow.com/a/8955580\\n\\n\\nfunction hyphenate(str) {\\n  return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\\n}\\n\\nfunction getPluginName(obj) {\\n  if (typeof obj.constructor.name !== 'undefined') {\\n    return hyphenate(obj.constructor.name);\\n  } else {\\n    return hyphenate(obj.className);\\n  }\\n}\\n\\n\\n\\n/***/ }),\\n/* 3 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return Keyboard; });\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jquery__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__foundation_util_core__ = __webpack_require__(1);\\n/*******************************************\\n *                                         *\\n * This util was created by Marius Olbertz *\\n * Please thank Marius on GitHub /owlbertz *\\n * or the web http://www.mariusolbertz.de/ *\\n *                                         *\\n ******************************************/\\n\\n\\n\\n\\n\\n\\nvar keyCodes = {\\n  9: 'TAB',\\n  13: 'ENTER',\\n  27: 'ESCAPE',\\n  32: 'SPACE',\\n  35: 'END',\\n  36: 'HOME',\\n  37: 'ARROW_LEFT',\\n  38: 'ARROW_UP',\\n  39: 'ARROW_RIGHT',\\n  40: 'ARROW_DOWN'\\n};\\n\\nvar commands = {};\\n\\n// Functions pulled out to be referenceable from internals\\nfunction findFocusable($element) {\\n  if (!$element) {\\n    return false;\\n  }\\n  return $element.find('a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), iframe, object, embed, *[tabindex], *[contenteditable]').filter(function () {\\n    if (!__WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).is(':visible') || __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).attr('tabindex') < 0) {\\n      return false;\\n    } //only have visible elements and those that have a tabindex greater or equal 0\\n    return true;\\n  });\\n}\\n\\nfunction parseKey(event) {\\n  var key = keyCodes[event.which || event.keyCode] || String.fromCharCode(event.which).toUpperCase();\\n\\n  // Remove un-printable characters, e.g. for `fromCharCode` calls for CTRL only events\\n  key = key.replace(/\\\\W+/, '');\\n\\n  if (event.shiftKey) key = 'SHIFT_' + key;\\n  if (event.ctrlKey) key = 'CTRL_' + key;\\n  if (event.altKey) key = 'ALT_' + key;\\n\\n  // Remove trailing underscore, in case only modifiers were used (e.g. only `CTRL_ALT`)\\n  key = key.replace(/_$/, '');\\n\\n  return key;\\n}\\n\\nvar Keyboard = {\\n  keys: getKeyCodes(keyCodes),\\n\\n  /**\\n   * Parses the (keyboard) event and returns a String that represents its key\\n   * Can be used like Foundation.parseKey(event) === Foundation.keys.SPACE\\n   * @param {Event} event - the event generated by the event handler\\n   * @return String key - String that represents the key pressed\\n   */\\n  parseKey: parseKey,\\n\\n  /**\\n   * Handles the given (keyboard) event\\n   * @param {Event} event - the event generated by the event handler\\n   * @param {String} component - Foundation component's name, e.g. Slider or Reveal\\n   * @param {Objects} functions - collection of functions that are to be executed\\n   */\\n  handleKey: function (event, component, functions) {\\n    var commandList = commands[component],\\n        keyCode = this.parseKey(event),\\n        cmds,\\n        command,\\n        fn;\\n\\n    if (!commandList) return console.warn('Component not defined!');\\n\\n    if (typeof commandList.ltr === 'undefined') {\\n      // this component does not differentiate between ltr and rtl\\n      cmds = commandList; // use plain list\\n    } else {\\n      // merge ltr and rtl: if document is rtl, rtl overwrites ltr and vice versa\\n      if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__foundation_util_core__[\\\"a\\\" /* rtl */])()) cmds = __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.extend({}, commandList.ltr, commandList.rtl);else cmds = __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.extend({}, commandList.rtl, commandList.ltr);\\n    }\\n    command = cmds[keyCode];\\n\\n    fn = functions[command];\\n    if (fn && typeof fn === 'function') {\\n      // execute function  if exists\\n      var returnValue = fn.apply();\\n      if (functions.handled || typeof functions.handled === 'function') {\\n        // execute function when event was handled\\n        functions.handled(returnValue);\\n      }\\n    } else {\\n      if (functions.unhandled || typeof functions.unhandled === 'function') {\\n        // execute function when event was not handled\\n        functions.unhandled();\\n      }\\n    }\\n  },\\n\\n\\n  /**\\n   * Finds all focusable elements within the given `$element`\\n   * @param {jQuery} $element - jQuery object to search within\\n   * @return {jQuery} $focusable - all focusable elements within `$element`\\n   */\\n\\n  findFocusable: findFocusable,\\n\\n  /**\\n   * Returns the component name name\\n   * @param {Object} component - Foundation component, e.g. Slider or Reveal\\n   * @return String componentName\\n   */\\n\\n  register: function (componentName, cmds) {\\n    commands[componentName] = cmds;\\n  },\\n\\n\\n  // TODO9438: These references to Keyboard need to not require global. Will 'this' work in this context?\\n  //\\n  /**\\n   * Traps the focus in the given element.\\n   * @param  {jQuery} $element  jQuery object to trap the foucs into.\\n   */\\n  trapFocus: function ($element) {\\n    var $focusable = findFocusable($element),\\n        $firstFocusable = $focusable.eq(0),\\n        $lastFocusable = $focusable.eq(-1);\\n\\n    $element.on('keydown.zf.trapfocus', function (event) {\\n      if (event.target === $lastFocusable[0] && parseKey(event) === 'TAB') {\\n        event.preventDefault();\\n        $firstFocusable.focus();\\n      } else if (event.target === $firstFocusable[0] && parseKey(event) === 'SHIFT_TAB') {\\n        event.preventDefault();\\n        $lastFocusable.focus();\\n      }\\n    });\\n  },\\n\\n  /**\\n   * Releases the trapped focus from the given element.\\n   * @param  {jQuery} $element  jQuery object to release the focus for.\\n   */\\n  releaseFocus: function ($element) {\\n    $element.off('keydown.zf.trapfocus');\\n  }\\n};\\n\\n/*\\n * Constants for easier comparing.\\n * Can be used like Foundation.parseKey(event) === Foundation.keys.SPACE\\n */\\nfunction getKeyCodes(kcs) {\\n  var k = {};\\n  for (var kc in kcs) {\\n    k[kcs[kc]] = kcs[kc];\\n  }return k;\\n}\\n\\n\\n\\n/***/ }),\\n/* 4 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return MediaQuery; });\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jquery__);\\n\\n\\n\\n\\n// Default set of media queries\\nvar defaultQueries = {\\n  'default': 'only screen',\\n  landscape: 'only screen and (orientation: landscape)',\\n  portrait: 'only screen and (orientation: portrait)',\\n  retina: 'only screen and (-webkit-min-device-pixel-ratio: 2),' + 'only screen and (min--moz-device-pixel-ratio: 2),' + 'only screen and (-o-min-device-pixel-ratio: 2/1),' + 'only screen and (min-device-pixel-ratio: 2),' + 'only screen and (min-resolution: 192dpi),' + 'only screen and (min-resolution: 2dppx)'\\n};\\n\\n// matchMedia() polyfill - Test a CSS media type/query in JS.\\n// Authors & copyright (c) 2012: Scott Jehl, Paul Irish, Nicholas Zakas, David Knight. Dual MIT/BSD license\\nvar matchMedia = window.matchMedia || function () {\\n  'use strict';\\n\\n  // For browsers that support matchMedium api such as IE 9 and webkit\\n\\n  var styleMedia = window.styleMedia || window.media;\\n\\n  // For those that don't support matchMedium\\n  if (!styleMedia) {\\n    var style = document.createElement('style'),\\n        script = document.getElementsByTagName('script')[0],\\n        info = null;\\n\\n    style.type = 'text/css';\\n    style.id = 'matchmediajs-test';\\n\\n    script && script.parentNode && script.parentNode.insertBefore(style, script);\\n\\n    // 'style.currentStyle' is used by IE <= 8 and 'window.getComputedStyle' for all other browsers\\n    info = 'getComputedStyle' in window && window.getComputedStyle(style, null) || style.currentStyle;\\n\\n    styleMedia = {\\n      matchMedium: function (media) {\\n        var text = '@media ' + media + '{ #matchmediajs-test { width: 1px; } }';\\n\\n        // 'style.styleSheet' is used by IE <= 8 and 'style.textContent' for all other browsers\\n        if (style.styleSheet) {\\n          style.styleSheet.cssText = text;\\n        } else {\\n          style.textContent = text;\\n        }\\n\\n        // Test if media query is true or false\\n        return info.width === '1px';\\n      }\\n    };\\n  }\\n\\n  return function (media) {\\n    return {\\n      matches: styleMedia.matchMedium(media || 'all'),\\n      media: media || 'all'\\n    };\\n  };\\n}();\\n\\nvar MediaQuery = {\\n  queries: [],\\n\\n  current: '',\\n\\n  /**\\n   * Initializes the media query helper, by extracting the breakpoint list from the CSS and activating the breakpoint watcher.\\n   * @function\\n   * @private\\n   */\\n  _init: function () {\\n    var self = this;\\n    var $meta = __WEBPACK_IMPORTED_MODULE_0_jquery___default()('meta.foundation-mq');\\n    if (!$meta.length) {\\n      __WEBPACK_IMPORTED_MODULE_0_jquery___default()('<meta class=\\\"foundation-mq\\\">').appendTo(document.head);\\n    }\\n\\n    var extractedStyles = __WEBPACK_IMPORTED_MODULE_0_jquery___default()('.foundation-mq').css('font-family');\\n    var namedQueries;\\n\\n    namedQueries = parseStyleToObject(extractedStyles);\\n\\n    for (var key in namedQueries) {\\n      if (namedQueries.hasOwnProperty(key)) {\\n        self.queries.push({\\n          name: key,\\n          value: 'only screen and (min-width: ' + namedQueries[key] + ')'\\n        });\\n      }\\n    }\\n\\n    this.current = this._getCurrentSize();\\n\\n    this._watcher();\\n  },\\n\\n\\n  /**\\n   * Checks if the screen is at least as wide as a breakpoint.\\n   * @function\\n   * @param {String} size - Name of the breakpoint to check.\\n   * @returns {Boolean} `true` if the breakpoint matches, `false` if it's smaller.\\n   */\\n  atLeast: function (size) {\\n    var query = this.get(size);\\n\\n    if (query) {\\n      return matchMedia(query).matches;\\n    }\\n\\n    return false;\\n  },\\n\\n\\n  /**\\n   * Checks if the screen matches to a breakpoint.\\n   * @function\\n   * @param {String} size - Name of the breakpoint to check, either 'small only' or 'small'. Omitting 'only' falls back to using atLeast() method.\\n   * @returns {Boolean} `true` if the breakpoint matches, `false` if it does not.\\n   */\\n  is: function (size) {\\n    size = size.trim().split(' ');\\n    if (size.length > 1 && size[1] === 'only') {\\n      if (size[0] === this._getCurrentSize()) return true;\\n    } else {\\n      return this.atLeast(size[0]);\\n    }\\n    return false;\\n  },\\n\\n\\n  /**\\n   * Gets the media query of a breakpoint.\\n   * @function\\n   * @param {String} size - Name of the breakpoint to get.\\n   * @returns {String|null} - The media query of the breakpoint, or `null` if the breakpoint doesn't exist.\\n   */\\n  get: function (size) {\\n    for (var i in this.queries) {\\n      if (this.queries.hasOwnProperty(i)) {\\n        var query = this.queries[i];\\n        if (size === query.name) return query.value;\\n      }\\n    }\\n\\n    return null;\\n  },\\n\\n\\n  /**\\n   * Gets the current breakpoint name by testing every breakpoint and returning the last one to match (the biggest one).\\n   * @function\\n   * @private\\n   * @returns {String} Name of the current breakpoint.\\n   */\\n  _getCurrentSize: function () {\\n    var matched;\\n\\n    for (var i = 0; i < this.queries.length; i++) {\\n      var query = this.queries[i];\\n\\n      if (matchMedia(query.value).matches) {\\n        matched = query;\\n      }\\n    }\\n\\n    if (typeof matched === 'object') {\\n      return matched.name;\\n    } else {\\n      return matched;\\n    }\\n  },\\n\\n\\n  /**\\n   * Activates the breakpoint watcher, which fires an event on the window whenever the breakpoint changes.\\n   * @function\\n   * @private\\n   */\\n  _watcher: function () {\\n    var _this = this;\\n\\n    __WEBPACK_IMPORTED_MODULE_0_jquery___default()(window).off('resize.zf.mediaquery').on('resize.zf.mediaquery', function () {\\n      var newSize = _this._getCurrentSize(),\\n          currentSize = _this.current;\\n\\n      if (newSize !== currentSize) {\\n        // Change the current media query\\n        _this.current = newSize;\\n\\n        // Broadcast the media query change on the window\\n        __WEBPACK_IMPORTED_MODULE_0_jquery___default()(window).trigger('changed.zf.mediaquery', [newSize, currentSize]);\\n      }\\n    });\\n  }\\n};\\n\\n// Thank you: https://github.com/sindresorhus/query-string\\nfunction parseStyleToObject(str) {\\n  var styleObject = {};\\n\\n  if (typeof str !== 'string') {\\n    return styleObject;\\n  }\\n\\n  str = str.trim().slice(1, -1); // browsers re-quote string style values\\n\\n  if (!str) {\\n    return styleObject;\\n  }\\n\\n  styleObject = str.split('&').reduce(function (ret, param) {\\n    var parts = param.replace(/\\\\+/g, ' ').split('=');\\n    var key = parts[0];\\n    var val = parts[1];\\n    key = decodeURIComponent(key);\\n\\n    // missing `=` should be `null`:\\n    // http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters\\n    val = val === undefined ? null : decodeURIComponent(val);\\n\\n    if (!ret.hasOwnProperty(key)) {\\n      ret[key] = val;\\n    } else if (Array.isArray(ret[key])) {\\n      ret[key].push(val);\\n    } else {\\n      ret[key] = [ret[key], val];\\n    }\\n    return ret;\\n  }, {});\\n\\n  return styleObject;\\n}\\n\\n\\n\\n/***/ }),\\n/* 5 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return Triggers; });\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jquery__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__foundation_util_motion__ = __webpack_require__(6);\\n\\n\\n\\n\\n\\nvar MutationObserver = function () {\\n  var prefixes = ['WebKit', 'Moz', 'O', 'Ms', ''];\\n  for (var i = 0; i < prefixes.length; i++) {\\n    if (prefixes[i] + 'MutationObserver' in window) {\\n      return window[prefixes[i] + 'MutationObserver'];\\n    }\\n  }\\n  return false;\\n}();\\n\\nvar triggers = function (el, type) {\\n  el.data(type).split(' ').forEach(function (id) {\\n    __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#' + id)[type === 'close' ? 'trigger' : 'triggerHandler'](type + '.zf.trigger', [el]);\\n  });\\n};\\n\\nvar Triggers = {\\n  Listeners: {\\n    Basic: {},\\n    Global: {}\\n  },\\n  Initializers: {}\\n};\\n\\nTriggers.Listeners.Basic = {\\n  openListener: function () {\\n    triggers(__WEBPACK_IMPORTED_MODULE_0_jquery___default()(this), 'open');\\n  },\\n  closeListener: function () {\\n    var id = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).data('close');\\n    if (id) {\\n      triggers(__WEBPACK_IMPORTED_MODULE_0_jquery___default()(this), 'close');\\n    } else {\\n      __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).trigger('close.zf.trigger');\\n    }\\n  },\\n  toggleListener: function () {\\n    var id = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).data('toggle');\\n    if (id) {\\n      triggers(__WEBPACK_IMPORTED_MODULE_0_jquery___default()(this), 'toggle');\\n    } else {\\n      __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).trigger('toggle.zf.trigger');\\n    }\\n  },\\n  closeableListener: function (e) {\\n    e.stopPropagation();\\n    var animation = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).data('closable');\\n\\n    if (animation !== '') {\\n      __WEBPACK_IMPORTED_MODULE_1__foundation_util_motion__[\\\"a\\\" /* Motion */].animateOut(__WEBPACK_IMPORTED_MODULE_0_jquery___default()(this), animation, function () {\\n        __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).trigger('closed.zf');\\n      });\\n    } else {\\n      __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).fadeOut().trigger('closed.zf');\\n    }\\n  },\\n  toggleFocusListener: function () {\\n    var id = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).data('toggle-focus');\\n    __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#' + id).triggerHandler('toggle.zf.trigger', [__WEBPACK_IMPORTED_MODULE_0_jquery___default()(this)]);\\n  }\\n};\\n\\n// Elements with [data-open] will reveal a plugin that supports it when clicked.\\nTriggers.Initializers.addOpenListener = function ($elem) {\\n  $elem.off('click.zf.trigger', Triggers.Listeners.Basic.openListener);\\n  $elem.on('click.zf.trigger', '[data-open]', Triggers.Listeners.Basic.openListener);\\n};\\n\\n// Elements with [data-close] will close a plugin that supports it when clicked.\\n// If used without a value on [data-close], the event will bubble, allowing it to close a parent component.\\nTriggers.Initializers.addCloseListener = function ($elem) {\\n  $elem.off('click.zf.trigger', Triggers.Listeners.Basic.closeListener);\\n  $elem.on('click.zf.trigger', '[data-close]', Triggers.Listeners.Basic.closeListener);\\n};\\n\\n// Elements with [data-toggle] will toggle a plugin that supports it when clicked.\\nTriggers.Initializers.addToggleListener = function ($elem) {\\n  $elem.off('click.zf.trigger', Triggers.Listeners.Basic.toggleListener);\\n  $elem.on('click.zf.trigger', '[data-toggle]', Triggers.Listeners.Basic.toggleListener);\\n};\\n\\n// Elements with [data-closable] will respond to close.zf.trigger events.\\nTriggers.Initializers.addCloseableListener = function ($elem) {\\n  $elem.off('close.zf.trigger', Triggers.Listeners.Basic.closeableListener);\\n  $elem.on('close.zf.trigger', '[data-closeable], [data-closable]', Triggers.Listeners.Basic.closeableListener);\\n};\\n\\n// Elements with [data-toggle-focus] will respond to coming in and out of focus\\nTriggers.Initializers.addToggleFocusListener = function ($elem) {\\n  $elem.off('focus.zf.trigger blur.zf.trigger', Triggers.Listeners.Basic.toggleFocusListener);\\n  $elem.on('focus.zf.trigger blur.zf.trigger', '[data-toggle-focus]', Triggers.Listeners.Basic.toggleFocusListener);\\n};\\n\\n// More Global/complex listeners and triggers\\nTriggers.Listeners.Global = {\\n  resizeListener: function ($nodes) {\\n    if (!MutationObserver) {\\n      //fallback for IE 9\\n      $nodes.each(function () {\\n        __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).triggerHandler('resizeme.zf.trigger');\\n      });\\n    }\\n    //trigger all listening elements and signal a resize event\\n    $nodes.attr('data-events', \\\"resize\\\");\\n  },\\n  scrollListener: function ($nodes) {\\n    if (!MutationObserver) {\\n      //fallback for IE 9\\n      $nodes.each(function () {\\n        __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).triggerHandler('scrollme.zf.trigger');\\n      });\\n    }\\n    //trigger all listening elements and signal a scroll event\\n    $nodes.attr('data-events', \\\"scroll\\\");\\n  },\\n  closeMeListener: function (e, pluginId) {\\n    var plugin = e.namespace.split('.')[0];\\n    var plugins = __WEBPACK_IMPORTED_MODULE_0_jquery___default()('[data-' + plugin + ']').not('[data-yeti-box=\\\"' + pluginId + '\\\"]');\\n\\n    plugins.each(function () {\\n      var _this = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this);\\n      _this.triggerHandler('close.zf.trigger', [_this]);\\n    });\\n  }\\n};\\n\\n// Global, parses whole document.\\nTriggers.Initializers.addClosemeListener = function (pluginName) {\\n  var yetiBoxes = __WEBPACK_IMPORTED_MODULE_0_jquery___default()('[data-yeti-box]'),\\n      plugNames = ['dropdown', 'tooltip', 'reveal'];\\n\\n  if (pluginName) {\\n    if (typeof pluginName === 'string') {\\n      plugNames.push(pluginName);\\n    } else if (typeof pluginName === 'object' && typeof pluginName[0] === 'string') {\\n      plugNames.concat(pluginName);\\n    } else {\\n      console.error('Plugin names must be strings');\\n    }\\n  }\\n  if (yetiBoxes.length) {\\n    var listeners = plugNames.map(function (name) {\\n      return 'closeme.zf.' + name;\\n    }).join(' ');\\n\\n    __WEBPACK_IMPORTED_MODULE_0_jquery___default()(window).off(listeners).on(listeners, Triggers.Listeners.Global.closeMeListener);\\n  }\\n};\\n\\nfunction debounceGlobalListener(debounce, trigger, listener) {\\n  var timer = void 0,\\n      args = Array.prototype.slice.call(arguments, 3);\\n  __WEBPACK_IMPORTED_MODULE_0_jquery___default()(window).off(trigger).on(trigger, function (e) {\\n    if (timer) {\\n      clearTimeout(timer);\\n    }\\n    timer = setTimeout(function () {\\n      listener.apply(null, args);\\n    }, debounce || 10); //default time to emit scroll event\\n  });\\n}\\n\\nTriggers.Initializers.addResizeListener = function (debounce) {\\n  var $nodes = __WEBPACK_IMPORTED_MODULE_0_jquery___default()('[data-resize]');\\n  if ($nodes.length) {\\n    debounceGlobalListener(debounce, 'resize.zf.trigger', Triggers.Listeners.Global.resizeListener, $nodes);\\n  }\\n};\\n\\nTriggers.Initializers.addScrollListener = function (debounce) {\\n  var $nodes = __WEBPACK_IMPORTED_MODULE_0_jquery___default()('[data-scroll]');\\n  if ($nodes.length) {\\n    debounceGlobalListener(debounce, 'scroll.zf.trigger', Triggers.Listeners.Global.scrollListener, $nodes);\\n  }\\n};\\n\\nTriggers.Initializers.addMutationEventsListener = function ($elem) {\\n  if (!MutationObserver) {\\n    return false;\\n  }\\n  var $nodes = $elem.find('[data-resize], [data-scroll], [data-mutate]');\\n\\n  //element callback\\n  var listeningElementsMutation = function (mutationRecordsList) {\\n    var $target = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(mutationRecordsList[0].target);\\n\\n    //trigger the event handler for the element depending on type\\n    switch (mutationRecordsList[0].type) {\\n      case \\\"attributes\\\":\\n        if ($target.attr(\\\"data-events\\\") === \\\"scroll\\\" && mutationRecordsList[0].attributeName === \\\"data-events\\\") {\\n          $target.triggerHandler('scrollme.zf.trigger', [$target, window.pageYOffset]);\\n        }\\n        if ($target.attr(\\\"data-events\\\") === \\\"resize\\\" && mutationRecordsList[0].attributeName === \\\"data-events\\\") {\\n          $target.triggerHandler('resizeme.zf.trigger', [$target]);\\n        }\\n        if (mutationRecordsList[0].attributeName === \\\"style\\\") {\\n          $target.closest(\\\"[data-mutate]\\\").attr(\\\"data-events\\\", \\\"mutate\\\");\\n          $target.closest(\\\"[data-mutate]\\\").triggerHandler('mutateme.zf.trigger', [$target.closest(\\\"[data-mutate]\\\")]);\\n        }\\n        break;\\n\\n      case \\\"childList\\\":\\n        $target.closest(\\\"[data-mutate]\\\").attr(\\\"data-events\\\", \\\"mutate\\\");\\n        $target.closest(\\\"[data-mutate]\\\").triggerHandler('mutateme.zf.trigger', [$target.closest(\\\"[data-mutate]\\\")]);\\n        break;\\n\\n      default:\\n        return false;\\n      //nothing\\n    }\\n  };\\n\\n  if ($nodes.length) {\\n    //for each element that needs to listen for resizing, scrolling, or mutation add a single observer\\n    for (var i = 0; i <= $nodes.length - 1; i++) {\\n      var elementObserver = new MutationObserver(listeningElementsMutation);\\n      elementObserver.observe($nodes[i], { attributes: true, childList: true, characterData: false, subtree: true, attributeFilter: [\\\"data-events\\\", \\\"style\\\"] });\\n    }\\n  }\\n};\\n\\nTriggers.Initializers.addSimpleListeners = function () {\\n  var $document = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(document);\\n\\n  Triggers.Initializers.addOpenListener($document);\\n  Triggers.Initializers.addCloseListener($document);\\n  Triggers.Initializers.addToggleListener($document);\\n  Triggers.Initializers.addCloseableListener($document);\\n  Triggers.Initializers.addToggleFocusListener($document);\\n};\\n\\nTriggers.Initializers.addGlobalListeners = function () {\\n  var $document = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(document);\\n  Triggers.Initializers.addMutationEventsListener($document);\\n  Triggers.Initializers.addResizeListener();\\n  Triggers.Initializers.addScrollListener();\\n  Triggers.Initializers.addClosemeListener();\\n};\\n\\nTriggers.init = function ($, Foundation) {\\n  if (typeof $.triggersInitialized === 'undefined') {\\n    var $document = $(document);\\n\\n    if (document.readyState === \\\"complete\\\") {\\n      Triggers.Initializers.addSimpleListeners();\\n      Triggers.Initializers.addGlobalListeners();\\n    } else {\\n      $(window).on('load', function () {\\n        Triggers.Initializers.addSimpleListeners();\\n        Triggers.Initializers.addGlobalListeners();\\n      });\\n    }\\n\\n    $.triggersInitialized = true;\\n  }\\n\\n  if (Foundation) {\\n    Foundation.Triggers = Triggers;\\n    // Legacy included to be backwards compatible for now.\\n    Foundation.IHearYou = Triggers.Initializers.addGlobalListeners;\\n  }\\n};\\n\\n\\n\\n/***/ }),\\n/* 6 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"b\\\", function() { return Move; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return Motion; });\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jquery__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__foundation_util_core__ = __webpack_require__(1);\\n\\n\\n\\n\\n\\n/**\\n * Motion module.\\n * @module foundation.motion\\n */\\n\\nvar initClasses = ['mui-enter', 'mui-leave'];\\nvar activeClasses = ['mui-enter-active', 'mui-leave-active'];\\n\\nvar Motion = {\\n  animateIn: function (element, animation, cb) {\\n    animate(true, element, animation, cb);\\n  },\\n\\n  animateOut: function (element, animation, cb) {\\n    animate(false, element, animation, cb);\\n  }\\n};\\n\\nfunction Move(duration, elem, fn) {\\n  var anim,\\n      prog,\\n      start = null;\\n  // console.log('called');\\n\\n  if (duration === 0) {\\n    fn.apply(elem);\\n    elem.trigger('finished.zf.animate', [elem]).triggerHandler('finished.zf.animate', [elem]);\\n    return;\\n  }\\n\\n  function move(ts) {\\n    if (!start) start = ts;\\n    // console.log(start, ts);\\n    prog = ts - start;\\n    fn.apply(elem);\\n\\n    if (prog < duration) {\\n      anim = window.requestAnimationFrame(move, elem);\\n    } else {\\n      window.cancelAnimationFrame(anim);\\n      elem.trigger('finished.zf.animate', [elem]).triggerHandler('finished.zf.animate', [elem]);\\n    }\\n  }\\n  anim = window.requestAnimationFrame(move);\\n}\\n\\n/**\\n * Animates an element in or out using a CSS transition class.\\n * @function\\n * @private\\n * @param {Boolean} isIn - Defines if the animation is in or out.\\n * @param {Object} element - jQuery or HTML object to animate.\\n * @param {String} animation - CSS class to use.\\n * @param {Function} cb - Callback to run when animation is finished.\\n */\\nfunction animate(isIn, element, animation, cb) {\\n  element = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(element).eq(0);\\n\\n  if (!element.length) return;\\n\\n  var initClass = isIn ? initClasses[0] : initClasses[1];\\n  var activeClass = isIn ? activeClasses[0] : activeClasses[1];\\n\\n  // Set up the animation\\n  reset();\\n\\n  element.addClass(animation).css('transition', 'none');\\n\\n  requestAnimationFrame(function () {\\n    element.addClass(initClass);\\n    if (isIn) element.show();\\n  });\\n\\n  // Start the animation\\n  requestAnimationFrame(function () {\\n    element[0].offsetWidth;\\n    element.css('transition', '').addClass(activeClass);\\n  });\\n\\n  // Clean up the animation when it finishes\\n  element.one(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__foundation_util_core__[\\\"c\\\" /* transitionend */])(element), finish);\\n\\n  // Hides the element (for out animations), resets the element, and runs a callback\\n  function finish() {\\n    if (!isIn) element.hide();\\n    reset();\\n    if (cb) cb.apply(element);\\n  }\\n\\n  // Resets transitions and removes motion-specific classes\\n  function reset() {\\n    element[0].style.transitionDuration = 0;\\n    element.removeClass(initClass + ' ' + activeClass + ' ' + animation);\\n  }\\n}\\n\\n\\n\\n/***/ }),\\n/* 7 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return Box; });\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__foundation_util_core__ = __webpack_require__(1);\\n\\n\\n\\n\\nvar Box = {\\n  ImNotTouchingYou: ImNotTouchingYou,\\n  OverlapArea: OverlapArea,\\n  GetDimensions: GetDimensions,\\n  GetOffsets: GetOffsets,\\n  GetExplicitOffsets: GetExplicitOffsets\\n};\\n\\n/**\\n * Compares the dimensions of an element to a container and determines collision events with container.\\n * @function\\n * @param {jQuery} element - jQuery object to test for collisions.\\n * @param {jQuery} parent - jQuery object to use as bounding container.\\n * @param {Boolean} lrOnly - set to true to check left and right values only.\\n * @param {Boolean} tbOnly - set to true to check top and bottom values only.\\n * @default if no parent object passed, detects collisions with `window`.\\n * @returns {Boolean} - true if collision free, false if a collision in any direction.\\n */\\nfunction ImNotTouchingYou(element, parent, lrOnly, tbOnly, ignoreBottom) {\\n  return OverlapArea(element, parent, lrOnly, tbOnly, ignoreBottom) === 0;\\n};\\n\\nfunction OverlapArea(element, parent, lrOnly, tbOnly, ignoreBottom) {\\n  var eleDims = GetDimensions(element),\\n      topOver,\\n      bottomOver,\\n      leftOver,\\n      rightOver;\\n  if (parent) {\\n    var parDims = GetDimensions(parent);\\n\\n    bottomOver = parDims.height + parDims.offset.top - (eleDims.offset.top + eleDims.height);\\n    topOver = eleDims.offset.top - parDims.offset.top;\\n    leftOver = eleDims.offset.left - parDims.offset.left;\\n    rightOver = parDims.width + parDims.offset.left - (eleDims.offset.left + eleDims.width);\\n  } else {\\n    bottomOver = eleDims.windowDims.height + eleDims.windowDims.offset.top - (eleDims.offset.top + eleDims.height);\\n    topOver = eleDims.offset.top - eleDims.windowDims.offset.top;\\n    leftOver = eleDims.offset.left - eleDims.windowDims.offset.left;\\n    rightOver = eleDims.windowDims.width - (eleDims.offset.left + eleDims.width);\\n  }\\n\\n  bottomOver = ignoreBottom ? 0 : Math.min(bottomOver, 0);\\n  topOver = Math.min(topOver, 0);\\n  leftOver = Math.min(leftOver, 0);\\n  rightOver = Math.min(rightOver, 0);\\n\\n  if (lrOnly) {\\n    return leftOver + rightOver;\\n  }\\n  if (tbOnly) {\\n    return topOver + bottomOver;\\n  }\\n\\n  // use sum of squares b/c we care about overlap area.\\n  return Math.sqrt(topOver * topOver + bottomOver * bottomOver + leftOver * leftOver + rightOver * rightOver);\\n}\\n\\n/**\\n * Uses native methods to return an object of dimension values.\\n * @function\\n * @param {jQuery || HTML} element - jQuery object or DOM element for which to get the dimensions. Can be any element other that document or window.\\n * @returns {Object} - nested object of integer pixel values\\n * TODO - if element is window, return only those values.\\n */\\nfunction GetDimensions(elem, test) {\\n  elem = elem.length ? elem[0] : elem;\\n\\n  if (elem === window || elem === document) {\\n    throw new Error(\\\"I'm sorry, Dave. I'm afraid I can't do that.\\\");\\n  }\\n\\n  var rect = elem.getBoundingClientRect(),\\n      parRect = elem.parentNode.getBoundingClientRect(),\\n      winRect = document.body.getBoundingClientRect(),\\n      winY = window.pageYOffset,\\n      winX = window.pageXOffset;\\n\\n  return {\\n    width: rect.width,\\n    height: rect.height,\\n    offset: {\\n      top: rect.top + winY,\\n      left: rect.left + winX\\n    },\\n    parentDims: {\\n      width: parRect.width,\\n      height: parRect.height,\\n      offset: {\\n        top: parRect.top + winY,\\n        left: parRect.left + winX\\n      }\\n    },\\n    windowDims: {\\n      width: winRect.width,\\n      height: winRect.height,\\n      offset: {\\n        top: winY,\\n        left: winX\\n      }\\n    }\\n  };\\n}\\n\\n/**\\n * Returns an object of top and left integer pixel values for dynamically rendered elements,\\n * such as: Tooltip, Reveal, and Dropdown. Maintained for backwards compatibility, and where\\n * you don't know alignment, but generally from\\n * 6.4 forward you should use GetExplicitOffsets, as GetOffsets conflates position and alignment.\\n * @function\\n * @param {jQuery} element - jQuery object for the element being positioned.\\n * @param {jQuery} anchor - jQuery object for the element's anchor point.\\n * @param {String} position - a string relating to the desired position of the element, relative to it's anchor\\n * @param {Number} vOffset - integer pixel value of desired vertical separation between anchor and element.\\n * @param {Number} hOffset - integer pixel value of desired horizontal separation between anchor and element.\\n * @param {Boolean} isOverflow - if a collision event is detected, sets to true to default the element to full width - any desired offset.\\n * TODO alter/rewrite to work with `em` values as well/instead of pixels\\n */\\nfunction GetOffsets(element, anchor, position, vOffset, hOffset, isOverflow) {\\n  console.log(\\\"NOTE: GetOffsets is deprecated in favor of GetExplicitOffsets and will be removed in 6.5\\\");\\n  switch (position) {\\n    case 'top':\\n      return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__foundation_util_core__[\\\"a\\\" /* rtl */])() ? GetExplicitOffsets(element, anchor, 'top', 'left', vOffset, hOffset, isOverflow) : GetExplicitOffsets(element, anchor, 'top', 'right', vOffset, hOffset, isOverflow);\\n    case 'bottom':\\n      return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__foundation_util_core__[\\\"a\\\" /* rtl */])() ? GetExplicitOffsets(element, anchor, 'bottom', 'left', vOffset, hOffset, isOverflow) : GetExplicitOffsets(element, anchor, 'bottom', 'right', vOffset, hOffset, isOverflow);\\n    case 'center top':\\n      return GetExplicitOffsets(element, anchor, 'top', 'center', vOffset, hOffset, isOverflow);\\n    case 'center bottom':\\n      return GetExplicitOffsets(element, anchor, 'bottom', 'center', vOffset, hOffset, isOverflow);\\n    case 'center left':\\n      return GetExplicitOffsets(element, anchor, 'left', 'center', vOffset, hOffset, isOverflow);\\n    case 'center right':\\n      return GetExplicitOffsets(element, anchor, 'right', 'center', vOffset, hOffset, isOverflow);\\n    case 'left bottom':\\n      return GetExplicitOffsets(element, anchor, 'bottom', 'left', vOffset, hOffset, isOverflow);\\n    case 'right bottom':\\n      return GetExplicitOffsets(element, anchor, 'bottom', 'right', vOffset, hOffset, isOverflow);\\n    // Backwards compatibility... this along with the reveal and reveal full\\n    // classes are the only ones that didn't reference anchor\\n    case 'center':\\n      return {\\n        left: $eleDims.windowDims.offset.left + $eleDims.windowDims.width / 2 - $eleDims.width / 2 + hOffset,\\n        top: $eleDims.windowDims.offset.top + $eleDims.windowDims.height / 2 - ($eleDims.height / 2 + vOffset)\\n      };\\n    case 'reveal':\\n      return {\\n        left: ($eleDims.windowDims.width - $eleDims.width) / 2 + hOffset,\\n        top: $eleDims.windowDims.offset.top + vOffset\\n      };\\n    case 'reveal full':\\n      return {\\n        left: $eleDims.windowDims.offset.left,\\n        top: $eleDims.windowDims.offset.top\\n      };\\n      break;\\n    default:\\n      return {\\n        left: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__foundation_util_core__[\\\"a\\\" /* rtl */])() ? $anchorDims.offset.left - $eleDims.width + $anchorDims.width - hOffset : $anchorDims.offset.left + hOffset,\\n        top: $anchorDims.offset.top + $anchorDims.height + vOffset\\n      };\\n\\n  }\\n}\\n\\nfunction GetExplicitOffsets(element, anchor, position, alignment, vOffset, hOffset, isOverflow) {\\n  var $eleDims = GetDimensions(element),\\n      $anchorDims = anchor ? GetDimensions(anchor) : null;\\n\\n  var topVal, leftVal;\\n\\n  // set position related attribute\\n\\n  switch (position) {\\n    case 'top':\\n      topVal = $anchorDims.offset.top - ($eleDims.height + vOffset);\\n      break;\\n    case 'bottom':\\n      topVal = $anchorDims.offset.top + $anchorDims.height + vOffset;\\n      break;\\n    case 'left':\\n      leftVal = $anchorDims.offset.left - ($eleDims.width + hOffset);\\n      break;\\n    case 'right':\\n      leftVal = $anchorDims.offset.left + $anchorDims.width + hOffset;\\n      break;\\n  }\\n\\n  // set alignment related attribute\\n  switch (position) {\\n    case 'top':\\n    case 'bottom':\\n      switch (alignment) {\\n        case 'left':\\n          leftVal = $anchorDims.offset.left + hOffset;\\n          break;\\n        case 'right':\\n          leftVal = $anchorDims.offset.left - $eleDims.width + $anchorDims.width - hOffset;\\n          break;\\n        case 'center':\\n          leftVal = isOverflow ? hOffset : $anchorDims.offset.left + $anchorDims.width / 2 - $eleDims.width / 2 + hOffset;\\n          break;\\n      }\\n      break;\\n    case 'right':\\n    case 'left':\\n      switch (alignment) {\\n        case 'bottom':\\n          topVal = $anchorDims.offset.top - vOffset + $anchorDims.height - $eleDims.height;\\n          break;\\n        case 'top':\\n          topVal = $anchorDims.offset.top + vOffset;\\n          break;\\n        case 'center':\\n          topVal = $anchorDims.offset.top + vOffset + $anchorDims.height / 2 - $eleDims.height / 2;\\n          break;\\n      }\\n      break;\\n  }\\n  return { top: topVal, left: leftVal };\\n}\\n\\n\\n\\n/***/ }),\\n/* 8 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return onImagesLoaded; });\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jquery__);\\n\\n\\n\\n\\n/**\\n * Runs a callback function when images are fully loaded.\\n * @param {Object} images - Image(s) to check if loaded.\\n * @param {Func} callback - Function to execute when image is fully loaded.\\n */\\nfunction onImagesLoaded(images, callback) {\\n  var self = this,\\n      unloaded = images.length;\\n\\n  if (unloaded === 0) {\\n    callback();\\n  }\\n\\n  images.each(function () {\\n    // Check if image is loaded\\n    if (this.complete && this.naturalWidth !== undefined) {\\n      singleImageLoaded();\\n    } else {\\n      // If the above check failed, simulate loading on detached element.\\n      var image = new Image();\\n      // Still count image as loaded if it finalizes with an error.\\n      var events = \\\"load.zf.images error.zf.images\\\";\\n      __WEBPACK_IMPORTED_MODULE_0_jquery___default()(image).one(events, function me(event) {\\n        // Unbind the event listeners. We're using 'one' but only one of the two events will have fired.\\n        __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).off(events, me);\\n        singleImageLoaded();\\n      });\\n      image.src = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).attr('src');\\n    }\\n  });\\n\\n  function singleImageLoaded() {\\n    unloaded--;\\n    if (unloaded === 0) {\\n      callback();\\n    }\\n  }\\n}\\n\\n\\n\\n/***/ }),\\n/* 9 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return Nest; });\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jquery__);\\n\\n\\n\\n\\nvar Nest = {\\n  Feather: function (menu) {\\n    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'zf';\\n\\n    menu.attr('role', 'menubar');\\n\\n    var items = menu.find('li').attr({ 'role': 'menuitem' }),\\n        subMenuClass = 'is-' + type + '-submenu',\\n        subItemClass = subMenuClass + '-item',\\n        hasSubClass = 'is-' + type + '-submenu-parent',\\n        applyAria = type !== 'accordion'; // Accordions handle their own ARIA attriutes.\\n\\n    items.each(function () {\\n      var $item = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this),\\n          $sub = $item.children('ul');\\n\\n      if ($sub.length) {\\n        $item.addClass(hasSubClass);\\n        $sub.addClass('submenu ' + subMenuClass).attr({ 'data-submenu': '' });\\n        if (applyAria) {\\n          $item.attr({\\n            'aria-haspopup': true,\\n            'aria-label': $item.children('a:first').text()\\n          });\\n          // Note:  Drilldowns behave differently in how they hide, and so need\\n          // additional attributes.  We should look if this possibly over-generalized\\n          // utility (Nest) is appropriate when we rework menus in 6.4\\n          if (type === 'drilldown') {\\n            $item.attr({ 'aria-expanded': false });\\n          }\\n        }\\n        $sub.addClass('submenu ' + subMenuClass).attr({\\n          'data-submenu': '',\\n          'role': 'menu'\\n        });\\n        if (type === 'drilldown') {\\n          $sub.attr({ 'aria-hidden': true });\\n        }\\n      }\\n\\n      if ($item.parent('[data-submenu]').length) {\\n        $item.addClass('is-submenu-item ' + subItemClass);\\n      }\\n    });\\n\\n    return;\\n  },\\n  Burn: function (menu, type) {\\n    var //items = menu.find('li'),\\n    subMenuClass = 'is-' + type + '-submenu',\\n        subItemClass = subMenuClass + '-item',\\n        hasSubClass = 'is-' + type + '-submenu-parent';\\n\\n    menu.find('>li, .menu, .menu > li').removeClass(subMenuClass + ' ' + subItemClass + ' ' + hasSubClass + ' is-submenu-item submenu is-active').removeAttr('data-submenu').css('display', '');\\n  }\\n};\\n\\n\\n\\n/***/ }),\\n/* 10 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return Touch; });\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jquery__);\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\n//**************************************************\\n//**Work inspired by multiple jquery swipe plugins**\\n//**Done by Yohai Ararat ***************************\\n//**************************************************\\n\\n\\n\\nvar Touch = {};\\n\\nvar startPosX,\\n    startPosY,\\n    startTime,\\n    elapsedTime,\\n    isMoving = false;\\n\\nfunction onTouchEnd() {\\n  //  alert(this);\\n  this.removeEventListener('touchmove', onTouchMove);\\n  this.removeEventListener('touchend', onTouchEnd);\\n  isMoving = false;\\n}\\n\\nfunction onTouchMove(e) {\\n  if (__WEBPACK_IMPORTED_MODULE_0_jquery___default.a.spotSwipe.preventDefault) {\\n    e.preventDefault();\\n  }\\n  if (isMoving) {\\n    var x = e.touches[0].pageX;\\n    var y = e.touches[0].pageY;\\n    var dx = startPosX - x;\\n    var dy = startPosY - y;\\n    var dir;\\n    elapsedTime = new Date().getTime() - startTime;\\n    if (Math.abs(dx) >= __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.spotSwipe.moveThreshold && elapsedTime <= __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.spotSwipe.timeThreshold) {\\n      dir = dx > 0 ? 'left' : 'right';\\n    }\\n    // else if(Math.abs(dy) >= $.spotSwipe.moveThreshold && elapsedTime <= $.spotSwipe.timeThreshold) {\\n    //   dir = dy > 0 ? 'down' : 'up';\\n    // }\\n    if (dir) {\\n      e.preventDefault();\\n      onTouchEnd.call(this);\\n      __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).trigger('swipe', dir).trigger('swipe' + dir);\\n    }\\n  }\\n}\\n\\nfunction onTouchStart(e) {\\n  if (e.touches.length == 1) {\\n    startPosX = e.touches[0].pageX;\\n    startPosY = e.touches[0].pageY;\\n    isMoving = true;\\n    startTime = new Date().getTime();\\n    this.addEventListener('touchmove', onTouchMove, false);\\n    this.addEventListener('touchend', onTouchEnd, false);\\n  }\\n}\\n\\nfunction init() {\\n  this.addEventListener && this.addEventListener('touchstart', onTouchStart, false);\\n}\\n\\nfunction teardown() {\\n  this.removeEventListener('touchstart', onTouchStart);\\n}\\n\\nvar SpotSwipe = function () {\\n  function SpotSwipe($) {\\n    _classCallCheck(this, SpotSwipe);\\n\\n    this.version = '1.0.0';\\n    this.enabled = 'ontouchstart' in document.documentElement;\\n    this.preventDefault = false;\\n    this.moveThreshold = 75;\\n    this.timeThreshold = 200;\\n    this.$ = $;\\n    this._init();\\n  }\\n\\n  _createClass(SpotSwipe, [{\\n    key: '_init',\\n    value: function _init() {\\n      var $ = this.$;\\n      $.event.special.swipe = { setup: init };\\n\\n      $.each(['left', 'up', 'down', 'right'], function () {\\n        $.event.special['swipe' + this] = { setup: function () {\\n            $(this).on('swipe', $.noop);\\n          } };\\n      });\\n    }\\n  }]);\\n\\n  return SpotSwipe;\\n}();\\n\\n/****************************************************\\n * As far as I can tell, both setupSpotSwipe and    *\\n * setupTouchHandler should be idempotent,          *\\n * because they directly replace functions &        *\\n * values, and do not add event handlers directly.  *\\n ****************************************************/\\n\\nTouch.setupSpotSwipe = function ($) {\\n  $.spotSwipe = new SpotSwipe($);\\n};\\n\\n/****************************************************\\n * Method for adding pseudo drag events to elements *\\n ***************************************************/\\nTouch.setupTouchHandler = function ($) {\\n  $.fn.addTouch = function () {\\n    this.each(function (i, el) {\\n      $(el).bind('touchstart touchmove touchend touchcancel', function () {\\n        //we pass the original event object because the jQuery event\\n        //object is normalized to w3c specs and does not provide the TouchList\\n        handleTouch(event);\\n      });\\n    });\\n\\n    var handleTouch = function (event) {\\n      var touches = event.changedTouches,\\n          first = touches[0],\\n          eventTypes = {\\n        touchstart: 'mousedown',\\n        touchmove: 'mousemove',\\n        touchend: 'mouseup'\\n      },\\n          type = eventTypes[event.type],\\n          simulatedEvent;\\n\\n      if ('MouseEvent' in window && typeof window.MouseEvent === 'function') {\\n        simulatedEvent = new window.MouseEvent(type, {\\n          'bubbles': true,\\n          'cancelable': true,\\n          'screenX': first.screenX,\\n          'screenY': first.screenY,\\n          'clientX': first.clientX,\\n          'clientY': first.clientY\\n        });\\n      } else {\\n        simulatedEvent = document.createEvent('MouseEvent');\\n        simulatedEvent.initMouseEvent(type, true, true, window, 1, first.screenX, first.screenY, first.clientX, first.clientY, false, false, false, false, 0 /*left*/, null);\\n      }\\n      first.target.dispatchEvent(simulatedEvent);\\n    };\\n  };\\n};\\n\\nTouch.init = function ($) {\\n  if (typeof $.spotSwipe === 'undefined') {\\n    Touch.setupSpotSwipe($);\\n    Touch.setupTouchHandler($);\\n  }\\n};\\n\\n\\n\\n/***/ }),\\n/* 11 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return Accordion; });\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jquery__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__foundation_util_keyboard__ = __webpack_require__(3);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__foundation_util_core__ = __webpack_require__(1);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__foundation_plugin__ = __webpack_require__(2);\\n\\n\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return call && (typeof call === \\\"object\\\" || typeof call === \\\"function\\\") ? call : self; }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function, not \\\" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\n\\n\\n\\n\\n\\n/**\\n * Accordion module.\\n * @module foundation.accordion\\n * @requires foundation.util.keyboard\\n */\\n\\nvar Accordion = function (_Plugin) {\\n  _inherits(Accordion, _Plugin);\\n\\n  function Accordion() {\\n    _classCallCheck(this, Accordion);\\n\\n    return _possibleConstructorReturn(this, (Accordion.__proto__ || Object.getPrototypeOf(Accordion)).apply(this, arguments));\\n  }\\n\\n  _createClass(Accordion, [{\\n    key: '_setup',\\n\\n    /**\\n     * Creates a new instance of an accordion.\\n     * @class\\n     * @name Accordion\\n     * @fires Accordion#init\\n     * @param {jQuery} element - jQuery object to make into an accordion.\\n     * @param {Object} options - a plain object with settings to override the default options.\\n     */\\n    value: function _setup(element, options) {\\n      this.$element = element;\\n      this.options = __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.extend({}, Accordion.defaults, this.$element.data(), options);\\n\\n      this.className = 'Accordion'; // ie9 back compat\\n      this._init();\\n\\n      __WEBPACK_IMPORTED_MODULE_1__foundation_util_keyboard__[\\\"a\\\" /* Keyboard */].register('Accordion', {\\n        'ENTER': 'toggle',\\n        'SPACE': 'toggle',\\n        'ARROW_DOWN': 'next',\\n        'ARROW_UP': 'previous'\\n      });\\n    }\\n\\n    /**\\n     * Initializes the accordion by animating the preset active pane(s).\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_init',\\n    value: function _init() {\\n      var _this3 = this;\\n\\n      this.$element.attr('role', 'tablist');\\n      this.$tabs = this.$element.children('[data-accordion-item]');\\n\\n      this.$tabs.each(function (idx, el) {\\n        var $el = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(el),\\n            $content = $el.children('[data-tab-content]'),\\n            id = $content[0].id || __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__foundation_util_core__[\\\"b\\\" /* GetYoDigits */])(6, 'accordion'),\\n            linkId = el.id || id + '-label';\\n\\n        $el.find('a:first').attr({\\n          'aria-controls': id,\\n          'role': 'tab',\\n          'id': linkId,\\n          'aria-expanded': false,\\n          'aria-selected': false\\n        });\\n\\n        $content.attr({ 'role': 'tabpanel', 'aria-labelledby': linkId, 'aria-hidden': true, 'id': id });\\n      });\\n      var $initActive = this.$element.find('.is-active').children('[data-tab-content]');\\n      this.firstTimeInit = true;\\n      if ($initActive.length) {\\n        this.down($initActive, this.firstTimeInit);\\n        this.firstTimeInit = false;\\n      }\\n\\n      this._checkDeepLink = function () {\\n        var anchor = window.location.hash;\\n        //need a hash and a relevant anchor in this tabset\\n        if (anchor.length) {\\n          var $link = _this3.$element.find('[href$=\\\"' + anchor + '\\\"]'),\\n              $anchor = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(anchor);\\n\\n          if ($link.length && $anchor) {\\n            if (!$link.parent('[data-accordion-item]').hasClass('is-active')) {\\n              _this3.down($anchor, _this3.firstTimeInit);\\n              _this3.firstTimeInit = false;\\n            };\\n\\n            //roll up a little to show the titles\\n            if (_this3.options.deepLinkSmudge) {\\n              var _this = _this3;\\n              __WEBPACK_IMPORTED_MODULE_0_jquery___default()(window).load(function () {\\n                var offset = _this.$element.offset();\\n                __WEBPACK_IMPORTED_MODULE_0_jquery___default()('html, body').animate({ scrollTop: offset.top }, _this.options.deepLinkSmudgeDelay);\\n              });\\n            }\\n\\n            /**\\n              * Fires when the zplugin has deeplinked at pageload\\n              * @event Accordion#deeplink\\n              */\\n            _this3.$element.trigger('deeplink.zf.accordion', [$link, $anchor]);\\n          }\\n        }\\n      };\\n\\n      //use browser to open a tab, if it exists in this tabset\\n      if (this.options.deepLink) {\\n        this._checkDeepLink();\\n      }\\n\\n      this._events();\\n    }\\n\\n    /**\\n     * Adds event handlers for items within the accordion.\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_events',\\n    value: function _events() {\\n      var _this = this;\\n\\n      this.$tabs.each(function () {\\n        var $elem = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this);\\n        var $tabContent = $elem.children('[data-tab-content]');\\n        if ($tabContent.length) {\\n          $elem.children('a').off('click.zf.accordion keydown.zf.accordion').on('click.zf.accordion', function (e) {\\n            e.preventDefault();\\n            _this.toggle($tabContent);\\n          }).on('keydown.zf.accordion', function (e) {\\n            __WEBPACK_IMPORTED_MODULE_1__foundation_util_keyboard__[\\\"a\\\" /* Keyboard */].handleKey(e, 'Accordion', {\\n              toggle: function () {\\n                _this.toggle($tabContent);\\n              },\\n              next: function () {\\n                var $a = $elem.next().find('a').focus();\\n                if (!_this.options.multiExpand) {\\n                  $a.trigger('click.zf.accordion');\\n                }\\n              },\\n              previous: function () {\\n                var $a = $elem.prev().find('a').focus();\\n                if (!_this.options.multiExpand) {\\n                  $a.trigger('click.zf.accordion');\\n                }\\n              },\\n              handled: function () {\\n                e.preventDefault();\\n                e.stopPropagation();\\n              }\\n            });\\n          });\\n        }\\n      });\\n      if (this.options.deepLink) {\\n        __WEBPACK_IMPORTED_MODULE_0_jquery___default()(window).on('popstate', this._checkDeepLink);\\n      }\\n    }\\n\\n    /**\\n     * Toggles the selected content pane's open/close state.\\n     * @param {jQuery} $target - jQuery object of the pane to toggle (`.accordion-content`).\\n     * @function\\n     */\\n\\n  }, {\\n    key: 'toggle',\\n    value: function toggle($target) {\\n      if ($target.closest('[data-accordion]').is('[disabled]')) {\\n        console.info('Cannot toggle an accordion that is disabled.');\\n        return;\\n      }\\n      if ($target.parent().hasClass('is-active')) {\\n        this.up($target);\\n      } else {\\n        this.down($target);\\n      }\\n      //either replace or update browser history\\n      if (this.options.deepLink) {\\n        var anchor = $target.prev('a').attr('href');\\n\\n        if (this.options.updateHistory) {\\n          history.pushState({}, '', anchor);\\n        } else {\\n          history.replaceState({}, '', anchor);\\n        }\\n      }\\n    }\\n\\n    /**\\n     * Opens the accordion tab defined by `$target`.\\n     * @param {jQuery} $target - Accordion pane to open (`.accordion-content`).\\n     * @param {Boolean} firstTime - flag to determine if reflow should happen.\\n     * @fires Accordion#down\\n     * @function\\n     */\\n\\n  }, {\\n    key: 'down',\\n    value: function down($target, firstTime) {\\n      var _this4 = this;\\n\\n      /**\\n       * checking firstTime allows for initial render of the accordion\\n       * to render preset is-active panes.\\n       */\\n      if ($target.closest('[data-accordion]').is('[disabled]') && !firstTime) {\\n        console.info('Cannot call down on an accordion that is disabled.');\\n        return;\\n      }\\n      $target.attr('aria-hidden', false).parent('[data-tab-content]').addBack().parent().addClass('is-active');\\n\\n      if (!this.options.multiExpand && !firstTime) {\\n        var $currentActive = this.$element.children('.is-active').children('[data-tab-content]');\\n        if ($currentActive.length) {\\n          this.up($currentActive.not($target));\\n        }\\n      }\\n\\n      $target.slideDown(this.options.slideSpeed, function () {\\n        /**\\n         * Fires when the tab is done opening.\\n         * @event Accordion#down\\n         */\\n        _this4.$element.trigger('down.zf.accordion', [$target]);\\n      });\\n\\n      __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#' + $target.attr('aria-labelledby')).attr({\\n        'aria-expanded': true,\\n        'aria-selected': true\\n      });\\n    }\\n\\n    /**\\n     * Closes the tab defined by `$target`.\\n     * @param {jQuery} $target - Accordion tab to close (`.accordion-content`).\\n     * @fires Accordion#up\\n     * @function\\n     */\\n\\n  }, {\\n    key: 'up',\\n    value: function up($target) {\\n      if ($target.closest('[data-accordion]').is('[disabled]')) {\\n        console.info('Cannot call up on an accordion that is disabled.');\\n        return;\\n      }\\n\\n      var $aunts = $target.parent().siblings(),\\n          _this = this;\\n\\n      if (!this.options.allowAllClosed && !$aunts.hasClass('is-active') || !$target.parent().hasClass('is-active')) {\\n        return;\\n      }\\n\\n      $target.slideUp(_this.options.slideSpeed, function () {\\n        /**\\n         * Fires when the tab is done collapsing up.\\n         * @event Accordion#up\\n         */\\n        _this.$element.trigger('up.zf.accordion', [$target]);\\n      });\\n\\n      $target.attr('aria-hidden', true).parent().removeClass('is-active');\\n\\n      __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#' + $target.attr('aria-labelledby')).attr({\\n        'aria-expanded': false,\\n        'aria-selected': false\\n      });\\n    }\\n\\n    /**\\n     * Destroys an instance of an accordion.\\n     * @fires Accordion#destroyed\\n     * @function\\n     */\\n\\n  }, {\\n    key: '_destroy',\\n    value: function _destroy() {\\n      this.$element.find('[data-tab-content]').stop(true).slideUp(0).css('display', '');\\n      this.$element.find('a').off('.zf.accordion');\\n      if (this.options.deepLink) {\\n        __WEBPACK_IMPORTED_MODULE_0_jquery___default()(window).off('popstate', this._checkDeepLink);\\n      }\\n    }\\n  }]);\\n\\n  return Accordion;\\n}(__WEBPACK_IMPORTED_MODULE_3__foundation_plugin__[\\\"a\\\" /* Plugin */]);\\n\\nAccordion.defaults = {\\n  /**\\n   * Amount of time to animate the opening of an accordion pane.\\n   * @option\\n   * @type {number}\\n   * @default 250\\n   */\\n  slideSpeed: 250,\\n  /**\\n   * Allow the accordion to have multiple open panes.\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  multiExpand: false,\\n  /**\\n   * Allow the accordion to close all panes.\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  allowAllClosed: false,\\n  /**\\n   * Allows the window to scroll to content of pane specified by hash anchor\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  deepLink: false,\\n\\n  /**\\n   * Adjust the deep link scroll to make sure the top of the accordion panel is visible\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  deepLinkSmudge: false,\\n\\n  /**\\n   * Animation time (ms) for the deep link adjustment\\n   * @option\\n   * @type {number}\\n   * @default 300\\n   */\\n  deepLinkSmudgeDelay: 300,\\n\\n  /**\\n   * Update the browser history with the open accordion\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  updateHistory: false\\n};\\n\\n\\n\\n/***/ }),\\n/* 12 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return AccordionMenu; });\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jquery__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__foundation_util_keyboard__ = __webpack_require__(3);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__foundation_util_nest__ = __webpack_require__(9);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__foundation_util_core__ = __webpack_require__(1);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__foundation_plugin__ = __webpack_require__(2);\\n\\n\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return call && (typeof call === \\\"object\\\" || typeof call === \\\"function\\\") ? call : self; }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function, not \\\" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\n\\n\\n\\n\\n\\n\\n/**\\n * AccordionMenu module.\\n * @module foundation.accordionMenu\\n * @requires foundation.util.keyboard\\n * @requires foundation.util.nest\\n */\\n\\nvar AccordionMenu = function (_Plugin) {\\n  _inherits(AccordionMenu, _Plugin);\\n\\n  function AccordionMenu() {\\n    _classCallCheck(this, AccordionMenu);\\n\\n    return _possibleConstructorReturn(this, (AccordionMenu.__proto__ || Object.getPrototypeOf(AccordionMenu)).apply(this, arguments));\\n  }\\n\\n  _createClass(AccordionMenu, [{\\n    key: '_setup',\\n\\n    /**\\n     * Creates a new instance of an accordion menu.\\n     * @class\\n     * @name AccordionMenu\\n     * @fires AccordionMenu#init\\n     * @param {jQuery} element - jQuery object to make into an accordion menu.\\n     * @param {Object} options - Overrides to the default plugin settings.\\n     */\\n    value: function _setup(element, options) {\\n      this.$element = element;\\n      this.options = __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.extend({}, AccordionMenu.defaults, this.$element.data(), options);\\n      this.className = 'AccordionMenu'; // ie9 back compat\\n\\n      __WEBPACK_IMPORTED_MODULE_2__foundation_util_nest__[\\\"a\\\" /* Nest */].Feather(this.$element, 'accordion');\\n\\n      this._init();\\n\\n      __WEBPACK_IMPORTED_MODULE_1__foundation_util_keyboard__[\\\"a\\\" /* Keyboard */].register('AccordionMenu', {\\n        'ENTER': 'toggle',\\n        'SPACE': 'toggle',\\n        'ARROW_RIGHT': 'open',\\n        'ARROW_UP': 'up',\\n        'ARROW_DOWN': 'down',\\n        'ARROW_LEFT': 'close',\\n        'ESCAPE': 'closeAll'\\n      });\\n    }\\n\\n    /**\\n     * Initializes the accordion menu by hiding all nested menus.\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_init',\\n    value: function _init() {\\n      var _this = this;\\n\\n      this.$element.find('[data-submenu]').not('.is-active').slideUp(0); //.find('a').css('padding-left', '1rem');\\n      this.$element.attr({\\n        'role': 'tree',\\n        'aria-multiselectable': this.options.multiOpen\\n      });\\n\\n      this.$menuLinks = this.$element.find('.is-accordion-submenu-parent');\\n      this.$menuLinks.each(function () {\\n        var linkId = this.id || __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__foundation_util_core__[\\\"b\\\" /* GetYoDigits */])(6, 'acc-menu-link'),\\n            $elem = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this),\\n            $sub = $elem.children('[data-submenu]'),\\n            subId = $sub[0].id || __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__foundation_util_core__[\\\"b\\\" /* GetYoDigits */])(6, 'acc-menu'),\\n            isActive = $sub.hasClass('is-active');\\n\\n        if (_this.options.submenuToggle) {\\n          $elem.addClass('has-submenu-toggle');\\n          $elem.children('a').after('<button id=\\\"' + linkId + '\\\" class=\\\"submenu-toggle\\\" aria-controls=\\\"' + subId + '\\\" aria-expanded=\\\"' + isActive + '\\\" title=\\\"' + _this.options.submenuToggleText + '\\\"><span class=\\\"submenu-toggle-text\\\">' + _this.options.submenuToggleText + '</span></button>');\\n        } else {\\n          $elem.attr({\\n            'aria-controls': subId,\\n            'aria-expanded': isActive,\\n            'id': linkId\\n          });\\n        }\\n        $sub.attr({\\n          'aria-labelledby': linkId,\\n          'aria-hidden': !isActive,\\n          'role': 'group',\\n          'id': subId\\n        });\\n      });\\n      this.$element.find('li').attr({\\n        'role': 'treeitem'\\n      });\\n      var initPanes = this.$element.find('.is-active');\\n      if (initPanes.length) {\\n        var _this = this;\\n        initPanes.each(function () {\\n          _this.down(__WEBPACK_IMPORTED_MODULE_0_jquery___default()(this));\\n        });\\n      }\\n      this._events();\\n    }\\n\\n    /**\\n     * Adds event handlers for items within the menu.\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_events',\\n    value: function _events() {\\n      var _this = this;\\n\\n      this.$element.find('li').each(function () {\\n        var $submenu = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).children('[data-submenu]');\\n\\n        if ($submenu.length) {\\n          if (_this.options.submenuToggle) {\\n            __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).children('.submenu-toggle').off('click.zf.accordionMenu').on('click.zf.accordionMenu', function (e) {\\n              _this.toggle($submenu);\\n            });\\n          } else {\\n            __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).children('a').off('click.zf.accordionMenu').on('click.zf.accordionMenu', function (e) {\\n              e.preventDefault();\\n              _this.toggle($submenu);\\n            });\\n          }\\n        }\\n      }).on('keydown.zf.accordionmenu', function (e) {\\n        var $element = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this),\\n            $elements = $element.parent('ul').children('li'),\\n            $prevElement,\\n            $nextElement,\\n            $target = $element.children('[data-submenu]');\\n\\n        $elements.each(function (i) {\\n          if (__WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).is($element)) {\\n            $prevElement = $elements.eq(Math.max(0, i - 1)).find('a').first();\\n            $nextElement = $elements.eq(Math.min(i + 1, $elements.length - 1)).find('a').first();\\n\\n            if (__WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).children('[data-submenu]:visible').length) {\\n              // has open sub menu\\n              $nextElement = $element.find('li:first-child').find('a').first();\\n            }\\n            if (__WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).is(':first-child')) {\\n              // is first element of sub menu\\n              $prevElement = $element.parents('li').first().find('a').first();\\n            } else if ($prevElement.parents('li').first().children('[data-submenu]:visible').length) {\\n              // if previous element has open sub menu\\n              $prevElement = $prevElement.parents('li').find('li:last-child').find('a').first();\\n            }\\n            if (__WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).is(':last-child')) {\\n              // is last element of sub menu\\n              $nextElement = $element.parents('li').first().next('li').find('a').first();\\n            }\\n\\n            return;\\n          }\\n        });\\n\\n        __WEBPACK_IMPORTED_MODULE_1__foundation_util_keyboard__[\\\"a\\\" /* Keyboard */].handleKey(e, 'AccordionMenu', {\\n          open: function () {\\n            if ($target.is(':hidden')) {\\n              _this.down($target);\\n              $target.find('li').first().find('a').first().focus();\\n            }\\n          },\\n          close: function () {\\n            if ($target.length && !$target.is(':hidden')) {\\n              // close active sub of this item\\n              _this.up($target);\\n            } else if ($element.parent('[data-submenu]').length) {\\n              // close currently open sub\\n              _this.up($element.parent('[data-submenu]'));\\n              $element.parents('li').first().find('a').first().focus();\\n            }\\n          },\\n          up: function () {\\n            $prevElement.focus();\\n            return true;\\n          },\\n          down: function () {\\n            $nextElement.focus();\\n            return true;\\n          },\\n          toggle: function () {\\n            if (_this.options.submenuToggle) {\\n              return false;\\n            }\\n            if ($element.children('[data-submenu]').length) {\\n              _this.toggle($element.children('[data-submenu]'));\\n              return true;\\n            }\\n          },\\n          closeAll: function () {\\n            _this.hideAll();\\n          },\\n          handled: function (preventDefault) {\\n            if (preventDefault) {\\n              e.preventDefault();\\n            }\\n            e.stopImmediatePropagation();\\n          }\\n        });\\n      }); //.attr('tabindex', 0);\\n    }\\n\\n    /**\\n     * Closes all panes of the menu.\\n     * @function\\n     */\\n\\n  }, {\\n    key: 'hideAll',\\n    value: function hideAll() {\\n      this.up(this.$element.find('[data-submenu]'));\\n    }\\n\\n    /**\\n     * Opens all panes of the menu.\\n     * @function\\n     */\\n\\n  }, {\\n    key: 'showAll',\\n    value: function showAll() {\\n      this.down(this.$element.find('[data-submenu]'));\\n    }\\n\\n    /**\\n     * Toggles the open/close state of a submenu.\\n     * @function\\n     * @param {jQuery} $target - the submenu to toggle\\n     */\\n\\n  }, {\\n    key: 'toggle',\\n    value: function toggle($target) {\\n      if (!$target.is(':animated')) {\\n        if (!$target.is(':hidden')) {\\n          this.up($target);\\n        } else {\\n          this.down($target);\\n        }\\n      }\\n    }\\n\\n    /**\\n     * Opens the sub-menu defined by `$target`.\\n     * @param {jQuery} $target - Sub-menu to open.\\n     * @fires AccordionMenu#down\\n     */\\n\\n  }, {\\n    key: 'down',\\n    value: function down($target) {\\n      var _this = this;\\n\\n      if (!this.options.multiOpen) {\\n        this.up(this.$element.find('.is-active').not($target.parentsUntil(this.$element).add($target)));\\n      }\\n\\n      $target.addClass('is-active').attr({ 'aria-hidden': false });\\n\\n      if (this.options.submenuToggle) {\\n        $target.prev('.submenu-toggle').attr({ 'aria-expanded': true });\\n      } else {\\n        $target.parent('.is-accordion-submenu-parent').attr({ 'aria-expanded': true });\\n      }\\n\\n      $target.slideDown(_this.options.slideSpeed, function () {\\n        /**\\n         * Fires when the menu is done opening.\\n         * @event AccordionMenu#down\\n         */\\n        _this.$element.trigger('down.zf.accordionMenu', [$target]);\\n      });\\n    }\\n\\n    /**\\n     * Closes the sub-menu defined by `$target`. All sub-menus inside the target will be closed as well.\\n     * @param {jQuery} $target - Sub-menu to close.\\n     * @fires AccordionMenu#up\\n     */\\n\\n  }, {\\n    key: 'up',\\n    value: function up($target) {\\n      var _this = this;\\n      $target.slideUp(_this.options.slideSpeed, function () {\\n        /**\\n         * Fires when the menu is done collapsing up.\\n         * @event AccordionMenu#up\\n         */\\n        _this.$element.trigger('up.zf.accordionMenu', [$target]);\\n      });\\n\\n      var $menus = $target.find('[data-submenu]').slideUp(0).addBack().attr('aria-hidden', true);\\n\\n      if (this.options.submenuToggle) {\\n        $menus.prev('.submenu-toggle').attr('aria-expanded', false);\\n      } else {\\n        $menus.parent('.is-accordion-submenu-parent').attr('aria-expanded', false);\\n      }\\n    }\\n\\n    /**\\n     * Destroys an instance of accordion menu.\\n     * @fires AccordionMenu#destroyed\\n     */\\n\\n  }, {\\n    key: '_destroy',\\n    value: function _destroy() {\\n      this.$element.find('[data-submenu]').slideDown(0).css('display', '');\\n      this.$element.find('a').off('click.zf.accordionMenu');\\n\\n      if (this.options.submenuToggle) {\\n        this.$element.find('.has-submenu-toggle').removeClass('has-submenu-toggle');\\n        this.$element.find('.submenu-toggle').remove();\\n      }\\n\\n      __WEBPACK_IMPORTED_MODULE_2__foundation_util_nest__[\\\"a\\\" /* Nest */].Burn(this.$element, 'accordion');\\n    }\\n  }]);\\n\\n  return AccordionMenu;\\n}(__WEBPACK_IMPORTED_MODULE_4__foundation_plugin__[\\\"a\\\" /* Plugin */]);\\n\\nAccordionMenu.defaults = {\\n  /**\\n   * Amount of time to animate the opening of a submenu in ms.\\n   * @option\\n   * @type {number}\\n   * @default 250\\n   */\\n  slideSpeed: 250,\\n  /**\\n   * Adds a separate submenu toggle button. This allows the parent item to have a link.\\n   * @option\\n   * @example true\\n   */\\n  submenuToggle: false,\\n  /**\\n   * The text used for the submenu toggle if enabled. This is used for screen readers only.\\n   * @option\\n   * @example true\\n   */\\n  submenuToggleText: 'Toggle menu',\\n  /**\\n   * Allow the menu to have multiple open panes.\\n   * @option\\n   * @type {boolean}\\n   * @default true\\n   */\\n  multiOpen: true\\n};\\n\\n\\n\\n/***/ }),\\n/* 13 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return Drilldown; });\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jquery__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__foundation_util_keyboard__ = __webpack_require__(3);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__foundation_util_nest__ = __webpack_require__(9);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__foundation_util_core__ = __webpack_require__(1);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__foundation_util_box__ = __webpack_require__(7);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__foundation_plugin__ = __webpack_require__(2);\\n\\n\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return call && (typeof call === \\\"object\\\" || typeof call === \\\"function\\\") ? call : self; }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function, not \\\" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\n\\n\\n\\n\\n\\n\\n\\n/**\\n * Drilldown module.\\n * @module foundation.drilldown\\n * @requires foundation.util.keyboard\\n * @requires foundation.util.nest\\n * @requires foundation.util.box\\n */\\n\\nvar Drilldown = function (_Plugin) {\\n  _inherits(Drilldown, _Plugin);\\n\\n  function Drilldown() {\\n    _classCallCheck(this, Drilldown);\\n\\n    return _possibleConstructorReturn(this, (Drilldown.__proto__ || Object.getPrototypeOf(Drilldown)).apply(this, arguments));\\n  }\\n\\n  _createClass(Drilldown, [{\\n    key: '_setup',\\n\\n    /**\\n     * Creates a new instance of a drilldown menu.\\n     * @class\\n     * @name Drilldown\\n     * @param {jQuery} element - jQuery object to make into an accordion menu.\\n     * @param {Object} options - Overrides to the default plugin settings.\\n     */\\n    value: function _setup(element, options) {\\n      this.$element = element;\\n      this.options = __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.extend({}, Drilldown.defaults, this.$element.data(), options);\\n      this.className = 'Drilldown'; // ie9 back compat\\n\\n      __WEBPACK_IMPORTED_MODULE_2__foundation_util_nest__[\\\"a\\\" /* Nest */].Feather(this.$element, 'drilldown');\\n\\n      this._init();\\n\\n      __WEBPACK_IMPORTED_MODULE_1__foundation_util_keyboard__[\\\"a\\\" /* Keyboard */].register('Drilldown', {\\n        'ENTER': 'open',\\n        'SPACE': 'open',\\n        'ARROW_RIGHT': 'next',\\n        'ARROW_UP': 'up',\\n        'ARROW_DOWN': 'down',\\n        'ARROW_LEFT': 'previous',\\n        'ESCAPE': 'close',\\n        'TAB': 'down',\\n        'SHIFT_TAB': 'up'\\n      });\\n    }\\n\\n    /**\\n     * Initializes the drilldown by creating jQuery collections of elements\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_init',\\n    value: function _init() {\\n      if (this.options.autoApplyClass) {\\n        this.$element.addClass('drilldown');\\n      }\\n\\n      this.$element.attr({\\n        'role': 'tree',\\n        'aria-multiselectable': false\\n      });\\n      this.$submenuAnchors = this.$element.find('li.is-drilldown-submenu-parent').children('a');\\n      this.$submenus = this.$submenuAnchors.parent('li').children('[data-submenu]').attr('role', 'group');\\n      this.$menuItems = this.$element.find('li').not('.js-drilldown-back').attr('role', 'treeitem').find('a');\\n      this.$element.attr('data-mutate', this.$element.attr('data-drilldown') || __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__foundation_util_core__[\\\"b\\\" /* GetYoDigits */])(6, 'drilldown'));\\n\\n      this._prepareMenu();\\n      this._registerEvents();\\n\\n      this._keyboardEvents();\\n    }\\n\\n    /**\\n     * prepares drilldown menu by setting attributes to links and elements\\n     * sets a min height to prevent content jumping\\n     * wraps the element if not already wrapped\\n     * @private\\n     * @function\\n     */\\n\\n  }, {\\n    key: '_prepareMenu',\\n    value: function _prepareMenu() {\\n      var _this = this;\\n      // if(!this.options.holdOpen){\\n      //   this._menuLinkEvents();\\n      // }\\n      this.$submenuAnchors.each(function () {\\n        var $link = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this);\\n        var $sub = $link.parent();\\n        if (_this.options.parentLink) {\\n          $link.clone().prependTo($sub.children('[data-submenu]')).wrap('<li class=\\\"is-submenu-parent-item is-submenu-item is-drilldown-submenu-item\\\" role=\\\"menu-item\\\"></li>');\\n        }\\n        $link.data('savedHref', $link.attr('href')).removeAttr('href').attr('tabindex', 0);\\n        $link.children('[data-submenu]').attr({\\n          'aria-hidden': true,\\n          'tabindex': 0,\\n          'role': 'group'\\n        });\\n        _this._events($link);\\n      });\\n      this.$submenus.each(function () {\\n        var $menu = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this),\\n            $back = $menu.find('.js-drilldown-back');\\n        if (!$back.length) {\\n          switch (_this.options.backButtonPosition) {\\n            case \\\"bottom\\\":\\n              $menu.append(_this.options.backButton);\\n              break;\\n            case \\\"top\\\":\\n              $menu.prepend(_this.options.backButton);\\n              break;\\n            default:\\n              console.error(\\\"Unsupported backButtonPosition value '\\\" + _this.options.backButtonPosition + \\\"'\\\");\\n          }\\n        }\\n        _this._back($menu);\\n      });\\n\\n      this.$submenus.addClass('invisible');\\n      if (!this.options.autoHeight) {\\n        this.$submenus.addClass('drilldown-submenu-cover-previous');\\n      }\\n\\n      // create a wrapper on element if it doesn't exist.\\n      if (!this.$element.parent().hasClass('is-drilldown')) {\\n        this.$wrapper = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this.options.wrapper).addClass('is-drilldown');\\n        if (this.options.animateHeight) this.$wrapper.addClass('animate-height');\\n        this.$element.wrap(this.$wrapper);\\n      }\\n      // set wrapper\\n      this.$wrapper = this.$element.parent();\\n      this.$wrapper.css(this._getMaxDims());\\n    }\\n  }, {\\n    key: '_resize',\\n    value: function _resize() {\\n      this.$wrapper.css({ 'max-width': 'none', 'min-height': 'none' });\\n      // _getMaxDims has side effects (boo) but calling it should update all other necessary heights & widths\\n      this.$wrapper.css(this._getMaxDims());\\n    }\\n\\n    /**\\n     * Adds event handlers to elements in the menu.\\n     * @function\\n     * @private\\n     * @param {jQuery} $elem - the current menu item to add handlers to.\\n     */\\n\\n  }, {\\n    key: '_events',\\n    value: function _events($elem) {\\n      var _this = this;\\n\\n      $elem.off('click.zf.drilldown').on('click.zf.drilldown', function (e) {\\n        if (__WEBPACK_IMPORTED_MODULE_0_jquery___default()(e.target).parentsUntil('ul', 'li').hasClass('is-drilldown-submenu-parent')) {\\n          e.stopImmediatePropagation();\\n          e.preventDefault();\\n        }\\n\\n        // if(e.target !== e.currentTarget.firstElementChild){\\n        //   return false;\\n        // }\\n        _this._show($elem.parent('li'));\\n\\n        if (_this.options.closeOnClick) {\\n          var $body = __WEBPACK_IMPORTED_MODULE_0_jquery___default()('body');\\n          $body.off('.zf.drilldown').on('click.zf.drilldown', function (e) {\\n            if (e.target === _this.$element[0] || __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.contains(_this.$element[0], e.target)) {\\n              return;\\n            }\\n            e.preventDefault();\\n            _this._hideAll();\\n            $body.off('.zf.drilldown');\\n          });\\n        }\\n      });\\n    }\\n\\n    /**\\n     * Adds event handlers to the menu element.\\n     * @function\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_registerEvents',\\n    value: function _registerEvents() {\\n      if (this.options.scrollTop) {\\n        this._bindHandler = this._scrollTop.bind(this);\\n        this.$element.on('open.zf.drilldown hide.zf.drilldown closed.zf.drilldown', this._bindHandler);\\n      }\\n      this.$element.on('mutateme.zf.trigger', this._resize.bind(this));\\n    }\\n\\n    /**\\n     * Scroll to Top of Element or data-scroll-top-element\\n     * @function\\n     * @fires Drilldown#scrollme\\n     */\\n\\n  }, {\\n    key: '_scrollTop',\\n    value: function _scrollTop() {\\n      var _this = this;\\n      var $scrollTopElement = _this.options.scrollTopElement != '' ? __WEBPACK_IMPORTED_MODULE_0_jquery___default()(_this.options.scrollTopElement) : _this.$element,\\n          scrollPos = parseInt($scrollTopElement.offset().top + _this.options.scrollTopOffset, 10);\\n      __WEBPACK_IMPORTED_MODULE_0_jquery___default()('html, body').stop(true).animate({ scrollTop: scrollPos }, _this.options.animationDuration, _this.options.animationEasing, function () {\\n        /**\\n          * Fires after the menu has scrolled\\n          * @event Drilldown#scrollme\\n          */\\n        if (this === __WEBPACK_IMPORTED_MODULE_0_jquery___default()('html')[0]) _this.$element.trigger('scrollme.zf.drilldown');\\n      });\\n    }\\n\\n    /**\\n     * Adds keydown event listener to `li`'s in the menu.\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_keyboardEvents',\\n    value: function _keyboardEvents() {\\n      var _this = this;\\n\\n      this.$menuItems.add(this.$element.find('.js-drilldown-back > a, .is-submenu-parent-item > a')).on('keydown.zf.drilldown', function (e) {\\n        var $element = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this),\\n            $elements = $element.parent('li').parent('ul').children('li').children('a'),\\n            $prevElement,\\n            $nextElement;\\n\\n        $elements.each(function (i) {\\n          if (__WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).is($element)) {\\n            $prevElement = $elements.eq(Math.max(0, i - 1));\\n            $nextElement = $elements.eq(Math.min(i + 1, $elements.length - 1));\\n            return;\\n          }\\n        });\\n\\n        __WEBPACK_IMPORTED_MODULE_1__foundation_util_keyboard__[\\\"a\\\" /* Keyboard */].handleKey(e, 'Drilldown', {\\n          next: function () {\\n            if ($element.is(_this.$submenuAnchors)) {\\n              _this._show($element.parent('li'));\\n              $element.parent('li').one(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__foundation_util_core__[\\\"c\\\" /* transitionend */])($element), function () {\\n                $element.parent('li').find('ul li a').filter(_this.$menuItems).first().focus();\\n              });\\n              return true;\\n            }\\n          },\\n          previous: function () {\\n            _this._hide($element.parent('li').parent('ul'));\\n            $element.parent('li').parent('ul').one(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__foundation_util_core__[\\\"c\\\" /* transitionend */])($element), function () {\\n              setTimeout(function () {\\n                $element.parent('li').parent('ul').parent('li').children('a').first().focus();\\n              }, 1);\\n            });\\n            return true;\\n          },\\n          up: function () {\\n            $prevElement.focus();\\n            // Don't tap focus on first element in root ul\\n            return !$element.is(_this.$element.find('> li:first-child > a'));\\n          },\\n          down: function () {\\n            $nextElement.focus();\\n            // Don't tap focus on last element in root ul\\n            return !$element.is(_this.$element.find('> li:last-child > a'));\\n          },\\n          close: function () {\\n            // Don't close on element in root ul\\n            if (!$element.is(_this.$element.find('> li > a'))) {\\n              _this._hide($element.parent().parent());\\n              $element.parent().parent().siblings('a').focus();\\n            }\\n          },\\n          open: function () {\\n            if (!$element.is(_this.$menuItems)) {\\n              // not menu item means back button\\n              _this._hide($element.parent('li').parent('ul'));\\n              $element.parent('li').parent('ul').one(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__foundation_util_core__[\\\"c\\\" /* transitionend */])($element), function () {\\n                setTimeout(function () {\\n                  $element.parent('li').parent('ul').parent('li').children('a').first().focus();\\n                }, 1);\\n              });\\n              return true;\\n            } else if ($element.is(_this.$submenuAnchors)) {\\n              _this._show($element.parent('li'));\\n              $element.parent('li').one(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__foundation_util_core__[\\\"c\\\" /* transitionend */])($element), function () {\\n                $element.parent('li').find('ul li a').filter(_this.$menuItems).first().focus();\\n              });\\n              return true;\\n            }\\n          },\\n          handled: function (preventDefault) {\\n            if (preventDefault) {\\n              e.preventDefault();\\n            }\\n            e.stopImmediatePropagation();\\n          }\\n        });\\n      }); // end keyboardAccess\\n    }\\n\\n    /**\\n     * Closes all open elements, and returns to root menu.\\n     * @function\\n     * @fires Drilldown#closed\\n     */\\n\\n  }, {\\n    key: '_hideAll',\\n    value: function _hideAll() {\\n      var $elem = this.$element.find('.is-drilldown-submenu.is-active').addClass('is-closing');\\n      if (this.options.autoHeight) this.$wrapper.css({ height: $elem.parent().closest('ul').data('calcHeight') });\\n      $elem.one(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__foundation_util_core__[\\\"c\\\" /* transitionend */])($elem), function (e) {\\n        $elem.removeClass('is-active is-closing');\\n      });\\n      /**\\n       * Fires when the menu is fully closed.\\n       * @event Drilldown#closed\\n       */\\n      this.$element.trigger('closed.zf.drilldown');\\n    }\\n\\n    /**\\n     * Adds event listener for each `back` button, and closes open menus.\\n     * @function\\n     * @fires Drilldown#back\\n     * @param {jQuery} $elem - the current sub-menu to add `back` event.\\n     */\\n\\n  }, {\\n    key: '_back',\\n    value: function _back($elem) {\\n      var _this = this;\\n      $elem.off('click.zf.drilldown');\\n      $elem.children('.js-drilldown-back').on('click.zf.drilldown', function (e) {\\n        e.stopImmediatePropagation();\\n        // console.log('mouseup on back');\\n        _this._hide($elem);\\n\\n        // If there is a parent submenu, call show\\n        var parentSubMenu = $elem.parent('li').parent('ul').parent('li');\\n        if (parentSubMenu.length) {\\n          _this._show(parentSubMenu);\\n        }\\n      });\\n    }\\n\\n    /**\\n     * Adds event listener to menu items w/o submenus to close open menus on click.\\n     * @function\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_menuLinkEvents',\\n    value: function _menuLinkEvents() {\\n      var _this = this;\\n      this.$menuItems.not('.is-drilldown-submenu-parent').off('click.zf.drilldown').on('click.zf.drilldown', function (e) {\\n        // e.stopImmediatePropagation();\\n        setTimeout(function () {\\n          _this._hideAll();\\n        }, 0);\\n      });\\n    }\\n\\n    /**\\n     * Opens a submenu.\\n     * @function\\n     * @fires Drilldown#open\\n     * @param {jQuery} $elem - the current element with a submenu to open, i.e. the `li` tag.\\n     */\\n\\n  }, {\\n    key: '_show',\\n    value: function _show($elem) {\\n      if (this.options.autoHeight) this.$wrapper.css({ height: $elem.children('[data-submenu]').data('calcHeight') });\\n      $elem.attr('aria-expanded', true);\\n      $elem.children('[data-submenu]').addClass('is-active').removeClass('invisible').attr('aria-hidden', false);\\n      /**\\n       * Fires when the submenu has opened.\\n       * @event Drilldown#open\\n       */\\n      this.$element.trigger('open.zf.drilldown', [$elem]);\\n    }\\n  }, {\\n    key: '_hide',\\n\\n\\n    /**\\n     * Hides a submenu\\n     * @function\\n     * @fires Drilldown#hide\\n     * @param {jQuery} $elem - the current sub-menu to hide, i.e. the `ul` tag.\\n     */\\n    value: function _hide($elem) {\\n      if (this.options.autoHeight) this.$wrapper.css({ height: $elem.parent().closest('ul').data('calcHeight') });\\n      var _this = this;\\n      $elem.parent('li').attr('aria-expanded', false);\\n      $elem.attr('aria-hidden', true).addClass('is-closing');\\n      $elem.addClass('is-closing').one(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__foundation_util_core__[\\\"c\\\" /* transitionend */])($elem), function () {\\n        $elem.removeClass('is-active is-closing');\\n        $elem.blur().addClass('invisible');\\n      });\\n      /**\\n       * Fires when the submenu has closed.\\n       * @event Drilldown#hide\\n       */\\n      $elem.trigger('hide.zf.drilldown', [$elem]);\\n    }\\n\\n    /**\\n     * Iterates through the nested menus to calculate the min-height, and max-width for the menu.\\n     * Prevents content jumping.\\n     * @function\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_getMaxDims',\\n    value: function _getMaxDims() {\\n      var maxHeight = 0,\\n          result = {},\\n          _this = this;\\n      this.$submenus.add(this.$element).each(function () {\\n        var numOfElems = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).children('li').length;\\n        var height = __WEBPACK_IMPORTED_MODULE_4__foundation_util_box__[\\\"a\\\" /* Box */].GetDimensions(this).height;\\n        maxHeight = height > maxHeight ? height : maxHeight;\\n        if (_this.options.autoHeight) {\\n          __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).data('calcHeight', height);\\n          if (!__WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).hasClass('is-drilldown-submenu')) result['height'] = height;\\n        }\\n      });\\n\\n      if (!this.options.autoHeight) result['min-height'] = maxHeight + 'px';\\n\\n      result['max-width'] = this.$element[0].getBoundingClientRect().width + 'px';\\n\\n      return result;\\n    }\\n\\n    /**\\n     * Destroys the Drilldown Menu\\n     * @function\\n     */\\n\\n  }, {\\n    key: '_destroy',\\n    value: function _destroy() {\\n      if (this.options.scrollTop) this.$element.off('.zf.drilldown', this._bindHandler);\\n      this._hideAll();\\n      this.$element.off('mutateme.zf.trigger');\\n      __WEBPACK_IMPORTED_MODULE_2__foundation_util_nest__[\\\"a\\\" /* Nest */].Burn(this.$element, 'drilldown');\\n      this.$element.unwrap().find('.js-drilldown-back, .is-submenu-parent-item').remove().end().find('.is-active, .is-closing, .is-drilldown-submenu').removeClass('is-active is-closing is-drilldown-submenu').end().find('[data-submenu]').removeAttr('aria-hidden tabindex role');\\n      this.$submenuAnchors.each(function () {\\n        __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).off('.zf.drilldown');\\n      });\\n\\n      this.$submenus.removeClass('drilldown-submenu-cover-previous invisible');\\n\\n      this.$element.find('a').each(function () {\\n        var $link = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this);\\n        $link.removeAttr('tabindex');\\n        if ($link.data('savedHref')) {\\n          $link.attr('href', $link.data('savedHref')).removeData('savedHref');\\n        } else {\\n          return;\\n        }\\n      });\\n    }\\n  }]);\\n\\n  return Drilldown;\\n}(__WEBPACK_IMPORTED_MODULE_5__foundation_plugin__[\\\"a\\\" /* Plugin */]);\\n\\nDrilldown.defaults = {\\n  /**\\n   * Drilldowns depend on styles in order to function properly; in the default build of Foundation these are\\n   * on the `drilldown` class. This option auto-applies this class to the drilldown upon initialization.\\n   * @option\\n   * @type {boolian}\\n   * @default true\\n   */\\n  autoApplyClass: true,\\n  /**\\n   * Markup used for JS generated back button. Prepended  or appended (see backButtonPosition) to submenu lists and deleted on `destroy` method, 'js-drilldown-back' class required. Remove the backslash (`\\\\`) if copy and pasting.\\n   * @option\\n   * @type {string}\\n   * @default '<li class=\\\"js-drilldown-back\\\"><a tabindex=\\\"0\\\">Back</a></li>'\\n   */\\n  backButton: '<li class=\\\"js-drilldown-back\\\"><a tabindex=\\\"0\\\">Back</a></li>',\\n  /**\\n   * Position the back button either at the top or bottom of drilldown submenus. Can be `'left'` or `'bottom'`.\\n   * @option\\n   * @type {string}\\n   * @default top\\n   */\\n  backButtonPosition: 'top',\\n  /**\\n   * Markup used to wrap drilldown menu. Use a class name for independent styling; the JS applied class: `is-drilldown` is required. Remove the backslash (`\\\\`) if copy and pasting.\\n   * @option\\n   * @type {string}\\n   * @default '<div></div>'\\n   */\\n  wrapper: '<div></div>',\\n  /**\\n   * Adds the parent link to the submenu.\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  parentLink: false,\\n  /**\\n   * Allow the menu to return to root list on body click.\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  closeOnClick: false,\\n  /**\\n   * Allow the menu to auto adjust height.\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  autoHeight: false,\\n  /**\\n   * Animate the auto adjust height.\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  animateHeight: false,\\n  /**\\n   * Scroll to the top of the menu after opening a submenu or navigating back using the menu back button\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  scrollTop: false,\\n  /**\\n   * String jquery selector (for example 'body') of element to take offset().top from, if empty string the drilldown menu offset().top is taken\\n   * @option\\n   * @type {string}\\n   * @default ''\\n   */\\n  scrollTopElement: '',\\n  /**\\n   * ScrollTop offset\\n   * @option\\n   * @type {number}\\n   * @default 0\\n   */\\n  scrollTopOffset: 0,\\n  /**\\n   * Scroll animation duration\\n   * @option\\n   * @type {number}\\n   * @default 500\\n   */\\n  animationDuration: 500,\\n  /**\\n   * Scroll animation easing. Can be `'swing'` or `'linear'`.\\n   * @option\\n   * @type {string}\\n   * @see {@link https://api.jquery.com/animate|JQuery animate}\\n   * @default 'swing'\\n   */\\n  animationEasing: 'swing'\\n  // holdOpen: false\\n};\\n\\n\\n\\n/***/ }),\\n/* 14 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return DropdownMenu; });\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jquery__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__foundation_util_keyboard__ = __webpack_require__(3);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__foundation_util_nest__ = __webpack_require__(9);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__foundation_util_box__ = __webpack_require__(7);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__foundation_util_core__ = __webpack_require__(1);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__foundation_plugin__ = __webpack_require__(2);\\n\\n\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return call && (typeof call === \\\"object\\\" || typeof call === \\\"function\\\") ? call : self; }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function, not \\\" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\n\\n\\n\\n\\n\\n\\n\\n/**\\n * DropdownMenu module.\\n * @module foundation.dropdown-menu\\n * @requires foundation.util.keyboard\\n * @requires foundation.util.box\\n * @requires foundation.util.nest\\n */\\n\\nvar DropdownMenu = function (_Plugin) {\\n  _inherits(DropdownMenu, _Plugin);\\n\\n  function DropdownMenu() {\\n    _classCallCheck(this, DropdownMenu);\\n\\n    return _possibleConstructorReturn(this, (DropdownMenu.__proto__ || Object.getPrototypeOf(DropdownMenu)).apply(this, arguments));\\n  }\\n\\n  _createClass(DropdownMenu, [{\\n    key: '_setup',\\n\\n    /**\\n     * Creates a new instance of DropdownMenu.\\n     * @class\\n     * @name DropdownMenu\\n     * @fires DropdownMenu#init\\n     * @param {jQuery} element - jQuery object to make into a dropdown menu.\\n     * @param {Object} options - Overrides to the default plugin settings.\\n     */\\n    value: function _setup(element, options) {\\n      this.$element = element;\\n      this.options = __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.extend({}, DropdownMenu.defaults, this.$element.data(), options);\\n      this.className = 'DropdownMenu'; // ie9 back compat\\n\\n      __WEBPACK_IMPORTED_MODULE_2__foundation_util_nest__[\\\"a\\\" /* Nest */].Feather(this.$element, 'dropdown');\\n      this._init();\\n\\n      __WEBPACK_IMPORTED_MODULE_1__foundation_util_keyboard__[\\\"a\\\" /* Keyboard */].register('DropdownMenu', {\\n        'ENTER': 'open',\\n        'SPACE': 'open',\\n        'ARROW_RIGHT': 'next',\\n        'ARROW_UP': 'up',\\n        'ARROW_DOWN': 'down',\\n        'ARROW_LEFT': 'previous',\\n        'ESCAPE': 'close'\\n      });\\n    }\\n\\n    /**\\n     * Initializes the plugin, and calls _prepareMenu\\n     * @private\\n     * @function\\n     */\\n\\n  }, {\\n    key: '_init',\\n    value: function _init() {\\n      var subs = this.$element.find('li.is-dropdown-submenu-parent');\\n      this.$element.children('.is-dropdown-submenu-parent').children('.is-dropdown-submenu').addClass('first-sub');\\n\\n      this.$menuItems = this.$element.find('[role=\\\"menuitem\\\"]');\\n      this.$tabs = this.$element.children('[role=\\\"menuitem\\\"]');\\n      this.$tabs.find('ul.is-dropdown-submenu').addClass(this.options.verticalClass);\\n\\n      if (this.options.alignment === 'auto') {\\n        if (this.$element.hasClass(this.options.rightClass) || __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__foundation_util_core__[\\\"a\\\" /* rtl */])() || this.$element.parents('.top-bar-right').is('*')) {\\n          this.options.alignment = 'right';\\n          subs.addClass('opens-left');\\n        } else {\\n          this.options.alignment = 'left';\\n          subs.addClass('opens-right');\\n        }\\n      } else {\\n        if (this.options.alignment === 'right') {\\n          subs.addClass('opens-left');\\n        } else {\\n          subs.addClass('opens-right');\\n        }\\n      }\\n      this.changed = false;\\n      this._events();\\n    }\\n  }, {\\n    key: '_isVertical',\\n    value: function _isVertical() {\\n      return this.$tabs.css('display') === 'block' || this.$element.css('flex-direction') === 'column';\\n    }\\n  }, {\\n    key: '_isRtl',\\n    value: function _isRtl() {\\n      return this.$element.hasClass('align-right') || __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__foundation_util_core__[\\\"a\\\" /* rtl */])() && !this.$element.hasClass('align-left');\\n    }\\n\\n    /**\\n     * Adds event listeners to elements within the menu\\n     * @private\\n     * @function\\n     */\\n\\n  }, {\\n    key: '_events',\\n    value: function _events() {\\n      var _this = this,\\n          hasTouch = 'ontouchstart' in window || typeof window.ontouchstart !== 'undefined',\\n          parClass = 'is-dropdown-submenu-parent';\\n\\n      // used for onClick and in the keyboard handlers\\n      var handleClickFn = function (e) {\\n        var $elem = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(e.target).parentsUntil('ul', '.' + parClass),\\n            hasSub = $elem.hasClass(parClass),\\n            hasClicked = $elem.attr('data-is-click') === 'true',\\n            $sub = $elem.children('.is-dropdown-submenu');\\n\\n        if (hasSub) {\\n          if (hasClicked) {\\n            if (!_this.options.closeOnClick || !_this.options.clickOpen && !hasTouch || _this.options.forceFollow && hasTouch) {\\n              return;\\n            } else {\\n              e.stopImmediatePropagation();\\n              e.preventDefault();\\n              _this._hide($elem);\\n            }\\n          } else {\\n            e.preventDefault();\\n            e.stopImmediatePropagation();\\n            _this._show($sub);\\n            $elem.add($elem.parentsUntil(_this.$element, '.' + parClass)).attr('data-is-click', true);\\n          }\\n        }\\n      };\\n\\n      if (this.options.clickOpen || hasTouch) {\\n        this.$menuItems.on('click.zf.dropdownmenu touchstart.zf.dropdownmenu', handleClickFn);\\n      }\\n\\n      // Handle Leaf element Clicks\\n      if (_this.options.closeOnClickInside) {\\n        this.$menuItems.on('click.zf.dropdownmenu', function (e) {\\n          var $elem = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this),\\n              hasSub = $elem.hasClass(parClass);\\n          if (!hasSub) {\\n            _this._hide();\\n          }\\n        });\\n      }\\n\\n      if (!this.options.disableHover) {\\n        this.$menuItems.on('mouseenter.zf.dropdownmenu', function (e) {\\n          var $elem = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this),\\n              hasSub = $elem.hasClass(parClass);\\n\\n          if (hasSub) {\\n            clearTimeout($elem.data('_delay'));\\n            $elem.data('_delay', setTimeout(function () {\\n              _this._show($elem.children('.is-dropdown-submenu'));\\n            }, _this.options.hoverDelay));\\n          }\\n        }).on('mouseleave.zf.dropdownmenu', function (e) {\\n          var $elem = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this),\\n              hasSub = $elem.hasClass(parClass);\\n          if (hasSub && _this.options.autoclose) {\\n            if ($elem.attr('data-is-click') === 'true' && _this.options.clickOpen) {\\n              return false;\\n            }\\n\\n            clearTimeout($elem.data('_delay'));\\n            $elem.data('_delay', setTimeout(function () {\\n              _this._hide($elem);\\n            }, _this.options.closingTime));\\n          }\\n        });\\n      }\\n      this.$menuItems.on('keydown.zf.dropdownmenu', function (e) {\\n        var $element = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(e.target).parentsUntil('ul', '[role=\\\"menuitem\\\"]'),\\n            isTab = _this.$tabs.index($element) > -1,\\n            $elements = isTab ? _this.$tabs : $element.siblings('li').add($element),\\n            $prevElement,\\n            $nextElement;\\n\\n        $elements.each(function (i) {\\n          if (__WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).is($element)) {\\n            $prevElement = $elements.eq(i - 1);\\n            $nextElement = $elements.eq(i + 1);\\n            return;\\n          }\\n        });\\n\\n        var nextSibling = function () {\\n          if (!$element.is(':last-child')) {\\n            $nextElement.children('a:first').focus();\\n            e.preventDefault();\\n          }\\n        },\\n            prevSibling = function () {\\n          $prevElement.children('a:first').focus();\\n          e.preventDefault();\\n        },\\n            openSub = function () {\\n          var $sub = $element.children('ul.is-dropdown-submenu');\\n          if ($sub.length) {\\n            _this._show($sub);\\n            $element.find('li > a:first').focus();\\n            e.preventDefault();\\n          } else {\\n            return;\\n          }\\n        },\\n            closeSub = function () {\\n          //if ($element.is(':first-child')) {\\n          var close = $element.parent('ul').parent('li');\\n          close.children('a:first').focus();\\n          _this._hide(close);\\n          e.preventDefault();\\n          //}\\n        };\\n        var functions = {\\n          open: openSub,\\n          close: function () {\\n            _this._hide(_this.$element);\\n            _this.$menuItems.eq(0).children('a').focus(); // focus to first element\\n            e.preventDefault();\\n          },\\n          handled: function () {\\n            e.stopImmediatePropagation();\\n          }\\n        };\\n\\n        if (isTab) {\\n          if (_this._isVertical()) {\\n            // vertical menu\\n            if (_this._isRtl()) {\\n              // right aligned\\n              __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.extend(functions, {\\n                down: nextSibling,\\n                up: prevSibling,\\n                next: closeSub,\\n                previous: openSub\\n              });\\n            } else {\\n              // left aligned\\n              __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.extend(functions, {\\n                down: nextSibling,\\n                up: prevSibling,\\n                next: openSub,\\n                previous: closeSub\\n              });\\n            }\\n          } else {\\n            // horizontal menu\\n            if (_this._isRtl()) {\\n              // right aligned\\n              __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.extend(functions, {\\n                next: prevSibling,\\n                previous: nextSibling,\\n                down: openSub,\\n                up: closeSub\\n              });\\n            } else {\\n              // left aligned\\n              __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.extend(functions, {\\n                next: nextSibling,\\n                previous: prevSibling,\\n                down: openSub,\\n                up: closeSub\\n              });\\n            }\\n          }\\n        } else {\\n          // not tabs -> one sub\\n          if (_this._isRtl()) {\\n            // right aligned\\n            __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.extend(functions, {\\n              next: closeSub,\\n              previous: openSub,\\n              down: nextSibling,\\n              up: prevSibling\\n            });\\n          } else {\\n            // left aligned\\n            __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.extend(functions, {\\n              next: openSub,\\n              previous: closeSub,\\n              down: nextSibling,\\n              up: prevSibling\\n            });\\n          }\\n        }\\n        __WEBPACK_IMPORTED_MODULE_1__foundation_util_keyboard__[\\\"a\\\" /* Keyboard */].handleKey(e, 'DropdownMenu', functions);\\n      });\\n    }\\n\\n    /**\\n     * Adds an event handler to the body to close any dropdowns on a click.\\n     * @function\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_addBodyHandler',\\n    value: function _addBodyHandler() {\\n      var $body = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(document.body),\\n          _this = this;\\n      $body.off('mouseup.zf.dropdownmenu touchend.zf.dropdownmenu').on('mouseup.zf.dropdownmenu touchend.zf.dropdownmenu', function (e) {\\n        var $link = _this.$element.find(e.target);\\n        if ($link.length) {\\n          return;\\n        }\\n\\n        _this._hide();\\n        $body.off('mouseup.zf.dropdownmenu touchend.zf.dropdownmenu');\\n      });\\n    }\\n\\n    /**\\n     * Opens a dropdown pane, and checks for collisions first.\\n     * @param {jQuery} $sub - ul element that is a submenu to show\\n     * @function\\n     * @private\\n     * @fires DropdownMenu#show\\n     */\\n\\n  }, {\\n    key: '_show',\\n    value: function _show($sub) {\\n      var idx = this.$tabs.index(this.$tabs.filter(function (i, el) {\\n        return __WEBPACK_IMPORTED_MODULE_0_jquery___default()(el).find($sub).length > 0;\\n      }));\\n      var $sibs = $sub.parent('li.is-dropdown-submenu-parent').siblings('li.is-dropdown-submenu-parent');\\n      this._hide($sibs, idx);\\n      $sub.css('visibility', 'hidden').addClass('js-dropdown-active').parent('li.is-dropdown-submenu-parent').addClass('is-active');\\n      var clear = __WEBPACK_IMPORTED_MODULE_3__foundation_util_box__[\\\"a\\\" /* Box */].ImNotTouchingYou($sub, null, true);\\n      if (!clear) {\\n        var oldClass = this.options.alignment === 'left' ? '-right' : '-left',\\n            $parentLi = $sub.parent('.is-dropdown-submenu-parent');\\n        $parentLi.removeClass('opens' + oldClass).addClass('opens-' + this.options.alignment);\\n        clear = __WEBPACK_IMPORTED_MODULE_3__foundation_util_box__[\\\"a\\\" /* Box */].ImNotTouchingYou($sub, null, true);\\n        if (!clear) {\\n          $parentLi.removeClass('opens-' + this.options.alignment).addClass('opens-inner');\\n        }\\n        this.changed = true;\\n      }\\n      $sub.css('visibility', '');\\n      if (this.options.closeOnClick) {\\n        this._addBodyHandler();\\n      }\\n      /**\\n       * Fires when the new dropdown pane is visible.\\n       * @event DropdownMenu#show\\n       */\\n      this.$element.trigger('show.zf.dropdownmenu', [$sub]);\\n    }\\n\\n    /**\\n     * Hides a single, currently open dropdown pane, if passed a parameter, otherwise, hides everything.\\n     * @function\\n     * @param {jQuery} $elem - element with a submenu to hide\\n     * @param {Number} idx - index of the $tabs collection to hide\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_hide',\\n    value: function _hide($elem, idx) {\\n      var $toClose;\\n      if ($elem && $elem.length) {\\n        $toClose = $elem;\\n      } else if (idx !== undefined) {\\n        $toClose = this.$tabs.not(function (i, el) {\\n          return i === idx;\\n        });\\n      } else {\\n        $toClose = this.$element;\\n      }\\n      var somethingToClose = $toClose.hasClass('is-active') || $toClose.find('.is-active').length > 0;\\n\\n      if (somethingToClose) {\\n        $toClose.find('li.is-active').add($toClose).attr({\\n          'data-is-click': false\\n        }).removeClass('is-active');\\n\\n        $toClose.find('ul.js-dropdown-active').removeClass('js-dropdown-active');\\n\\n        if (this.changed || $toClose.find('opens-inner').length) {\\n          var oldClass = this.options.alignment === 'left' ? 'right' : 'left';\\n          $toClose.find('li.is-dropdown-submenu-parent').add($toClose).removeClass('opens-inner opens-' + this.options.alignment).addClass('opens-' + oldClass);\\n          this.changed = false;\\n        }\\n        /**\\n         * Fires when the open menus are closed.\\n         * @event DropdownMenu#hide\\n         */\\n        this.$element.trigger('hide.zf.dropdownmenu', [$toClose]);\\n      }\\n    }\\n\\n    /**\\n     * Destroys the plugin.\\n     * @function\\n     */\\n\\n  }, {\\n    key: '_destroy',\\n    value: function _destroy() {\\n      this.$menuItems.off('.zf.dropdownmenu').removeAttr('data-is-click').removeClass('is-right-arrow is-left-arrow is-down-arrow opens-right opens-left opens-inner');\\n      __WEBPACK_IMPORTED_MODULE_0_jquery___default()(document.body).off('.zf.dropdownmenu');\\n      __WEBPACK_IMPORTED_MODULE_2__foundation_util_nest__[\\\"a\\\" /* Nest */].Burn(this.$element, 'dropdown');\\n    }\\n  }]);\\n\\n  return DropdownMenu;\\n}(__WEBPACK_IMPORTED_MODULE_5__foundation_plugin__[\\\"a\\\" /* Plugin */]);\\n\\n/**\\n * Default settings for plugin\\n */\\n\\n\\nDropdownMenu.defaults = {\\n  /**\\n   * Disallows hover events from opening submenus\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  disableHover: false,\\n  /**\\n   * Allow a submenu to automatically close on a mouseleave event, if not clicked open.\\n   * @option\\n   * @type {boolean}\\n   * @default true\\n   */\\n  autoclose: true,\\n  /**\\n   * Amount of time to delay opening a submenu on hover event.\\n   * @option\\n   * @type {number}\\n   * @default 50\\n   */\\n  hoverDelay: 50,\\n  /**\\n   * Allow a submenu to open/remain open on parent click event. Allows cursor to move away from menu.\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  clickOpen: false,\\n  /**\\n   * Amount of time to delay closing a submenu on a mouseleave event.\\n   * @option\\n   * @type {number}\\n   * @default 500\\n   */\\n\\n  closingTime: 500,\\n  /**\\n   * Position of the menu relative to what direction the submenus should open. Handled by JS. Can be `'auto'`, `'left'` or `'right'`.\\n   * @option\\n   * @type {string}\\n   * @default 'auto'\\n   */\\n  alignment: 'auto',\\n  /**\\n   * Allow clicks on the body to close any open submenus.\\n   * @option\\n   * @type {boolean}\\n   * @default true\\n   */\\n  closeOnClick: true,\\n  /**\\n   * Allow clicks on leaf anchor links to close any open submenus.\\n   * @option\\n   * @type {boolean}\\n   * @default true\\n   */\\n  closeOnClickInside: true,\\n  /**\\n   * Class applied to vertical oriented menus, Foundation default is `vertical`. Update this if using your own class.\\n   * @option\\n   * @type {string}\\n   * @default 'vertical'\\n   */\\n  verticalClass: 'vertical',\\n  /**\\n   * Class applied to right-side oriented menus, Foundation default is `align-right`. Update this if using your own class.\\n   * @option\\n   * @type {string}\\n   * @default 'align-right'\\n   */\\n  rightClass: 'align-right',\\n  /**\\n   * Boolean to force overide the clicking of links to perform default action, on second touch event for mobile.\\n   * @option\\n   * @type {boolean}\\n   * @default true\\n   */\\n  forceFollow: true\\n};\\n\\n\\n\\n/***/ }),\\n/* 15 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return Positionable; });\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__foundation_util_box__ = __webpack_require__(7);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__foundation_plugin__ = __webpack_require__(2);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__foundation_util_core__ = __webpack_require__(1);\\n\\n\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return call && (typeof call === \\\"object\\\" || typeof call === \\\"function\\\") ? call : self; }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function, not \\\" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\n\\n\\n\\n\\nvar POSITIONS = ['left', 'right', 'top', 'bottom'];\\nvar VERTICAL_ALIGNMENTS = ['top', 'bottom', 'center'];\\nvar HORIZONTAL_ALIGNMENTS = ['left', 'right', 'center'];\\n\\nvar ALIGNMENTS = {\\n  'left': VERTICAL_ALIGNMENTS,\\n  'right': VERTICAL_ALIGNMENTS,\\n  'top': HORIZONTAL_ALIGNMENTS,\\n  'bottom': HORIZONTAL_ALIGNMENTS\\n};\\n\\nfunction nextItem(item, array) {\\n  var currentIdx = array.indexOf(item);\\n  if (currentIdx === array.length - 1) {\\n    return array[0];\\n  } else {\\n    return array[currentIdx + 1];\\n  }\\n}\\n\\nvar Positionable = function (_Plugin) {\\n  _inherits(Positionable, _Plugin);\\n\\n  function Positionable() {\\n    _classCallCheck(this, Positionable);\\n\\n    return _possibleConstructorReturn(this, (Positionable.__proto__ || Object.getPrototypeOf(Positionable)).apply(this, arguments));\\n  }\\n\\n  _createClass(Positionable, [{\\n    key: '_init',\\n\\n    /**\\n     * Abstract class encapsulating the tether-like explicit positioning logic\\n     * including repositioning based on overlap.\\n     * Expects classes to define defaults for vOffset, hOffset, position,\\n     * alignment, allowOverlap, and allowBottomOverlap. They can do this by\\n     * extending the defaults, or (for now recommended due to the way docs are\\n     * generated) by explicitly declaring them.\\n     *\\n     **/\\n\\n    value: function _init() {\\n      this.triedPositions = {};\\n      this.position = this.options.position === 'auto' ? this._getDefaultPosition() : this.options.position;\\n      this.alignment = this.options.alignment === 'auto' ? this._getDefaultAlignment() : this.options.alignment;\\n    }\\n  }, {\\n    key: '_getDefaultPosition',\\n    value: function _getDefaultPosition() {\\n      return 'bottom';\\n    }\\n  }, {\\n    key: '_getDefaultAlignment',\\n    value: function _getDefaultAlignment() {\\n      switch (this.position) {\\n        case 'bottom':\\n        case 'top':\\n          return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__foundation_util_core__[\\\"a\\\" /* rtl */])() ? 'right' : 'left';\\n        case 'left':\\n        case 'right':\\n          return 'bottom';\\n      }\\n    }\\n\\n    /**\\n     * Adjusts the positionable possible positions by iterating through alignments\\n     * and positions.\\n     * @function\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_reposition',\\n    value: function _reposition() {\\n      if (this._alignmentsExhausted(this.position)) {\\n        this.position = nextItem(this.position, POSITIONS);\\n        this.alignment = ALIGNMENTS[this.position][0];\\n      } else {\\n        this._realign();\\n      }\\n    }\\n\\n    /**\\n     * Adjusts the dropdown pane possible positions by iterating through alignments\\n     * on the current position.\\n     * @function\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_realign',\\n    value: function _realign() {\\n      this._addTriedPosition(this.position, this.alignment);\\n      this.alignment = nextItem(this.alignment, ALIGNMENTS[this.position]);\\n    }\\n  }, {\\n    key: '_addTriedPosition',\\n    value: function _addTriedPosition(position, alignment) {\\n      this.triedPositions[position] = this.triedPositions[position] || [];\\n      this.triedPositions[position].push(alignment);\\n    }\\n  }, {\\n    key: '_positionsExhausted',\\n    value: function _positionsExhausted() {\\n      var isExhausted = true;\\n      for (var i = 0; i < POSITIONS.length; i++) {\\n        isExhausted = isExhausted && this._alignmentsExhausted(POSITIONS[i]);\\n      }\\n      return isExhausted;\\n    }\\n  }, {\\n    key: '_alignmentsExhausted',\\n    value: function _alignmentsExhausted(position) {\\n      return this.triedPositions[position] && this.triedPositions[position].length == ALIGNMENTS[position].length;\\n    }\\n\\n    // When we're trying to center, we don't want to apply offset that's going to\\n    // take us just off center, so wrap around to return 0 for the appropriate\\n    // offset in those alignments.  TODO: Figure out if we want to make this\\n    // configurable behavior... it feels more intuitive, especially for tooltips, but\\n    // it's possible someone might actually want to start from center and then nudge\\n    // slightly off.\\n\\n  }, {\\n    key: '_getVOffset',\\n    value: function _getVOffset() {\\n      return this.options.vOffset;\\n    }\\n  }, {\\n    key: '_getHOffset',\\n    value: function _getHOffset() {\\n      return this.options.hOffset;\\n    }\\n  }, {\\n    key: '_setPosition',\\n    value: function _setPosition($anchor, $element, $parent) {\\n      if ($anchor.attr('aria-expanded') === 'false') {\\n        return false;\\n      }\\n      var $eleDims = __WEBPACK_IMPORTED_MODULE_0__foundation_util_box__[\\\"a\\\" /* Box */].GetDimensions($element),\\n          $anchorDims = __WEBPACK_IMPORTED_MODULE_0__foundation_util_box__[\\\"a\\\" /* Box */].GetDimensions($anchor);\\n\\n      $element.offset(__WEBPACK_IMPORTED_MODULE_0__foundation_util_box__[\\\"a\\\" /* Box */].GetExplicitOffsets($element, $anchor, this.position, this.alignment, this._getVOffset(), this._getHOffset()));\\n\\n      if (!this.options.allowOverlap) {\\n        var overlaps = {};\\n        var minOverlap = 100000000;\\n        // default coordinates to how we start, in case we can't figure out better\\n        var minCoordinates = { position: this.position, alignment: this.alignment };\\n        while (!this._positionsExhausted()) {\\n          var overlap = __WEBPACK_IMPORTED_MODULE_0__foundation_util_box__[\\\"a\\\" /* Box */].OverlapArea($element, $parent, false, false, this.options.allowBottomOverlap);\\n          if (overlap === 0) {\\n            return;\\n          }\\n\\n          if (overlap < minOverlap) {\\n            minOverlap = overlap;\\n            minCoordinates = { position: this.position, alignment: this.alignment };\\n          }\\n\\n          this._reposition();\\n\\n          $element.offset(__WEBPACK_IMPORTED_MODULE_0__foundation_util_box__[\\\"a\\\" /* Box */].GetExplicitOffsets($element, $anchor, this.position, this.alignment, this._getVOffset(), this._getHOffset()));\\n        }\\n        // If we get through the entire loop, there was no non-overlapping\\n        // position available. Pick the version with least overlap.\\n        this.position = minCoordinates.position;\\n        this.alignment = minCoordinates.alignment;\\n        $element.offset(__WEBPACK_IMPORTED_MODULE_0__foundation_util_box__[\\\"a\\\" /* Box */].GetExplicitOffsets($element, $anchor, this.position, this.alignment, this._getVOffset(), this._getHOffset()));\\n      }\\n    }\\n  }]);\\n\\n  return Positionable;\\n}(__WEBPACK_IMPORTED_MODULE_1__foundation_plugin__[\\\"a\\\" /* Plugin */]);\\n\\nPositionable.defaults = {\\n  /**\\n   * Position of positionable relative to anchor. Can be left, right, bottom, top, or auto.\\n   * @option\\n   * @type {string}\\n   * @default 'auto'\\n   */\\n  position: 'auto',\\n  /**\\n   * Alignment of positionable relative to anchor. Can be left, right, bottom, top, center, or auto.\\n   * @option\\n   * @type {string}\\n   * @default 'auto'\\n   */\\n  alignment: 'auto',\\n  /**\\n   * Allow overlap of container/window. If false, dropdown positionable first\\n   * try to position as defined by data-position and data-alignment, but\\n   * reposition if it would cause an overflow.\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  allowOverlap: false,\\n  /**\\n   * Allow overlap of only the bottom of the container. This is the most common\\n   * behavior for dropdowns, allowing the dropdown to extend the bottom of the\\n   * screen but not otherwise influence or break out of the container.\\n   * @option\\n   * @type {boolean}\\n   * @default true\\n   */\\n  allowBottomOverlap: true,\\n  /**\\n   * Number of pixels the positionable should be separated vertically from anchor\\n   * @option\\n   * @type {number}\\n   * @default 0\\n   */\\n  vOffset: 0,\\n  /**\\n   * Number of pixels the positionable should be separated horizontally from anchor\\n   * @option\\n   * @type {number}\\n   * @default 0\\n   */\\n  hOffset: 0\\n};\\n\\n\\n\\n/***/ }),\\n/* 16 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return SmoothScroll; });\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jquery__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__foundation_util_core__ = __webpack_require__(1);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__foundation_plugin__ = __webpack_require__(2);\\n\\n\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return call && (typeof call === \\\"object\\\" || typeof call === \\\"function\\\") ? call : self; }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function, not \\\" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\n\\n\\n\\n\\n/**\\n * SmoothScroll module.\\n * @module foundation.smooth-scroll\\n */\\n\\nvar SmoothScroll = function (_Plugin) {\\n    _inherits(SmoothScroll, _Plugin);\\n\\n    function SmoothScroll() {\\n        _classCallCheck(this, SmoothScroll);\\n\\n        return _possibleConstructorReturn(this, (SmoothScroll.__proto__ || Object.getPrototypeOf(SmoothScroll)).apply(this, arguments));\\n    }\\n\\n    _createClass(SmoothScroll, [{\\n        key: '_setup',\\n\\n        /**\\n         * Creates a new instance of SmoothScroll.\\n         * @class\\n         * @name SmoothScroll\\n         * @fires SmoothScroll#init\\n         * @param {Object} element - jQuery object to add the trigger to.\\n         * @param {Object} options - Overrides to the default plugin settings.\\n         */\\n        value: function _setup(element, options) {\\n            this.$element = element;\\n            this.options = __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.extend({}, SmoothScroll.defaults, this.$element.data(), options);\\n            this.className = 'SmoothScroll'; // ie9 back compat\\n\\n            this._init();\\n        }\\n\\n        /**\\n         * Initialize the SmoothScroll plugin\\n         * @private\\n         */\\n\\n    }, {\\n        key: '_init',\\n        value: function _init() {\\n            var id = this.$element[0].id || __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__foundation_util_core__[\\\"b\\\" /* GetYoDigits */])(6, 'smooth-scroll');\\n            var _this = this;\\n            this.$element.attr({\\n                'id': id\\n            });\\n\\n            this._events();\\n        }\\n\\n        /**\\n         * Initializes events for SmoothScroll.\\n         * @private\\n         */\\n\\n    }, {\\n        key: '_events',\\n        value: function _events() {\\n            var _this = this;\\n\\n            // click handler function.\\n            var handleLinkClick = function (e) {\\n                // exit function if the event source isn't coming from an anchor with href attribute starts with '#'\\n                if (!__WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).is('a[href^=\\\"#\\\"]')) {\\n                    return false;\\n                }\\n\\n                var arrival = this.getAttribute('href');\\n\\n                _this._inTransition = true;\\n\\n                SmoothScroll.scrollToLoc(arrival, _this.options, function () {\\n                    _this._inTransition = false;\\n                });\\n\\n                e.preventDefault();\\n            };\\n\\n            this.$element.on('click.zf.smoothScroll', handleLinkClick);\\n            this.$element.on('click.zf.smoothScroll', 'a[href^=\\\"#\\\"]', handleLinkClick);\\n        }\\n\\n        /**\\n         * Function to scroll to a given location on the page.\\n         * @param {String} loc - A properly formatted jQuery id selector. Example: '#foo'\\n         * @param {Object} options - The options to use.\\n         * @param {Function} callback - The callback function.\\n         * @static\\n         * @function\\n         */\\n\\n    }], [{\\n        key: 'scrollToLoc',\\n        value: function scrollToLoc(loc) {\\n            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : SmoothScroll.defaults;\\n            var callback = arguments[2];\\n\\n            // Do nothing if target does not exist to prevent errors\\n            if (!__WEBPACK_IMPORTED_MODULE_0_jquery___default()(loc).length) {\\n                return false;\\n            }\\n\\n            var scrollPos = Math.round(__WEBPACK_IMPORTED_MODULE_0_jquery___default()(loc).offset().top - options.threshold / 2 - options.offset);\\n\\n            __WEBPACK_IMPORTED_MODULE_0_jquery___default()('html, body').stop(true).animate({ scrollTop: scrollPos }, options.animationDuration, options.animationEasing, function () {\\n                if (callback && typeof callback == \\\"function\\\") {\\n                    callback();\\n                }\\n            });\\n        }\\n    }]);\\n\\n    return SmoothScroll;\\n}(__WEBPACK_IMPORTED_MODULE_2__foundation_plugin__[\\\"a\\\" /* Plugin */]);\\n\\n/**\\n * Default settings for plugin.\\n */\\n\\n\\nSmoothScroll.defaults = {\\n    /**\\n     * Amount of time, in ms, the animated scrolling should take between locations.\\n     * @option\\n     * @type {number}\\n     * @default 500\\n     */\\n    animationDuration: 500,\\n    /**\\n     * Animation style to use when scrolling between locations. Can be `'swing'` or `'linear'`.\\n     * @option\\n     * @type {string}\\n     * @default 'linear'\\n     * @see {@link https://api.jquery.com/animate|Jquery animate}\\n     */\\n    animationEasing: 'linear',\\n    /**\\n     * Number of pixels to use as a marker for location changes.\\n     * @option\\n     * @type {number}\\n     * @default 50\\n     */\\n    threshold: 50,\\n    /**\\n     * Number of pixels to offset the scroll of the page on item click if using a sticky nav bar.\\n     * @option\\n     * @type {number}\\n     * @default 0\\n     */\\n    offset: 0\\n};\\n\\n\\n\\n/***/ }),\\n/* 17 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return Tabs; });\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jquery__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__foundation_util_keyboard__ = __webpack_require__(3);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__foundation_util_imageLoader__ = __webpack_require__(8);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__foundation_plugin__ = __webpack_require__(2);\\n\\n\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return call && (typeof call === \\\"object\\\" || typeof call === \\\"function\\\") ? call : self; }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function, not \\\" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\n\\n\\n\\n\\n/**\\n * Tabs module.\\n * @module foundation.tabs\\n * @requires foundation.util.keyboard\\n * @requires foundation.util.imageLoader if tabs contain images\\n */\\n\\nvar Tabs = function (_Plugin) {\\n  _inherits(Tabs, _Plugin);\\n\\n  function Tabs() {\\n    _classCallCheck(this, Tabs);\\n\\n    return _possibleConstructorReturn(this, (Tabs.__proto__ || Object.getPrototypeOf(Tabs)).apply(this, arguments));\\n  }\\n\\n  _createClass(Tabs, [{\\n    key: '_setup',\\n\\n    /**\\n     * Creates a new instance of tabs.\\n     * @class\\n     * @name Tabs\\n     * @fires Tabs#init\\n     * @param {jQuery} element - jQuery object to make into tabs.\\n     * @param {Object} options - Overrides to the default plugin settings.\\n     */\\n    value: function _setup(element, options) {\\n      this.$element = element;\\n      this.options = __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.extend({}, Tabs.defaults, this.$element.data(), options);\\n      this.className = 'Tabs'; // ie9 back compat\\n\\n      this._init();\\n      __WEBPACK_IMPORTED_MODULE_1__foundation_util_keyboard__[\\\"a\\\" /* Keyboard */].register('Tabs', {\\n        'ENTER': 'open',\\n        'SPACE': 'open',\\n        'ARROW_RIGHT': 'next',\\n        'ARROW_UP': 'previous',\\n        'ARROW_DOWN': 'next',\\n        'ARROW_LEFT': 'previous'\\n        // 'TAB': 'next',\\n        // 'SHIFT_TAB': 'previous'\\n      });\\n    }\\n\\n    /**\\n     * Initializes the tabs by showing and focusing (if autoFocus=true) the preset active tab.\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_init',\\n    value: function _init() {\\n      var _this3 = this;\\n\\n      var _this = this;\\n\\n      this.$element.attr({ 'role': 'tablist' });\\n      this.$tabTitles = this.$element.find('.' + this.options.linkClass);\\n      this.$tabContent = __WEBPACK_IMPORTED_MODULE_0_jquery___default()('[data-tabs-content=\\\"' + this.$element[0].id + '\\\"]');\\n\\n      this.$tabTitles.each(function () {\\n        var $elem = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this),\\n            $link = $elem.find('a'),\\n            isActive = $elem.hasClass('' + _this.options.linkActiveClass),\\n            hash = $link.attr('data-tabs-target') || $link[0].hash.slice(1),\\n            linkId = $link[0].id ? $link[0].id : hash + '-label',\\n            $tabContent = __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#' + hash);\\n\\n        $elem.attr({ 'role': 'presentation' });\\n\\n        $link.attr({\\n          'role': 'tab',\\n          'aria-controls': hash,\\n          'aria-selected': isActive,\\n          'id': linkId,\\n          'tabindex': isActive ? '0' : '-1'\\n        });\\n\\n        $tabContent.attr({\\n          'role': 'tabpanel',\\n          'aria-labelledby': linkId\\n        });\\n\\n        if (!isActive) {\\n          $tabContent.attr('aria-hidden', 'true');\\n        }\\n\\n        if (isActive && _this.options.autoFocus) {\\n          __WEBPACK_IMPORTED_MODULE_0_jquery___default()(window).load(function () {\\n            __WEBPACK_IMPORTED_MODULE_0_jquery___default()('html, body').animate({ scrollTop: $elem.offset().top }, _this.options.deepLinkSmudgeDelay, function () {\\n              $link.focus();\\n            });\\n          });\\n        }\\n      });\\n      if (this.options.matchHeight) {\\n        var $images = this.$tabContent.find('img');\\n\\n        if ($images.length) {\\n          __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__foundation_util_imageLoader__[\\\"a\\\" /* onImagesLoaded */])($images, this._setHeight.bind(this));\\n        } else {\\n          this._setHeight();\\n        }\\n      }\\n\\n      //current context-bound function to open tabs on page load or history popstate\\n      this._checkDeepLink = function () {\\n        var anchor = window.location.hash;\\n        //need a hash and a relevant anchor in this tabset\\n        if (anchor.length) {\\n          var $link = _this3.$element.find('[href$=\\\"' + anchor + '\\\"]');\\n          if ($link.length) {\\n            _this3.selectTab(__WEBPACK_IMPORTED_MODULE_0_jquery___default()(anchor), true);\\n\\n            //roll up a little to show the titles\\n            if (_this3.options.deepLinkSmudge) {\\n              var offset = _this3.$element.offset();\\n              __WEBPACK_IMPORTED_MODULE_0_jquery___default()('html, body').animate({ scrollTop: offset.top }, _this3.options.deepLinkSmudgeDelay);\\n            }\\n\\n            /**\\n              * Fires when the zplugin has deeplinked at pageload\\n              * @event Tabs#deeplink\\n              */\\n            _this3.$element.trigger('deeplink.zf.tabs', [$link, __WEBPACK_IMPORTED_MODULE_0_jquery___default()(anchor)]);\\n          }\\n        }\\n      };\\n\\n      //use browser to open a tab, if it exists in this tabset\\n      if (this.options.deepLink) {\\n        this._checkDeepLink();\\n      }\\n\\n      this._events();\\n    }\\n\\n    /**\\n     * Adds event handlers for items within the tabs.\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_events',\\n    value: function _events() {\\n      this._addKeyHandler();\\n      this._addClickHandler();\\n      this._setHeightMqHandler = null;\\n\\n      if (this.options.matchHeight) {\\n        this._setHeightMqHandler = this._setHeight.bind(this);\\n\\n        __WEBPACK_IMPORTED_MODULE_0_jquery___default()(window).on('changed.zf.mediaquery', this._setHeightMqHandler);\\n      }\\n\\n      if (this.options.deepLink) {\\n        __WEBPACK_IMPORTED_MODULE_0_jquery___default()(window).on('popstate', this._checkDeepLink);\\n      }\\n    }\\n\\n    /**\\n     * Adds click handlers for items within the tabs.\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_addClickHandler',\\n    value: function _addClickHandler() {\\n      var _this = this;\\n\\n      this.$element.off('click.zf.tabs').on('click.zf.tabs', '.' + this.options.linkClass, function (e) {\\n        e.preventDefault();\\n        e.stopPropagation();\\n        _this._handleTabChange(__WEBPACK_IMPORTED_MODULE_0_jquery___default()(this));\\n      });\\n    }\\n\\n    /**\\n     * Adds keyboard event handlers for items within the tabs.\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_addKeyHandler',\\n    value: function _addKeyHandler() {\\n      var _this = this;\\n\\n      this.$tabTitles.off('keydown.zf.tabs').on('keydown.zf.tabs', function (e) {\\n        if (e.which === 9) return;\\n\\n        var $element = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this),\\n            $elements = $element.parent('ul').children('li'),\\n            $prevElement,\\n            $nextElement;\\n\\n        $elements.each(function (i) {\\n          if (__WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).is($element)) {\\n            if (_this.options.wrapOnKeys) {\\n              $prevElement = i === 0 ? $elements.last() : $elements.eq(i - 1);\\n              $nextElement = i === $elements.length - 1 ? $elements.first() : $elements.eq(i + 1);\\n            } else {\\n              $prevElement = $elements.eq(Math.max(0, i - 1));\\n              $nextElement = $elements.eq(Math.min(i + 1, $elements.length - 1));\\n            }\\n            return;\\n          }\\n        });\\n\\n        // handle keyboard event with keyboard util\\n        __WEBPACK_IMPORTED_MODULE_1__foundation_util_keyboard__[\\\"a\\\" /* Keyboard */].handleKey(e, 'Tabs', {\\n          open: function () {\\n            $element.find('[role=\\\"tab\\\"]').focus();\\n            _this._handleTabChange($element);\\n          },\\n          previous: function () {\\n            $prevElement.find('[role=\\\"tab\\\"]').focus();\\n            _this._handleTabChange($prevElement);\\n          },\\n          next: function () {\\n            $nextElement.find('[role=\\\"tab\\\"]').focus();\\n            _this._handleTabChange($nextElement);\\n          },\\n          handled: function () {\\n            e.stopPropagation();\\n            e.preventDefault();\\n          }\\n        });\\n      });\\n    }\\n\\n    /**\\n     * Opens the tab `$targetContent` defined by `$target`. Collapses active tab.\\n     * @param {jQuery} $target - Tab to open.\\n     * @param {boolean} historyHandled - browser has already handled a history update\\n     * @fires Tabs#change\\n     * @function\\n     */\\n\\n  }, {\\n    key: '_handleTabChange',\\n    value: function _handleTabChange($target, historyHandled) {\\n\\n      /**\\n       * Check for active class on target. Collapse if exists.\\n       */\\n      if ($target.hasClass('' + this.options.linkActiveClass)) {\\n        if (this.options.activeCollapse) {\\n          this._collapseTab($target);\\n\\n          /**\\n           * Fires when the zplugin has successfully collapsed tabs.\\n           * @event Tabs#collapse\\n           */\\n          this.$element.trigger('collapse.zf.tabs', [$target]);\\n        }\\n        return;\\n      }\\n\\n      var $oldTab = this.$element.find('.' + this.options.linkClass + '.' + this.options.linkActiveClass),\\n          $tabLink = $target.find('[role=\\\"tab\\\"]'),\\n          hash = $tabLink.attr('data-tabs-target') || $tabLink[0].hash.slice(1),\\n          $targetContent = this.$tabContent.find('#' + hash);\\n\\n      //close old tab\\n      this._collapseTab($oldTab);\\n\\n      //open new tab\\n      this._openTab($target);\\n\\n      //either replace or update browser history\\n      if (this.options.deepLink && !historyHandled) {\\n        var anchor = $target.find('a').attr('href');\\n\\n        if (this.options.updateHistory) {\\n          history.pushState({}, '', anchor);\\n        } else {\\n          history.replaceState({}, '', anchor);\\n        }\\n      }\\n\\n      /**\\n       * Fires when the plugin has successfully changed tabs.\\n       * @event Tabs#change\\n       */\\n      this.$element.trigger('change.zf.tabs', [$target, $targetContent]);\\n\\n      //fire to children a mutation event\\n      $targetContent.find(\\\"[data-mutate]\\\").trigger(\\\"mutateme.zf.trigger\\\");\\n    }\\n\\n    /**\\n     * Opens the tab `$targetContent` defined by `$target`.\\n     * @param {jQuery} $target - Tab to Open.\\n     * @function\\n     */\\n\\n  }, {\\n    key: '_openTab',\\n    value: function _openTab($target) {\\n      var $tabLink = $target.find('[role=\\\"tab\\\"]'),\\n          hash = $tabLink.attr('data-tabs-target') || $tabLink[0].hash.slice(1),\\n          $targetContent = this.$tabContent.find('#' + hash);\\n\\n      $target.addClass('' + this.options.linkActiveClass);\\n\\n      $tabLink.attr({\\n        'aria-selected': 'true',\\n        'tabindex': '0'\\n      });\\n\\n      $targetContent.addClass('' + this.options.panelActiveClass).removeAttr('aria-hidden');\\n    }\\n\\n    /**\\n     * Collapses `$targetContent` defined by `$target`.\\n     * @param {jQuery} $target - Tab to Open.\\n     * @function\\n     */\\n\\n  }, {\\n    key: '_collapseTab',\\n    value: function _collapseTab($target) {\\n      var $target_anchor = $target.removeClass('' + this.options.linkActiveClass).find('[role=\\\"tab\\\"]').attr({\\n        'aria-selected': 'false',\\n        'tabindex': -1\\n      });\\n\\n      __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#' + $target_anchor.attr('aria-controls')).removeClass('' + this.options.panelActiveClass).attr({ 'aria-hidden': 'true' });\\n    }\\n\\n    /**\\n     * Public method for selecting a content pane to display.\\n     * @param {jQuery | String} elem - jQuery object or string of the id of the pane to display.\\n     * @param {boolean} historyHandled - browser has already handled a history update\\n     * @function\\n     */\\n\\n  }, {\\n    key: 'selectTab',\\n    value: function selectTab(elem, historyHandled) {\\n      var idStr;\\n\\n      if (typeof elem === 'object') {\\n        idStr = elem[0].id;\\n      } else {\\n        idStr = elem;\\n      }\\n\\n      if (idStr.indexOf('#') < 0) {\\n        idStr = '#' + idStr;\\n      }\\n\\n      var $target = this.$tabTitles.find('[href$=\\\"' + idStr + '\\\"]').parent('.' + this.options.linkClass);\\n\\n      this._handleTabChange($target, historyHandled);\\n    }\\n  }, {\\n    key: '_setHeight',\\n\\n    /**\\n     * Sets the height of each panel to the height of the tallest panel.\\n     * If enabled in options, gets called on media query change.\\n     * If loading content via external source, can be called directly or with _reflow.\\n     * If enabled with `data-match-height=\\\"true\\\"`, tabs sets to equal height\\n     * @function\\n     * @private\\n     */\\n    value: function _setHeight() {\\n      var max = 0,\\n          _this = this; // Lock down the `this` value for the root tabs object\\n\\n      this.$tabContent.find('.' + this.options.panelClass).css('height', '').each(function () {\\n\\n        var panel = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this),\\n            isActive = panel.hasClass('' + _this.options.panelActiveClass); // get the options from the parent instead of trying to get them from the child\\n\\n        if (!isActive) {\\n          panel.css({ 'visibility': 'hidden', 'display': 'block' });\\n        }\\n\\n        var temp = this.getBoundingClientRect().height;\\n\\n        if (!isActive) {\\n          panel.css({\\n            'visibility': '',\\n            'display': ''\\n          });\\n        }\\n\\n        max = temp > max ? temp : max;\\n      }).css('height', max + 'px');\\n    }\\n\\n    /**\\n     * Destroys an instance of an tabs.\\n     * @fires Tabs#destroyed\\n     */\\n\\n  }, {\\n    key: '_destroy',\\n    value: function _destroy() {\\n      this.$element.find('.' + this.options.linkClass).off('.zf.tabs').hide().end().find('.' + this.options.panelClass).hide();\\n\\n      if (this.options.matchHeight) {\\n        if (this._setHeightMqHandler != null) {\\n          __WEBPACK_IMPORTED_MODULE_0_jquery___default()(window).off('changed.zf.mediaquery', this._setHeightMqHandler);\\n        }\\n      }\\n\\n      if (this.options.deepLink) {\\n        __WEBPACK_IMPORTED_MODULE_0_jquery___default()(window).off('popstate', this._checkDeepLink);\\n      }\\n    }\\n  }]);\\n\\n  return Tabs;\\n}(__WEBPACK_IMPORTED_MODULE_3__foundation_plugin__[\\\"a\\\" /* Plugin */]);\\n\\nTabs.defaults = {\\n  /**\\n   * Allows the window to scroll to content of pane specified by hash anchor\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  deepLink: false,\\n\\n  /**\\n   * Adjust the deep link scroll to make sure the top of the tab panel is visible\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  deepLinkSmudge: false,\\n\\n  /**\\n   * Animation time (ms) for the deep link adjustment\\n   * @option\\n   * @type {number}\\n   * @default 300\\n   */\\n  deepLinkSmudgeDelay: 300,\\n\\n  /**\\n   * Update the browser history with the open tab\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  updateHistory: false,\\n\\n  /**\\n   * Allows the window to scroll to content of active pane on load if set to true.\\n   * Not recommended if more than one tab panel per page.\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  autoFocus: false,\\n\\n  /**\\n   * Allows keyboard input to 'wrap' around the tab links.\\n   * @option\\n   * @type {boolean}\\n   * @default true\\n   */\\n  wrapOnKeys: true,\\n\\n  /**\\n   * Allows the tab content panes to match heights if set to true.\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  matchHeight: false,\\n\\n  /**\\n   * Allows active tabs to collapse when clicked.\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  activeCollapse: false,\\n\\n  /**\\n   * Class applied to `li`'s in tab link list.\\n   * @option\\n   * @type {string}\\n   * @default 'tabs-title'\\n   */\\n  linkClass: 'tabs-title',\\n\\n  /**\\n   * Class applied to the active `li` in tab link list.\\n   * @option\\n   * @type {string}\\n   * @default 'is-active'\\n   */\\n  linkActiveClass: 'is-active',\\n\\n  /**\\n   * Class applied to the content containers.\\n   * @option\\n   * @type {string}\\n   * @default 'tabs-panel'\\n   */\\n  panelClass: 'tabs-panel',\\n\\n  /**\\n   * Class applied to the active content container.\\n   * @option\\n   * @type {string}\\n   * @default 'is-active'\\n   */\\n  panelActiveClass: 'is-active'\\n};\\n\\n\\n\\n/***/ }),\\n/* 18 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return Timer; });\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jquery__);\\n\\n\\n\\n\\nfunction Timer(elem, options, cb) {\\n  var _this = this,\\n      duration = options.duration,\\n      //options is an object for easily adding features later.\\n  nameSpace = Object.keys(elem.data())[0] || 'timer',\\n      remain = -1,\\n      start,\\n      timer;\\n\\n  this.isPaused = false;\\n\\n  this.restart = function () {\\n    remain = -1;\\n    clearTimeout(timer);\\n    this.start();\\n  };\\n\\n  this.start = function () {\\n    this.isPaused = false;\\n    // if(!elem.data('paused')){ return false; }//maybe implement this sanity check if used for other things.\\n    clearTimeout(timer);\\n    remain = remain <= 0 ? duration : remain;\\n    elem.data('paused', false);\\n    start = Date.now();\\n    timer = setTimeout(function () {\\n      if (options.infinite) {\\n        _this.restart(); //rerun the timer.\\n      }\\n      if (cb && typeof cb === 'function') {\\n        cb();\\n      }\\n    }, remain);\\n    elem.trigger('timerstart.zf.' + nameSpace);\\n  };\\n\\n  this.pause = function () {\\n    this.isPaused = true;\\n    //if(elem.data('paused')){ return false; }//maybe implement this sanity check if used for other things.\\n    clearTimeout(timer);\\n    elem.data('paused', true);\\n    var end = Date.now();\\n    remain = remain - (end - start);\\n    elem.trigger('timerpaused.zf.' + nameSpace);\\n  };\\n}\\n\\n\\n\\n/***/ }),\\n/* 19 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\nObject.defineProperty(__webpack_exports__, \\\"__esModule\\\", { value: true });\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jquery__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__foundation_core__ = __webpack_require__(21);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__foundation_util_core__ = __webpack_require__(1);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__foundation_util_box__ = __webpack_require__(7);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__foundation_util_imageLoader__ = __webpack_require__(8);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__foundation_util_keyboard__ = __webpack_require__(3);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__foundation_util_mediaQuery__ = __webpack_require__(4);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__foundation_util_motion__ = __webpack_require__(6);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__foundation_util_nest__ = __webpack_require__(9);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__foundation_util_timer__ = __webpack_require__(18);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__foundation_util_touch__ = __webpack_require__(10);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__foundation_util_triggers__ = __webpack_require__(5);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__foundation_abide__ = __webpack_require__(20);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__foundation_accordion__ = __webpack_require__(11);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__foundation_accordionMenu__ = __webpack_require__(12);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__foundation_drilldown__ = __webpack_require__(13);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__foundation_dropdown__ = __webpack_require__(22);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__foundation_dropdownMenu__ = __webpack_require__(14);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__foundation_equalizer__ = __webpack_require__(23);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__foundation_interchange__ = __webpack_require__(24);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__foundation_magellan__ = __webpack_require__(25);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__foundation_offcanvas__ = __webpack_require__(26);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__foundation_orbit__ = __webpack_require__(27);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__foundation_responsiveMenu__ = __webpack_require__(29);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24__foundation_responsiveToggle__ = __webpack_require__(30);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25__foundation_reveal__ = __webpack_require__(31);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26__foundation_slider__ = __webpack_require__(32);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_27__foundation_smoothScroll__ = __webpack_require__(16);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_28__foundation_sticky__ = __webpack_require__(33);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_29__foundation_tabs__ = __webpack_require__(17);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_30__foundation_toggler__ = __webpack_require__(34);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_31__foundation_tooltip__ = __webpack_require__(35);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_32__foundation_responsiveAccordionTabs__ = __webpack_require__(28);\\n\\n\\n\\n__WEBPACK_IMPORTED_MODULE_1__foundation_core__[\\\"a\\\" /* Foundation */].addToJquery(__WEBPACK_IMPORTED_MODULE_0_jquery___default.a);\\n\\n// Add Foundation Utils to Foundation global namespace for backwards\\n// compatibility.\\n\\n\\n__WEBPACK_IMPORTED_MODULE_1__foundation_core__[\\\"a\\\" /* Foundation */].rtl = __WEBPACK_IMPORTED_MODULE_2__foundation_util_core__[\\\"a\\\" /* rtl */];\\n__WEBPACK_IMPORTED_MODULE_1__foundation_core__[\\\"a\\\" /* Foundation */].GetYoDigits = __WEBPACK_IMPORTED_MODULE_2__foundation_util_core__[\\\"b\\\" /* GetYoDigits */];\\n__WEBPACK_IMPORTED_MODULE_1__foundation_core__[\\\"a\\\" /* Foundation */].transitionend = __WEBPACK_IMPORTED_MODULE_2__foundation_util_core__[\\\"c\\\" /* transitionend */];\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n__WEBPACK_IMPORTED_MODULE_1__foundation_core__[\\\"a\\\" /* Foundation */].Box = __WEBPACK_IMPORTED_MODULE_3__foundation_util_box__[\\\"a\\\" /* Box */];\\n__WEBPACK_IMPORTED_MODULE_1__foundation_core__[\\\"a\\\" /* Foundation */].onImagesLoaded = __WEBPACK_IMPORTED_MODULE_4__foundation_util_imageLoader__[\\\"a\\\" /* onImagesLoaded */];\\n__WEBPACK_IMPORTED_MODULE_1__foundation_core__[\\\"a\\\" /* Foundation */].Keyboard = __WEBPACK_IMPORTED_MODULE_5__foundation_util_keyboard__[\\\"a\\\" /* Keyboard */];\\n__WEBPACK_IMPORTED_MODULE_1__foundation_core__[\\\"a\\\" /* Foundation */].MediaQuery = __WEBPACK_IMPORTED_MODULE_6__foundation_util_mediaQuery__[\\\"a\\\" /* MediaQuery */];\\n__WEBPACK_IMPORTED_MODULE_1__foundation_core__[\\\"a\\\" /* Foundation */].Motion = __WEBPACK_IMPORTED_MODULE_7__foundation_util_motion__[\\\"a\\\" /* Motion */];\\n__WEBPACK_IMPORTED_MODULE_1__foundation_core__[\\\"a\\\" /* Foundation */].Move = __WEBPACK_IMPORTED_MODULE_7__foundation_util_motion__[\\\"b\\\" /* Move */];\\n__WEBPACK_IMPORTED_MODULE_1__foundation_core__[\\\"a\\\" /* Foundation */].Nest = __WEBPACK_IMPORTED_MODULE_8__foundation_util_nest__[\\\"a\\\" /* Nest */];\\n__WEBPACK_IMPORTED_MODULE_1__foundation_core__[\\\"a\\\" /* Foundation */].Timer = __WEBPACK_IMPORTED_MODULE_9__foundation_util_timer__[\\\"a\\\" /* Timer */];\\n\\n// Touch and Triggers previously were almost purely sede effect driven,\\n// so no // need to add it to Foundation, just init them.\\n\\n\\n__WEBPACK_IMPORTED_MODULE_10__foundation_util_touch__[\\\"a\\\" /* Touch */].init(__WEBPACK_IMPORTED_MODULE_0_jquery___default.a);\\n\\n\\n__WEBPACK_IMPORTED_MODULE_11__foundation_util_triggers__[\\\"a\\\" /* Triggers */].init(__WEBPACK_IMPORTED_MODULE_0_jquery___default.a, __WEBPACK_IMPORTED_MODULE_1__foundation_core__[\\\"a\\\" /* Foundation */]);\\n\\n\\n__WEBPACK_IMPORTED_MODULE_1__foundation_core__[\\\"a\\\" /* Foundation */].plugin(__WEBPACK_IMPORTED_MODULE_12__foundation_abide__[\\\"a\\\" /* Abide */], 'Abide');\\n\\n\\n__WEBPACK_IMPORTED_MODULE_1__foundation_core__[\\\"a\\\" /* Foundation */].plugin(__WEBPACK_IMPORTED_MODULE_13__foundation_accordion__[\\\"a\\\" /* Accordion */], 'Accordion');\\n\\n\\n__WEBPACK_IMPORTED_MODULE_1__foundation_core__[\\\"a\\\" /* Foundation */].plugin(__WEBPACK_IMPORTED_MODULE_14__foundation_accordionMenu__[\\\"a\\\" /* AccordionMenu */], 'AccordionMenu');\\n\\n\\n__WEBPACK_IMPORTED_MODULE_1__foundation_core__[\\\"a\\\" /* Foundation */].plugin(__WEBPACK_IMPORTED_MODULE_15__foundation_drilldown__[\\\"a\\\" /* Drilldown */], 'Drilldown');\\n\\n\\n__WEBPACK_IMPORTED_MODULE_1__foundation_core__[\\\"a\\\" /* Foundation */].plugin(__WEBPACK_IMPORTED_MODULE_16__foundation_dropdown__[\\\"a\\\" /* Dropdown */], 'Dropdown');\\n\\n\\n__WEBPACK_IMPORTED_MODULE_1__foundation_core__[\\\"a\\\" /* Foundation */].plugin(__WEBPACK_IMPORTED_MODULE_17__foundation_dropdownMenu__[\\\"a\\\" /* DropdownMenu */], 'DropdownMenu');\\n\\n\\n__WEBPACK_IMPORTED_MODULE_1__foundation_core__[\\\"a\\\" /* Foundation */].plugin(__WEBPACK_IMPORTED_MODULE_18__foundation_equalizer__[\\\"a\\\" /* Equalizer */], 'Equalizer');\\n\\n\\n__WEBPACK_IMPORTED_MODULE_1__foundation_core__[\\\"a\\\" /* Foundation */].plugin(__WEBPACK_IMPORTED_MODULE_19__foundation_interchange__[\\\"a\\\" /* Interchange */], 'Interchange');\\n\\n\\n__WEBPACK_IMPORTED_MODULE_1__foundation_core__[\\\"a\\\" /* Foundation */].plugin(__WEBPACK_IMPORTED_MODULE_20__foundation_magellan__[\\\"a\\\" /* Magellan */], 'Magellan');\\n\\n\\n__WEBPACK_IMPORTED_MODULE_1__foundation_core__[\\\"a\\\" /* Foundation */].plugin(__WEBPACK_IMPORTED_MODULE_21__foundation_offcanvas__[\\\"a\\\" /* OffCanvas */], 'OffCanvas');\\n\\n\\n__WEBPACK_IMPORTED_MODULE_1__foundation_core__[\\\"a\\\" /* Foundation */].plugin(__WEBPACK_IMPORTED_MODULE_22__foundation_orbit__[\\\"a\\\" /* Orbit */], 'Orbit');\\n\\n\\n__WEBPACK_IMPORTED_MODULE_1__foundation_core__[\\\"a\\\" /* Foundation */].plugin(__WEBPACK_IMPORTED_MODULE_23__foundation_responsiveMenu__[\\\"a\\\" /* ResponsiveMenu */], 'ResponsiveMenu');\\n\\n\\n__WEBPACK_IMPORTED_MODULE_1__foundation_core__[\\\"a\\\" /* Foundation */].plugin(__WEBPACK_IMPORTED_MODULE_24__foundation_responsiveToggle__[\\\"a\\\" /* ResponsiveToggle */], 'ResponsiveToggle');\\n\\n\\n__WEBPACK_IMPORTED_MODULE_1__foundation_core__[\\\"a\\\" /* Foundation */].plugin(__WEBPACK_IMPORTED_MODULE_25__foundation_reveal__[\\\"a\\\" /* Reveal */], 'Reveal');\\n\\n\\n__WEBPACK_IMPORTED_MODULE_1__foundation_core__[\\\"a\\\" /* Foundation */].plugin(__WEBPACK_IMPORTED_MODULE_26__foundation_slider__[\\\"a\\\" /* Slider */], 'Slider');\\n\\n\\n__WEBPACK_IMPORTED_MODULE_1__foundation_core__[\\\"a\\\" /* Foundation */].plugin(__WEBPACK_IMPORTED_MODULE_27__foundation_smoothScroll__[\\\"a\\\" /* SmoothScroll */], 'SmoothScroll');\\n\\n\\n__WEBPACK_IMPORTED_MODULE_1__foundation_core__[\\\"a\\\" /* Foundation */].plugin(__WEBPACK_IMPORTED_MODULE_28__foundation_sticky__[\\\"a\\\" /* Sticky */], 'Sticky');\\n\\n\\n__WEBPACK_IMPORTED_MODULE_1__foundation_core__[\\\"a\\\" /* Foundation */].plugin(__WEBPACK_IMPORTED_MODULE_29__foundation_tabs__[\\\"a\\\" /* Tabs */], 'Tabs');\\n\\n\\n__WEBPACK_IMPORTED_MODULE_1__foundation_core__[\\\"a\\\" /* Foundation */].plugin(__WEBPACK_IMPORTED_MODULE_30__foundation_toggler__[\\\"a\\\" /* Toggler */], 'Toggler');\\n\\n\\n__WEBPACK_IMPORTED_MODULE_1__foundation_core__[\\\"a\\\" /* Foundation */].plugin(__WEBPACK_IMPORTED_MODULE_31__foundation_tooltip__[\\\"a\\\" /* Tooltip */], 'Tooltip');\\n\\n\\n__WEBPACK_IMPORTED_MODULE_1__foundation_core__[\\\"a\\\" /* Foundation */].plugin(__WEBPACK_IMPORTED_MODULE_32__foundation_responsiveAccordionTabs__[\\\"a\\\" /* ResponsiveAccordionTabs */], 'ResponsiveAccordionTabs');\\n\\n/***/ }),\\n/* 20 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return Abide; });\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jquery__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__foundation_plugin__ = __webpack_require__(2);\\n\\n\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return call && (typeof call === \\\"object\\\" || typeof call === \\\"function\\\") ? call : self; }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function, not \\\" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\n\\n\\n\\n/**\\n * Abide module.\\n * @module foundation.abide\\n */\\n\\nvar Abide = function (_Plugin) {\\n  _inherits(Abide, _Plugin);\\n\\n  function Abide() {\\n    _classCallCheck(this, Abide);\\n\\n    return _possibleConstructorReturn(this, (Abide.__proto__ || Object.getPrototypeOf(Abide)).apply(this, arguments));\\n  }\\n\\n  _createClass(Abide, [{\\n    key: '_setup',\\n\\n    /**\\n     * Creates a new instance of Abide.\\n     * @class\\n     * @name Abide\\n     * @fires Abide#init\\n     * @param {Object} element - jQuery object to add the trigger to.\\n     * @param {Object} options - Overrides to the default plugin settings.\\n     */\\n    value: function _setup(element) {\\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\\n\\n      this.$element = element;\\n      this.options = __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.extend({}, Abide.defaults, this.$element.data(), options);\\n\\n      this.className = 'Abide'; // ie9 back compat\\n      this._init();\\n    }\\n\\n    /**\\n     * Initializes the Abide plugin and calls functions to get Abide functioning on load.\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_init',\\n    value: function _init() {\\n      this.$inputs = this.$element.find('input, textarea, select');\\n\\n      this._events();\\n    }\\n\\n    /**\\n     * Initializes events for Abide.\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_events',\\n    value: function _events() {\\n      var _this3 = this;\\n\\n      this.$element.off('.abide').on('reset.zf.abide', function () {\\n        _this3.resetForm();\\n      }).on('submit.zf.abide', function () {\\n        return _this3.validateForm();\\n      });\\n\\n      if (this.options.validateOn === 'fieldChange') {\\n        this.$inputs.off('change.zf.abide').on('change.zf.abide', function (e) {\\n          _this3.validateInput(__WEBPACK_IMPORTED_MODULE_0_jquery___default()(e.target));\\n        });\\n      }\\n\\n      if (this.options.liveValidate) {\\n        this.$inputs.off('input.zf.abide').on('input.zf.abide', function (e) {\\n          _this3.validateInput(__WEBPACK_IMPORTED_MODULE_0_jquery___default()(e.target));\\n        });\\n      }\\n\\n      if (this.options.validateOnBlur) {\\n        this.$inputs.off('blur.zf.abide').on('blur.zf.abide', function (e) {\\n          _this3.validateInput(__WEBPACK_IMPORTED_MODULE_0_jquery___default()(e.target));\\n        });\\n      }\\n    }\\n\\n    /**\\n     * Calls necessary functions to update Abide upon DOM change\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_reflow',\\n    value: function _reflow() {\\n      this._init();\\n    }\\n\\n    /**\\n     * Checks whether or not a form element has the required attribute and if it's checked or not\\n     * @param {Object} element - jQuery object to check for required attribute\\n     * @returns {Boolean} Boolean value depends on whether or not attribute is checked or empty\\n     */\\n\\n  }, {\\n    key: 'requiredCheck',\\n    value: function requiredCheck($el) {\\n      if (!$el.attr('required')) return true;\\n\\n      var isGood = true;\\n\\n      switch ($el[0].type) {\\n        case 'checkbox':\\n          isGood = $el[0].checked;\\n          break;\\n\\n        case 'select':\\n        case 'select-one':\\n        case 'select-multiple':\\n          var opt = $el.find('option:selected');\\n          if (!opt.length || !opt.val()) isGood = false;\\n          break;\\n\\n        default:\\n          if (!$el.val() || !$el.val().length) isGood = false;\\n      }\\n\\n      return isGood;\\n    }\\n\\n    /**\\n     * Get:\\n     * - Based on $el, the first element(s) corresponding to `formErrorSelector` in this order:\\n     *   1. The element's direct sibling('s).\\n     *   2. The element's parent's children.\\n     * - Element(s) with the attribute `[data-form-error-for]` set with the element's id.\\n     *\\n     * This allows for multiple form errors per input, though if none are found, no form errors will be shown.\\n     *\\n     * @param {Object} $el - jQuery object to use as reference to find the form error selector.\\n     * @returns {Object} jQuery object with the selector.\\n     */\\n\\n  }, {\\n    key: 'findFormError',\\n    value: function findFormError($el) {\\n      var id = $el[0].id;\\n      var $error = $el.siblings(this.options.formErrorSelector);\\n\\n      if (!$error.length) {\\n        $error = $el.parent().find(this.options.formErrorSelector);\\n      }\\n\\n      $error = $error.add(this.$element.find('[data-form-error-for=\\\"' + id + '\\\"]'));\\n\\n      return $error;\\n    }\\n\\n    /**\\n     * Get the first element in this order:\\n     * 2. The <label> with the attribute `[for=\\\"someInputId\\\"]`\\n     * 3. The `.closest()` <label>\\n     *\\n     * @param {Object} $el - jQuery object to check for required attribute\\n     * @returns {Boolean} Boolean value depends on whether or not attribute is checked or empty\\n     */\\n\\n  }, {\\n    key: 'findLabel',\\n    value: function findLabel($el) {\\n      var id = $el[0].id;\\n      var $label = this.$element.find('label[for=\\\"' + id + '\\\"]');\\n\\n      if (!$label.length) {\\n        return $el.closest('label');\\n      }\\n\\n      return $label;\\n    }\\n\\n    /**\\n     * Get the set of labels associated with a set of radio els in this order\\n     * 2. The <label> with the attribute `[for=\\\"someInputId\\\"]`\\n     * 3. The `.closest()` <label>\\n     *\\n     * @param {Object} $el - jQuery object to check for required attribute\\n     * @returns {Boolean} Boolean value depends on whether or not attribute is checked or empty\\n     */\\n\\n  }, {\\n    key: 'findRadioLabels',\\n    value: function findRadioLabels($els) {\\n      var _this4 = this;\\n\\n      var labels = $els.map(function (i, el) {\\n        var id = el.id;\\n        var $label = _this4.$element.find('label[for=\\\"' + id + '\\\"]');\\n\\n        if (!$label.length) {\\n          $label = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(el).closest('label');\\n        }\\n        return $label[0];\\n      });\\n\\n      return __WEBPACK_IMPORTED_MODULE_0_jquery___default()(labels);\\n    }\\n\\n    /**\\n     * Adds the CSS error class as specified by the Abide settings to the label, input, and the form\\n     * @param {Object} $el - jQuery object to add the class to\\n     */\\n\\n  }, {\\n    key: 'addErrorClasses',\\n    value: function addErrorClasses($el) {\\n      var $label = this.findLabel($el);\\n      var $formError = this.findFormError($el);\\n\\n      if ($label.length) {\\n        $label.addClass(this.options.labelErrorClass);\\n      }\\n\\n      if ($formError.length) {\\n        $formError.addClass(this.options.formErrorClass);\\n      }\\n\\n      $el.addClass(this.options.inputErrorClass).attr('data-invalid', '');\\n    }\\n\\n    /**\\n     * Remove CSS error classes etc from an entire radio button group\\n     * @param {String} groupName - A string that specifies the name of a radio button group\\n     *\\n     */\\n\\n  }, {\\n    key: 'removeRadioErrorClasses',\\n    value: function removeRadioErrorClasses(groupName) {\\n      var $els = this.$element.find(':radio[name=\\\"' + groupName + '\\\"]');\\n      var $labels = this.findRadioLabels($els);\\n      var $formErrors = this.findFormError($els);\\n\\n      if ($labels.length) {\\n        $labels.removeClass(this.options.labelErrorClass);\\n      }\\n\\n      if ($formErrors.length) {\\n        $formErrors.removeClass(this.options.formErrorClass);\\n      }\\n\\n      $els.removeClass(this.options.inputErrorClass).removeAttr('data-invalid');\\n    }\\n\\n    /**\\n     * Removes CSS error class as specified by the Abide settings from the label, input, and the form\\n     * @param {Object} $el - jQuery object to remove the class from\\n     */\\n\\n  }, {\\n    key: 'removeErrorClasses',\\n    value: function removeErrorClasses($el) {\\n      // radios need to clear all of the els\\n      if ($el[0].type == 'radio') {\\n        return this.removeRadioErrorClasses($el.attr('name'));\\n      }\\n\\n      var $label = this.findLabel($el);\\n      var $formError = this.findFormError($el);\\n\\n      if ($label.length) {\\n        $label.removeClass(this.options.labelErrorClass);\\n      }\\n\\n      if ($formError.length) {\\n        $formError.removeClass(this.options.formErrorClass);\\n      }\\n\\n      $el.removeClass(this.options.inputErrorClass).removeAttr('data-invalid');\\n    }\\n\\n    /**\\n     * Goes through a form to find inputs and proceeds to validate them in ways specific to their type.\\n     * Ignores inputs with data-abide-ignore, type=\\\"hidden\\\" or disabled attributes set\\n     * @fires Abide#invalid\\n     * @fires Abide#valid\\n     * @param {Object} element - jQuery object to validate, should be an HTML input\\n     * @returns {Boolean} goodToGo - If the input is valid or not.\\n     */\\n\\n  }, {\\n    key: 'validateInput',\\n    value: function validateInput($el) {\\n      var clearRequire = this.requiredCheck($el),\\n          validated = false,\\n          customValidator = true,\\n          validator = $el.attr('data-validator'),\\n          equalTo = true;\\n\\n      // don't validate ignored inputs or hidden inputs or disabled inputs\\n      if ($el.is('[data-abide-ignore]') || $el.is('[type=\\\"hidden\\\"]') || $el.is('[disabled]')) {\\n        return true;\\n      }\\n\\n      switch ($el[0].type) {\\n        case 'radio':\\n          validated = this.validateRadio($el.attr('name'));\\n          break;\\n\\n        case 'checkbox':\\n          validated = clearRequire;\\n          break;\\n\\n        case 'select':\\n        case 'select-one':\\n        case 'select-multiple':\\n          validated = clearRequire;\\n          break;\\n\\n        default:\\n          validated = this.validateText($el);\\n      }\\n\\n      if (validator) {\\n        customValidator = this.matchValidation($el, validator, $el.attr('required'));\\n      }\\n\\n      if ($el.attr('data-equalto')) {\\n        equalTo = this.options.validators.equalTo($el);\\n      }\\n\\n      var goodToGo = [clearRequire, validated, customValidator, equalTo].indexOf(false) === -1;\\n      var message = (goodToGo ? 'valid' : 'invalid') + '.zf.abide';\\n\\n      if (goodToGo) {\\n        // Re-validate inputs that depend on this one with equalto\\n        var dependentElements = this.$element.find('[data-equalto=\\\"' + $el.attr('id') + '\\\"]');\\n        if (dependentElements.length) {\\n          var _this = this;\\n          dependentElements.each(function () {\\n            if (__WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).val()) {\\n              _this.validateInput(__WEBPACK_IMPORTED_MODULE_0_jquery___default()(this));\\n            }\\n          });\\n        }\\n      }\\n\\n      this[goodToGo ? 'removeErrorClasses' : 'addErrorClasses']($el);\\n\\n      /**\\n       * Fires when the input is done checking for validation. Event trigger is either `valid.zf.abide` or `invalid.zf.abide`\\n       * Trigger includes the DOM element of the input.\\n       * @event Abide#valid\\n       * @event Abide#invalid\\n       */\\n      $el.trigger(message, [$el]);\\n\\n      return goodToGo;\\n    }\\n\\n    /**\\n     * Goes through a form and if there are any invalid inputs, it will display the form error element\\n     * @returns {Boolean} noError - true if no errors were detected...\\n     * @fires Abide#formvalid\\n     * @fires Abide#forminvalid\\n     */\\n\\n  }, {\\n    key: 'validateForm',\\n    value: function validateForm() {\\n      var acc = [];\\n      var _this = this;\\n\\n      this.$inputs.each(function () {\\n        acc.push(_this.validateInput(__WEBPACK_IMPORTED_MODULE_0_jquery___default()(this)));\\n      });\\n\\n      var noError = acc.indexOf(false) === -1;\\n\\n      this.$element.find('[data-abide-error]').css('display', noError ? 'none' : 'block');\\n\\n      /**\\n       * Fires when the form is finished validating. Event trigger is either `formvalid.zf.abide` or `forminvalid.zf.abide`.\\n       * Trigger includes the element of the form.\\n       * @event Abide#formvalid\\n       * @event Abide#forminvalid\\n       */\\n      this.$element.trigger((noError ? 'formvalid' : 'forminvalid') + '.zf.abide', [this.$element]);\\n\\n      return noError;\\n    }\\n\\n    /**\\n     * Determines whether or a not a text input is valid based on the pattern specified in the attribute. If no matching pattern is found, returns true.\\n     * @param {Object} $el - jQuery object to validate, should be a text input HTML element\\n     * @param {String} pattern - string value of one of the RegEx patterns in Abide.options.patterns\\n     * @returns {Boolean} Boolean value depends on whether or not the input value matches the pattern specified\\n     */\\n\\n  }, {\\n    key: 'validateText',\\n    value: function validateText($el, pattern) {\\n      // A pattern can be passed to this function, or it will be infered from the input's \\\"pattern\\\" attribute, or it's \\\"type\\\" attribute\\n      pattern = pattern || $el.attr('pattern') || $el.attr('type');\\n      var inputText = $el.val();\\n      var valid = false;\\n\\n      if (inputText.length) {\\n        // If the pattern attribute on the element is in Abide's list of patterns, then test that regexp\\n        if (this.options.patterns.hasOwnProperty(pattern)) {\\n          valid = this.options.patterns[pattern].test(inputText);\\n        }\\n        // If the pattern name isn't also the type attribute of the field, then test it as a regexp\\n        else if (pattern !== $el.attr('type')) {\\n            valid = new RegExp(pattern).test(inputText);\\n          } else {\\n            valid = true;\\n          }\\n      }\\n      // An empty field is valid if it's not required\\n      else if (!$el.prop('required')) {\\n          valid = true;\\n        }\\n\\n      return valid;\\n    }\\n\\n    /**\\n     * Determines whether or a not a radio input is valid based on whether or not it is required and selected. Although the function targets a single `<input>`, it validates by checking the `required` and `checked` properties of all radio buttons in its group.\\n     * @param {String} groupName - A string that specifies the name of a radio button group\\n     * @returns {Boolean} Boolean value depends on whether or not at least one radio input has been selected (if it's required)\\n     */\\n\\n  }, {\\n    key: 'validateRadio',\\n    value: function validateRadio(groupName) {\\n      // If at least one radio in the group has the `required` attribute, the group is considered required\\n      // Per W3C spec, all radio buttons in a group should have `required`, but we're being nice\\n      var $group = this.$element.find(':radio[name=\\\"' + groupName + '\\\"]');\\n      var valid = false,\\n          required = false;\\n\\n      // For the group to be required, at least one radio needs to be required\\n      $group.each(function (i, e) {\\n        if (__WEBPACK_IMPORTED_MODULE_0_jquery___default()(e).attr('required')) {\\n          required = true;\\n        }\\n      });\\n      if (!required) valid = true;\\n\\n      if (!valid) {\\n        // For the group to be valid, at least one radio needs to be checked\\n        $group.each(function (i, e) {\\n          if (__WEBPACK_IMPORTED_MODULE_0_jquery___default()(e).prop('checked')) {\\n            valid = true;\\n          }\\n        });\\n      };\\n\\n      return valid;\\n    }\\n\\n    /**\\n     * Determines if a selected input passes a custom validation function. Multiple validations can be used, if passed to the element with `data-validator=\\\"foo bar baz\\\"` in a space separated listed.\\n     * @param {Object} $el - jQuery input element.\\n     * @param {String} validators - a string of function names matching functions in the Abide.options.validators object.\\n     * @param {Boolean} required - self explanatory?\\n     * @returns {Boolean} - true if validations passed.\\n     */\\n\\n  }, {\\n    key: 'matchValidation',\\n    value: function matchValidation($el, validators, required) {\\n      var _this5 = this;\\n\\n      required = required ? true : false;\\n\\n      var clear = validators.split(' ').map(function (v) {\\n        return _this5.options.validators[v]($el, required, $el.parent());\\n      });\\n      return clear.indexOf(false) === -1;\\n    }\\n\\n    /**\\n     * Resets form inputs and styles\\n     * @fires Abide#formreset\\n     */\\n\\n  }, {\\n    key: 'resetForm',\\n    value: function resetForm() {\\n      var $form = this.$element,\\n          opts = this.options;\\n\\n      __WEBPACK_IMPORTED_MODULE_0_jquery___default()('.' + opts.labelErrorClass, $form).not('small').removeClass(opts.labelErrorClass);\\n      __WEBPACK_IMPORTED_MODULE_0_jquery___default()('.' + opts.inputErrorClass, $form).not('small').removeClass(opts.inputErrorClass);\\n      __WEBPACK_IMPORTED_MODULE_0_jquery___default()(opts.formErrorSelector + '.' + opts.formErrorClass).removeClass(opts.formErrorClass);\\n      $form.find('[data-abide-error]').css('display', 'none');\\n      __WEBPACK_IMPORTED_MODULE_0_jquery___default()(':input', $form).not(':button, :submit, :reset, :hidden, :radio, :checkbox, [data-abide-ignore]').val('').removeAttr('data-invalid');\\n      __WEBPACK_IMPORTED_MODULE_0_jquery___default()(':input:radio', $form).not('[data-abide-ignore]').prop('checked', false).removeAttr('data-invalid');\\n      __WEBPACK_IMPORTED_MODULE_0_jquery___default()(':input:checkbox', $form).not('[data-abide-ignore]').prop('checked', false).removeAttr('data-invalid');\\n      /**\\n       * Fires when the form has been reset.\\n       * @event Abide#formreset\\n       */\\n      $form.trigger('formreset.zf.abide', [$form]);\\n    }\\n\\n    /**\\n     * Destroys an instance of Abide.\\n     * Removes error styles and classes from elements, without resetting their values.\\n     */\\n\\n  }, {\\n    key: '_destroy',\\n    value: function _destroy() {\\n      var _this = this;\\n      this.$element.off('.abide').find('[data-abide-error]').css('display', 'none');\\n\\n      this.$inputs.off('.abide').each(function () {\\n        _this.removeErrorClasses(__WEBPACK_IMPORTED_MODULE_0_jquery___default()(this));\\n      });\\n    }\\n  }]);\\n\\n  return Abide;\\n}(__WEBPACK_IMPORTED_MODULE_1__foundation_plugin__[\\\"a\\\" /* Plugin */]);\\n\\n/**\\n * Default settings for plugin\\n */\\n\\n\\nAbide.defaults = {\\n  /**\\n   * The default event to validate inputs. Checkboxes and radios validate immediately.\\n   * Remove or change this value for manual validation.\\n   * @option\\n   * @type {?string}\\n   * @default 'fieldChange'\\n   */\\n  validateOn: 'fieldChange',\\n\\n  /**\\n   * Class to be applied to input labels on failed validation.\\n   * @option\\n   * @type {string}\\n   * @default 'is-invalid-label'\\n   */\\n  labelErrorClass: 'is-invalid-label',\\n\\n  /**\\n   * Class to be applied to inputs on failed validation.\\n   * @option\\n   * @type {string}\\n   * @default 'is-invalid-input'\\n   */\\n  inputErrorClass: 'is-invalid-input',\\n\\n  /**\\n   * Class selector to use to target Form Errors for show/hide.\\n   * @option\\n   * @type {string}\\n   * @default '.form-error'\\n   */\\n  formErrorSelector: '.form-error',\\n\\n  /**\\n   * Class added to Form Errors on failed validation.\\n   * @option\\n   * @type {string}\\n   * @default 'is-visible'\\n   */\\n  formErrorClass: 'is-visible',\\n\\n  /**\\n   * Set to true to validate text inputs on any value change.\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  liveValidate: false,\\n\\n  /**\\n   * Set to true to validate inputs on blur.\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  validateOnBlur: false,\\n\\n  patterns: {\\n    alpha: /^[a-zA-Z]+$/,\\n    alpha_numeric: /^[a-zA-Z0-9]+$/,\\n    integer: /^[-+]?\\\\d+$/,\\n    number: /^[-+]?\\\\d*(?:[\\\\.\\\\,]\\\\d+)?$/,\\n\\n    // amex, visa, diners\\n    card: /^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|(?:222[1-9]|2[3-6][0-9]{2}|27[0-1][0-9]|2720)[0-9]{12}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\\\\d{3})\\\\d{11})$/,\\n    cvv: /^([0-9]){3,4}$/,\\n\\n    // http://www.whatwg.org/specs/web-apps/current-work/multipage/states-of-the-type-attribute.html#valid-e-mail-address\\n    email: /^[a-zA-Z0-9.!#$%&'*+\\\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+$/,\\n\\n    url: /^(https?|ftp|file|ssh):\\\\/\\\\/(((([a-zA-Z]|\\\\d|-|\\\\.|_|~|[\\\\u00A0-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF])|(%[\\\\da-f]{2})|[!\\\\$&'\\\\(\\\\)\\\\*\\\\+,;=]|:)*@)?(((\\\\d|[1-9]\\\\d|1\\\\d\\\\d|2[0-4]\\\\d|25[0-5])\\\\.(\\\\d|[1-9]\\\\d|1\\\\d\\\\d|2[0-4]\\\\d|25[0-5])\\\\.(\\\\d|[1-9]\\\\d|1\\\\d\\\\d|2[0-4]\\\\d|25[0-5])\\\\.(\\\\d|[1-9]\\\\d|1\\\\d\\\\d|2[0-4]\\\\d|25[0-5]))|((([a-zA-Z]|\\\\d|[\\\\u00A0-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF])|(([a-zA-Z]|\\\\d|[\\\\u00A0-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF])([a-zA-Z]|\\\\d|-|\\\\.|_|~|[\\\\u00A0-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF])*([a-zA-Z]|\\\\d|[\\\\u00A0-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF])))\\\\.)+(([a-zA-Z]|[\\\\u00A0-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF])|(([a-zA-Z]|[\\\\u00A0-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF])([a-zA-Z]|\\\\d|-|\\\\.|_|~|[\\\\u00A0-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF])*([a-zA-Z]|[\\\\u00A0-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF])))\\\\.?)(:\\\\d*)?)(\\\\/((([a-zA-Z]|\\\\d|-|\\\\.|_|~|[\\\\u00A0-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF])|(%[\\\\da-f]{2})|[!\\\\$&'\\\\(\\\\)\\\\*\\\\+,;=]|:|@)+(\\\\/(([a-zA-Z]|\\\\d|-|\\\\.|_|~|[\\\\u00A0-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF])|(%[\\\\da-f]{2})|[!\\\\$&'\\\\(\\\\)\\\\*\\\\+,;=]|:|@)*)*)?)?(\\\\?((([a-zA-Z]|\\\\d|-|\\\\.|_|~|[\\\\u00A0-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF])|(%[\\\\da-f]{2})|[!\\\\$&'\\\\(\\\\)\\\\*\\\\+,;=]|:|@)|[\\\\uE000-\\\\uF8FF]|\\\\/|\\\\?)*)?(\\\\#((([a-zA-Z]|\\\\d|-|\\\\.|_|~|[\\\\u00A0-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF])|(%[\\\\da-f]{2})|[!\\\\$&'\\\\(\\\\)\\\\*\\\\+,;=]|:|@)|\\\\/|\\\\?)*)?$/,\\n    // abc.de\\n    domain: /^([a-zA-Z0-9]([a-zA-Z0-9\\\\-]{0,61}[a-zA-Z0-9])?\\\\.)+[a-zA-Z]{2,8}$/,\\n\\n    datetime: /^([0-2][0-9]{3})\\\\-([0-1][0-9])\\\\-([0-3][0-9])T([0-5][0-9])\\\\:([0-5][0-9])\\\\:([0-5][0-9])(Z|([\\\\-\\\\+]([0-1][0-9])\\\\:00))$/,\\n    // YYYY-MM-DD\\n    date: /(?:19|20)[0-9]{2}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-9])|(?:(?!02)(?:0[1-9]|1[0-2])-(?:30))|(?:(?:0[13578]|1[02])-31))$/,\\n    // HH:MM:SS\\n    time: /^(0[0-9]|1[0-9]|2[0-3])(:[0-5][0-9]){2}$/,\\n    dateISO: /^\\\\d{4}[\\\\/\\\\-]\\\\d{1,2}[\\\\/\\\\-]\\\\d{1,2}$/,\\n    // MM/DD/YYYY\\n    month_day_year: /^(0[1-9]|1[012])[- \\\\/.](0[1-9]|[12][0-9]|3[01])[- \\\\/.]\\\\d{4}$/,\\n    // DD/MM/YYYY\\n    day_month_year: /^(0[1-9]|[12][0-9]|3[01])[- \\\\/.](0[1-9]|1[012])[- \\\\/.]\\\\d{4}$/,\\n\\n    // #FFF or #FFFFFF\\n    color: /^#?([a-fA-F0-9]{6}|[a-fA-F0-9]{3})$/,\\n\\n    // Domain || URL\\n    website: {\\n      test: function (text) {\\n        return Abide.defaults.patterns['domain'].test(text) || Abide.defaults.patterns['url'].test(text);\\n      }\\n    }\\n  },\\n\\n  /**\\n   * Optional validation functions to be used. `equalTo` being the only default included function.\\n   * Functions should return only a boolean if the input is valid or not. Functions are given the following arguments:\\n   * el : The jQuery element to validate.\\n   * required : Boolean value of the required attribute be present or not.\\n   * parent : The direct parent of the input.\\n   * @option\\n   */\\n  validators: {\\n    equalTo: function (el, required, parent) {\\n      return __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#' + el.attr('data-equalto')).val() === el.val();\\n    }\\n  }\\n};\\n\\n\\n\\n/***/ }),\\n/* 21 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return Foundation; });\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jquery__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__foundation_util_core__ = __webpack_require__(1);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__foundation_util_mediaQuery__ = __webpack_require__(4);\\n\\n\\n\\n\\n\\n\\nvar FOUNDATION_VERSION = '6.4.1';\\n\\n// Global Foundation object\\n// This is attached to the window, or used as a module for AMD/Browserify\\nvar Foundation = {\\n  version: FOUNDATION_VERSION,\\n\\n  /**\\n   * Stores initialized plugins.\\n   */\\n  _plugins: {},\\n\\n  /**\\n   * Stores generated unique ids for plugin instances\\n   */\\n  _uuids: [],\\n\\n  /**\\n   * Defines a Foundation plugin, adding it to the `Foundation` namespace and the list of plugins to initialize when reflowing.\\n   * @param {Object} plugin - The constructor of the plugin.\\n   */\\n  plugin: function (plugin, name) {\\n    // Object key to use when adding to global Foundation object\\n    // Examples: Foundation.Reveal, Foundation.OffCanvas\\n    var className = name || functionName(plugin);\\n    // Object key to use when storing the plugin, also used to create the identifying data attribute for the plugin\\n    // Examples: data-reveal, data-off-canvas\\n    var attrName = hyphenate(className);\\n\\n    // Add to the Foundation object and the plugins list (for reflowing)\\n    this._plugins[attrName] = this[className] = plugin;\\n  },\\n  /**\\n   * @function\\n   * Populates the _uuids array with pointers to each individual plugin instance.\\n   * Adds the `zfPlugin` data-attribute to programmatically created plugins to allow use of $(selector).foundation(method) calls.\\n   * Also fires the initialization event for each plugin, consolidating repetitive code.\\n   * @param {Object} plugin - an instance of a plugin, usually `this` in context.\\n   * @param {String} name - the name of the plugin, passed as a camelCased string.\\n   * @fires Plugin#init\\n   */\\n  registerPlugin: function (plugin, name) {\\n    var pluginName = name ? hyphenate(name) : functionName(plugin.constructor).toLowerCase();\\n    plugin.uuid = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__foundation_util_core__[\\\"b\\\" /* GetYoDigits */])(6, pluginName);\\n\\n    if (!plugin.$element.attr('data-' + pluginName)) {\\n      plugin.$element.attr('data-' + pluginName, plugin.uuid);\\n    }\\n    if (!plugin.$element.data('zfPlugin')) {\\n      plugin.$element.data('zfPlugin', plugin);\\n    }\\n    /**\\n     * Fires when the plugin has initialized.\\n     * @event Plugin#init\\n     */\\n    plugin.$element.trigger('init.zf.' + pluginName);\\n\\n    this._uuids.push(plugin.uuid);\\n\\n    return;\\n  },\\n  /**\\n   * @function\\n   * Removes the plugins uuid from the _uuids array.\\n   * Removes the zfPlugin data attribute, as well as the data-plugin-name attribute.\\n   * Also fires the destroyed event for the plugin, consolidating repetitive code.\\n   * @param {Object} plugin - an instance of a plugin, usually `this` in context.\\n   * @fires Plugin#destroyed\\n   */\\n  unregisterPlugin: function (plugin) {\\n    var pluginName = hyphenate(functionName(plugin.$element.data('zfPlugin').constructor));\\n\\n    this._uuids.splice(this._uuids.indexOf(plugin.uuid), 1);\\n    plugin.$element.removeAttr('data-' + pluginName).removeData('zfPlugin')\\n    /**\\n     * Fires when the plugin has been destroyed.\\n     * @event Plugin#destroyed\\n     */\\n    .trigger('destroyed.zf.' + pluginName);\\n    for (var prop in plugin) {\\n      plugin[prop] = null; //clean up script to prep for garbage collection.\\n    }\\n    return;\\n  },\\n\\n  /**\\n   * @function\\n   * Causes one or more active plugins to re-initialize, resetting event listeners, recalculating positions, etc.\\n   * @param {String} plugins - optional string of an individual plugin key, attained by calling `$(element).data('pluginName')`, or string of a plugin class i.e. `'dropdown'`\\n   * @default If no argument is passed, reflow all currently active plugins.\\n   */\\n  reInit: function (plugins) {\\n    var isJQ = plugins instanceof __WEBPACK_IMPORTED_MODULE_0_jquery___default.a;\\n    try {\\n      if (isJQ) {\\n        plugins.each(function () {\\n          __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).data('zfPlugin')._init();\\n        });\\n      } else {\\n        var type = typeof plugins,\\n            _this = this,\\n            fns = {\\n          'object': function (plgs) {\\n            plgs.forEach(function (p) {\\n              p = hyphenate(p);\\n              __WEBPACK_IMPORTED_MODULE_0_jquery___default()('[data-' + p + ']').foundation('_init');\\n            });\\n          },\\n          'string': function () {\\n            plugins = hyphenate(plugins);\\n            __WEBPACK_IMPORTED_MODULE_0_jquery___default()('[data-' + plugins + ']').foundation('_init');\\n          },\\n          'undefined': function () {\\n            this['object'](Object.keys(_this._plugins));\\n          }\\n        };\\n        fns[type](plugins);\\n      }\\n    } catch (err) {\\n      console.error(err);\\n    } finally {\\n      return plugins;\\n    }\\n  },\\n\\n  /**\\n   * Initialize plugins on any elements within `elem` (and `elem` itself) that aren't already initialized.\\n   * @param {Object} elem - jQuery object containing the element to check inside. Also checks the element itself, unless it's the `document` object.\\n   * @param {String|Array} plugins - A list of plugins to initialize. Leave this out to initialize everything.\\n   */\\n  reflow: function (elem, plugins) {\\n\\n    // If plugins is undefined, just grab everything\\n    if (typeof plugins === 'undefined') {\\n      plugins = Object.keys(this._plugins);\\n    }\\n    // If plugins is a string, convert it to an array with one item\\n    else if (typeof plugins === 'string') {\\n        plugins = [plugins];\\n      }\\n\\n    var _this = this;\\n\\n    // Iterate through each plugin\\n    __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.each(plugins, function (i, name) {\\n      // Get the current plugin\\n      var plugin = _this._plugins[name];\\n\\n      // Localize the search to all elements inside elem, as well as elem itself, unless elem === document\\n      var $elem = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(elem).find('[data-' + name + ']').addBack('[data-' + name + ']');\\n\\n      // For each plugin found, initialize it\\n      $elem.each(function () {\\n        var $el = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this),\\n            opts = {};\\n        // Don't double-dip on plugins\\n        if ($el.data('zfPlugin')) {\\n          console.warn(\\\"Tried to initialize \\\" + name + \\\" on an element that already has a Foundation plugin.\\\");\\n          return;\\n        }\\n\\n        if ($el.attr('data-options')) {\\n          var thing = $el.attr('data-options').split(';').forEach(function (e, i) {\\n            var opt = e.split(':').map(function (el) {\\n              return el.trim();\\n            });\\n            if (opt[0]) opts[opt[0]] = parseValue(opt[1]);\\n          });\\n        }\\n        try {\\n          $el.data('zfPlugin', new plugin(__WEBPACK_IMPORTED_MODULE_0_jquery___default()(this), opts));\\n        } catch (er) {\\n          console.error(er);\\n        } finally {\\n          return;\\n        }\\n      });\\n    });\\n  },\\n  getFnName: functionName,\\n\\n  addToJquery: function ($) {\\n    // TODO: consider not making this a jQuery function\\n    // TODO: need way to reflow vs. re-initialize\\n    /**\\n     * The Foundation jQuery method.\\n     * @param {String|Array} method - An action to perform on the current jQuery object.\\n     */\\n    var foundation = function (method) {\\n      var type = typeof method,\\n          $noJS = $('.no-js');\\n\\n      if ($noJS.length) {\\n        $noJS.removeClass('no-js');\\n      }\\n\\n      if (type === 'undefined') {\\n        //needs to initialize the Foundation object, or an individual plugin.\\n        __WEBPACK_IMPORTED_MODULE_2__foundation_util_mediaQuery__[\\\"a\\\" /* MediaQuery */]._init();\\n        Foundation.reflow(this);\\n      } else if (type === 'string') {\\n        //an individual method to invoke on a plugin or group of plugins\\n        var args = Array.prototype.slice.call(arguments, 1); //collect all the arguments, if necessary\\n        var plugClass = this.data('zfPlugin'); //determine the class of plugin\\n\\n        if (plugClass !== undefined && plugClass[method] !== undefined) {\\n          //make sure both the class and method exist\\n          if (this.length === 1) {\\n            //if there's only one, call it directly.\\n            plugClass[method].apply(plugClass, args);\\n          } else {\\n            this.each(function (i, el) {\\n              //otherwise loop through the jQuery collection and invoke the method on each\\n              plugClass[method].apply($(el).data('zfPlugin'), args);\\n            });\\n          }\\n        } else {\\n          //error for no class or no method\\n          throw new ReferenceError(\\\"We're sorry, '\\\" + method + \\\"' is not an available method for \\\" + (plugClass ? functionName(plugClass) : 'this element') + '.');\\n        }\\n      } else {\\n        //error for invalid argument type\\n        throw new TypeError('We\\\\'re sorry, ' + type + ' is not a valid parameter. You must use a string representing the method you wish to invoke.');\\n      }\\n      return this;\\n    };\\n    $.fn.foundation = foundation;\\n    return $;\\n  }\\n};\\n\\nFoundation.util = {\\n  /**\\n   * Function for applying a debounce effect to a function call.\\n   * @function\\n   * @param {Function} func - Function to be called at end of timeout.\\n   * @param {Number} delay - Time in ms to delay the call of `func`.\\n   * @returns function\\n   */\\n  throttle: function (func, delay) {\\n    var timer = null;\\n\\n    return function () {\\n      var context = this,\\n          args = arguments;\\n\\n      if (timer === null) {\\n        timer = setTimeout(function () {\\n          func.apply(context, args);\\n          timer = null;\\n        }, delay);\\n      }\\n    };\\n  }\\n};\\n\\nwindow.Foundation = Foundation;\\n\\n// Polyfill for requestAnimationFrame\\n(function () {\\n  if (!Date.now || !window.Date.now) window.Date.now = Date.now = function () {\\n    return new Date().getTime();\\n  };\\n\\n  var vendors = ['webkit', 'moz'];\\n  for (var i = 0; i < vendors.length && !window.requestAnimationFrame; ++i) {\\n    var vp = vendors[i];\\n    window.requestAnimationFrame = window[vp + 'RequestAnimationFrame'];\\n    window.cancelAnimationFrame = window[vp + 'CancelAnimationFrame'] || window[vp + 'CancelRequestAnimationFrame'];\\n  }\\n  if (/iP(ad|hone|od).*OS 6/.test(window.navigator.userAgent) || !window.requestAnimationFrame || !window.cancelAnimationFrame) {\\n    var lastTime = 0;\\n    window.requestAnimationFrame = function (callback) {\\n      var now = Date.now();\\n      var nextTime = Math.max(lastTime + 16, now);\\n      return setTimeout(function () {\\n        callback(lastTime = nextTime);\\n      }, nextTime - now);\\n    };\\n    window.cancelAnimationFrame = clearTimeout;\\n  }\\n  /**\\n   * Polyfill for performance.now, required by rAF\\n   */\\n  if (!window.performance || !window.performance.now) {\\n    window.performance = {\\n      start: Date.now(),\\n      now: function () {\\n        return Date.now() - this.start;\\n      }\\n    };\\n  }\\n})();\\nif (!Function.prototype.bind) {\\n  Function.prototype.bind = function (oThis) {\\n    if (typeof this !== 'function') {\\n      // closest thing possible to the ECMAScript 5\\n      // internal IsCallable function\\n      throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');\\n    }\\n\\n    var aArgs = Array.prototype.slice.call(arguments, 1),\\n        fToBind = this,\\n        fNOP = function () {},\\n        fBound = function () {\\n      return fToBind.apply(this instanceof fNOP ? this : oThis, aArgs.concat(Array.prototype.slice.call(arguments)));\\n    };\\n\\n    if (this.prototype) {\\n      // native functions don't have a prototype\\n      fNOP.prototype = this.prototype;\\n    }\\n    fBound.prototype = new fNOP();\\n\\n    return fBound;\\n  };\\n}\\n// Polyfill to get the name of a function in IE9\\nfunction functionName(fn) {\\n  if (Function.prototype.name === undefined) {\\n    var funcNameRegex = /function\\\\s([^(]{1,})\\\\(/;\\n    var results = funcNameRegex.exec(fn.toString());\\n    return results && results.length > 1 ? results[1].trim() : \\\"\\\";\\n  } else if (fn.prototype === undefined) {\\n    return fn.constructor.name;\\n  } else {\\n    return fn.prototype.constructor.name;\\n  }\\n}\\nfunction parseValue(str) {\\n  if ('true' === str) return true;else if ('false' === str) return false;else if (!isNaN(str * 1)) return parseFloat(str);\\n  return str;\\n}\\n// Convert PascalCase to kebab-case\\n// Thank you: http://stackoverflow.com/a/8955580\\nfunction hyphenate(str) {\\n  return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\\n}\\n\\n\\n\\n/***/ }),\\n/* 22 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return Dropdown; });\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jquery__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__foundation_util_keyboard__ = __webpack_require__(3);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__foundation_util_core__ = __webpack_require__(1);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__foundation_positionable__ = __webpack_require__(15);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__foundation_util_triggers__ = __webpack_require__(5);\\n\\n\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\\\"value\\\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return call && (typeof call === \\\"object\\\" || typeof call === \\\"function\\\") ? call : self; }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function, not \\\" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\n\\n\\n\\n\\n\\n\\n\\n/**\\n * Dropdown module.\\n * @module foundation.dropdown\\n * @requires foundation.util.keyboard\\n * @requires foundation.util.box\\n * @requires foundation.util.triggers\\n */\\n\\nvar Dropdown = function (_Positionable) {\\n  _inherits(Dropdown, _Positionable);\\n\\n  function Dropdown() {\\n    _classCallCheck(this, Dropdown);\\n\\n    return _possibleConstructorReturn(this, (Dropdown.__proto__ || Object.getPrototypeOf(Dropdown)).apply(this, arguments));\\n  }\\n\\n  _createClass(Dropdown, [{\\n    key: '_setup',\\n\\n    /**\\n     * Creates a new instance of a dropdown.\\n     * @class\\n     * @name Dropdown\\n     * @param {jQuery} element - jQuery object to make into a dropdown.\\n     *        Object should be of the dropdown panel, rather than its anchor.\\n     * @param {Object} options - Overrides to the default plugin settings.\\n     */\\n    value: function _setup(element, options) {\\n      this.$element = element;\\n      this.options = __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.extend({}, Dropdown.defaults, this.$element.data(), options);\\n      this.className = 'Dropdown'; // ie9 back compat\\n\\n      // Triggers init is idempotent, just need to make sure it is initialized\\n      __WEBPACK_IMPORTED_MODULE_4__foundation_util_triggers__[\\\"a\\\" /* Triggers */].init(__WEBPACK_IMPORTED_MODULE_0_jquery___default.a);\\n\\n      this._init();\\n\\n      __WEBPACK_IMPORTED_MODULE_1__foundation_util_keyboard__[\\\"a\\\" /* Keyboard */].register('Dropdown', {\\n        'ENTER': 'open',\\n        'SPACE': 'open',\\n        'ESCAPE': 'close'\\n      });\\n    }\\n\\n    /**\\n     * Initializes the plugin by setting/checking options and attributes, adding helper variables, and saving the anchor.\\n     * @function\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_init',\\n    value: function _init() {\\n      var $id = this.$element.attr('id');\\n\\n      this.$anchor = __WEBPACK_IMPORTED_MODULE_0_jquery___default()('[data-toggle=\\\"' + $id + '\\\"]').length ? __WEBPACK_IMPORTED_MODULE_0_jquery___default()('[data-toggle=\\\"' + $id + '\\\"]') : __WEBPACK_IMPORTED_MODULE_0_jquery___default()('[data-open=\\\"' + $id + '\\\"]');\\n      this.$anchor.attr({\\n        'aria-controls': $id,\\n        'data-is-focus': false,\\n        'data-yeti-box': $id,\\n        'aria-haspopup': true,\\n        'aria-expanded': false\\n\\n      });\\n\\n      if (this.options.parentClass) {\\n        this.$parent = this.$element.parents('.' + this.options.parentClass);\\n      } else {\\n        this.$parent = null;\\n      }\\n\\n      this.$element.attr({\\n        'aria-hidden': 'true',\\n        'data-yeti-box': $id,\\n        'data-resize': $id,\\n        'aria-labelledby': this.$anchor[0].id || __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__foundation_util_core__[\\\"b\\\" /* GetYoDigits */])(6, 'dd-anchor')\\n      });\\n      _get(Dropdown.prototype.__proto__ || Object.getPrototypeOf(Dropdown.prototype), '_init', this).call(this);\\n      this._events();\\n    }\\n  }, {\\n    key: '_getDefaultPosition',\\n    value: function _getDefaultPosition() {\\n      // handle legacy classnames\\n      var position = this.$element[0].className.match(/(top|left|right|bottom)/g);\\n      if (position) {\\n        return position[0];\\n      } else {\\n        return 'bottom';\\n      }\\n    }\\n  }, {\\n    key: '_getDefaultAlignment',\\n    value: function _getDefaultAlignment() {\\n      // handle legacy float approach\\n      var horizontalPosition = /float-(\\\\S+)/.exec(this.$anchor[0].className);\\n      if (horizontalPosition) {\\n        return horizontalPosition[1];\\n      }\\n\\n      return _get(Dropdown.prototype.__proto__ || Object.getPrototypeOf(Dropdown.prototype), '_getDefaultAlignment', this).call(this);\\n    }\\n\\n    /**\\n     * Sets the position and orientation of the dropdown pane, checks for collisions if allow-overlap is not true.\\n     * Recursively calls itself if a collision is detected, with a new position class.\\n     * @function\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_setPosition',\\n    value: function _setPosition() {\\n      _get(Dropdown.prototype.__proto__ || Object.getPrototypeOf(Dropdown.prototype), '_setPosition', this).call(this, this.$anchor, this.$element, this.$parent);\\n    }\\n\\n    /**\\n     * Adds event listeners to the element utilizing the triggers utility library.\\n     * @function\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_events',\\n    value: function _events() {\\n      var _this = this;\\n      this.$element.on({\\n        'open.zf.trigger': this.open.bind(this),\\n        'close.zf.trigger': this.close.bind(this),\\n        'toggle.zf.trigger': this.toggle.bind(this),\\n        'resizeme.zf.trigger': this._setPosition.bind(this)\\n      });\\n\\n      if (this.options.hover) {\\n        this.$anchor.off('mouseenter.zf.dropdown mouseleave.zf.dropdown').on('mouseenter.zf.dropdown', function () {\\n          var bodyData = __WEBPACK_IMPORTED_MODULE_0_jquery___default()('body').data();\\n          if (typeof bodyData.whatinput === 'undefined' || bodyData.whatinput === 'mouse') {\\n            clearTimeout(_this.timeout);\\n            _this.timeout = setTimeout(function () {\\n              _this.open();\\n              _this.$anchor.data('hover', true);\\n            }, _this.options.hoverDelay);\\n          }\\n        }).on('mouseleave.zf.dropdown', function () {\\n          clearTimeout(_this.timeout);\\n          _this.timeout = setTimeout(function () {\\n            _this.close();\\n            _this.$anchor.data('hover', false);\\n          }, _this.options.hoverDelay);\\n        });\\n        if (this.options.hoverPane) {\\n          this.$element.off('mouseenter.zf.dropdown mouseleave.zf.dropdown').on('mouseenter.zf.dropdown', function () {\\n            clearTimeout(_this.timeout);\\n          }).on('mouseleave.zf.dropdown', function () {\\n            clearTimeout(_this.timeout);\\n            _this.timeout = setTimeout(function () {\\n              _this.close();\\n              _this.$anchor.data('hover', false);\\n            }, _this.options.hoverDelay);\\n          });\\n        }\\n      }\\n      this.$anchor.add(this.$element).on('keydown.zf.dropdown', function (e) {\\n\\n        var $target = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this),\\n            visibleFocusableElements = __WEBPACK_IMPORTED_MODULE_1__foundation_util_keyboard__[\\\"a\\\" /* Keyboard */].findFocusable(_this.$element);\\n\\n        __WEBPACK_IMPORTED_MODULE_1__foundation_util_keyboard__[\\\"a\\\" /* Keyboard */].handleKey(e, 'Dropdown', {\\n          open: function () {\\n            if ($target.is(_this.$anchor)) {\\n              _this.open();\\n              _this.$element.attr('tabindex', -1).focus();\\n              e.preventDefault();\\n            }\\n          },\\n          close: function () {\\n            _this.close();\\n            _this.$anchor.focus();\\n          }\\n        });\\n      });\\n    }\\n\\n    /**\\n     * Adds an event handler to the body to close any dropdowns on a click.\\n     * @function\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_addBodyHandler',\\n    value: function _addBodyHandler() {\\n      var $body = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(document.body).not(this.$element),\\n          _this = this;\\n      $body.off('click.zf.dropdown').on('click.zf.dropdown', function (e) {\\n        if (_this.$anchor.is(e.target) || _this.$anchor.find(e.target).length) {\\n          return;\\n        }\\n        if (_this.$element.find(e.target).length) {\\n          return;\\n        }\\n        _this.close();\\n        $body.off('click.zf.dropdown');\\n      });\\n    }\\n\\n    /**\\n     * Opens the dropdown pane, and fires a bubbling event to close other dropdowns.\\n     * @function\\n     * @fires Dropdown#closeme\\n     * @fires Dropdown#show\\n     */\\n\\n  }, {\\n    key: 'open',\\n    value: function open() {\\n      // var _this = this;\\n      /**\\n       * Fires to close other open dropdowns, typically when dropdown is opening\\n       * @event Dropdown#closeme\\n       */\\n      this.$element.trigger('closeme.zf.dropdown', this.$element.attr('id'));\\n      this.$anchor.addClass('hover').attr({ 'aria-expanded': true });\\n      // this.$element/*.show()*/;\\n\\n      this.$element.addClass('is-opening');\\n      this._setPosition();\\n      this.$element.removeClass('is-opening').addClass('is-open').attr({ 'aria-hidden': false });\\n\\n      if (this.options.autoFocus) {\\n        var $focusable = __WEBPACK_IMPORTED_MODULE_1__foundation_util_keyboard__[\\\"a\\\" /* Keyboard */].findFocusable(this.$element);\\n        if ($focusable.length) {\\n          $focusable.eq(0).focus();\\n        }\\n      }\\n\\n      if (this.options.closeOnClick) {\\n        this._addBodyHandler();\\n      }\\n\\n      if (this.options.trapFocus) {\\n        __WEBPACK_IMPORTED_MODULE_1__foundation_util_keyboard__[\\\"a\\\" /* Keyboard */].trapFocus(this.$element);\\n      }\\n\\n      /**\\n       * Fires once the dropdown is visible.\\n       * @event Dropdown#show\\n       */\\n      this.$element.trigger('show.zf.dropdown', [this.$element]);\\n    }\\n\\n    /**\\n     * Closes the open dropdown pane.\\n     * @function\\n     * @fires Dropdown#hide\\n     */\\n\\n  }, {\\n    key: 'close',\\n    value: function close() {\\n      if (!this.$element.hasClass('is-open')) {\\n        return false;\\n      }\\n      this.$element.removeClass('is-open').attr({ 'aria-hidden': true });\\n\\n      this.$anchor.removeClass('hover').attr('aria-expanded', false);\\n\\n      /**\\n       * Fires once the dropdown is no longer visible.\\n       * @event Dropdown#hide\\n       */\\n      this.$element.trigger('hide.zf.dropdown', [this.$element]);\\n\\n      if (this.options.trapFocus) {\\n        __WEBPACK_IMPORTED_MODULE_1__foundation_util_keyboard__[\\\"a\\\" /* Keyboard */].releaseFocus(this.$element);\\n      }\\n    }\\n\\n    /**\\n     * Toggles the dropdown pane's visibility.\\n     * @function\\n     */\\n\\n  }, {\\n    key: 'toggle',\\n    value: function toggle() {\\n      if (this.$element.hasClass('is-open')) {\\n        if (this.$anchor.data('hover')) return;\\n        this.close();\\n      } else {\\n        this.open();\\n      }\\n    }\\n\\n    /**\\n     * Destroys the dropdown.\\n     * @function\\n     */\\n\\n  }, {\\n    key: '_destroy',\\n    value: function _destroy() {\\n      this.$element.off('.zf.trigger').hide();\\n      this.$anchor.off('.zf.dropdown');\\n      __WEBPACK_IMPORTED_MODULE_0_jquery___default()(document.body).off('click.zf.dropdown');\\n    }\\n  }]);\\n\\n  return Dropdown;\\n}(__WEBPACK_IMPORTED_MODULE_3__foundation_positionable__[\\\"a\\\" /* Positionable */]);\\n\\nDropdown.defaults = {\\n  /**\\n   * Class that designates bounding container of Dropdown (default: window)\\n   * @option\\n   * @type {?string}\\n   * @default null\\n   */\\n  parentClass: null,\\n  /**\\n   * Amount of time to delay opening a submenu on hover event.\\n   * @option\\n   * @type {number}\\n   * @default 250\\n   */\\n  hoverDelay: 250,\\n  /**\\n   * Allow submenus to open on hover events\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  hover: false,\\n  /**\\n   * Don't close dropdown when hovering over dropdown pane\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  hoverPane: false,\\n  /**\\n   * Number of pixels between the dropdown pane and the triggering element on open.\\n   * @option\\n   * @type {number}\\n   * @default 0\\n   */\\n  vOffset: 0,\\n  /**\\n   * Number of pixels between the dropdown pane and the triggering element on open.\\n   * @option\\n   * @type {number}\\n   * @default 0\\n   */\\n  hOffset: 0,\\n  /**\\n   * DEPRECATED: Class applied to adjust open position.\\n   * @option\\n   * @type {string}\\n   * @default ''\\n   */\\n  positionClass: '',\\n\\n  /**\\n   * Position of dropdown. Can be left, right, bottom, top, or auto.\\n   * @option\\n   * @type {string}\\n   * @default 'auto'\\n   */\\n  position: 'auto',\\n  /**\\n   * Alignment of dropdown relative to anchor. Can be left, right, bottom, top, center, or auto.\\n   * @option\\n   * @type {string}\\n   * @default 'auto'\\n   */\\n  alignment: 'auto',\\n  /**\\n   * Allow overlap of container/window. If false, dropdown will first try to position as defined by data-position and data-alignment, but reposition if it would cause an overflow.\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  allowOverlap: false,\\n  /**\\n   * Allow overlap of only the bottom of the container. This is the most common\\n   * behavior for dropdowns, allowing the dropdown to extend the bottom of the\\n   * screen but not otherwise influence or break out of the container.\\n   * @option\\n   * @type {boolean}\\n   * @default true\\n   */\\n  allowBottomOverlap: true,\\n  /**\\n   * Allow the plugin to trap focus to the dropdown pane if opened with keyboard commands.\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  trapFocus: false,\\n  /**\\n   * Allow the plugin to set focus to the first focusable element within the pane, regardless of method of opening.\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  autoFocus: false,\\n  /**\\n   * Allows a click on the body to close the dropdown.\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  closeOnClick: false\\n};\\n\\n\\n\\n/***/ }),\\n/* 23 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return Equalizer; });\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jquery__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__foundation_util_mediaQuery__ = __webpack_require__(4);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__foundation_util_imageLoader__ = __webpack_require__(8);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__foundation_util_core__ = __webpack_require__(1);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__foundation_plugin__ = __webpack_require__(2);\\n\\n\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return call && (typeof call === \\\"object\\\" || typeof call === \\\"function\\\") ? call : self; }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function, not \\\" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\n\\n\\n\\n\\n\\n\\n/**\\n * Equalizer module.\\n * @module foundation.equalizer\\n * @requires foundation.util.mediaQuery\\n * @requires foundation.util.imageLoader if equalizer contains images\\n */\\n\\nvar Equalizer = function (_Plugin) {\\n  _inherits(Equalizer, _Plugin);\\n\\n  function Equalizer() {\\n    _classCallCheck(this, Equalizer);\\n\\n    return _possibleConstructorReturn(this, (Equalizer.__proto__ || Object.getPrototypeOf(Equalizer)).apply(this, arguments));\\n  }\\n\\n  _createClass(Equalizer, [{\\n    key: '_setup',\\n\\n    /**\\n     * Creates a new instance of Equalizer.\\n     * @class\\n     * @name Equalizer\\n     * @fires Equalizer#init\\n     * @param {Object} element - jQuery object to add the trigger to.\\n     * @param {Object} options - Overrides to the default plugin settings.\\n     */\\n    value: function _setup(element, options) {\\n      this.$element = element;\\n      this.options = __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.extend({}, Equalizer.defaults, this.$element.data(), options);\\n      this.className = 'Equalizer'; // ie9 back compat\\n\\n      this._init();\\n    }\\n\\n    /**\\n     * Initializes the Equalizer plugin and calls functions to get equalizer functioning on load.\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_init',\\n    value: function _init() {\\n      var eqId = this.$element.attr('data-equalizer') || '';\\n      var $watched = this.$element.find('[data-equalizer-watch=\\\"' + eqId + '\\\"]');\\n\\n      __WEBPACK_IMPORTED_MODULE_1__foundation_util_mediaQuery__[\\\"a\\\" /* MediaQuery */]._init();\\n\\n      this.$watched = $watched.length ? $watched : this.$element.find('[data-equalizer-watch]');\\n      this.$element.attr('data-resize', eqId || __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__foundation_util_core__[\\\"b\\\" /* GetYoDigits */])(6, 'eq'));\\n      this.$element.attr('data-mutate', eqId || __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__foundation_util_core__[\\\"b\\\" /* GetYoDigits */])(6, 'eq'));\\n\\n      this.hasNested = this.$element.find('[data-equalizer]').length > 0;\\n      this.isNested = this.$element.parentsUntil(document.body, '[data-equalizer]').length > 0;\\n      this.isOn = false;\\n      this._bindHandler = {\\n        onResizeMeBound: this._onResizeMe.bind(this),\\n        onPostEqualizedBound: this._onPostEqualized.bind(this)\\n      };\\n\\n      var imgs = this.$element.find('img');\\n      var tooSmall;\\n      if (this.options.equalizeOn) {\\n        tooSmall = this._checkMQ();\\n        __WEBPACK_IMPORTED_MODULE_0_jquery___default()(window).on('changed.zf.mediaquery', this._checkMQ.bind(this));\\n      } else {\\n        this._events();\\n      }\\n      if (tooSmall !== undefined && tooSmall === false || tooSmall === undefined) {\\n        if (imgs.length) {\\n          __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__foundation_util_imageLoader__[\\\"a\\\" /* onImagesLoaded */])(imgs, this._reflow.bind(this));\\n        } else {\\n          this._reflow();\\n        }\\n      }\\n    }\\n\\n    /**\\n     * Removes event listeners if the breakpoint is too small.\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_pauseEvents',\\n    value: function _pauseEvents() {\\n      this.isOn = false;\\n      this.$element.off({\\n        '.zf.equalizer': this._bindHandler.onPostEqualizedBound,\\n        'resizeme.zf.trigger': this._bindHandler.onResizeMeBound,\\n        'mutateme.zf.trigger': this._bindHandler.onResizeMeBound\\n      });\\n    }\\n\\n    /**\\n     * function to handle $elements resizeme.zf.trigger, with bound this on _bindHandler.onResizeMeBound\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_onResizeMe',\\n    value: function _onResizeMe(e) {\\n      this._reflow();\\n    }\\n\\n    /**\\n     * function to handle $elements postequalized.zf.equalizer, with bound this on _bindHandler.onPostEqualizedBound\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_onPostEqualized',\\n    value: function _onPostEqualized(e) {\\n      if (e.target !== this.$element[0]) {\\n        this._reflow();\\n      }\\n    }\\n\\n    /**\\n     * Initializes events for Equalizer.\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_events',\\n    value: function _events() {\\n      var _this = this;\\n      this._pauseEvents();\\n      if (this.hasNested) {\\n        this.$element.on('postequalized.zf.equalizer', this._bindHandler.onPostEqualizedBound);\\n      } else {\\n        this.$element.on('resizeme.zf.trigger', this._bindHandler.onResizeMeBound);\\n        this.$element.on('mutateme.zf.trigger', this._bindHandler.onResizeMeBound);\\n      }\\n      this.isOn = true;\\n    }\\n\\n    /**\\n     * Checks the current breakpoint to the minimum required size.\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_checkMQ',\\n    value: function _checkMQ() {\\n      var tooSmall = !__WEBPACK_IMPORTED_MODULE_1__foundation_util_mediaQuery__[\\\"a\\\" /* MediaQuery */].is(this.options.equalizeOn);\\n      if (tooSmall) {\\n        if (this.isOn) {\\n          this._pauseEvents();\\n          this.$watched.css('height', 'auto');\\n        }\\n      } else {\\n        if (!this.isOn) {\\n          this._events();\\n        }\\n      }\\n      return tooSmall;\\n    }\\n\\n    /**\\n     * A noop version for the plugin\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_killswitch',\\n    value: function _killswitch() {\\n      return;\\n    }\\n\\n    /**\\n     * Calls necessary functions to update Equalizer upon DOM change\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_reflow',\\n    value: function _reflow() {\\n      if (!this.options.equalizeOnStack) {\\n        if (this._isStacked()) {\\n          this.$watched.css('height', 'auto');\\n          return false;\\n        }\\n      }\\n      if (this.options.equalizeByRow) {\\n        this.getHeightsByRow(this.applyHeightByRow.bind(this));\\n      } else {\\n        this.getHeights(this.applyHeight.bind(this));\\n      }\\n    }\\n\\n    /**\\n     * Manually determines if the first 2 elements are *NOT* stacked.\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_isStacked',\\n    value: function _isStacked() {\\n      if (!this.$watched[0] || !this.$watched[1]) {\\n        return true;\\n      }\\n      return this.$watched[0].getBoundingClientRect().top !== this.$watched[1].getBoundingClientRect().top;\\n    }\\n\\n    /**\\n     * Finds the outer heights of children contained within an Equalizer parent and returns them in an array\\n     * @param {Function} cb - A non-optional callback to return the heights array to.\\n     * @returns {Array} heights - An array of heights of children within Equalizer container\\n     */\\n\\n  }, {\\n    key: 'getHeights',\\n    value: function getHeights(cb) {\\n      var heights = [];\\n      for (var i = 0, len = this.$watched.length; i < len; i++) {\\n        this.$watched[i].style.height = 'auto';\\n        heights.push(this.$watched[i].offsetHeight);\\n      }\\n      cb(heights);\\n    }\\n\\n    /**\\n     * Finds the outer heights of children contained within an Equalizer parent and returns them in an array\\n     * @param {Function} cb - A non-optional callback to return the heights array to.\\n     * @returns {Array} groups - An array of heights of children within Equalizer container grouped by row with element,height and max as last child\\n     */\\n\\n  }, {\\n    key: 'getHeightsByRow',\\n    value: function getHeightsByRow(cb) {\\n      var lastElTopOffset = this.$watched.length ? this.$watched.first().offset().top : 0,\\n          groups = [],\\n          group = 0;\\n      //group by Row\\n      groups[group] = [];\\n      for (var i = 0, len = this.$watched.length; i < len; i++) {\\n        this.$watched[i].style.height = 'auto';\\n        //maybe could use this.$watched[i].offsetTop\\n        var elOffsetTop = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this.$watched[i]).offset().top;\\n        if (elOffsetTop != lastElTopOffset) {\\n          group++;\\n          groups[group] = [];\\n          lastElTopOffset = elOffsetTop;\\n        }\\n        groups[group].push([this.$watched[i], this.$watched[i].offsetHeight]);\\n      }\\n\\n      for (var j = 0, ln = groups.length; j < ln; j++) {\\n        var heights = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(groups[j]).map(function () {\\n          return this[1];\\n        }).get();\\n        var max = Math.max.apply(null, heights);\\n        groups[j].push(max);\\n      }\\n      cb(groups);\\n    }\\n\\n    /**\\n     * Changes the CSS height property of each child in an Equalizer parent to match the tallest\\n     * @param {array} heights - An array of heights of children within Equalizer container\\n     * @fires Equalizer#preequalized\\n     * @fires Equalizer#postequalized\\n     */\\n\\n  }, {\\n    key: 'applyHeight',\\n    value: function applyHeight(heights) {\\n      var max = Math.max.apply(null, heights);\\n      /**\\n       * Fires before the heights are applied\\n       * @event Equalizer#preequalized\\n       */\\n      this.$element.trigger('preequalized.zf.equalizer');\\n\\n      this.$watched.css('height', max);\\n\\n      /**\\n       * Fires when the heights have been applied\\n       * @event Equalizer#postequalized\\n       */\\n      this.$element.trigger('postequalized.zf.equalizer');\\n    }\\n\\n    /**\\n     * Changes the CSS height property of each child in an Equalizer parent to match the tallest by row\\n     * @param {array} groups - An array of heights of children within Equalizer container grouped by row with element,height and max as last child\\n     * @fires Equalizer#preequalized\\n     * @fires Equalizer#preequalizedrow\\n     * @fires Equalizer#postequalizedrow\\n     * @fires Equalizer#postequalized\\n     */\\n\\n  }, {\\n    key: 'applyHeightByRow',\\n    value: function applyHeightByRow(groups) {\\n      /**\\n       * Fires before the heights are applied\\n       */\\n      this.$element.trigger('preequalized.zf.equalizer');\\n      for (var i = 0, len = groups.length; i < len; i++) {\\n        var groupsILength = groups[i].length,\\n            max = groups[i][groupsILength - 1];\\n        if (groupsILength <= 2) {\\n          __WEBPACK_IMPORTED_MODULE_0_jquery___default()(groups[i][0][0]).css({ 'height': 'auto' });\\n          continue;\\n        }\\n        /**\\n          * Fires before the heights per row are applied\\n          * @event Equalizer#preequalizedrow\\n          */\\n        this.$element.trigger('preequalizedrow.zf.equalizer');\\n        for (var j = 0, lenJ = groupsILength - 1; j < lenJ; j++) {\\n          __WEBPACK_IMPORTED_MODULE_0_jquery___default()(groups[i][j][0]).css({ 'height': max });\\n        }\\n        /**\\n          * Fires when the heights per row have been applied\\n          * @event Equalizer#postequalizedrow\\n          */\\n        this.$element.trigger('postequalizedrow.zf.equalizer');\\n      }\\n      /**\\n       * Fires when the heights have been applied\\n       */\\n      this.$element.trigger('postequalized.zf.equalizer');\\n    }\\n\\n    /**\\n     * Destroys an instance of Equalizer.\\n     * @function\\n     */\\n\\n  }, {\\n    key: '_destroy',\\n    value: function _destroy() {\\n      this._pauseEvents();\\n      this.$watched.css('height', 'auto');\\n    }\\n  }]);\\n\\n  return Equalizer;\\n}(__WEBPACK_IMPORTED_MODULE_4__foundation_plugin__[\\\"a\\\" /* Plugin */]);\\n\\n/**\\n * Default settings for plugin\\n */\\n\\n\\nEqualizer.defaults = {\\n  /**\\n   * Enable height equalization when stacked on smaller screens.\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  equalizeOnStack: false,\\n  /**\\n   * Enable height equalization row by row.\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  equalizeByRow: false,\\n  /**\\n   * String representing the minimum breakpoint size the plugin should equalize heights on.\\n   * @option\\n   * @type {string}\\n   * @default ''\\n   */\\n  equalizeOn: ''\\n};\\n\\n\\n\\n/***/ }),\\n/* 24 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return Interchange; });\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jquery__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__foundation_util_mediaQuery__ = __webpack_require__(4);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__foundation_plugin__ = __webpack_require__(2);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__foundation_util_core__ = __webpack_require__(1);\\n\\n\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return call && (typeof call === \\\"object\\\" || typeof call === \\\"function\\\") ? call : self; }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function, not \\\" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\n\\n\\n\\n\\n\\n/**\\n * Interchange module.\\n * @module foundation.interchange\\n * @requires foundation.util.mediaQuery\\n */\\n\\nvar Interchange = function (_Plugin) {\\n  _inherits(Interchange, _Plugin);\\n\\n  function Interchange() {\\n    _classCallCheck(this, Interchange);\\n\\n    return _possibleConstructorReturn(this, (Interchange.__proto__ || Object.getPrototypeOf(Interchange)).apply(this, arguments));\\n  }\\n\\n  _createClass(Interchange, [{\\n    key: '_setup',\\n\\n    /**\\n     * Creates a new instance of Interchange.\\n     * @class\\n     * @name Interchange\\n     * @fires Interchange#init\\n     * @param {Object} element - jQuery object to add the trigger to.\\n     * @param {Object} options - Overrides to the default plugin settings.\\n     */\\n    value: function _setup(element, options) {\\n      this.$element = element;\\n      this.options = __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.extend({}, Interchange.defaults, options);\\n      this.rules = [];\\n      this.currentPath = '';\\n      this.className = 'Interchange'; // ie9 back compat\\n\\n      this._init();\\n      this._events();\\n    }\\n\\n    /**\\n     * Initializes the Interchange plugin and calls functions to get interchange functioning on load.\\n     * @function\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_init',\\n    value: function _init() {\\n      __WEBPACK_IMPORTED_MODULE_1__foundation_util_mediaQuery__[\\\"a\\\" /* MediaQuery */]._init();\\n\\n      var id = this.$element[0].id || __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__foundation_util_core__[\\\"b\\\" /* GetYoDigits */])(6, 'interchange');\\n      this.$element.attr({\\n        'data-resize': id,\\n        'id': id\\n      });\\n\\n      this._addBreakpoints();\\n      this._generateRules();\\n      this._reflow();\\n    }\\n\\n    /**\\n     * Initializes events for Interchange.\\n     * @function\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_events',\\n    value: function _events() {\\n      var _this3 = this;\\n\\n      this.$element.off('resizeme.zf.trigger').on('resizeme.zf.trigger', function () {\\n        return _this3._reflow();\\n      });\\n    }\\n\\n    /**\\n     * Calls necessary functions to update Interchange upon DOM change\\n     * @function\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_reflow',\\n    value: function _reflow() {\\n      var match;\\n\\n      // Iterate through each rule, but only save the last match\\n      for (var i in this.rules) {\\n        if (this.rules.hasOwnProperty(i)) {\\n          var rule = this.rules[i];\\n          if (window.matchMedia(rule.query).matches) {\\n            match = rule;\\n          }\\n        }\\n      }\\n\\n      if (match) {\\n        this.replace(match.path);\\n      }\\n    }\\n\\n    /**\\n     * Gets the Foundation breakpoints and adds them to the Interchange.SPECIAL_QUERIES object.\\n     * @function\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_addBreakpoints',\\n    value: function _addBreakpoints() {\\n      for (var i in __WEBPACK_IMPORTED_MODULE_1__foundation_util_mediaQuery__[\\\"a\\\" /* MediaQuery */].queries) {\\n        if (__WEBPACK_IMPORTED_MODULE_1__foundation_util_mediaQuery__[\\\"a\\\" /* MediaQuery */].queries.hasOwnProperty(i)) {\\n          var query = __WEBPACK_IMPORTED_MODULE_1__foundation_util_mediaQuery__[\\\"a\\\" /* MediaQuery */].queries[i];\\n          Interchange.SPECIAL_QUERIES[query.name] = query.value;\\n        }\\n      }\\n    }\\n\\n    /**\\n     * Checks the Interchange element for the provided media query + content pairings\\n     * @function\\n     * @private\\n     * @param {Object} element - jQuery object that is an Interchange instance\\n     * @returns {Array} scenarios - Array of objects that have 'mq' and 'path' keys with corresponding keys\\n     */\\n\\n  }, {\\n    key: '_generateRules',\\n    value: function _generateRules(element) {\\n      var rulesList = [];\\n      var rules;\\n\\n      if (this.options.rules) {\\n        rules = this.options.rules;\\n      } else {\\n        rules = this.$element.data('interchange');\\n      }\\n\\n      rules = typeof rules === 'string' ? rules.match(/\\\\[.*?\\\\]/g) : rules;\\n\\n      for (var i in rules) {\\n        if (rules.hasOwnProperty(i)) {\\n          var rule = rules[i].slice(1, -1).split(', ');\\n          var path = rule.slice(0, -1).join('');\\n          var query = rule[rule.length - 1];\\n\\n          if (Interchange.SPECIAL_QUERIES[query]) {\\n            query = Interchange.SPECIAL_QUERIES[query];\\n          }\\n\\n          rulesList.push({\\n            path: path,\\n            query: query\\n          });\\n        }\\n      }\\n\\n      this.rules = rulesList;\\n    }\\n\\n    /**\\n     * Update the `src` property of an image, or change the HTML of a container, to the specified path.\\n     * @function\\n     * @param {String} path - Path to the image or HTML partial.\\n     * @fires Interchange#replaced\\n     */\\n\\n  }, {\\n    key: 'replace',\\n    value: function replace(path) {\\n      if (this.currentPath === path) return;\\n\\n      var _this = this,\\n          trigger = 'replaced.zf.interchange';\\n\\n      // Replacing images\\n      if (this.$element[0].nodeName === 'IMG') {\\n        this.$element.attr('src', path).on('load', function () {\\n          _this.currentPath = path;\\n        }).trigger(trigger);\\n      }\\n      // Replacing background images\\n      else if (path.match(/\\\\.(gif|jpg|jpeg|png|svg|tiff)([?#].*)?/i)) {\\n          path = path.replace(/\\\\(/g, '%28').replace(/\\\\)/g, '%29');\\n          this.$element.css({ 'background-image': 'url(' + path + ')' }).trigger(trigger);\\n        }\\n        // Replacing HTML\\n        else {\\n            __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.get(path, function (response) {\\n              _this.$element.html(response).trigger(trigger);\\n              __WEBPACK_IMPORTED_MODULE_0_jquery___default()(response).foundation();\\n              _this.currentPath = path;\\n            });\\n          }\\n\\n      /**\\n       * Fires when content in an Interchange element is done being loaded.\\n       * @event Interchange#replaced\\n       */\\n      // this.$element.trigger('replaced.zf.interchange');\\n    }\\n\\n    /**\\n     * Destroys an instance of interchange.\\n     * @function\\n     */\\n\\n  }, {\\n    key: '_destroy',\\n    value: function _destroy() {\\n      this.$element.off('resizeme.zf.trigger');\\n    }\\n  }]);\\n\\n  return Interchange;\\n}(__WEBPACK_IMPORTED_MODULE_2__foundation_plugin__[\\\"a\\\" /* Plugin */]);\\n\\n/**\\n * Default settings for plugin\\n */\\n\\n\\nInterchange.defaults = {\\n  /**\\n   * Rules to be applied to Interchange elements. Set with the `data-interchange` array notation.\\n   * @option\\n   * @type {?array}\\n   * @default null\\n   */\\n  rules: null\\n};\\n\\nInterchange.SPECIAL_QUERIES = {\\n  'landscape': 'screen and (orientation: landscape)',\\n  'portrait': 'screen and (orientation: portrait)',\\n  'retina': 'only screen and (-webkit-min-device-pixel-ratio: 2), only screen and (min--moz-device-pixel-ratio: 2), only screen and (-o-min-device-pixel-ratio: 2/1), only screen and (min-device-pixel-ratio: 2), only screen and (min-resolution: 192dpi), only screen and (min-resolution: 2dppx)'\\n};\\n\\n\\n\\n/***/ }),\\n/* 25 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return Magellan; });\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jquery__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__foundation_util_core__ = __webpack_require__(1);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__foundation_plugin__ = __webpack_require__(2);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__foundation_smoothScroll__ = __webpack_require__(16);\\n\\n\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return call && (typeof call === \\\"object\\\" || typeof call === \\\"function\\\") ? call : self; }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function, not \\\" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\n\\n\\n\\n\\n\\n/**\\n * Magellan module.\\n * @module foundation.magellan\\n * @requires foundation.smoothScroll\\n */\\n\\nvar Magellan = function (_Plugin) {\\n  _inherits(Magellan, _Plugin);\\n\\n  function Magellan() {\\n    _classCallCheck(this, Magellan);\\n\\n    return _possibleConstructorReturn(this, (Magellan.__proto__ || Object.getPrototypeOf(Magellan)).apply(this, arguments));\\n  }\\n\\n  _createClass(Magellan, [{\\n    key: '_setup',\\n\\n    /**\\n     * Creates a new instance of Magellan.\\n     * @class\\n     * @name Magellan\\n     * @fires Magellan#init\\n     * @param {Object} element - jQuery object to add the trigger to.\\n     * @param {Object} options - Overrides to the default plugin settings.\\n     */\\n    value: function _setup(element, options) {\\n      this.$element = element;\\n      this.options = __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.extend({}, Magellan.defaults, this.$element.data(), options);\\n      this.className = 'Magellan'; // ie9 back compat\\n\\n      this._init();\\n      this.calcPoints();\\n    }\\n\\n    /**\\n     * Initializes the Magellan plugin and calls functions to get equalizer functioning on load.\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_init',\\n    value: function _init() {\\n      var id = this.$element[0].id || __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__foundation_util_core__[\\\"b\\\" /* GetYoDigits */])(6, 'magellan');\\n      var _this = this;\\n      this.$targets = __WEBPACK_IMPORTED_MODULE_0_jquery___default()('[data-magellan-target]');\\n      this.$links = this.$element.find('a');\\n      this.$element.attr({\\n        'data-resize': id,\\n        'data-scroll': id,\\n        'id': id\\n      });\\n      this.$active = __WEBPACK_IMPORTED_MODULE_0_jquery___default()();\\n      this.scrollPos = parseInt(window.pageYOffset, 10);\\n\\n      this._events();\\n    }\\n\\n    /**\\n     * Calculates an array of pixel values that are the demarcation lines between locations on the page.\\n     * Can be invoked if new elements are added or the size of a location changes.\\n     * @function\\n     */\\n\\n  }, {\\n    key: 'calcPoints',\\n    value: function calcPoints() {\\n      var _this = this,\\n          body = document.body,\\n          html = document.documentElement;\\n\\n      this.points = [];\\n      this.winHeight = Math.round(Math.max(window.innerHeight, html.clientHeight));\\n      this.docHeight = Math.round(Math.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight));\\n\\n      this.$targets.each(function () {\\n        var $tar = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this),\\n            pt = Math.round($tar.offset().top - _this.options.threshold);\\n        $tar.targetPoint = pt;\\n        _this.points.push(pt);\\n      });\\n    }\\n\\n    /**\\n     * Initializes events for Magellan.\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_events',\\n    value: function _events() {\\n      var _this = this,\\n          $body = __WEBPACK_IMPORTED_MODULE_0_jquery___default()('html, body'),\\n          opts = {\\n        duration: _this.options.animationDuration,\\n        easing: _this.options.animationEasing\\n      };\\n      __WEBPACK_IMPORTED_MODULE_0_jquery___default()(window).one('load', function () {\\n        if (_this.options.deepLinking) {\\n          if (location.hash) {\\n            _this.scrollToLoc(location.hash);\\n          }\\n        }\\n        _this.calcPoints();\\n        _this._updateActive();\\n      });\\n\\n      this.$element.on({\\n        'resizeme.zf.trigger': this.reflow.bind(this),\\n        'scrollme.zf.trigger': this._updateActive.bind(this)\\n      }).on('click.zf.magellan', 'a[href^=\\\"#\\\"]', function (e) {\\n        e.preventDefault();\\n        var arrival = this.getAttribute('href');\\n        _this.scrollToLoc(arrival);\\n      });\\n\\n      this._deepLinkScroll = function (e) {\\n        if (_this.options.deepLinking) {\\n          _this.scrollToLoc(window.location.hash);\\n        }\\n      };\\n\\n      __WEBPACK_IMPORTED_MODULE_0_jquery___default()(window).on('popstate', this._deepLinkScroll);\\n    }\\n\\n    /**\\n     * Function to scroll to a given location on the page.\\n     * @param {String} loc - a properly formatted jQuery id selector. Example: '#foo'\\n     * @function\\n     */\\n\\n  }, {\\n    key: 'scrollToLoc',\\n    value: function scrollToLoc(loc) {\\n      this._inTransition = true;\\n      var _this = this;\\n\\n      var options = {\\n        animationEasing: this.options.animationEasing,\\n        animationDuration: this.options.animationDuration,\\n        threshold: this.options.threshold,\\n        offset: this.options.offset\\n      };\\n\\n      __WEBPACK_IMPORTED_MODULE_3__foundation_smoothScroll__[\\\"a\\\" /* SmoothScroll */].scrollToLoc(loc, options, function () {\\n        _this._inTransition = false;\\n        _this._updateActive();\\n      });\\n    }\\n\\n    /**\\n     * Calls necessary functions to update Magellan upon DOM change\\n     * @function\\n     */\\n\\n  }, {\\n    key: 'reflow',\\n    value: function reflow() {\\n      this.calcPoints();\\n      this._updateActive();\\n    }\\n\\n    /**\\n     * Updates the visibility of an active location link, and updates the url hash for the page, if deepLinking enabled.\\n     * @private\\n     * @function\\n     * @fires Magellan#update\\n     */\\n\\n  }, {\\n    key: '_updateActive',\\n    value: function _updateActive() /*evt, elem, scrollPos*/{\\n      if (this._inTransition) {\\n        return;\\n      }\\n      var winPos = /*scrollPos ||*/parseInt(window.pageYOffset, 10),\\n          curIdx;\\n\\n      if (winPos + this.winHeight === this.docHeight) {\\n        curIdx = this.points.length - 1;\\n      } else if (winPos < this.points[0]) {\\n        curIdx = undefined;\\n      } else {\\n        var isDown = this.scrollPos < winPos,\\n            _this = this,\\n            curVisible = this.points.filter(function (p, i) {\\n          return isDown ? p - _this.options.offset <= winPos : p - _this.options.offset - _this.options.threshold <= winPos;\\n        });\\n        curIdx = curVisible.length ? curVisible.length - 1 : 0;\\n      }\\n\\n      this.$active.removeClass(this.options.activeClass);\\n      this.$active = this.$links.filter('[href=\\\"#' + this.$targets.eq(curIdx).data('magellan-target') + '\\\"]').addClass(this.options.activeClass);\\n\\n      if (this.options.deepLinking) {\\n        var hash = \\\"\\\";\\n        if (curIdx != undefined) {\\n          hash = this.$active[0].getAttribute('href');\\n        }\\n        if (hash !== window.location.hash) {\\n          if (window.history.pushState) {\\n            window.history.pushState(null, null, hash);\\n          } else {\\n            window.location.hash = hash;\\n          }\\n        }\\n      }\\n\\n      this.scrollPos = winPos;\\n      /**\\n       * Fires when magellan is finished updating to the new active element.\\n       * @event Magellan#update\\n       */\\n      this.$element.trigger('update.zf.magellan', [this.$active]);\\n    }\\n\\n    /**\\n     * Destroys an instance of Magellan and resets the url of the window.\\n     * @function\\n     */\\n\\n  }, {\\n    key: '_destroy',\\n    value: function _destroy() {\\n      this.$element.off('.zf.trigger .zf.magellan').find('.' + this.options.activeClass).removeClass(this.options.activeClass);\\n\\n      if (this.options.deepLinking) {\\n        var hash = this.$active[0].getAttribute('href');\\n        window.location.hash.replace(hash, '');\\n      }\\n      __WEBPACK_IMPORTED_MODULE_0_jquery___default()(window).off('popstate', this._deepLinkScroll);\\n    }\\n  }]);\\n\\n  return Magellan;\\n}(__WEBPACK_IMPORTED_MODULE_2__foundation_plugin__[\\\"a\\\" /* Plugin */]);\\n\\n/**\\n * Default settings for plugin\\n */\\n\\n\\nMagellan.defaults = {\\n  /**\\n   * Amount of time, in ms, the animated scrolling should take between locations.\\n   * @option\\n   * @type {number}\\n   * @default 500\\n   */\\n  animationDuration: 500,\\n  /**\\n   * Animation style to use when scrolling between locations. Can be `'swing'` or `'linear'`.\\n   * @option\\n   * @type {string}\\n   * @default 'linear'\\n   * @see {@link https://api.jquery.com/animate|Jquery animate}\\n   */\\n  animationEasing: 'linear',\\n  /**\\n   * Number of pixels to use as a marker for location changes.\\n   * @option\\n   * @type {number}\\n   * @default 50\\n   */\\n  threshold: 50,\\n  /**\\n   * Class applied to the active locations link on the magellan container.\\n   * @option\\n   * @type {string}\\n   * @default 'is-active'\\n   */\\n  activeClass: 'is-active',\\n  /**\\n   * Allows the script to manipulate the url of the current page, and if supported, alter the history.\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  deepLinking: false,\\n  /**\\n   * Number of pixels to offset the scroll of the page on item click if using a sticky nav bar.\\n   * @option\\n   * @type {number}\\n   * @default 0\\n   */\\n  offset: 0\\n};\\n\\n\\n\\n/***/ }),\\n/* 26 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return OffCanvas; });\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jquery__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__foundation_util_keyboard__ = __webpack_require__(3);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__foundation_util_mediaQuery__ = __webpack_require__(4);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__foundation_util_core__ = __webpack_require__(1);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__foundation_plugin__ = __webpack_require__(2);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__foundation_util_triggers__ = __webpack_require__(5);\\n\\n\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return call && (typeof call === \\\"object\\\" || typeof call === \\\"function\\\") ? call : self; }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function, not \\\" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n/**\\n * OffCanvas module.\\n * @module foundation.offcanvas\\n * @requires foundation.util.keyboard\\n * @requires foundation.util.mediaQuery\\n * @requires foundation.util.triggers\\n */\\n\\nvar OffCanvas = function (_Plugin) {\\n  _inherits(OffCanvas, _Plugin);\\n\\n  function OffCanvas() {\\n    _classCallCheck(this, OffCanvas);\\n\\n    return _possibleConstructorReturn(this, (OffCanvas.__proto__ || Object.getPrototypeOf(OffCanvas)).apply(this, arguments));\\n  }\\n\\n  _createClass(OffCanvas, [{\\n    key: '_setup',\\n\\n    /**\\n     * Creates a new instance of an off-canvas wrapper.\\n     * @class\\n     * @name OffCanvas\\n     * @fires OffCanvas#init\\n     * @param {Object} element - jQuery object to initialize.\\n     * @param {Object} options - Overrides to the default plugin settings.\\n     */\\n    value: function _setup(element, options) {\\n      var _this3 = this;\\n\\n      this.className = 'OffCanvas'; // ie9 back compat\\n      this.$element = element;\\n      this.options = __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.extend({}, OffCanvas.defaults, this.$element.data(), options);\\n      this.contentClasses = { base: [], reveal: [] };\\n      this.$lastTrigger = __WEBPACK_IMPORTED_MODULE_0_jquery___default()();\\n      this.$triggers = __WEBPACK_IMPORTED_MODULE_0_jquery___default()();\\n      this.position = 'left';\\n      this.$content = __WEBPACK_IMPORTED_MODULE_0_jquery___default()();\\n      this.nested = !!this.options.nested;\\n\\n      // Defines the CSS transition/position classes of the off-canvas content container.\\n      __WEBPACK_IMPORTED_MODULE_0_jquery___default()(['push', 'overlap']).each(function (index, val) {\\n        _this3.contentClasses.base.push('has-transition-' + val);\\n      });\\n      __WEBPACK_IMPORTED_MODULE_0_jquery___default()(['left', 'right', 'top', 'bottom']).each(function (index, val) {\\n        _this3.contentClasses.base.push('has-position-' + val);\\n        _this3.contentClasses.reveal.push('has-reveal-' + val);\\n      });\\n\\n      // Triggers init is idempotent, just need to make sure it is initialized\\n      __WEBPACK_IMPORTED_MODULE_5__foundation_util_triggers__[\\\"a\\\" /* Triggers */].init(__WEBPACK_IMPORTED_MODULE_0_jquery___default.a);\\n      __WEBPACK_IMPORTED_MODULE_2__foundation_util_mediaQuery__[\\\"a\\\" /* MediaQuery */]._init();\\n\\n      this._init();\\n      this._events();\\n\\n      __WEBPACK_IMPORTED_MODULE_1__foundation_util_keyboard__[\\\"a\\\" /* Keyboard */].register('OffCanvas', {\\n        'ESCAPE': 'close'\\n      });\\n    }\\n\\n    /**\\n     * Initializes the off-canvas wrapper by adding the exit overlay (if needed).\\n     * @function\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_init',\\n    value: function _init() {\\n      var id = this.$element.attr('id');\\n\\n      this.$element.attr('aria-hidden', 'true');\\n\\n      // Find off-canvas content, either by ID (if specified), by siblings or by closest selector (fallback)\\n      if (this.options.contentId) {\\n        this.$content = __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#' + this.options.contentId);\\n      } else if (this.$element.siblings('[data-off-canvas-content]').length) {\\n        this.$content = this.$element.siblings('[data-off-canvas-content]').first();\\n      } else {\\n        this.$content = this.$element.closest('[data-off-canvas-content]').first();\\n      }\\n\\n      if (!this.options.contentId) {\\n        // Assume that the off-canvas element is nested if it isn't a sibling of the content\\n        this.nested = this.$element.siblings('[data-off-canvas-content]').length === 0;\\n      } else if (this.options.contentId && this.options.nested === null) {\\n        // Warning if using content ID without setting the nested option\\n        // Once the element is nested it is required to work properly in this case\\n        console.warn('Remember to use the nested option if using the content ID option!');\\n      }\\n\\n      if (this.nested === true) {\\n        // Force transition overlap if nested\\n        this.options.transition = 'overlap';\\n        // Remove appropriate classes if already assigned in markup\\n        this.$element.removeClass('is-transition-push');\\n      }\\n\\n      this.$element.addClass('is-transition-' + this.options.transition + ' is-closed');\\n\\n      // Find triggers that affect this element and add aria-expanded to them\\n      this.$triggers = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(document).find('[data-open=\\\"' + id + '\\\"], [data-close=\\\"' + id + '\\\"], [data-toggle=\\\"' + id + '\\\"]').attr('aria-expanded', 'false').attr('aria-controls', id);\\n\\n      // Get position by checking for related CSS class\\n      this.position = this.$element.is('.position-left, .position-top, .position-right, .position-bottom') ? this.$element.attr('class').match(/position\\\\-(left|top|right|bottom)/)[1] : this.position;\\n\\n      // Add an overlay over the content if necessary\\n      if (this.options.contentOverlay === true) {\\n        var overlay = document.createElement('div');\\n        var overlayPosition = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this.$element).css(\\\"position\\\") === 'fixed' ? 'is-overlay-fixed' : 'is-overlay-absolute';\\n        overlay.setAttribute('class', 'js-off-canvas-overlay ' + overlayPosition);\\n        this.$overlay = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(overlay);\\n        if (overlayPosition === 'is-overlay-fixed') {\\n          __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this.$overlay).insertAfter(this.$element);\\n        } else {\\n          this.$content.append(this.$overlay);\\n        }\\n      }\\n\\n      this.options.isRevealed = this.options.isRevealed || new RegExp(this.options.revealClass, 'g').test(this.$element[0].className);\\n\\n      if (this.options.isRevealed === true) {\\n        this.options.revealOn = this.options.revealOn || this.$element[0].className.match(/(reveal-for-medium|reveal-for-large)/g)[0].split('-')[2];\\n        this._setMQChecker();\\n      }\\n\\n      if (this.options.transitionTime) {\\n        this.$element.css('transition-duration', this.options.transitionTime);\\n      }\\n\\n      // Initally remove all transition/position CSS classes from off-canvas content container.\\n      this._removeContentClasses();\\n    }\\n\\n    /**\\n     * Adds event handlers to the off-canvas wrapper and the exit overlay.\\n     * @function\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_events',\\n    value: function _events() {\\n      this.$element.off('.zf.trigger .zf.offcanvas').on({\\n        'open.zf.trigger': this.open.bind(this),\\n        'close.zf.trigger': this.close.bind(this),\\n        'toggle.zf.trigger': this.toggle.bind(this),\\n        'keydown.zf.offcanvas': this._handleKeyboard.bind(this)\\n      });\\n\\n      if (this.options.closeOnClick === true) {\\n        var $target = this.options.contentOverlay ? this.$overlay : this.$content;\\n        $target.on({ 'click.zf.offcanvas': this.close.bind(this) });\\n      }\\n    }\\n\\n    /**\\n     * Applies event listener for elements that will reveal at certain breakpoints.\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_setMQChecker',\\n    value: function _setMQChecker() {\\n      var _this = this;\\n\\n      __WEBPACK_IMPORTED_MODULE_0_jquery___default()(window).on('changed.zf.mediaquery', function () {\\n        if (__WEBPACK_IMPORTED_MODULE_2__foundation_util_mediaQuery__[\\\"a\\\" /* MediaQuery */].atLeast(_this.options.revealOn)) {\\n          _this.reveal(true);\\n        } else {\\n          _this.reveal(false);\\n        }\\n      }).one('load.zf.offcanvas', function () {\\n        if (__WEBPACK_IMPORTED_MODULE_2__foundation_util_mediaQuery__[\\\"a\\\" /* MediaQuery */].atLeast(_this.options.revealOn)) {\\n          _this.reveal(true);\\n        }\\n      });\\n    }\\n\\n    /**\\n     * Removes the CSS transition/position classes of the off-canvas content container.\\n     * Removing the classes is important when another off-canvas gets opened that uses the same content container.\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_removeContentClasses',\\n    value: function _removeContentClasses(hasReveal) {\\n      this.$content.removeClass(this.contentClasses.base.join(' '));\\n      if (hasReveal === true) {\\n        this.$content.removeClass(this.contentClasses.reveal.join(' '));\\n      }\\n    }\\n\\n    /**\\n     * Adds the CSS transition/position classes of the off-canvas content container, based on the opening off-canvas element.\\n     * Beforehand any transition/position class gets removed.\\n     * @param {Boolean} hasReveal - true if related off-canvas element is revealed.\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_addContentClasses',\\n    value: function _addContentClasses(hasReveal) {\\n      this._removeContentClasses();\\n      this.$content.addClass('has-transition-' + this.options.transition + ' has-position-' + this.position);\\n      if (hasReveal === true) {\\n        this.$content.addClass('has-reveal-' + this.position);\\n      }\\n    }\\n\\n    /**\\n     * Handles the revealing/hiding the off-canvas at breakpoints, not the same as open.\\n     * @param {Boolean} isRevealed - true if element should be revealed.\\n     * @function\\n     */\\n\\n  }, {\\n    key: 'reveal',\\n    value: function reveal(isRevealed) {\\n      if (isRevealed) {\\n        this.close();\\n        this.isRevealed = true;\\n        this.$element.attr('aria-hidden', 'false');\\n        this.$element.off('open.zf.trigger toggle.zf.trigger');\\n        this.$element.removeClass('is-closed');\\n      } else {\\n        this.isRevealed = false;\\n        this.$element.attr('aria-hidden', 'true');\\n        this.$element.off('open.zf.trigger toggle.zf.trigger').on({\\n          'open.zf.trigger': this.open.bind(this),\\n          'toggle.zf.trigger': this.toggle.bind(this)\\n        });\\n        this.$element.addClass('is-closed');\\n      }\\n      this._addContentClasses(isRevealed);\\n    }\\n\\n    /**\\n     * Stops scrolling of the body when offcanvas is open on mobile Safari and other troublesome browsers.\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_stopScrolling',\\n    value: function _stopScrolling(event) {\\n      return false;\\n    }\\n\\n    // Taken and adapted from http://stackoverflow.com/questions/16889447/prevent-full-page-scrolling-ios\\n    // Only really works for y, not sure how to extend to x or if we need to.\\n\\n  }, {\\n    key: '_recordScrollable',\\n    value: function _recordScrollable(event) {\\n      var elem = this; // called from event handler context with this as elem\\n\\n      // If the element is scrollable (content overflows), then...\\n      if (elem.scrollHeight !== elem.clientHeight) {\\n        // If we're at the top, scroll down one pixel to allow scrolling up\\n        if (elem.scrollTop === 0) {\\n          elem.scrollTop = 1;\\n        }\\n        // If we're at the bottom, scroll up one pixel to allow scrolling down\\n        if (elem.scrollTop === elem.scrollHeight - elem.clientHeight) {\\n          elem.scrollTop = elem.scrollHeight - elem.clientHeight - 1;\\n        }\\n      }\\n      elem.allowUp = elem.scrollTop > 0;\\n      elem.allowDown = elem.scrollTop < elem.scrollHeight - elem.clientHeight;\\n      elem.lastY = event.originalEvent.pageY;\\n    }\\n  }, {\\n    key: '_stopScrollPropagation',\\n    value: function _stopScrollPropagation(event) {\\n      var elem = this; // called from event handler context with this as elem\\n      var up = event.pageY < elem.lastY;\\n      var down = !up;\\n      elem.lastY = event.pageY;\\n\\n      if (up && elem.allowUp || down && elem.allowDown) {\\n        event.stopPropagation();\\n      } else {\\n        event.preventDefault();\\n      }\\n    }\\n\\n    /**\\n     * Opens the off-canvas menu.\\n     * @function\\n     * @param {Object} event - Event object passed from listener.\\n     * @param {jQuery} trigger - element that triggered the off-canvas to open.\\n     * @fires OffCanvas#opened\\n     */\\n\\n  }, {\\n    key: 'open',\\n    value: function open(event, trigger) {\\n      if (this.$element.hasClass('is-open') || this.isRevealed) {\\n        return;\\n      }\\n      var _this = this;\\n\\n      if (trigger) {\\n        this.$lastTrigger = trigger;\\n      }\\n\\n      if (this.options.forceTo === 'top') {\\n        window.scrollTo(0, 0);\\n      } else if (this.options.forceTo === 'bottom') {\\n        window.scrollTo(0, document.body.scrollHeight);\\n      }\\n\\n      if (this.options.transitionTime && this.options.transition !== 'overlap') {\\n        this.$element.siblings('[data-off-canvas-content]').css('transition-duration', this.options.transitionTime);\\n      } else {\\n        this.$element.siblings('[data-off-canvas-content]').css('transition-duration', '');\\n      }\\n\\n      /**\\n       * Fires when the off-canvas menu opens.\\n       * @event OffCanvas#opened\\n       */\\n      this.$element.addClass('is-open').removeClass('is-closed');\\n\\n      this.$triggers.attr('aria-expanded', 'true');\\n      this.$element.attr('aria-hidden', 'false').trigger('opened.zf.offcanvas');\\n\\n      this.$content.addClass('is-open-' + this.position);\\n\\n      // If `contentScroll` is set to false, add class and disable scrolling on touch devices.\\n      if (this.options.contentScroll === false) {\\n        __WEBPACK_IMPORTED_MODULE_0_jquery___default()('body').addClass('is-off-canvas-open').on('touchmove', this._stopScrolling);\\n        this.$element.on('touchstart', this._recordScrollable);\\n        this.$element.on('touchmove', this._stopScrollPropagation);\\n      }\\n\\n      if (this.options.contentOverlay === true) {\\n        this.$overlay.addClass('is-visible');\\n      }\\n\\n      if (this.options.closeOnClick === true && this.options.contentOverlay === true) {\\n        this.$overlay.addClass('is-closable');\\n      }\\n\\n      if (this.options.autoFocus === true) {\\n        this.$element.one(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__foundation_util_core__[\\\"c\\\" /* transitionend */])(this.$element), function () {\\n          if (!_this.$element.hasClass('is-open')) {\\n            return; // exit if prematurely closed\\n          }\\n          var canvasFocus = _this.$element.find('[data-autofocus]');\\n          if (canvasFocus.length) {\\n            canvasFocus.eq(0).focus();\\n          } else {\\n            _this.$element.find('a, button').eq(0).focus();\\n          }\\n        });\\n      }\\n\\n      if (this.options.trapFocus === true) {\\n        this.$content.attr('tabindex', '-1');\\n        __WEBPACK_IMPORTED_MODULE_1__foundation_util_keyboard__[\\\"a\\\" /* Keyboard */].trapFocus(this.$element);\\n      }\\n\\n      this._addContentClasses();\\n    }\\n\\n    /**\\n     * Closes the off-canvas menu.\\n     * @function\\n     * @param {Function} cb - optional cb to fire after closure.\\n     * @fires OffCanvas#closed\\n     */\\n\\n  }, {\\n    key: 'close',\\n    value: function close(cb) {\\n      if (!this.$element.hasClass('is-open') || this.isRevealed) {\\n        return;\\n      }\\n\\n      var _this = this;\\n\\n      this.$element.removeClass('is-open');\\n\\n      this.$element.attr('aria-hidden', 'true')\\n      /**\\n       * Fires when the off-canvas menu opens.\\n       * @event OffCanvas#closed\\n       */\\n      .trigger('closed.zf.offcanvas');\\n\\n      this.$content.removeClass('is-open-left is-open-top is-open-right is-open-bottom');\\n\\n      // If `contentScroll` is set to false, remove class and re-enable scrolling on touch devices.\\n      if (this.options.contentScroll === false) {\\n        __WEBPACK_IMPORTED_MODULE_0_jquery___default()('body').removeClass('is-off-canvas-open').off('touchmove', this._stopScrolling);\\n        this.$element.off('touchstart', this._recordScrollable);\\n        this.$element.off('touchmove', this._stopScrollPropagation);\\n      }\\n\\n      if (this.options.contentOverlay === true) {\\n        this.$overlay.removeClass('is-visible');\\n      }\\n\\n      if (this.options.closeOnClick === true && this.options.contentOverlay === true) {\\n        this.$overlay.removeClass('is-closable');\\n      }\\n\\n      this.$triggers.attr('aria-expanded', 'false');\\n\\n      if (this.options.trapFocus === true) {\\n        this.$content.removeAttr('tabindex');\\n        __WEBPACK_IMPORTED_MODULE_1__foundation_util_keyboard__[\\\"a\\\" /* Keyboard */].releaseFocus(this.$element);\\n      }\\n\\n      // Listen to transitionEnd and add class when done.\\n      this.$element.one(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__foundation_util_core__[\\\"c\\\" /* transitionend */])(this.$element), function (e) {\\n        _this.$element.addClass('is-closed');\\n        _this._removeContentClasses();\\n      });\\n    }\\n\\n    /**\\n     * Toggles the off-canvas menu open or closed.\\n     * @function\\n     * @param {Object} event - Event object passed from listener.\\n     * @param {jQuery} trigger - element that triggered the off-canvas to open.\\n     */\\n\\n  }, {\\n    key: 'toggle',\\n    value: function toggle(event, trigger) {\\n      if (this.$element.hasClass('is-open')) {\\n        this.close(event, trigger);\\n      } else {\\n        this.open(event, trigger);\\n      }\\n    }\\n\\n    /**\\n     * Handles keyboard input when detected. When the escape key is pressed, the off-canvas menu closes, and focus is restored to the element that opened the menu.\\n     * @function\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_handleKeyboard',\\n    value: function _handleKeyboard(e) {\\n      var _this4 = this;\\n\\n      __WEBPACK_IMPORTED_MODULE_1__foundation_util_keyboard__[\\\"a\\\" /* Keyboard */].handleKey(e, 'OffCanvas', {\\n        close: function () {\\n          _this4.close();\\n          _this4.$lastTrigger.focus();\\n          return true;\\n        },\\n        handled: function () {\\n          e.stopPropagation();\\n          e.preventDefault();\\n        }\\n      });\\n    }\\n\\n    /**\\n     * Destroys the offcanvas plugin.\\n     * @function\\n     */\\n\\n  }, {\\n    key: '_destroy',\\n    value: function _destroy() {\\n      this.close();\\n      this.$element.off('.zf.trigger .zf.offcanvas');\\n      this.$overlay.off('.zf.offcanvas');\\n    }\\n  }]);\\n\\n  return OffCanvas;\\n}(__WEBPACK_IMPORTED_MODULE_4__foundation_plugin__[\\\"a\\\" /* Plugin */]);\\n\\nOffCanvas.defaults = {\\n  /**\\n   * Allow the user to click outside of the menu to close it.\\n   * @option\\n   * @type {boolean}\\n   * @default true\\n   */\\n  closeOnClick: true,\\n\\n  /**\\n   * Adds an overlay on top of `[data-off-canvas-content]`.\\n   * @option\\n   * @type {boolean}\\n   * @default true\\n   */\\n  contentOverlay: true,\\n\\n  /**\\n   * Target an off-canvas content container by ID that may be placed anywhere. If null the closest content container will be taken.\\n   * @option\\n   * @type {?string}\\n   * @default null\\n   */\\n  contentId: null,\\n\\n  /**\\n   * Define the off-canvas element is nested in an off-canvas content. This is required when using the contentId option for a nested element.\\n   * @option\\n   * @type {boolean}\\n   * @default null\\n   */\\n  nested: null,\\n\\n  /**\\n   * Enable/disable scrolling of the main content when an off canvas panel is open.\\n   * @option\\n   * @type {boolean}\\n   * @default true\\n   */\\n  contentScroll: true,\\n\\n  /**\\n   * Amount of time in ms the open and close transition requires. If none selected, pulls from body style.\\n   * @option\\n   * @type {number}\\n   * @default null\\n   */\\n  transitionTime: null,\\n\\n  /**\\n   * Type of transition for the offcanvas menu. Options are 'push', 'detached' or 'slide'.\\n   * @option\\n   * @type {string}\\n   * @default push\\n   */\\n  transition: 'push',\\n\\n  /**\\n   * Force the page to scroll to top or bottom on open.\\n   * @option\\n   * @type {?string}\\n   * @default null\\n   */\\n  forceTo: null,\\n\\n  /**\\n   * Allow the offcanvas to remain open for certain breakpoints.\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  isRevealed: false,\\n\\n  /**\\n   * Breakpoint at which to reveal. JS will use a RegExp to target standard classes, if changing classnames, pass your class with the `revealClass` option.\\n   * @option\\n   * @type {?string}\\n   * @default null\\n   */\\n  revealOn: null,\\n\\n  /**\\n   * Force focus to the offcanvas on open. If true, will focus the opening trigger on close.\\n   * @option\\n   * @type {boolean}\\n   * @default true\\n   */\\n  autoFocus: true,\\n\\n  /**\\n   * Class used to force an offcanvas to remain open. Foundation defaults for this are `reveal-for-large` & `reveal-for-medium`.\\n   * @option\\n   * @type {string}\\n   * @default reveal-for-\\n   * @todo improve the regex testing for this.\\n   */\\n  revealClass: 'reveal-for-',\\n\\n  /**\\n   * Triggers optional focus trapping when opening an offcanvas. Sets tabindex of [data-off-canvas-content] to -1 for accessibility purposes.\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  trapFocus: false\\n};\\n\\n\\n\\n/***/ }),\\n/* 27 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return Orbit; });\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jquery__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__foundation_util_keyboard__ = __webpack_require__(3);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__foundation_util_motion__ = __webpack_require__(6);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__foundation_util_timer__ = __webpack_require__(18);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__foundation_util_imageLoader__ = __webpack_require__(8);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__foundation_util_core__ = __webpack_require__(1);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__foundation_plugin__ = __webpack_require__(2);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__foundation_util_touch__ = __webpack_require__(10);\\n\\n\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return call && (typeof call === \\\"object\\\" || typeof call === \\\"function\\\") ? call : self; }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function, not \\\" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n/**\\n * Orbit module.\\n * @module foundation.orbit\\n * @requires foundation.util.keyboard\\n * @requires foundation.util.motion\\n * @requires foundation.util.timer\\n * @requires foundation.util.imageLoader\\n * @requires foundation.util.touch\\n */\\n\\nvar Orbit = function (_Plugin) {\\n  _inherits(Orbit, _Plugin);\\n\\n  function Orbit() {\\n    _classCallCheck(this, Orbit);\\n\\n    return _possibleConstructorReturn(this, (Orbit.__proto__ || Object.getPrototypeOf(Orbit)).apply(this, arguments));\\n  }\\n\\n  _createClass(Orbit, [{\\n    key: '_setup',\\n\\n    /**\\n    * Creates a new instance of an orbit carousel.\\n    * @class\\n    * @name Orbit\\n    * @param {jQuery} element - jQuery object to make into an Orbit Carousel.\\n    * @param {Object} options - Overrides to the default plugin settings.\\n    */\\n    value: function _setup(element, options) {\\n      this.$element = element;\\n      this.options = __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.extend({}, Orbit.defaults, this.$element.data(), options);\\n      this.className = 'Orbit'; // ie9 back compat\\n\\n      __WEBPACK_IMPORTED_MODULE_7__foundation_util_touch__[\\\"a\\\" /* Touch */].init(__WEBPACK_IMPORTED_MODULE_0_jquery___default.a); // Touch init is idempotent, we just need to make sure it's initialied.\\n\\n      this._init();\\n\\n      __WEBPACK_IMPORTED_MODULE_1__foundation_util_keyboard__[\\\"a\\\" /* Keyboard */].register('Orbit', {\\n        'ltr': {\\n          'ARROW_RIGHT': 'next',\\n          'ARROW_LEFT': 'previous'\\n        },\\n        'rtl': {\\n          'ARROW_LEFT': 'next',\\n          'ARROW_RIGHT': 'previous'\\n        }\\n      });\\n    }\\n\\n    /**\\n    * Initializes the plugin by creating jQuery collections, setting attributes, and starting the animation.\\n    * @function\\n    * @private\\n    */\\n\\n  }, {\\n    key: '_init',\\n    value: function _init() {\\n      // @TODO: consider discussion on PR #9278 about DOM pollution by changeSlide\\n      this._reset();\\n\\n      this.$wrapper = this.$element.find('.' + this.options.containerClass);\\n      this.$slides = this.$element.find('.' + this.options.slideClass);\\n\\n      var $images = this.$element.find('img'),\\n          initActive = this.$slides.filter('.is-active'),\\n          id = this.$element[0].id || __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__foundation_util_core__[\\\"b\\\" /* GetYoDigits */])(6, 'orbit');\\n\\n      this.$element.attr({\\n        'data-resize': id,\\n        'id': id\\n      });\\n\\n      if (!initActive.length) {\\n        this.$slides.eq(0).addClass('is-active');\\n      }\\n\\n      if (!this.options.useMUI) {\\n        this.$slides.addClass('no-motionui');\\n      }\\n\\n      if ($images.length) {\\n        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__foundation_util_imageLoader__[\\\"a\\\" /* onImagesLoaded */])($images, this._prepareForOrbit.bind(this));\\n      } else {\\n        this._prepareForOrbit(); //hehe\\n      }\\n\\n      if (this.options.bullets) {\\n        this._loadBullets();\\n      }\\n\\n      this._events();\\n\\n      if (this.options.autoPlay && this.$slides.length > 1) {\\n        this.geoSync();\\n      }\\n\\n      if (this.options.accessible) {\\n        // allow wrapper to be focusable to enable arrow navigation\\n        this.$wrapper.attr('tabindex', 0);\\n      }\\n    }\\n\\n    /**\\n    * Creates a jQuery collection of bullets, if they are being used.\\n    * @function\\n    * @private\\n    */\\n\\n  }, {\\n    key: '_loadBullets',\\n    value: function _loadBullets() {\\n      this.$bullets = this.$element.find('.' + this.options.boxOfBullets).find('button');\\n    }\\n\\n    /**\\n    * Sets a `timer` object on the orbit, and starts the counter for the next slide.\\n    * @function\\n    */\\n\\n  }, {\\n    key: 'geoSync',\\n    value: function geoSync() {\\n      var _this = this;\\n      this.timer = new __WEBPACK_IMPORTED_MODULE_3__foundation_util_timer__[\\\"a\\\" /* Timer */](this.$element, {\\n        duration: this.options.timerDelay,\\n        infinite: false\\n      }, function () {\\n        _this.changeSlide(true);\\n      });\\n      this.timer.start();\\n    }\\n\\n    /**\\n    * Sets wrapper and slide heights for the orbit.\\n    * @function\\n    * @private\\n    */\\n\\n  }, {\\n    key: '_prepareForOrbit',\\n    value: function _prepareForOrbit() {\\n      var _this = this;\\n      this._setWrapperHeight();\\n    }\\n\\n    /**\\n    * Calulates the height of each slide in the collection, and uses the tallest one for the wrapper height.\\n    * @function\\n    * @private\\n    * @param {Function} cb - a callback function to fire when complete.\\n    */\\n\\n  }, {\\n    key: '_setWrapperHeight',\\n    value: function _setWrapperHeight(cb) {\\n      //rewrite this to `for` loop\\n      var max = 0,\\n          temp,\\n          counter = 0,\\n          _this = this;\\n\\n      this.$slides.each(function () {\\n        temp = this.getBoundingClientRect().height;\\n        __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).attr('data-slide', counter);\\n\\n        if (_this.$slides.filter('.is-active')[0] !== _this.$slides.eq(counter)[0]) {\\n          //if not the active slide, set css position and display property\\n          __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).css({ 'position': 'relative', 'display': 'none' });\\n        }\\n        max = temp > max ? temp : max;\\n        counter++;\\n      });\\n\\n      if (counter === this.$slides.length) {\\n        this.$wrapper.css({ 'height': max }); //only change the wrapper height property once.\\n        if (cb) {\\n          cb(max);\\n        } //fire callback with max height dimension.\\n      }\\n    }\\n\\n    /**\\n    * Sets the max-height of each slide.\\n    * @function\\n    * @private\\n    */\\n\\n  }, {\\n    key: '_setSlideHeight',\\n    value: function _setSlideHeight(height) {\\n      this.$slides.each(function () {\\n        __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).css('max-height', height);\\n      });\\n    }\\n\\n    /**\\n    * Adds event listeners to basically everything within the element.\\n    * @function\\n    * @private\\n    */\\n\\n  }, {\\n    key: '_events',\\n    value: function _events() {\\n      var _this = this;\\n\\n      //***************************************\\n      //**Now using custom event - thanks to:**\\n      //**      Yohai Ararat of Toronto      **\\n      //***************************************\\n      //\\n      this.$element.off('.resizeme.zf.trigger').on({\\n        'resizeme.zf.trigger': this._prepareForOrbit.bind(this)\\n      });\\n      if (this.$slides.length > 1) {\\n\\n        if (this.options.swipe) {\\n          this.$slides.off('swipeleft.zf.orbit swiperight.zf.orbit').on('swipeleft.zf.orbit', function (e) {\\n            e.preventDefault();\\n            _this.changeSlide(true);\\n          }).on('swiperight.zf.orbit', function (e) {\\n            e.preventDefault();\\n            _this.changeSlide(false);\\n          });\\n        }\\n        //***************************************\\n\\n        if (this.options.autoPlay) {\\n          this.$slides.on('click.zf.orbit', function () {\\n            _this.$element.data('clickedOn', _this.$element.data('clickedOn') ? false : true);\\n            _this.timer[_this.$element.data('clickedOn') ? 'pause' : 'start']();\\n          });\\n\\n          if (this.options.pauseOnHover) {\\n            this.$element.on('mouseenter.zf.orbit', function () {\\n              _this.timer.pause();\\n            }).on('mouseleave.zf.orbit', function () {\\n              if (!_this.$element.data('clickedOn')) {\\n                _this.timer.start();\\n              }\\n            });\\n          }\\n        }\\n\\n        if (this.options.navButtons) {\\n          var $controls = this.$element.find('.' + this.options.nextClass + ', .' + this.options.prevClass);\\n          $controls.attr('tabindex', 0)\\n          //also need to handle enter/return and spacebar key presses\\n          .on('click.zf.orbit touchend.zf.orbit', function (e) {\\n            e.preventDefault();\\n            _this.changeSlide(__WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).hasClass(_this.options.nextClass));\\n          });\\n        }\\n\\n        if (this.options.bullets) {\\n          this.$bullets.on('click.zf.orbit touchend.zf.orbit', function () {\\n            if (/is-active/g.test(this.className)) {\\n              return false;\\n            } //if this is active, kick out of function.\\n            var idx = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).data('slide'),\\n                ltr = idx > _this.$slides.filter('.is-active').data('slide'),\\n                $slide = _this.$slides.eq(idx);\\n\\n            _this.changeSlide(ltr, $slide, idx);\\n          });\\n        }\\n\\n        if (this.options.accessible) {\\n          this.$wrapper.add(this.$bullets).on('keydown.zf.orbit', function (e) {\\n            // handle keyboard event with keyboard util\\n            __WEBPACK_IMPORTED_MODULE_1__foundation_util_keyboard__[\\\"a\\\" /* Keyboard */].handleKey(e, 'Orbit', {\\n              next: function () {\\n                _this.changeSlide(true);\\n              },\\n              previous: function () {\\n                _this.changeSlide(false);\\n              },\\n              handled: function () {\\n                // if bullet is focused, make sure focus moves\\n                if (__WEBPACK_IMPORTED_MODULE_0_jquery___default()(e.target).is(_this.$bullets)) {\\n                  _this.$bullets.filter('.is-active').focus();\\n                }\\n              }\\n            });\\n          });\\n        }\\n      }\\n    }\\n\\n    /**\\n     * Resets Orbit so it can be reinitialized\\n     */\\n\\n  }, {\\n    key: '_reset',\\n    value: function _reset() {\\n      // Don't do anything if there are no slides (first run)\\n      if (typeof this.$slides == 'undefined') {\\n        return;\\n      }\\n\\n      if (this.$slides.length > 1) {\\n        // Remove old events\\n        this.$element.off('.zf.orbit').find('*').off('.zf.orbit');\\n\\n        // Restart timer if autoPlay is enabled\\n        if (this.options.autoPlay) {\\n          this.timer.restart();\\n        }\\n\\n        // Reset all sliddes\\n        this.$slides.each(function (el) {\\n          __WEBPACK_IMPORTED_MODULE_0_jquery___default()(el).removeClass('is-active is-active is-in').removeAttr('aria-live').hide();\\n        });\\n\\n        // Show the first slide\\n        this.$slides.first().addClass('is-active').show();\\n\\n        // Triggers when the slide has finished animating\\n        this.$element.trigger('slidechange.zf.orbit', [this.$slides.first()]);\\n\\n        // Select first bullet if bullets are present\\n        if (this.options.bullets) {\\n          this._updateBullets(0);\\n        }\\n      }\\n    }\\n\\n    /**\\n    * Changes the current slide to a new one.\\n    * @function\\n    * @param {Boolean} isLTR - flag if the slide should move left to right.\\n    * @param {jQuery} chosenSlide - the jQuery element of the slide to show next, if one is selected.\\n    * @param {Number} idx - the index of the new slide in its collection, if one chosen.\\n    * @fires Orbit#slidechange\\n    */\\n\\n  }, {\\n    key: 'changeSlide',\\n    value: function changeSlide(isLTR, chosenSlide, idx) {\\n      if (!this.$slides) {\\n        return;\\n      } // Don't freak out if we're in the middle of cleanup\\n      var $curSlide = this.$slides.filter('.is-active').eq(0);\\n\\n      if (/mui/g.test($curSlide[0].className)) {\\n        return false;\\n      } //if the slide is currently animating, kick out of the function\\n\\n      var $firstSlide = this.$slides.first(),\\n          $lastSlide = this.$slides.last(),\\n          dirIn = isLTR ? 'Right' : 'Left',\\n          dirOut = isLTR ? 'Left' : 'Right',\\n          _this = this,\\n          $newSlide;\\n\\n      if (!chosenSlide) {\\n        //most of the time, this will be auto played or clicked from the navButtons.\\n        $newSlide = isLTR ? //if wrapping enabled, check to see if there is a `next` or `prev` sibling, if not, select the first or last slide to fill in. if wrapping not enabled, attempt to select `next` or `prev`, if there's nothing there, the function will kick out on next step. CRAZY NESTED TERNARIES!!!!!\\n        this.options.infiniteWrap ? $curSlide.next('.' + this.options.slideClass).length ? $curSlide.next('.' + this.options.slideClass) : $firstSlide : $curSlide.next('.' + this.options.slideClass) : //pick next slide if moving left to right\\n        this.options.infiniteWrap ? $curSlide.prev('.' + this.options.slideClass).length ? $curSlide.prev('.' + this.options.slideClass) : $lastSlide : $curSlide.prev('.' + this.options.slideClass); //pick prev slide if moving right to left\\n      } else {\\n        $newSlide = chosenSlide;\\n      }\\n\\n      if ($newSlide.length) {\\n        /**\\n        * Triggers before the next slide starts animating in and only if a next slide has been found.\\n        * @event Orbit#beforeslidechange\\n        */\\n        this.$element.trigger('beforeslidechange.zf.orbit', [$curSlide, $newSlide]);\\n\\n        if (this.options.bullets) {\\n          idx = idx || this.$slides.index($newSlide); //grab index to update bullets\\n          this._updateBullets(idx);\\n        }\\n\\n        if (this.options.useMUI && !this.$element.is(':hidden')) {\\n          __WEBPACK_IMPORTED_MODULE_2__foundation_util_motion__[\\\"a\\\" /* Motion */].animateIn($newSlide.addClass('is-active').css({ 'position': 'absolute', 'top': 0 }), this.options['animInFrom' + dirIn], function () {\\n            $newSlide.css({ 'position': 'relative', 'display': 'block' }).attr('aria-live', 'polite');\\n          });\\n\\n          __WEBPACK_IMPORTED_MODULE_2__foundation_util_motion__[\\\"a\\\" /* Motion */].animateOut($curSlide.removeClass('is-active'), this.options['animOutTo' + dirOut], function () {\\n            $curSlide.removeAttr('aria-live');\\n            if (_this.options.autoPlay && !_this.timer.isPaused) {\\n              _this.timer.restart();\\n            }\\n            //do stuff?\\n          });\\n        } else {\\n          $curSlide.removeClass('is-active is-in').removeAttr('aria-live').hide();\\n          $newSlide.addClass('is-active is-in').attr('aria-live', 'polite').show();\\n          if (this.options.autoPlay && !this.timer.isPaused) {\\n            this.timer.restart();\\n          }\\n        }\\n        /**\\n        * Triggers when the slide has finished animating in.\\n        * @event Orbit#slidechange\\n        */\\n        this.$element.trigger('slidechange.zf.orbit', [$newSlide]);\\n      }\\n    }\\n\\n    /**\\n    * Updates the active state of the bullets, if displayed.\\n    * @function\\n    * @private\\n    * @param {Number} idx - the index of the current slide.\\n    */\\n\\n  }, {\\n    key: '_updateBullets',\\n    value: function _updateBullets(idx) {\\n      var $oldBullet = this.$element.find('.' + this.options.boxOfBullets).find('.is-active').removeClass('is-active').blur(),\\n          span = $oldBullet.find('span:last').detach(),\\n          $newBullet = this.$bullets.eq(idx).addClass('is-active').append(span);\\n    }\\n\\n    /**\\n    * Destroys the carousel and hides the element.\\n    * @function\\n    */\\n\\n  }, {\\n    key: '_destroy',\\n    value: function _destroy() {\\n      this.$element.off('.zf.orbit').find('*').off('.zf.orbit').end().hide();\\n    }\\n  }]);\\n\\n  return Orbit;\\n}(__WEBPACK_IMPORTED_MODULE_6__foundation_plugin__[\\\"a\\\" /* Plugin */]);\\n\\nOrbit.defaults = {\\n  /**\\n  * Tells the JS to look for and loadBullets.\\n  * @option\\n   * @type {boolean}\\n  * @default true\\n  */\\n  bullets: true,\\n  /**\\n  * Tells the JS to apply event listeners to nav buttons\\n  * @option\\n   * @type {boolean}\\n  * @default true\\n  */\\n  navButtons: true,\\n  /**\\n  * motion-ui animation class to apply\\n  * @option\\n   * @type {string}\\n  * @default 'slide-in-right'\\n  */\\n  animInFromRight: 'slide-in-right',\\n  /**\\n  * motion-ui animation class to apply\\n  * @option\\n   * @type {string}\\n  * @default 'slide-out-right'\\n  */\\n  animOutToRight: 'slide-out-right',\\n  /**\\n  * motion-ui animation class to apply\\n  * @option\\n   * @type {string}\\n  * @default 'slide-in-left'\\n  *\\n  */\\n  animInFromLeft: 'slide-in-left',\\n  /**\\n  * motion-ui animation class to apply\\n  * @option\\n   * @type {string}\\n  * @default 'slide-out-left'\\n  */\\n  animOutToLeft: 'slide-out-left',\\n  /**\\n  * Allows Orbit to automatically animate on page load.\\n  * @option\\n   * @type {boolean}\\n  * @default true\\n  */\\n  autoPlay: true,\\n  /**\\n  * Amount of time, in ms, between slide transitions\\n  * @option\\n   * @type {number}\\n  * @default 5000\\n  */\\n  timerDelay: 5000,\\n  /**\\n  * Allows Orbit to infinitely loop through the slides\\n  * @option\\n   * @type {boolean}\\n  * @default true\\n  */\\n  infiniteWrap: true,\\n  /**\\n  * Allows the Orbit slides to bind to swipe events for mobile, requires an additional util library\\n  * @option\\n   * @type {boolean}\\n  * @default true\\n  */\\n  swipe: true,\\n  /**\\n  * Allows the timing function to pause animation on hover.\\n  * @option\\n   * @type {boolean}\\n  * @default true\\n  */\\n  pauseOnHover: true,\\n  /**\\n  * Allows Orbit to bind keyboard events to the slider, to animate frames with arrow keys\\n  * @option\\n   * @type {boolean}\\n  * @default true\\n  */\\n  accessible: true,\\n  /**\\n  * Class applied to the container of Orbit\\n  * @option\\n   * @type {string}\\n  * @default 'orbit-container'\\n  */\\n  containerClass: 'orbit-container',\\n  /**\\n  * Class applied to individual slides.\\n  * @option\\n   * @type {string}\\n  * @default 'orbit-slide'\\n  */\\n  slideClass: 'orbit-slide',\\n  /**\\n  * Class applied to the bullet container. You're welcome.\\n  * @option\\n   * @type {string}\\n  * @default 'orbit-bullets'\\n  */\\n  boxOfBullets: 'orbit-bullets',\\n  /**\\n  * Class applied to the `next` navigation button.\\n  * @option\\n   * @type {string}\\n  * @default 'orbit-next'\\n  */\\n  nextClass: 'orbit-next',\\n  /**\\n  * Class applied to the `previous` navigation button.\\n  * @option\\n   * @type {string}\\n  * @default 'orbit-previous'\\n  */\\n  prevClass: 'orbit-previous',\\n  /**\\n  * Boolean to flag the js to use motion ui classes or not. Default to true for backwards compatability.\\n  * @option\\n   * @type {boolean}\\n  * @default true\\n  */\\n  useMUI: true\\n};\\n\\n\\n\\n/***/ }),\\n/* 28 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return ResponsiveAccordionTabs; });\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jquery__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__foundation_util_mediaQuery__ = __webpack_require__(4);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__foundation_util_core__ = __webpack_require__(1);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__foundation_plugin__ = __webpack_require__(2);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__foundation_accordion__ = __webpack_require__(11);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__foundation_tabs__ = __webpack_require__(17);\\n\\n\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return call && (typeof call === \\\"object\\\" || typeof call === \\\"function\\\") ? call : self; }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function, not \\\" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n// The plugin matches the plugin classes with these plugin instances.\\nvar MenuPlugins = {\\n  tabs: {\\n    cssClass: 'tabs',\\n    plugin: __WEBPACK_IMPORTED_MODULE_5__foundation_tabs__[\\\"a\\\" /* Tabs */]\\n  },\\n  accordion: {\\n    cssClass: 'accordion',\\n    plugin: __WEBPACK_IMPORTED_MODULE_4__foundation_accordion__[\\\"a\\\" /* Accordion */]\\n  }\\n};\\n\\n/**\\n * ResponsiveAccordionTabs module.\\n * @module foundation.responsiveAccordionTabs\\n * @requires foundation.util.motion\\n * @requires foundation.accordion\\n * @requires foundation.tabs\\n */\\n\\nvar ResponsiveAccordionTabs = function (_Plugin) {\\n  _inherits(ResponsiveAccordionTabs, _Plugin);\\n\\n  function ResponsiveAccordionTabs() {\\n    _classCallCheck(this, ResponsiveAccordionTabs);\\n\\n    return _possibleConstructorReturn(this, (ResponsiveAccordionTabs.__proto__ || Object.getPrototypeOf(ResponsiveAccordionTabs)).apply(this, arguments));\\n  }\\n\\n  _createClass(ResponsiveAccordionTabs, [{\\n    key: '_setup',\\n\\n    /**\\n     * Creates a new instance of a responsive accordion tabs.\\n     * @class\\n     * @name ResponsiveAccordionTabs\\n     * @fires ResponsiveAccordionTabs#init\\n     * @param {jQuery} element - jQuery object to make into Responsive Accordion Tabs.\\n     * @param {Object} options - Overrides to the default plugin settings.\\n     */\\n    value: function _setup(element, options) {\\n      this.$element = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(element);\\n      this.options = __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.extend({}, this.$element.data(), options);\\n      this.rules = this.$element.data('responsive-accordion-tabs');\\n      this.currentMq = null;\\n      this.currentPlugin = null;\\n      this.className = 'ResponsiveAccordionTabs'; // ie9 back compat\\n      if (!this.$element.attr('id')) {\\n        this.$element.attr('id', __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__foundation_util_core__[\\\"b\\\" /* GetYoDigits */])(6, 'responsiveaccordiontabs'));\\n      };\\n\\n      this._init();\\n      this._events();\\n    }\\n\\n    /**\\n     * Initializes the Menu by parsing the classes from the 'data-responsive-accordion-tabs' attribute on the element.\\n     * @function\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_init',\\n    value: function _init() {\\n      __WEBPACK_IMPORTED_MODULE_1__foundation_util_mediaQuery__[\\\"a\\\" /* MediaQuery */]._init();\\n\\n      // The first time an Interchange plugin is initialized, this.rules is converted from a string of \\\"classes\\\" to an object of rules\\n      if (typeof this.rules === 'string') {\\n        var rulesTree = {};\\n\\n        // Parse rules from \\\"classes\\\" pulled from data attribute\\n        var rules = this.rules.split(' ');\\n\\n        // Iterate through every rule found\\n        for (var i = 0; i < rules.length; i++) {\\n          var rule = rules[i].split('-');\\n          var ruleSize = rule.length > 1 ? rule[0] : 'small';\\n          var rulePlugin = rule.length > 1 ? rule[1] : rule[0];\\n\\n          if (MenuPlugins[rulePlugin] !== null) {\\n            rulesTree[ruleSize] = MenuPlugins[rulePlugin];\\n          }\\n        }\\n\\n        this.rules = rulesTree;\\n      }\\n\\n      this._getAllOptions();\\n\\n      if (!__WEBPACK_IMPORTED_MODULE_0_jquery___default.a.isEmptyObject(this.rules)) {\\n        this._checkMediaQueries();\\n      }\\n    }\\n  }, {\\n    key: '_getAllOptions',\\n    value: function _getAllOptions() {\\n      //get all defaults and options\\n      var _this = this;\\n      _this.allOptions = {};\\n      for (var key in MenuPlugins) {\\n        if (MenuPlugins.hasOwnProperty(key)) {\\n          var obj = MenuPlugins[key];\\n          try {\\n            var dummyPlugin = __WEBPACK_IMPORTED_MODULE_0_jquery___default()('<ul></ul>');\\n            var tmpPlugin = new obj.plugin(dummyPlugin, _this.options);\\n            for (var keyKey in tmpPlugin.options) {\\n              if (tmpPlugin.options.hasOwnProperty(keyKey) && keyKey !== 'zfPlugin') {\\n                var objObj = tmpPlugin.options[keyKey];\\n                _this.allOptions[keyKey] = objObj;\\n              }\\n            }\\n            tmpPlugin.destroy();\\n          } catch (e) {}\\n        }\\n      }\\n    }\\n\\n    /**\\n     * Initializes events for the Menu.\\n     * @function\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_events',\\n    value: function _events() {\\n      var _this = this;\\n\\n      __WEBPACK_IMPORTED_MODULE_0_jquery___default()(window).on('changed.zf.mediaquery', function () {\\n        _this._checkMediaQueries();\\n      });\\n    }\\n\\n    /**\\n     * Checks the current screen width against available media queries. If the media query has changed, and the plugin needed has changed, the plugins will swap out.\\n     * @function\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_checkMediaQueries',\\n    value: function _checkMediaQueries() {\\n      var matchedMq,\\n          _this = this;\\n      // Iterate through each rule and find the last matching rule\\n      __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.each(this.rules, function (key) {\\n        if (__WEBPACK_IMPORTED_MODULE_1__foundation_util_mediaQuery__[\\\"a\\\" /* MediaQuery */].atLeast(key)) {\\n          matchedMq = key;\\n        }\\n      });\\n\\n      // No match? No dice\\n      if (!matchedMq) return;\\n\\n      // Plugin already initialized? We good\\n      if (this.currentPlugin instanceof this.rules[matchedMq].plugin) return;\\n\\n      // Remove existing plugin-specific CSS classes\\n      __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.each(MenuPlugins, function (key, value) {\\n        _this.$element.removeClass(value.cssClass);\\n      });\\n\\n      // Add the CSS class for the new plugin\\n      this.$element.addClass(this.rules[matchedMq].cssClass);\\n\\n      // Create an instance of the new plugin\\n      if (this.currentPlugin) {\\n        //don't know why but on nested elements data zfPlugin get's lost\\n        if (!this.currentPlugin.$element.data('zfPlugin') && this.storezfData) this.currentPlugin.$element.data('zfPlugin', this.storezfData);\\n        this.currentPlugin.destroy();\\n      }\\n      this._handleMarkup(this.rules[matchedMq].cssClass);\\n      this.currentPlugin = new this.rules[matchedMq].plugin(this.$element, {});\\n      this.storezfData = this.currentPlugin.$element.data('zfPlugin');\\n    }\\n  }, {\\n    key: '_handleMarkup',\\n    value: function _handleMarkup(toSet) {\\n      var _this = this,\\n          fromString = 'accordion';\\n      var $panels = __WEBPACK_IMPORTED_MODULE_0_jquery___default()('[data-tabs-content=' + this.$element.attr('id') + ']');\\n      if ($panels.length) fromString = 'tabs';\\n      if (fromString === toSet) {\\n        return;\\n      };\\n\\n      var tabsTitle = _this.allOptions.linkClass ? _this.allOptions.linkClass : 'tabs-title';\\n      var tabsPanel = _this.allOptions.panelClass ? _this.allOptions.panelClass : 'tabs-panel';\\n\\n      this.$element.removeAttr('role');\\n      var $liHeads = this.$element.children('.' + tabsTitle + ',[data-accordion-item]').removeClass(tabsTitle).removeClass('accordion-item').removeAttr('data-accordion-item');\\n      var $liHeadsA = $liHeads.children('a').removeClass('accordion-title');\\n\\n      if (fromString === 'tabs') {\\n        $panels = $panels.children('.' + tabsPanel).removeClass(tabsPanel).removeAttr('role').removeAttr('aria-hidden').removeAttr('aria-labelledby');\\n        $panels.children('a').removeAttr('role').removeAttr('aria-controls').removeAttr('aria-selected');\\n      } else {\\n        $panels = $liHeads.children('[data-tab-content]').removeClass('accordion-content');\\n      };\\n\\n      $panels.css({ display: '', visibility: '' });\\n      $liHeads.css({ display: '', visibility: '' });\\n      if (toSet === 'accordion') {\\n        $panels.each(function (key, value) {\\n          __WEBPACK_IMPORTED_MODULE_0_jquery___default()(value).appendTo($liHeads.get(key)).addClass('accordion-content').attr('data-tab-content', '').removeClass('is-active').css({ height: '' });\\n          __WEBPACK_IMPORTED_MODULE_0_jquery___default()('[data-tabs-content=' + _this.$element.attr('id') + ']').after('<div id=\\\"tabs-placeholder-' + _this.$element.attr('id') + '\\\"></div>').detach();\\n          $liHeads.addClass('accordion-item').attr('data-accordion-item', '');\\n          $liHeadsA.addClass('accordion-title');\\n        });\\n      } else if (toSet === 'tabs') {\\n        var $tabsContent = __WEBPACK_IMPORTED_MODULE_0_jquery___default()('[data-tabs-content=' + _this.$element.attr('id') + ']');\\n        var $placeholder = __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#tabs-placeholder-' + _this.$element.attr('id'));\\n        if ($placeholder.length) {\\n          $tabsContent = __WEBPACK_IMPORTED_MODULE_0_jquery___default()('<div class=\\\"tabs-content\\\"></div>').insertAfter($placeholder).attr('data-tabs-content', _this.$element.attr('id'));\\n          $placeholder.remove();\\n        } else {\\n          $tabsContent = __WEBPACK_IMPORTED_MODULE_0_jquery___default()('<div class=\\\"tabs-content\\\"></div>').insertAfter(_this.$element).attr('data-tabs-content', _this.$element.attr('id'));\\n        };\\n        $panels.each(function (key, value) {\\n          var tempValue = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(value).appendTo($tabsContent).addClass(tabsPanel);\\n          var hash = $liHeadsA.get(key).hash.slice(1);\\n          var id = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(value).attr('id') || __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__foundation_util_core__[\\\"b\\\" /* GetYoDigits */])(6, 'accordion');\\n          if (hash !== id) {\\n            if (hash !== '') {\\n              __WEBPACK_IMPORTED_MODULE_0_jquery___default()(value).attr('id', hash);\\n            } else {\\n              hash = id;\\n              __WEBPACK_IMPORTED_MODULE_0_jquery___default()(value).attr('id', hash);\\n              __WEBPACK_IMPORTED_MODULE_0_jquery___default()($liHeadsA.get(key)).attr('href', __WEBPACK_IMPORTED_MODULE_0_jquery___default()($liHeadsA.get(key)).attr('href').replace('#', '') + '#' + hash);\\n            };\\n          };\\n          var isActive = __WEBPACK_IMPORTED_MODULE_0_jquery___default()($liHeads.get(key)).hasClass('is-active');\\n          if (isActive) {\\n            tempValue.addClass('is-active');\\n          };\\n        });\\n        $liHeads.addClass(tabsTitle);\\n      };\\n    }\\n\\n    /**\\n     * Destroys the instance of the current plugin on this element, as well as the window resize handler that switches the plugins out.\\n     * @function\\n     */\\n\\n  }, {\\n    key: '_destroy',\\n    value: function _destroy() {\\n      if (this.currentPlugin) this.currentPlugin.destroy();\\n      __WEBPACK_IMPORTED_MODULE_0_jquery___default()(window).off('.zf.ResponsiveAccordionTabs');\\n    }\\n  }]);\\n\\n  return ResponsiveAccordionTabs;\\n}(__WEBPACK_IMPORTED_MODULE_3__foundation_plugin__[\\\"a\\\" /* Plugin */]);\\n\\nResponsiveAccordionTabs.defaults = {};\\n\\n\\n\\n/***/ }),\\n/* 29 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return ResponsiveMenu; });\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jquery__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__foundation_util_mediaQuery__ = __webpack_require__(4);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__foundation_util_core__ = __webpack_require__(1);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__foundation_plugin__ = __webpack_require__(2);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__foundation_dropdownMenu__ = __webpack_require__(14);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__foundation_drilldown__ = __webpack_require__(13);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__foundation_accordionMenu__ = __webpack_require__(12);\\n\\n\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return call && (typeof call === \\\"object\\\" || typeof call === \\\"function\\\") ? call : self; }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function, not \\\" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nvar MenuPlugins = {\\n  dropdown: {\\n    cssClass: 'dropdown',\\n    plugin: __WEBPACK_IMPORTED_MODULE_4__foundation_dropdownMenu__[\\\"a\\\" /* DropdownMenu */]\\n  },\\n  drilldown: {\\n    cssClass: 'drilldown',\\n    plugin: __WEBPACK_IMPORTED_MODULE_5__foundation_drilldown__[\\\"a\\\" /* Drilldown */]\\n  },\\n  accordion: {\\n    cssClass: 'accordion-menu',\\n    plugin: __WEBPACK_IMPORTED_MODULE_6__foundation_accordionMenu__[\\\"a\\\" /* AccordionMenu */]\\n  }\\n};\\n\\n// import \\\"foundation.util.triggers.js\\\";\\n\\n\\n/**\\n * ResponsiveMenu module.\\n * @module foundation.responsiveMenu\\n * @requires foundation.util.triggers\\n * @requires foundation.util.mediaQuery\\n */\\n\\nvar ResponsiveMenu = function (_Plugin) {\\n  _inherits(ResponsiveMenu, _Plugin);\\n\\n  function ResponsiveMenu() {\\n    _classCallCheck(this, ResponsiveMenu);\\n\\n    return _possibleConstructorReturn(this, (ResponsiveMenu.__proto__ || Object.getPrototypeOf(ResponsiveMenu)).apply(this, arguments));\\n  }\\n\\n  _createClass(ResponsiveMenu, [{\\n    key: '_setup',\\n\\n    /**\\n     * Creates a new instance of a responsive menu.\\n     * @class\\n     * @name ResponsiveMenu\\n     * @fires ResponsiveMenu#init\\n     * @param {jQuery} element - jQuery object to make into a dropdown menu.\\n     * @param {Object} options - Overrides to the default plugin settings.\\n     */\\n    value: function _setup(element, options) {\\n      this.$element = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(element);\\n      this.rules = this.$element.data('responsive-menu');\\n      this.currentMq = null;\\n      this.currentPlugin = null;\\n      this.className = 'ResponsiveMenu'; // ie9 back compat\\n\\n      this._init();\\n      this._events();\\n    }\\n\\n    /**\\n     * Initializes the Menu by parsing the classes from the 'data-ResponsiveMenu' attribute on the element.\\n     * @function\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_init',\\n    value: function _init() {\\n\\n      __WEBPACK_IMPORTED_MODULE_1__foundation_util_mediaQuery__[\\\"a\\\" /* MediaQuery */]._init();\\n      // The first time an Interchange plugin is initialized, this.rules is converted from a string of \\\"classes\\\" to an object of rules\\n      if (typeof this.rules === 'string') {\\n        var rulesTree = {};\\n\\n        // Parse rules from \\\"classes\\\" pulled from data attribute\\n        var rules = this.rules.split(' ');\\n\\n        // Iterate through every rule found\\n        for (var i = 0; i < rules.length; i++) {\\n          var rule = rules[i].split('-');\\n          var ruleSize = rule.length > 1 ? rule[0] : 'small';\\n          var rulePlugin = rule.length > 1 ? rule[1] : rule[0];\\n\\n          if (MenuPlugins[rulePlugin] !== null) {\\n            rulesTree[ruleSize] = MenuPlugins[rulePlugin];\\n          }\\n        }\\n\\n        this.rules = rulesTree;\\n      }\\n\\n      if (!__WEBPACK_IMPORTED_MODULE_0_jquery___default.a.isEmptyObject(this.rules)) {\\n        this._checkMediaQueries();\\n      }\\n      // Add data-mutate since children may need it.\\n      this.$element.attr('data-mutate', this.$element.attr('data-mutate') || __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__foundation_util_core__[\\\"b\\\" /* GetYoDigits */])(6, 'responsive-menu'));\\n    }\\n\\n    /**\\n     * Initializes events for the Menu.\\n     * @function\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_events',\\n    value: function _events() {\\n      var _this = this;\\n\\n      __WEBPACK_IMPORTED_MODULE_0_jquery___default()(window).on('changed.zf.mediaquery', function () {\\n        _this._checkMediaQueries();\\n      });\\n      // $(window).on('resize.zf.ResponsiveMenu', function() {\\n      //   _this._checkMediaQueries();\\n      // });\\n    }\\n\\n    /**\\n     * Checks the current screen width against available media queries. If the media query has changed, and the plugin needed has changed, the plugins will swap out.\\n     * @function\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_checkMediaQueries',\\n    value: function _checkMediaQueries() {\\n      var matchedMq,\\n          _this = this;\\n      // Iterate through each rule and find the last matching rule\\n      __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.each(this.rules, function (key) {\\n        if (__WEBPACK_IMPORTED_MODULE_1__foundation_util_mediaQuery__[\\\"a\\\" /* MediaQuery */].atLeast(key)) {\\n          matchedMq = key;\\n        }\\n      });\\n\\n      // No match? No dice\\n      if (!matchedMq) return;\\n\\n      // Plugin already initialized? We good\\n      if (this.currentPlugin instanceof this.rules[matchedMq].plugin) return;\\n\\n      // Remove existing plugin-specific CSS classes\\n      __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.each(MenuPlugins, function (key, value) {\\n        _this.$element.removeClass(value.cssClass);\\n      });\\n\\n      // Add the CSS class for the new plugin\\n      this.$element.addClass(this.rules[matchedMq].cssClass);\\n\\n      // Create an instance of the new plugin\\n      if (this.currentPlugin) this.currentPlugin.destroy();\\n      this.currentPlugin = new this.rules[matchedMq].plugin(this.$element, {});\\n    }\\n\\n    /**\\n     * Destroys the instance of the current plugin on this element, as well as the window resize handler that switches the plugins out.\\n     * @function\\n     */\\n\\n  }, {\\n    key: '_destroy',\\n    value: function _destroy() {\\n      this.currentPlugin.destroy();\\n      __WEBPACK_IMPORTED_MODULE_0_jquery___default()(window).off('.zf.ResponsiveMenu');\\n    }\\n  }]);\\n\\n  return ResponsiveMenu;\\n}(__WEBPACK_IMPORTED_MODULE_3__foundation_plugin__[\\\"a\\\" /* Plugin */]);\\n\\nResponsiveMenu.defaults = {};\\n\\n\\n\\n/***/ }),\\n/* 30 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return ResponsiveToggle; });\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jquery__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__foundation_util_mediaQuery__ = __webpack_require__(4);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__foundation_util_motion__ = __webpack_require__(6);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__foundation_plugin__ = __webpack_require__(2);\\n\\n\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return call && (typeof call === \\\"object\\\" || typeof call === \\\"function\\\") ? call : self; }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function, not \\\" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\n\\n\\n\\n\\n\\n\\n/**\\n * ResponsiveToggle module.\\n * @module foundation.responsiveToggle\\n * @requires foundation.util.mediaQuery\\n * @requires foundation.util.motion\\n */\\n\\nvar ResponsiveToggle = function (_Plugin) {\\n  _inherits(ResponsiveToggle, _Plugin);\\n\\n  function ResponsiveToggle() {\\n    _classCallCheck(this, ResponsiveToggle);\\n\\n    return _possibleConstructorReturn(this, (ResponsiveToggle.__proto__ || Object.getPrototypeOf(ResponsiveToggle)).apply(this, arguments));\\n  }\\n\\n  _createClass(ResponsiveToggle, [{\\n    key: '_setup',\\n\\n    /**\\n     * Creates a new instance of Tab Bar.\\n     * @class\\n     * @name ResponsiveToggle\\n     * @fires ResponsiveToggle#init\\n     * @param {jQuery} element - jQuery object to attach tab bar functionality to.\\n     * @param {Object} options - Overrides to the default plugin settings.\\n     */\\n    value: function _setup(element, options) {\\n      this.$element = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(element);\\n      this.options = __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.extend({}, ResponsiveToggle.defaults, this.$element.data(), options);\\n      this.className = 'ResponsiveToggle'; // ie9 back compat\\n\\n      this._init();\\n      this._events();\\n    }\\n\\n    /**\\n     * Initializes the tab bar by finding the target element, toggling element, and running update().\\n     * @function\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_init',\\n    value: function _init() {\\n      __WEBPACK_IMPORTED_MODULE_1__foundation_util_mediaQuery__[\\\"a\\\" /* MediaQuery */]._init();\\n      var targetID = this.$element.data('responsive-toggle');\\n      if (!targetID) {\\n        console.error('Your tab bar needs an ID of a Menu as the value of data-tab-bar.');\\n      }\\n\\n      this.$targetMenu = __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#' + targetID);\\n      this.$toggler = this.$element.find('[data-toggle]').filter(function () {\\n        var target = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).data('toggle');\\n        return target === targetID || target === \\\"\\\";\\n      });\\n      this.options = __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.extend({}, this.options, this.$targetMenu.data());\\n\\n      // If they were set, parse the animation classes\\n      if (this.options.animate) {\\n        var input = this.options.animate.split(' ');\\n\\n        this.animationIn = input[0];\\n        this.animationOut = input[1] || null;\\n      }\\n\\n      this._update();\\n    }\\n\\n    /**\\n     * Adds necessary event handlers for the tab bar to work.\\n     * @function\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_events',\\n    value: function _events() {\\n      var _this = this;\\n\\n      this._updateMqHandler = this._update.bind(this);\\n\\n      __WEBPACK_IMPORTED_MODULE_0_jquery___default()(window).on('changed.zf.mediaquery', this._updateMqHandler);\\n\\n      this.$toggler.on('click.zf.responsiveToggle', this.toggleMenu.bind(this));\\n    }\\n\\n    /**\\n     * Checks the current media query to determine if the tab bar should be visible or hidden.\\n     * @function\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_update',\\n    value: function _update() {\\n      // Mobile\\n      if (!__WEBPACK_IMPORTED_MODULE_1__foundation_util_mediaQuery__[\\\"a\\\" /* MediaQuery */].atLeast(this.options.hideFor)) {\\n        this.$element.show();\\n        this.$targetMenu.hide();\\n      }\\n\\n      // Desktop\\n      else {\\n          this.$element.hide();\\n          this.$targetMenu.show();\\n        }\\n    }\\n\\n    /**\\n     * Toggles the element attached to the tab bar. The toggle only happens if the screen is small enough to allow it.\\n     * @function\\n     * @fires ResponsiveToggle#toggled\\n     */\\n\\n  }, {\\n    key: 'toggleMenu',\\n    value: function toggleMenu() {\\n      var _this3 = this;\\n\\n      if (!__WEBPACK_IMPORTED_MODULE_1__foundation_util_mediaQuery__[\\\"a\\\" /* MediaQuery */].atLeast(this.options.hideFor)) {\\n        /**\\n         * Fires when the element attached to the tab bar toggles.\\n         * @event ResponsiveToggle#toggled\\n         */\\n        if (this.options.animate) {\\n          if (this.$targetMenu.is(':hidden')) {\\n            __WEBPACK_IMPORTED_MODULE_2__foundation_util_motion__[\\\"a\\\" /* Motion */].animateIn(this.$targetMenu, this.animationIn, function () {\\n              _this3.$element.trigger('toggled.zf.responsiveToggle');\\n              _this3.$targetMenu.find('[data-mutate]').triggerHandler('mutateme.zf.trigger');\\n            });\\n          } else {\\n            __WEBPACK_IMPORTED_MODULE_2__foundation_util_motion__[\\\"a\\\" /* Motion */].animateOut(this.$targetMenu, this.animationOut, function () {\\n              _this3.$element.trigger('toggled.zf.responsiveToggle');\\n            });\\n          }\\n        } else {\\n          this.$targetMenu.toggle(0);\\n          this.$targetMenu.find('[data-mutate]').trigger('mutateme.zf.trigger');\\n          this.$element.trigger('toggled.zf.responsiveToggle');\\n        }\\n      }\\n    }\\n  }, {\\n    key: '_destroy',\\n    value: function _destroy() {\\n      this.$element.off('.zf.responsiveToggle');\\n      this.$toggler.off('.zf.responsiveToggle');\\n\\n      __WEBPACK_IMPORTED_MODULE_0_jquery___default()(window).off('changed.zf.mediaquery', this._updateMqHandler);\\n    }\\n  }]);\\n\\n  return ResponsiveToggle;\\n}(__WEBPACK_IMPORTED_MODULE_3__foundation_plugin__[\\\"a\\\" /* Plugin */]);\\n\\nResponsiveToggle.defaults = {\\n  /**\\n   * The breakpoint after which the menu is always shown, and the tab bar is hidden.\\n   * @option\\n   * @type {string}\\n   * @default 'medium'\\n   */\\n  hideFor: 'medium',\\n\\n  /**\\n   * To decide if the toggle should be animated or not.\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  animate: false\\n};\\n\\n\\n\\n/***/ }),\\n/* 31 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return Reveal; });\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jquery__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__foundation_util_keyboard__ = __webpack_require__(3);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__foundation_util_mediaQuery__ = __webpack_require__(4);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__foundation_util_motion__ = __webpack_require__(6);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__foundation_plugin__ = __webpack_require__(2);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__foundation_util_triggers__ = __webpack_require__(5);\\n\\n\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return call && (typeof call === \\\"object\\\" || typeof call === \\\"function\\\") ? call : self; }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function, not \\\" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\n\\n\\n\\n\\n\\n\\n\\n/**\\n * Reveal module.\\n * @module foundation.reveal\\n * @requires foundation.util.keyboard\\n * @requires foundation.util.triggers\\n * @requires foundation.util.mediaQuery\\n * @requires foundation.util.motion if using animations\\n */\\n\\nvar Reveal = function (_Plugin) {\\n  _inherits(Reveal, _Plugin);\\n\\n  function Reveal() {\\n    _classCallCheck(this, Reveal);\\n\\n    return _possibleConstructorReturn(this, (Reveal.__proto__ || Object.getPrototypeOf(Reveal)).apply(this, arguments));\\n  }\\n\\n  _createClass(Reveal, [{\\n    key: '_setup',\\n\\n    /**\\n     * Creates a new instance of Reveal.\\n     * @class\\n     * @name Reveal\\n     * @param {jQuery} element - jQuery object to use for the modal.\\n     * @param {Object} options - optional parameters.\\n     */\\n    value: function _setup(element, options) {\\n      this.$element = element;\\n      this.options = __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.extend({}, Reveal.defaults, this.$element.data(), options);\\n      this.className = 'Reveal'; // ie9 back compat\\n      this._init();\\n\\n      // Triggers init is idempotent, just need to make sure it is initialized\\n      __WEBPACK_IMPORTED_MODULE_5__foundation_util_triggers__[\\\"a\\\" /* Triggers */].init(__WEBPACK_IMPORTED_MODULE_0_jquery___default.a);\\n\\n      __WEBPACK_IMPORTED_MODULE_1__foundation_util_keyboard__[\\\"a\\\" /* Keyboard */].register('Reveal', {\\n        'ESCAPE': 'close'\\n      });\\n    }\\n\\n    /**\\n     * Initializes the modal by adding the overlay and close buttons, (if selected).\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_init',\\n    value: function _init() {\\n      __WEBPACK_IMPORTED_MODULE_2__foundation_util_mediaQuery__[\\\"a\\\" /* MediaQuery */]._init();\\n      this.id = this.$element.attr('id');\\n      this.isActive = false;\\n      this.cached = { mq: __WEBPACK_IMPORTED_MODULE_2__foundation_util_mediaQuery__[\\\"a\\\" /* MediaQuery */].current };\\n      this.isMobile = mobileSniff();\\n\\n      this.$anchor = __WEBPACK_IMPORTED_MODULE_0_jquery___default()('[data-open=\\\"' + this.id + '\\\"]').length ? __WEBPACK_IMPORTED_MODULE_0_jquery___default()('[data-open=\\\"' + this.id + '\\\"]') : __WEBPACK_IMPORTED_MODULE_0_jquery___default()('[data-toggle=\\\"' + this.id + '\\\"]');\\n      this.$anchor.attr({\\n        'aria-controls': this.id,\\n        'aria-haspopup': true,\\n        'tabindex': 0\\n      });\\n\\n      if (this.options.fullScreen || this.$element.hasClass('full')) {\\n        this.options.fullScreen = true;\\n        this.options.overlay = false;\\n      }\\n      if (this.options.overlay && !this.$overlay) {\\n        this.$overlay = this._makeOverlay(this.id);\\n      }\\n\\n      this.$element.attr({\\n        'role': 'dialog',\\n        'aria-hidden': true,\\n        'data-yeti-box': this.id,\\n        'data-resize': this.id\\n      });\\n\\n      if (this.$overlay) {\\n        this.$element.detach().appendTo(this.$overlay);\\n      } else {\\n        this.$element.detach().appendTo(__WEBPACK_IMPORTED_MODULE_0_jquery___default()(this.options.appendTo));\\n        this.$element.addClass('without-overlay');\\n      }\\n      this._events();\\n      if (this.options.deepLink && window.location.hash === '#' + this.id) {\\n        __WEBPACK_IMPORTED_MODULE_0_jquery___default()(window).one('load.zf.reveal', this.open.bind(this));\\n      }\\n    }\\n\\n    /**\\n     * Creates an overlay div to display behind the modal.\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_makeOverlay',\\n    value: function _makeOverlay() {\\n      var additionalOverlayClasses = '';\\n\\n      if (this.options.additionalOverlayClasses) {\\n        additionalOverlayClasses = ' ' + this.options.additionalOverlayClasses;\\n      }\\n\\n      return __WEBPACK_IMPORTED_MODULE_0_jquery___default()('<div></div>').addClass('reveal-overlay' + additionalOverlayClasses).appendTo(this.options.appendTo);\\n    }\\n\\n    /**\\n     * Updates position of modal\\n     * TODO:  Figure out if we actually need to cache these values or if it doesn't matter\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_updatePosition',\\n    value: function _updatePosition() {\\n      var width = this.$element.outerWidth();\\n      var outerWidth = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(window).width();\\n      var height = this.$element.outerHeight();\\n      var outerHeight = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(window).height();\\n      var left, top;\\n      if (this.options.hOffset === 'auto') {\\n        left = parseInt((outerWidth - width) / 2, 10);\\n      } else {\\n        left = parseInt(this.options.hOffset, 10);\\n      }\\n      if (this.options.vOffset === 'auto') {\\n        if (height > outerHeight) {\\n          top = parseInt(Math.min(100, outerHeight / 10), 10);\\n        } else {\\n          top = parseInt((outerHeight - height) / 4, 10);\\n        }\\n      } else {\\n        top = parseInt(this.options.vOffset, 10);\\n      }\\n      this.$element.css({ top: top + 'px' });\\n      // only worry about left if we don't have an overlay or we havea  horizontal offset,\\n      // otherwise we're perfectly in the middle\\n      if (!this.$overlay || this.options.hOffset !== 'auto') {\\n        this.$element.css({ left: left + 'px' });\\n        this.$element.css({ margin: '0px' });\\n      }\\n    }\\n\\n    /**\\n     * Adds event handlers for the modal.\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_events',\\n    value: function _events() {\\n      var _this3 = this;\\n\\n      var _this = this;\\n\\n      this.$element.on({\\n        'open.zf.trigger': this.open.bind(this),\\n        'close.zf.trigger': function (event, $element) {\\n          if (event.target === _this.$element[0] || __WEBPACK_IMPORTED_MODULE_0_jquery___default()(event.target).parents('[data-closable]')[0] === $element) {\\n            // only close reveal when it's explicitly called\\n            return _this3.close.apply(_this3);\\n          }\\n        },\\n        'toggle.zf.trigger': this.toggle.bind(this),\\n        'resizeme.zf.trigger': function () {\\n          _this._updatePosition();\\n        }\\n      });\\n\\n      if (this.options.closeOnClick && this.options.overlay) {\\n        this.$overlay.off('.zf.reveal').on('click.zf.reveal', function (e) {\\n          if (e.target === _this.$element[0] || __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.contains(_this.$element[0], e.target) || !__WEBPACK_IMPORTED_MODULE_0_jquery___default.a.contains(document, e.target)) {\\n            return;\\n          }\\n          _this.close();\\n        });\\n      }\\n      if (this.options.deepLink) {\\n        __WEBPACK_IMPORTED_MODULE_0_jquery___default()(window).on('popstate.zf.reveal:' + this.id, this._handleState.bind(this));\\n      }\\n    }\\n\\n    /**\\n     * Handles modal methods on back/forward button clicks or any other event that triggers popstate.\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_handleState',\\n    value: function _handleState(e) {\\n      if (window.location.hash === '#' + this.id && !this.isActive) {\\n        this.open();\\n      } else {\\n        this.close();\\n      }\\n    }\\n\\n    /**\\n     * Opens the modal controlled by `this.$anchor`, and closes all others by default.\\n     * @function\\n     * @fires Reveal#closeme\\n     * @fires Reveal#open\\n     */\\n\\n  }, {\\n    key: 'open',\\n    value: function open() {\\n      var _this4 = this;\\n\\n      // either update or replace browser history\\n      if (this.options.deepLink) {\\n        var hash = '#' + this.id;\\n\\n        if (window.history.pushState) {\\n          if (this.options.updateHistory) {\\n            window.history.pushState({}, '', hash);\\n          } else {\\n            window.history.replaceState({}, '', hash);\\n          }\\n        } else {\\n          window.location.hash = hash;\\n        }\\n      }\\n\\n      this.isActive = true;\\n\\n      // Make elements invisible, but remove display: none so we can get size and positioning\\n      this.$element.css({ 'visibility': 'hidden' }).show().scrollTop(0);\\n      if (this.options.overlay) {\\n        this.$overlay.css({ 'visibility': 'hidden' }).show();\\n      }\\n\\n      this._updatePosition();\\n\\n      this.$element.hide().css({ 'visibility': '' });\\n\\n      if (this.$overlay) {\\n        this.$overlay.css({ 'visibility': '' }).hide();\\n        if (this.$element.hasClass('fast')) {\\n          this.$overlay.addClass('fast');\\n        } else if (this.$element.hasClass('slow')) {\\n          this.$overlay.addClass('slow');\\n        }\\n      }\\n\\n      if (!this.options.multipleOpened) {\\n        /**\\n         * Fires immediately before the modal opens.\\n         * Closes any other modals that are currently open\\n         * @event Reveal#closeme\\n         */\\n        this.$element.trigger('closeme.zf.reveal', this.id);\\n      }\\n\\n      var _this = this;\\n\\n      function addRevealOpenClasses() {\\n        if (_this.isMobile) {\\n          if (!_this.originalScrollPos) {\\n            _this.originalScrollPos = window.pageYOffset;\\n          }\\n          __WEBPACK_IMPORTED_MODULE_0_jquery___default()('html, body').addClass('is-reveal-open');\\n        } else {\\n          __WEBPACK_IMPORTED_MODULE_0_jquery___default()('body').addClass('is-reveal-open');\\n        }\\n      }\\n      // Motion UI method of reveal\\n      if (this.options.animationIn) {\\n        var afterAnimation = function () {\\n          _this.$element.attr({\\n            'aria-hidden': false,\\n            'tabindex': -1\\n          }).focus();\\n          addRevealOpenClasses();\\n          __WEBPACK_IMPORTED_MODULE_1__foundation_util_keyboard__[\\\"a\\\" /* Keyboard */].trapFocus(_this.$element);\\n        };\\n\\n        if (this.options.overlay) {\\n          __WEBPACK_IMPORTED_MODULE_3__foundation_util_motion__[\\\"a\\\" /* Motion */].animateIn(this.$overlay, 'fade-in');\\n        }\\n        __WEBPACK_IMPORTED_MODULE_3__foundation_util_motion__[\\\"a\\\" /* Motion */].animateIn(this.$element, this.options.animationIn, function () {\\n          if (_this4.$element) {\\n            // protect against object having been removed\\n            _this4.focusableElements = __WEBPACK_IMPORTED_MODULE_1__foundation_util_keyboard__[\\\"a\\\" /* Keyboard */].findFocusable(_this4.$element);\\n            afterAnimation();\\n          }\\n        });\\n      }\\n      // jQuery method of reveal\\n      else {\\n          if (this.options.overlay) {\\n            this.$overlay.show(0);\\n          }\\n          this.$element.show(this.options.showDelay);\\n        }\\n\\n      // handle accessibility\\n      this.$element.attr({\\n        'aria-hidden': false,\\n        'tabindex': -1\\n      }).focus();\\n      __WEBPACK_IMPORTED_MODULE_1__foundation_util_keyboard__[\\\"a\\\" /* Keyboard */].trapFocus(this.$element);\\n\\n      addRevealOpenClasses();\\n\\n      this._extraHandlers();\\n\\n      /**\\n       * Fires when the modal has successfully opened.\\n       * @event Reveal#open\\n       */\\n      this.$element.trigger('open.zf.reveal');\\n    }\\n\\n    /**\\n     * Adds extra event handlers for the body and window if necessary.\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_extraHandlers',\\n    value: function _extraHandlers() {\\n      var _this = this;\\n      if (!this.$element) {\\n        return;\\n      } // If we're in the middle of cleanup, don't freak out\\n      this.focusableElements = __WEBPACK_IMPORTED_MODULE_1__foundation_util_keyboard__[\\\"a\\\" /* Keyboard */].findFocusable(this.$element);\\n\\n      if (!this.options.overlay && this.options.closeOnClick && !this.options.fullScreen) {\\n        __WEBPACK_IMPORTED_MODULE_0_jquery___default()('body').on('click.zf.reveal', function (e) {\\n          if (e.target === _this.$element[0] || __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.contains(_this.$element[0], e.target) || !__WEBPACK_IMPORTED_MODULE_0_jquery___default.a.contains(document, e.target)) {\\n            return;\\n          }\\n          _this.close();\\n        });\\n      }\\n\\n      if (this.options.closeOnEsc) {\\n        __WEBPACK_IMPORTED_MODULE_0_jquery___default()(window).on('keydown.zf.reveal', function (e) {\\n          __WEBPACK_IMPORTED_MODULE_1__foundation_util_keyboard__[\\\"a\\\" /* Keyboard */].handleKey(e, 'Reveal', {\\n            close: function () {\\n              if (_this.options.closeOnEsc) {\\n                _this.close();\\n              }\\n            }\\n          });\\n        });\\n      }\\n    }\\n\\n    /**\\n     * Closes the modal.\\n     * @function\\n     * @fires Reveal#closed\\n     */\\n\\n  }, {\\n    key: 'close',\\n    value: function close() {\\n      if (!this.isActive || !this.$element.is(':visible')) {\\n        return false;\\n      }\\n      var _this = this;\\n\\n      // Motion UI method of hiding\\n      if (this.options.animationOut) {\\n        if (this.options.overlay) {\\n          __WEBPACK_IMPORTED_MODULE_3__foundation_util_motion__[\\\"a\\\" /* Motion */].animateOut(this.$overlay, 'fade-out');\\n        }\\n\\n        __WEBPACK_IMPORTED_MODULE_3__foundation_util_motion__[\\\"a\\\" /* Motion */].animateOut(this.$element, this.options.animationOut, finishUp);\\n      }\\n      // jQuery method of hiding\\n      else {\\n          this.$element.hide(this.options.hideDelay);\\n\\n          if (this.options.overlay) {\\n            this.$overlay.hide(0, finishUp);\\n          } else {\\n            finishUp();\\n          }\\n        }\\n\\n      // Conditionals to remove extra event listeners added on open\\n      if (this.options.closeOnEsc) {\\n        __WEBPACK_IMPORTED_MODULE_0_jquery___default()(window).off('keydown.zf.reveal');\\n      }\\n\\n      if (!this.options.overlay && this.options.closeOnClick) {\\n        __WEBPACK_IMPORTED_MODULE_0_jquery___default()('body').off('click.zf.reveal');\\n      }\\n\\n      this.$element.off('keydown.zf.reveal');\\n\\n      function finishUp() {\\n        if (_this.isMobile) {\\n          if (__WEBPACK_IMPORTED_MODULE_0_jquery___default()('.reveal:visible').length === 0) {\\n            __WEBPACK_IMPORTED_MODULE_0_jquery___default()('html, body').removeClass('is-reveal-open');\\n          }\\n          if (_this.originalScrollPos) {\\n            __WEBPACK_IMPORTED_MODULE_0_jquery___default()('body').scrollTop(_this.originalScrollPos);\\n            _this.originalScrollPos = null;\\n          }\\n        } else {\\n          if (__WEBPACK_IMPORTED_MODULE_0_jquery___default()('.reveal:visible').length === 0) {\\n            __WEBPACK_IMPORTED_MODULE_0_jquery___default()('body').removeClass('is-reveal-open');\\n          }\\n        }\\n\\n        __WEBPACK_IMPORTED_MODULE_1__foundation_util_keyboard__[\\\"a\\\" /* Keyboard */].releaseFocus(_this.$element);\\n\\n        _this.$element.attr('aria-hidden', true);\\n\\n        /**\\n        * Fires when the modal is done closing.\\n        * @event Reveal#closed\\n        */\\n        _this.$element.trigger('closed.zf.reveal');\\n      }\\n\\n      /**\\n      * Resets the modal content\\n      * This prevents a running video to keep going in the background\\n      */\\n      if (this.options.resetOnClose) {\\n        this.$element.html(this.$element.html());\\n      }\\n\\n      this.isActive = false;\\n      if (_this.options.deepLink) {\\n        if (window.history.replaceState) {\\n          window.history.replaceState('', document.title, window.location.href.replace('#' + this.id, ''));\\n        } else {\\n          window.location.hash = '';\\n        }\\n      }\\n\\n      this.$anchor.focus();\\n    }\\n\\n    /**\\n     * Toggles the open/closed state of a modal.\\n     * @function\\n     */\\n\\n  }, {\\n    key: 'toggle',\\n    value: function toggle() {\\n      if (this.isActive) {\\n        this.close();\\n      } else {\\n        this.open();\\n      }\\n    }\\n  }, {\\n    key: '_destroy',\\n\\n\\n    /**\\n     * Destroys an instance of a modal.\\n     * @function\\n     */\\n    value: function _destroy() {\\n      if (this.options.overlay) {\\n        this.$element.appendTo(__WEBPACK_IMPORTED_MODULE_0_jquery___default()(this.options.appendTo)); // move $element outside of $overlay to prevent error unregisterPlugin()\\n        this.$overlay.hide().off().remove();\\n      }\\n      this.$element.hide().off();\\n      this.$anchor.off('.zf');\\n      __WEBPACK_IMPORTED_MODULE_0_jquery___default()(window).off('.zf.reveal:' + this.id);\\n    }\\n  }]);\\n\\n  return Reveal;\\n}(__WEBPACK_IMPORTED_MODULE_4__foundation_plugin__[\\\"a\\\" /* Plugin */]);\\n\\nReveal.defaults = {\\n  /**\\n   * Motion-UI class to use for animated elements. If none used, defaults to simple show/hide.\\n   * @option\\n   * @type {string}\\n   * @default ''\\n   */\\n  animationIn: '',\\n  /**\\n   * Motion-UI class to use for animated elements. If none used, defaults to simple show/hide.\\n   * @option\\n   * @type {string}\\n   * @default ''\\n   */\\n  animationOut: '',\\n  /**\\n   * Time, in ms, to delay the opening of a modal after a click if no animation used.\\n   * @option\\n   * @type {number}\\n   * @default 0\\n   */\\n  showDelay: 0,\\n  /**\\n   * Time, in ms, to delay the closing of a modal after a click if no animation used.\\n   * @option\\n   * @type {number}\\n   * @default 0\\n   */\\n  hideDelay: 0,\\n  /**\\n   * Allows a click on the body/overlay to close the modal.\\n   * @option\\n   * @type {boolean}\\n   * @default true\\n   */\\n  closeOnClick: true,\\n  /**\\n   * Allows the modal to close if the user presses the `ESCAPE` key.\\n   * @option\\n   * @type {boolean}\\n   * @default true\\n   */\\n  closeOnEsc: true,\\n  /**\\n   * If true, allows multiple modals to be displayed at once.\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  multipleOpened: false,\\n  /**\\n   * Distance, in pixels, the modal should push down from the top of the screen.\\n   * @option\\n   * @type {number|string}\\n   * @default auto\\n   */\\n  vOffset: 'auto',\\n  /**\\n   * Distance, in pixels, the modal should push in from the side of the screen.\\n   * @option\\n   * @type {number|string}\\n   * @default auto\\n   */\\n  hOffset: 'auto',\\n  /**\\n   * Allows the modal to be fullscreen, completely blocking out the rest of the view. JS checks for this as well.\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  fullScreen: false,\\n  /**\\n   * Percentage of screen height the modal should push up from the bottom of the view.\\n   * @option\\n   * @type {number}\\n   * @default 10\\n   */\\n  btmOffsetPct: 10,\\n  /**\\n   * Allows the modal to generate an overlay div, which will cover the view when modal opens.\\n   * @option\\n   * @type {boolean}\\n   * @default true\\n   */\\n  overlay: true,\\n  /**\\n   * Allows the modal to remove and reinject markup on close. Should be true if using video elements w/o using provider's api, otherwise, videos will continue to play in the background.\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  resetOnClose: false,\\n  /**\\n   * Allows the modal to alter the url on open/close, and allows the use of the `back` button to close modals. ALSO, allows a modal to auto-maniacally open on page load IF the hash === the modal's user-set id.\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  deepLink: false,\\n  /**\\n   * Update the browser history with the open modal\\n   * @option\\n   * @default false\\n   */\\n  updateHistory: false,\\n  /**\\n  * Allows the modal to append to custom div.\\n  * @option\\n  * @type {string}\\n  * @default \\\"body\\\"\\n  */\\n  appendTo: \\\"body\\\",\\n  /**\\n   * Allows adding additional class names to the reveal overlay.\\n   * @option\\n   * @type {string}\\n   * @default ''\\n   */\\n  additionalOverlayClasses: ''\\n};\\n\\nfunction iPhoneSniff() {\\n  return (/iP(ad|hone|od).*OS/.test(window.navigator.userAgent)\\n  );\\n}\\n\\nfunction androidSniff() {\\n  return (/Android/.test(window.navigator.userAgent)\\n  );\\n}\\n\\nfunction mobileSniff() {\\n  return iPhoneSniff() || androidSniff();\\n}\\n\\n\\n\\n/***/ }),\\n/* 32 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return Slider; });\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jquery__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__foundation_util_keyboard__ = __webpack_require__(3);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__foundation_util_motion__ = __webpack_require__(6);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__foundation_util_core__ = __webpack_require__(1);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__foundation_plugin__ = __webpack_require__(2);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__foundation_util_touch__ = __webpack_require__(10);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__foundation_util_triggers__ = __webpack_require__(5);\\n\\n\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return call && (typeof call === \\\"object\\\" || typeof call === \\\"function\\\") ? call : self; }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function, not \\\" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n/**\\n * Slider module.\\n * @module foundation.slider\\n * @requires foundation.util.motion\\n * @requires foundation.util.triggers\\n * @requires foundation.util.keyboard\\n * @requires foundation.util.touch\\n */\\n\\nvar Slider = function (_Plugin) {\\n  _inherits(Slider, _Plugin);\\n\\n  function Slider() {\\n    _classCallCheck(this, Slider);\\n\\n    return _possibleConstructorReturn(this, (Slider.__proto__ || Object.getPrototypeOf(Slider)).apply(this, arguments));\\n  }\\n\\n  _createClass(Slider, [{\\n    key: '_setup',\\n\\n    /**\\n     * Creates a new instance of a slider control.\\n     * @class\\n     * @name Slider\\n     * @param {jQuery} element - jQuery object to make into a slider control.\\n     * @param {Object} options - Overrides to the default plugin settings.\\n     */\\n    value: function _setup(element, options) {\\n      this.$element = element;\\n      this.options = __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.extend({}, Slider.defaults, this.$element.data(), options);\\n      this.className = 'Slider'; // ie9 back compat\\n\\n      // Touch and Triggers inits are idempotent, we just need to make sure it's initialied.\\n      __WEBPACK_IMPORTED_MODULE_5__foundation_util_touch__[\\\"a\\\" /* Touch */].init(__WEBPACK_IMPORTED_MODULE_0_jquery___default.a);\\n      __WEBPACK_IMPORTED_MODULE_6__foundation_util_triggers__[\\\"a\\\" /* Triggers */].init(__WEBPACK_IMPORTED_MODULE_0_jquery___default.a);\\n\\n      this._init();\\n\\n      __WEBPACK_IMPORTED_MODULE_1__foundation_util_keyboard__[\\\"a\\\" /* Keyboard */].register('Slider', {\\n        'ltr': {\\n          'ARROW_RIGHT': 'increase',\\n          'ARROW_UP': 'increase',\\n          'ARROW_DOWN': 'decrease',\\n          'ARROW_LEFT': 'decrease',\\n          'SHIFT_ARROW_RIGHT': 'increase_fast',\\n          'SHIFT_ARROW_UP': 'increase_fast',\\n          'SHIFT_ARROW_DOWN': 'decrease_fast',\\n          'SHIFT_ARROW_LEFT': 'decrease_fast',\\n          'HOME': 'min',\\n          'END': 'max'\\n        },\\n        'rtl': {\\n          'ARROW_LEFT': 'increase',\\n          'ARROW_RIGHT': 'decrease',\\n          'SHIFT_ARROW_LEFT': 'increase_fast',\\n          'SHIFT_ARROW_RIGHT': 'decrease_fast'\\n        }\\n      });\\n    }\\n\\n    /**\\n     * Initilizes the plugin by reading/setting attributes, creating collections and setting the initial position of the handle(s).\\n     * @function\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_init',\\n    value: function _init() {\\n      this.inputs = this.$element.find('input');\\n      this.handles = this.$element.find('[data-slider-handle]');\\n\\n      this.$handle = this.handles.eq(0);\\n      this.$input = this.inputs.length ? this.inputs.eq(0) : __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#' + this.$handle.attr('aria-controls'));\\n      this.$fill = this.$element.find('[data-slider-fill]').css(this.options.vertical ? 'height' : 'width', 0);\\n\\n      var isDbl = false,\\n          _this = this;\\n      if (this.options.disabled || this.$element.hasClass(this.options.disabledClass)) {\\n        this.options.disabled = true;\\n        this.$element.addClass(this.options.disabledClass);\\n      }\\n      if (!this.inputs.length) {\\n        this.inputs = __WEBPACK_IMPORTED_MODULE_0_jquery___default()().add(this.$input);\\n        this.options.binding = true;\\n      }\\n\\n      this._setInitAttr(0);\\n\\n      if (this.handles[1]) {\\n        this.options.doubleSided = true;\\n        this.$handle2 = this.handles.eq(1);\\n        this.$input2 = this.inputs.length > 1 ? this.inputs.eq(1) : __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#' + this.$handle2.attr('aria-controls'));\\n\\n        if (!this.inputs[1]) {\\n          this.inputs = this.inputs.add(this.$input2);\\n        }\\n        isDbl = true;\\n\\n        // this.$handle.triggerHandler('click.zf.slider');\\n        this._setInitAttr(1);\\n      }\\n\\n      // Set handle positions\\n      this.setHandles();\\n\\n      this._events();\\n    }\\n  }, {\\n    key: 'setHandles',\\n    value: function setHandles() {\\n      var _this3 = this;\\n\\n      if (this.handles[1]) {\\n        this._setHandlePos(this.$handle, this.inputs.eq(0).val(), true, function () {\\n          _this3._setHandlePos(_this3.$handle2, _this3.inputs.eq(1).val(), true);\\n        });\\n      } else {\\n        this._setHandlePos(this.$handle, this.inputs.eq(0).val(), true);\\n      }\\n    }\\n  }, {\\n    key: '_reflow',\\n    value: function _reflow() {\\n      this.setHandles();\\n    }\\n    /**\\n    * @function\\n    * @private\\n    * @param {Number} value - floating point (the value) to be transformed using to a relative position on the slider (the inverse of _value)\\n    */\\n\\n  }, {\\n    key: '_pctOfBar',\\n    value: function _pctOfBar(value) {\\n      var pctOfBar = percent(value - this.options.start, this.options.end - this.options.start);\\n\\n      switch (this.options.positionValueFunction) {\\n        case \\\"pow\\\":\\n          pctOfBar = this._logTransform(pctOfBar);\\n          break;\\n        case \\\"log\\\":\\n          pctOfBar = this._powTransform(pctOfBar);\\n          break;\\n      }\\n\\n      return pctOfBar.toFixed(2);\\n    }\\n\\n    /**\\n    * @function\\n    * @private\\n    * @param {Number} pctOfBar - floating point, the relative position of the slider (typically between 0-1) to be transformed to a value\\n    */\\n\\n  }, {\\n    key: '_value',\\n    value: function _value(pctOfBar) {\\n      switch (this.options.positionValueFunction) {\\n        case \\\"pow\\\":\\n          pctOfBar = this._powTransform(pctOfBar);\\n          break;\\n        case \\\"log\\\":\\n          pctOfBar = this._logTransform(pctOfBar);\\n          break;\\n      }\\n      var value = (this.options.end - this.options.start) * pctOfBar + this.options.start;\\n\\n      return value;\\n    }\\n\\n    /**\\n    * @function\\n    * @private\\n    * @param {Number} value - floating point (typically between 0-1) to be transformed using the log function\\n    */\\n\\n  }, {\\n    key: '_logTransform',\\n    value: function _logTransform(value) {\\n      return baseLog(this.options.nonLinearBase, value * (this.options.nonLinearBase - 1) + 1);\\n    }\\n\\n    /**\\n    * @function\\n    * @private\\n    * @param {Number} value - floating point (typically between 0-1) to be transformed using the power function\\n    */\\n\\n  }, {\\n    key: '_powTransform',\\n    value: function _powTransform(value) {\\n      return (Math.pow(this.options.nonLinearBase, value) - 1) / (this.options.nonLinearBase - 1);\\n    }\\n\\n    /**\\n     * Sets the position of the selected handle and fill bar.\\n     * @function\\n     * @private\\n     * @param {jQuery} $hndl - the selected handle to move.\\n     * @param {Number} location - floating point between the start and end values of the slider bar.\\n     * @param {Function} cb - callback function to fire on completion.\\n     * @fires Slider#moved\\n     * @fires Slider#changed\\n     */\\n\\n  }, {\\n    key: '_setHandlePos',\\n    value: function _setHandlePos($hndl, location, noInvert, cb) {\\n      // don't move if the slider has been disabled since its initialization\\n      if (this.$element.hasClass(this.options.disabledClass)) {\\n        return;\\n      }\\n      //might need to alter that slightly for bars that will have odd number selections.\\n      location = parseFloat(location); //on input change events, convert string to number...grumble.\\n\\n      // prevent slider from running out of bounds, if value exceeds the limits set through options, override the value to min/max\\n      if (location < this.options.start) {\\n        location = this.options.start;\\n      } else if (location > this.options.end) {\\n        location = this.options.end;\\n      }\\n\\n      var isDbl = this.options.doubleSided;\\n\\n      if (isDbl) {\\n        //this block is to prevent 2 handles from crossing eachother. Could/should be improved.\\n        if (this.handles.index($hndl) === 0) {\\n          var h2Val = parseFloat(this.$handle2.attr('aria-valuenow'));\\n          location = location >= h2Val ? h2Val - this.options.step : location;\\n        } else {\\n          var h1Val = parseFloat(this.$handle.attr('aria-valuenow'));\\n          location = location <= h1Val ? h1Val + this.options.step : location;\\n        }\\n      }\\n\\n      //this is for single-handled vertical sliders, it adjusts the value to account for the slider being \\\"upside-down\\\"\\n      //for click and drag events, it's weird due to the scale(-1, 1) css property\\n      if (this.options.vertical && !noInvert) {\\n        location = this.options.end - location;\\n      }\\n\\n      var _this = this,\\n          vert = this.options.vertical,\\n          hOrW = vert ? 'height' : 'width',\\n          lOrT = vert ? 'top' : 'left',\\n          handleDim = $hndl[0].getBoundingClientRect()[hOrW],\\n          elemDim = this.$element[0].getBoundingClientRect()[hOrW],\\n\\n      //percentage of bar min/max value based on click or drag point\\n      pctOfBar = this._pctOfBar(location),\\n\\n      //number of actual pixels to shift the handle, based on the percentage obtained above\\n      pxToMove = (elemDim - handleDim) * pctOfBar,\\n\\n      //percentage of bar to shift the handle\\n      movement = (percent(pxToMove, elemDim) * 100).toFixed(this.options.decimal);\\n      //fixing the decimal value for the location number, is passed to other methods as a fixed floating-point value\\n      location = parseFloat(location.toFixed(this.options.decimal));\\n      // declare empty object for css adjustments, only used with 2 handled-sliders\\n      var css = {};\\n\\n      this._setValues($hndl, location);\\n\\n      // TODO update to calculate based on values set to respective inputs??\\n      if (isDbl) {\\n        var isLeftHndl = this.handles.index($hndl) === 0,\\n\\n        //empty variable, will be used for min-height/width for fill bar\\n        dim,\\n\\n        //percentage w/h of the handle compared to the slider bar\\n        handlePct = ~~(percent(handleDim, elemDim) * 100);\\n        //if left handle, the math is slightly different than if it's the right handle, and the left/top property needs to be changed for the fill bar\\n        if (isLeftHndl) {\\n          //left or top percentage value to apply to the fill bar.\\n          css[lOrT] = movement + '%';\\n          //calculate the new min-height/width for the fill bar.\\n          dim = parseFloat(this.$handle2[0].style[lOrT]) - movement + handlePct;\\n          //this callback is necessary to prevent errors and allow the proper placement and initialization of a 2-handled slider\\n          //plus, it means we don't care if 'dim' isNaN on init, it won't be in the future.\\n          if (cb && typeof cb === 'function') {\\n            cb();\\n          } //this is only needed for the initialization of 2 handled sliders\\n        } else {\\n          //just caching the value of the left/bottom handle's left/top property\\n          var handlePos = parseFloat(this.$handle[0].style[lOrT]);\\n          //calculate the new min-height/width for the fill bar. Use isNaN to prevent false positives for numbers <= 0\\n          //based on the percentage of movement of the handle being manipulated, less the opposing handle's left/top position, plus the percentage w/h of the handle itself\\n          dim = movement - (isNaN(handlePos) ? (this.options.initialStart - this.options.start) / ((this.options.end - this.options.start) / 100) : handlePos) + handlePct;\\n        }\\n        // assign the min-height/width to our css object\\n        css['min-' + hOrW] = dim + '%';\\n      }\\n\\n      this.$element.one('finished.zf.animate', function () {\\n        /**\\n         * Fires when the handle is done moving.\\n         * @event Slider#moved\\n         */\\n        _this.$element.trigger('moved.zf.slider', [$hndl]);\\n      });\\n\\n      //because we don't know exactly how the handle will be moved, check the amount of time it should take to move.\\n      var moveTime = this.$element.data('dragging') ? 1000 / 60 : this.options.moveTime;\\n\\n      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__foundation_util_motion__[\\\"b\\\" /* Move */])(moveTime, $hndl, function () {\\n        // adjusting the left/top property of the handle, based on the percentage calculated above\\n        // if movement isNaN, that is because the slider is hidden and we cannot determine handle width,\\n        // fall back to next best guess.\\n        if (isNaN(movement)) {\\n          $hndl.css(lOrT, pctOfBar * 100 + '%');\\n        } else {\\n          $hndl.css(lOrT, movement + '%');\\n        }\\n\\n        if (!_this.options.doubleSided) {\\n          //if single-handled, a simple method to expand the fill bar\\n          _this.$fill.css(hOrW, pctOfBar * 100 + '%');\\n        } else {\\n          //otherwise, use the css object we created above\\n          _this.$fill.css(css);\\n        }\\n      });\\n\\n      /**\\n       * Fires when the value has not been change for a given time.\\n       * @event Slider#changed\\n       */\\n      clearTimeout(_this.timeout);\\n      _this.timeout = setTimeout(function () {\\n        _this.$element.trigger('changed.zf.slider', [$hndl]);\\n      }, _this.options.changedDelay);\\n    }\\n\\n    /**\\n     * Sets the initial attribute for the slider element.\\n     * @function\\n     * @private\\n     * @param {Number} idx - index of the current handle/input to use.\\n     */\\n\\n  }, {\\n    key: '_setInitAttr',\\n    value: function _setInitAttr(idx) {\\n      var initVal = idx === 0 ? this.options.initialStart : this.options.initialEnd;\\n      var id = this.inputs.eq(idx).attr('id') || __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__foundation_util_core__[\\\"b\\\" /* GetYoDigits */])(6, 'slider');\\n      this.inputs.eq(idx).attr({\\n        'id': id,\\n        'max': this.options.end,\\n        'min': this.options.start,\\n        'step': this.options.step\\n      });\\n      this.inputs.eq(idx).val(initVal);\\n      this.handles.eq(idx).attr({\\n        'role': 'slider',\\n        'aria-controls': id,\\n        'aria-valuemax': this.options.end,\\n        'aria-valuemin': this.options.start,\\n        'aria-valuenow': initVal,\\n        'aria-orientation': this.options.vertical ? 'vertical' : 'horizontal',\\n        'tabindex': 0\\n      });\\n    }\\n\\n    /**\\n     * Sets the input and `aria-valuenow` values for the slider element.\\n     * @function\\n     * @private\\n     * @param {jQuery} $handle - the currently selected handle.\\n     * @param {Number} val - floating point of the new value.\\n     */\\n\\n  }, {\\n    key: '_setValues',\\n    value: function _setValues($handle, val) {\\n      var idx = this.options.doubleSided ? this.handles.index($handle) : 0;\\n      this.inputs.eq(idx).val(val);\\n      $handle.attr('aria-valuenow', val);\\n    }\\n\\n    /**\\n     * Handles events on the slider element.\\n     * Calculates the new location of the current handle.\\n     * If there are two handles and the bar was clicked, it determines which handle to move.\\n     * @function\\n     * @private\\n     * @param {Object} e - the `event` object passed from the listener.\\n     * @param {jQuery} $handle - the current handle to calculate for, if selected.\\n     * @param {Number} val - floating point number for the new value of the slider.\\n     * TODO clean this up, there's a lot of repeated code between this and the _setHandlePos fn.\\n     */\\n\\n  }, {\\n    key: '_handleEvent',\\n    value: function _handleEvent(e, $handle, val) {\\n      var value, hasVal;\\n      if (!val) {\\n        //click or drag events\\n        e.preventDefault();\\n        var _this = this,\\n            vertical = this.options.vertical,\\n            param = vertical ? 'height' : 'width',\\n            direction = vertical ? 'top' : 'left',\\n            eventOffset = vertical ? e.pageY : e.pageX,\\n            halfOfHandle = this.$handle[0].getBoundingClientRect()[param] / 2,\\n            barDim = this.$element[0].getBoundingClientRect()[param],\\n            windowScroll = vertical ? __WEBPACK_IMPORTED_MODULE_0_jquery___default()(window).scrollTop() : __WEBPACK_IMPORTED_MODULE_0_jquery___default()(window).scrollLeft();\\n\\n        var elemOffset = this.$element.offset()[direction];\\n\\n        // touch events emulated by the touch util give position relative to screen, add window.scroll to event coordinates...\\n        // best way to guess this is simulated is if clientY == pageY\\n        if (e.clientY === e.pageY) {\\n          eventOffset = eventOffset + windowScroll;\\n        }\\n        var eventFromBar = eventOffset - elemOffset;\\n        var barXY;\\n        if (eventFromBar < 0) {\\n          barXY = 0;\\n        } else if (eventFromBar > barDim) {\\n          barXY = barDim;\\n        } else {\\n          barXY = eventFromBar;\\n        }\\n        var offsetPct = percent(barXY, barDim);\\n\\n        value = this._value(offsetPct);\\n\\n        // turn everything around for RTL, yay math!\\n        if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__foundation_util_core__[\\\"a\\\" /* rtl */])() && !this.options.vertical) {\\n          value = this.options.end - value;\\n        }\\n\\n        value = _this._adjustValue(null, value);\\n        //boolean flag for the setHandlePos fn, specifically for vertical sliders\\n        hasVal = false;\\n\\n        if (!$handle) {\\n          //figure out which handle it is, pass it to the next function.\\n          var firstHndlPos = absPosition(this.$handle, direction, barXY, param),\\n              secndHndlPos = absPosition(this.$handle2, direction, barXY, param);\\n          $handle = firstHndlPos <= secndHndlPos ? this.$handle : this.$handle2;\\n        }\\n      } else {\\n        //change event on input\\n        value = this._adjustValue(null, val);\\n        hasVal = true;\\n      }\\n\\n      this._setHandlePos($handle, value, hasVal);\\n    }\\n\\n    /**\\n     * Adjustes value for handle in regard to step value. returns adjusted value\\n     * @function\\n     * @private\\n     * @param {jQuery} $handle - the selected handle.\\n     * @param {Number} value - value to adjust. used if $handle is falsy\\n     */\\n\\n  }, {\\n    key: '_adjustValue',\\n    value: function _adjustValue($handle, value) {\\n      var val,\\n          step = this.options.step,\\n          div = parseFloat(step / 2),\\n          left,\\n          prev_val,\\n          next_val;\\n      if (!!$handle) {\\n        val = parseFloat($handle.attr('aria-valuenow'));\\n      } else {\\n        val = value;\\n      }\\n      left = val % step;\\n      prev_val = val - left;\\n      next_val = prev_val + step;\\n      if (left === 0) {\\n        return val;\\n      }\\n      val = val >= prev_val + div ? next_val : prev_val;\\n      return val;\\n    }\\n\\n    /**\\n     * Adds event listeners to the slider elements.\\n     * @function\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_events',\\n    value: function _events() {\\n      this._eventsForHandle(this.$handle);\\n      if (this.handles[1]) {\\n        this._eventsForHandle(this.$handle2);\\n      }\\n    }\\n\\n    /**\\n     * Adds event listeners a particular handle\\n     * @function\\n     * @private\\n     * @param {jQuery} $handle - the current handle to apply listeners to.\\n     */\\n\\n  }, {\\n    key: '_eventsForHandle',\\n    value: function _eventsForHandle($handle) {\\n      var _this = this,\\n          curHandle,\\n          timer;\\n\\n      this.inputs.off('change.zf.slider').on('change.zf.slider', function (e) {\\n        var idx = _this.inputs.index(__WEBPACK_IMPORTED_MODULE_0_jquery___default()(this));\\n        _this._handleEvent(e, _this.handles.eq(idx), __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this).val());\\n      });\\n\\n      if (this.options.clickSelect) {\\n        this.$element.off('click.zf.slider').on('click.zf.slider', function (e) {\\n          if (_this.$element.data('dragging')) {\\n            return false;\\n          }\\n\\n          if (!__WEBPACK_IMPORTED_MODULE_0_jquery___default()(e.target).is('[data-slider-handle]')) {\\n            if (_this.options.doubleSided) {\\n              _this._handleEvent(e);\\n            } else {\\n              _this._handleEvent(e, _this.$handle);\\n            }\\n          }\\n        });\\n      }\\n\\n      if (this.options.draggable) {\\n        this.handles.addTouch();\\n\\n        var $body = __WEBPACK_IMPORTED_MODULE_0_jquery___default()('body');\\n        $handle.off('mousedown.zf.slider').on('mousedown.zf.slider', function (e) {\\n          $handle.addClass('is-dragging');\\n          _this.$fill.addClass('is-dragging'); //\\n          _this.$element.data('dragging', true);\\n\\n          curHandle = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(e.currentTarget);\\n\\n          $body.on('mousemove.zf.slider', function (e) {\\n            e.preventDefault();\\n            _this._handleEvent(e, curHandle);\\n          }).on('mouseup.zf.slider', function (e) {\\n            _this._handleEvent(e, curHandle);\\n\\n            $handle.removeClass('is-dragging');\\n            _this.$fill.removeClass('is-dragging');\\n            _this.$element.data('dragging', false);\\n\\n            $body.off('mousemove.zf.slider mouseup.zf.slider');\\n          });\\n        })\\n        // prevent events triggered by touch\\n        .on('selectstart.zf.slider touchmove.zf.slider', function (e) {\\n          e.preventDefault();\\n        });\\n      }\\n\\n      $handle.off('keydown.zf.slider').on('keydown.zf.slider', function (e) {\\n        var _$handle = __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this),\\n            idx = _this.options.doubleSided ? _this.handles.index(_$handle) : 0,\\n            oldValue = parseFloat(_this.inputs.eq(idx).val()),\\n            newValue;\\n\\n        // handle keyboard event with keyboard util\\n        __WEBPACK_IMPORTED_MODULE_1__foundation_util_keyboard__[\\\"a\\\" /* Keyboard */].handleKey(e, 'Slider', {\\n          decrease: function () {\\n            newValue = oldValue - _this.options.step;\\n          },\\n          increase: function () {\\n            newValue = oldValue + _this.options.step;\\n          },\\n          decrease_fast: function () {\\n            newValue = oldValue - _this.options.step * 10;\\n          },\\n          increase_fast: function () {\\n            newValue = oldValue + _this.options.step * 10;\\n          },\\n          min: function () {\\n            newValue = _this.options.start;\\n          },\\n          max: function () {\\n            newValue = _this.options.end;\\n          },\\n          handled: function () {\\n            // only set handle pos when event was handled specially\\n            e.preventDefault();\\n            _this._setHandlePos(_$handle, newValue, true);\\n          }\\n        });\\n        /*if (newValue) { // if pressed key has special function, update value\\n          e.preventDefault();\\n          _this._setHandlePos(_$handle, newValue);\\n        }*/\\n      });\\n    }\\n\\n    /**\\n     * Destroys the slider plugin.\\n     */\\n\\n  }, {\\n    key: '_destroy',\\n    value: function _destroy() {\\n      this.handles.off('.zf.slider');\\n      this.inputs.off('.zf.slider');\\n      this.$element.off('.zf.slider');\\n\\n      clearTimeout(this.timeout);\\n    }\\n  }]);\\n\\n  return Slider;\\n}(__WEBPACK_IMPORTED_MODULE_4__foundation_plugin__[\\\"a\\\" /* Plugin */]);\\n\\nSlider.defaults = {\\n  /**\\n   * Minimum value for the slider scale.\\n   * @option\\n   * @type {number}\\n   * @default 0\\n   */\\n  start: 0,\\n  /**\\n   * Maximum value for the slider scale.\\n   * @option\\n   * @type {number}\\n   * @default 100\\n   */\\n  end: 100,\\n  /**\\n   * Minimum value change per change event.\\n   * @option\\n   * @type {number}\\n   * @default 1\\n   */\\n  step: 1,\\n  /**\\n   * Value at which the handle/input *(left handle/first input)* should be set to on initialization.\\n   * @option\\n   * @type {number}\\n   * @default 0\\n   */\\n  initialStart: 0,\\n  /**\\n   * Value at which the right handle/second input should be set to on initialization.\\n   * @option\\n   * @type {number}\\n   * @default 100\\n   */\\n  initialEnd: 100,\\n  /**\\n   * Allows the input to be located outside the container and visible. Set to by the JS\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  binding: false,\\n  /**\\n   * Allows the user to click/tap on the slider bar to select a value.\\n   * @option\\n   * @type {boolean}\\n   * @default true\\n   */\\n  clickSelect: true,\\n  /**\\n   * Set to true and use the `vertical` class to change alignment to vertical.\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  vertical: false,\\n  /**\\n   * Allows the user to drag the slider handle(s) to select a value.\\n   * @option\\n   * @type {boolean}\\n   * @default true\\n   */\\n  draggable: true,\\n  /**\\n   * Disables the slider and prevents event listeners from being applied. Double checked by JS with `disabledClass`.\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  disabled: false,\\n  /**\\n   * Allows the use of two handles. Double checked by the JS. Changes some logic handling.\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  doubleSided: false,\\n  /**\\n   * Potential future feature.\\n   */\\n  // steps: 100,\\n  /**\\n   * Number of decimal places the plugin should go to for floating point precision.\\n   * @option\\n   * @type {number}\\n   * @default 2\\n   */\\n  decimal: 2,\\n  /**\\n   * Time delay for dragged elements.\\n   */\\n  // dragDelay: 0,\\n  /**\\n   * Time, in ms, to animate the movement of a slider handle if user clicks/taps on the bar. Needs to be manually set if updating the transition time in the Sass settings.\\n   * @option\\n   * @type {number}\\n   * @default 200\\n   */\\n  moveTime: 200, //update this if changing the transition time in the sass\\n  /**\\n   * Class applied to disabled sliders.\\n   * @option\\n   * @type {string}\\n   * @default 'disabled'\\n   */\\n  disabledClass: 'disabled',\\n  /**\\n   * Will invert the default layout for a vertical<span data-tooltip title=\\\"who would do this???\\\"> </span>slider.\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  invertVertical: false,\\n  /**\\n   * Milliseconds before the `changed.zf-slider` event is triggered after value change.\\n   * @option\\n   * @type {number}\\n   * @default 500\\n   */\\n  changedDelay: 500,\\n  /**\\n  * Basevalue for non-linear sliders\\n  * @option\\n  * @type {number}\\n  * @default 5\\n  */\\n  nonLinearBase: 5,\\n  /**\\n  * Basevalue for non-linear sliders, possible values are: `'linear'`, `'pow'` & `'log'`. Pow and Log use the nonLinearBase setting.\\n  * @option\\n  * @type {string}\\n  * @default 'linear'\\n  */\\n  positionValueFunction: 'linear'\\n};\\n\\nfunction percent(frac, num) {\\n  return frac / num;\\n}\\nfunction absPosition($handle, dir, clickPos, param) {\\n  return Math.abs($handle.position()[dir] + $handle[param]() / 2 - clickPos);\\n}\\nfunction baseLog(base, value) {\\n  return Math.log(value) / Math.log(base);\\n}\\n\\n\\n\\n/***/ }),\\n/* 33 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return Sticky; });\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jquery__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__foundation_util_core__ = __webpack_require__(1);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__foundation_util_mediaQuery__ = __webpack_require__(4);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__foundation_plugin__ = __webpack_require__(2);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__foundation_util_triggers__ = __webpack_require__(5);\\n\\n\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return call && (typeof call === \\\"object\\\" || typeof call === \\\"function\\\") ? call : self; }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function, not \\\" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\n\\n\\n\\n\\n\\n\\n/**\\n * Sticky module.\\n * @module foundation.sticky\\n * @requires foundation.util.triggers\\n * @requires foundation.util.mediaQuery\\n */\\n\\nvar Sticky = function (_Plugin) {\\n  _inherits(Sticky, _Plugin);\\n\\n  function Sticky() {\\n    _classCallCheck(this, Sticky);\\n\\n    return _possibleConstructorReturn(this, (Sticky.__proto__ || Object.getPrototypeOf(Sticky)).apply(this, arguments));\\n  }\\n\\n  _createClass(Sticky, [{\\n    key: '_setup',\\n\\n    /**\\n     * Creates a new instance of a sticky thing.\\n     * @class\\n     * @name Sticky\\n     * @param {jQuery} element - jQuery object to make sticky.\\n     * @param {Object} options - options object passed when creating the element programmatically.\\n     */\\n    value: function _setup(element, options) {\\n      this.$element = element;\\n      this.options = __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.extend({}, Sticky.defaults, this.$element.data(), options);\\n      this.className = 'Sticky'; // ie9 back compat\\n\\n      // Triggers init is idempotent, just need to make sure it is initialized\\n      __WEBPACK_IMPORTED_MODULE_4__foundation_util_triggers__[\\\"a\\\" /* Triggers */].init(__WEBPACK_IMPORTED_MODULE_0_jquery___default.a);\\n\\n      this._init();\\n    }\\n\\n    /**\\n     * Initializes the sticky element by adding classes, getting/setting dimensions, breakpoints and attributes\\n     * @function\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_init',\\n    value: function _init() {\\n      __WEBPACK_IMPORTED_MODULE_2__foundation_util_mediaQuery__[\\\"a\\\" /* MediaQuery */]._init();\\n\\n      var $parent = this.$element.parent('[data-sticky-container]'),\\n          id = this.$element[0].id || __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__foundation_util_core__[\\\"b\\\" /* GetYoDigits */])(6, 'sticky'),\\n          _this = this;\\n\\n      if ($parent.length) {\\n        this.$container = $parent;\\n      } else {\\n        this.wasWrapped = true;\\n        this.$element.wrap(this.options.container);\\n        this.$container = this.$element.parent();\\n      }\\n      this.$container.addClass(this.options.containerClass);\\n\\n      this.$element.addClass(this.options.stickyClass).attr({ 'data-resize': id, 'data-mutate': id });\\n      if (this.options.anchor !== '') {\\n        __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#' + _this.options.anchor).attr({ 'data-mutate': id });\\n      }\\n\\n      this.scrollCount = this.options.checkEvery;\\n      this.isStuck = false;\\n      __WEBPACK_IMPORTED_MODULE_0_jquery___default()(window).one('load.zf.sticky', function () {\\n        //We calculate the container height to have correct values for anchor points offset calculation.\\n        _this.containerHeight = _this.$element.css(\\\"display\\\") == \\\"none\\\" ? 0 : _this.$element[0].getBoundingClientRect().height;\\n        _this.$container.css('height', _this.containerHeight);\\n        _this.elemHeight = _this.containerHeight;\\n        if (_this.options.anchor !== '') {\\n          _this.$anchor = __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#' + _this.options.anchor);\\n        } else {\\n          _this._parsePoints();\\n        }\\n\\n        _this._setSizes(function () {\\n          var scroll = window.pageYOffset;\\n          _this._calc(false, scroll);\\n          //Unstick the element will ensure that proper classes are set.\\n          if (!_this.isStuck) {\\n            _this._removeSticky(scroll >= _this.topPoint ? false : true);\\n          }\\n        });\\n        _this._events(id.split('-').reverse().join('-'));\\n      });\\n    }\\n\\n    /**\\n     * If using multiple elements as anchors, calculates the top and bottom pixel values the sticky thing should stick and unstick on.\\n     * @function\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_parsePoints',\\n    value: function _parsePoints() {\\n      var top = this.options.topAnchor == \\\"\\\" ? 1 : this.options.topAnchor,\\n          btm = this.options.btmAnchor == \\\"\\\" ? document.documentElement.scrollHeight : this.options.btmAnchor,\\n          pts = [top, btm],\\n          breaks = {};\\n      for (var i = 0, len = pts.length; i < len && pts[i]; i++) {\\n        var pt;\\n        if (typeof pts[i] === 'number') {\\n          pt = pts[i];\\n        } else {\\n          var place = pts[i].split(':'),\\n              anchor = __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#' + place[0]);\\n\\n          pt = anchor.offset().top;\\n          if (place[1] && place[1].toLowerCase() === 'bottom') {\\n            pt += anchor[0].getBoundingClientRect().height;\\n          }\\n        }\\n        breaks[i] = pt;\\n      }\\n\\n      this.points = breaks;\\n      return;\\n    }\\n\\n    /**\\n     * Adds event handlers for the scrolling element.\\n     * @private\\n     * @param {String} id - pseudo-random id for unique scroll event listener.\\n     */\\n\\n  }, {\\n    key: '_events',\\n    value: function _events(id) {\\n      var _this = this,\\n          scrollListener = this.scrollListener = 'scroll.zf.' + id;\\n      if (this.isOn) {\\n        return;\\n      }\\n      if (this.canStick) {\\n        this.isOn = true;\\n        __WEBPACK_IMPORTED_MODULE_0_jquery___default()(window).off(scrollListener).on(scrollListener, function (e) {\\n          if (_this.scrollCount === 0) {\\n            _this.scrollCount = _this.options.checkEvery;\\n            _this._setSizes(function () {\\n              _this._calc(false, window.pageYOffset);\\n            });\\n          } else {\\n            _this.scrollCount--;\\n            _this._calc(false, window.pageYOffset);\\n          }\\n        });\\n      }\\n\\n      this.$element.off('resizeme.zf.trigger').on('resizeme.zf.trigger', function (e, el) {\\n        _this._eventsHandler(id);\\n      });\\n\\n      this.$element.on('mutateme.zf.trigger', function (e, el) {\\n        _this._eventsHandler(id);\\n      });\\n\\n      if (this.$anchor) {\\n        this.$anchor.on('mutateme.zf.trigger', function (e, el) {\\n          _this._eventsHandler(id);\\n        });\\n      }\\n    }\\n\\n    /**\\n     * Handler for events.\\n     * @private\\n     * @param {String} id - pseudo-random id for unique scroll event listener.\\n     */\\n\\n  }, {\\n    key: '_eventsHandler',\\n    value: function _eventsHandler(id) {\\n      var _this = this,\\n          scrollListener = this.scrollListener = 'scroll.zf.' + id;\\n\\n      _this._setSizes(function () {\\n        _this._calc(false);\\n        if (_this.canStick) {\\n          if (!_this.isOn) {\\n            _this._events(id);\\n          }\\n        } else if (_this.isOn) {\\n          _this._pauseListeners(scrollListener);\\n        }\\n      });\\n    }\\n\\n    /**\\n     * Removes event handlers for scroll and change events on anchor.\\n     * @fires Sticky#pause\\n     * @param {String} scrollListener - unique, namespaced scroll listener attached to `window`\\n     */\\n\\n  }, {\\n    key: '_pauseListeners',\\n    value: function _pauseListeners(scrollListener) {\\n      this.isOn = false;\\n      __WEBPACK_IMPORTED_MODULE_0_jquery___default()(window).off(scrollListener);\\n\\n      /**\\n       * Fires when the plugin is paused due to resize event shrinking the view.\\n       * @event Sticky#pause\\n       * @private\\n       */\\n      this.$element.trigger('pause.zf.sticky');\\n    }\\n\\n    /**\\n     * Called on every `scroll` event and on `_init`\\n     * fires functions based on booleans and cached values\\n     * @param {Boolean} checkSizes - true if plugin should recalculate sizes and breakpoints.\\n     * @param {Number} scroll - current scroll position passed from scroll event cb function. If not passed, defaults to `window.pageYOffset`.\\n     */\\n\\n  }, {\\n    key: '_calc',\\n    value: function _calc(checkSizes, scroll) {\\n      if (checkSizes) {\\n        this._setSizes();\\n      }\\n\\n      if (!this.canStick) {\\n        if (this.isStuck) {\\n          this._removeSticky(true);\\n        }\\n        return false;\\n      }\\n\\n      if (!scroll) {\\n        scroll = window.pageYOffset;\\n      }\\n\\n      if (scroll >= this.topPoint) {\\n        if (scroll <= this.bottomPoint) {\\n          if (!this.isStuck) {\\n            this._setSticky();\\n          }\\n        } else {\\n          if (this.isStuck) {\\n            this._removeSticky(false);\\n          }\\n        }\\n      } else {\\n        if (this.isStuck) {\\n          this._removeSticky(true);\\n        }\\n      }\\n    }\\n\\n    /**\\n     * Causes the $element to become stuck.\\n     * Adds `position: fixed;`, and helper classes.\\n     * @fires Sticky#stuckto\\n     * @function\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_setSticky',\\n    value: function _setSticky() {\\n      var _this = this,\\n          stickTo = this.options.stickTo,\\n          mrgn = stickTo === 'top' ? 'marginTop' : 'marginBottom',\\n          notStuckTo = stickTo === 'top' ? 'bottom' : 'top',\\n          css = {};\\n\\n      css[mrgn] = this.options[mrgn] + 'em';\\n      css[stickTo] = 0;\\n      css[notStuckTo] = 'auto';\\n      this.isStuck = true;\\n      this.$element.removeClass('is-anchored is-at-' + notStuckTo).addClass('is-stuck is-at-' + stickTo).css(css)\\n      /**\\n       * Fires when the $element has become `position: fixed;`\\n       * Namespaced to `top` or `bottom`, e.g. `sticky.zf.stuckto:top`\\n       * @event Sticky#stuckto\\n       */\\n      .trigger('sticky.zf.stuckto:' + stickTo);\\n      this.$element.on(\\\"transitionend webkitTransitionEnd oTransitionEnd otransitionend MSTransitionEnd\\\", function () {\\n        _this._setSizes();\\n      });\\n    }\\n\\n    /**\\n     * Causes the $element to become unstuck.\\n     * Removes `position: fixed;`, and helper classes.\\n     * Adds other helper classes.\\n     * @param {Boolean} isTop - tells the function if the $element should anchor to the top or bottom of its $anchor element.\\n     * @fires Sticky#unstuckfrom\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_removeSticky',\\n    value: function _removeSticky(isTop) {\\n      var stickTo = this.options.stickTo,\\n          stickToTop = stickTo === 'top',\\n          css = {},\\n          anchorPt = (this.points ? this.points[1] - this.points[0] : this.anchorHeight) - this.elemHeight,\\n          mrgn = stickToTop ? 'marginTop' : 'marginBottom',\\n          notStuckTo = stickToTop ? 'bottom' : 'top',\\n          topOrBottom = isTop ? 'top' : 'bottom';\\n\\n      css[mrgn] = 0;\\n\\n      css['bottom'] = 'auto';\\n      if (isTop) {\\n        css['top'] = 0;\\n      } else {\\n        css['top'] = anchorPt;\\n      }\\n\\n      this.isStuck = false;\\n      this.$element.removeClass('is-stuck is-at-' + stickTo).addClass('is-anchored is-at-' + topOrBottom).css(css)\\n      /**\\n       * Fires when the $element has become anchored.\\n       * Namespaced to `top` or `bottom`, e.g. `sticky.zf.unstuckfrom:bottom`\\n       * @event Sticky#unstuckfrom\\n       */\\n      .trigger('sticky.zf.unstuckfrom:' + topOrBottom);\\n    }\\n\\n    /**\\n     * Sets the $element and $container sizes for plugin.\\n     * Calls `_setBreakPoints`.\\n     * @param {Function} cb - optional callback function to fire on completion of `_setBreakPoints`.\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_setSizes',\\n    value: function _setSizes(cb) {\\n      this.canStick = __WEBPACK_IMPORTED_MODULE_2__foundation_util_mediaQuery__[\\\"a\\\" /* MediaQuery */].is(this.options.stickyOn);\\n      if (!this.canStick) {\\n        if (cb && typeof cb === 'function') {\\n          cb();\\n        }\\n      }\\n      var _this = this,\\n          newElemWidth = this.$container[0].getBoundingClientRect().width,\\n          comp = window.getComputedStyle(this.$container[0]),\\n          pdngl = parseInt(comp['padding-left'], 10),\\n          pdngr = parseInt(comp['padding-right'], 10);\\n\\n      if (this.$anchor && this.$anchor.length) {\\n        this.anchorHeight = this.$anchor[0].getBoundingClientRect().height;\\n      } else {\\n        this._parsePoints();\\n      }\\n\\n      this.$element.css({\\n        'max-width': newElemWidth - pdngl - pdngr + 'px'\\n      });\\n\\n      var newContainerHeight = this.$element[0].getBoundingClientRect().height || this.containerHeight;\\n      if (this.$element.css(\\\"display\\\") == \\\"none\\\") {\\n        newContainerHeight = 0;\\n      }\\n      this.containerHeight = newContainerHeight;\\n      this.$container.css({\\n        height: newContainerHeight\\n      });\\n      this.elemHeight = newContainerHeight;\\n\\n      if (!this.isStuck) {\\n        if (this.$element.hasClass('is-at-bottom')) {\\n          var anchorPt = (this.points ? this.points[1] - this.$container.offset().top : this.anchorHeight) - this.elemHeight;\\n          this.$element.css('top', anchorPt);\\n        }\\n      }\\n\\n      this._setBreakPoints(newContainerHeight, function () {\\n        if (cb && typeof cb === 'function') {\\n          cb();\\n        }\\n      });\\n    }\\n\\n    /**\\n     * Sets the upper and lower breakpoints for the element to become sticky/unsticky.\\n     * @param {Number} elemHeight - px value for sticky.$element height, calculated by `_setSizes`.\\n     * @param {Function} cb - optional callback function to be called on completion.\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_setBreakPoints',\\n    value: function _setBreakPoints(elemHeight, cb) {\\n      if (!this.canStick) {\\n        if (cb && typeof cb === 'function') {\\n          cb();\\n        } else {\\n          return false;\\n        }\\n      }\\n      var mTop = emCalc(this.options.marginTop),\\n          mBtm = emCalc(this.options.marginBottom),\\n          topPoint = this.points ? this.points[0] : this.$anchor.offset().top,\\n          bottomPoint = this.points ? this.points[1] : topPoint + this.anchorHeight,\\n\\n      // topPoint = this.$anchor.offset().top || this.points[0],\\n      // bottomPoint = topPoint + this.anchorHeight || this.points[1],\\n      winHeight = window.innerHeight;\\n\\n      if (this.options.stickTo === 'top') {\\n        topPoint -= mTop;\\n        bottomPoint -= elemHeight + mTop;\\n      } else if (this.options.stickTo === 'bottom') {\\n        topPoint -= winHeight - (elemHeight + mBtm);\\n        bottomPoint -= winHeight - mBtm;\\n      } else {\\n        //this would be the stickTo: both option... tricky\\n      }\\n\\n      this.topPoint = topPoint;\\n      this.bottomPoint = bottomPoint;\\n\\n      if (cb && typeof cb === 'function') {\\n        cb();\\n      }\\n    }\\n\\n    /**\\n     * Destroys the current sticky element.\\n     * Resets the element to the top position first.\\n     * Removes event listeners, JS-added css properties and classes, and unwraps the $element if the JS added the $container.\\n     * @function\\n     */\\n\\n  }, {\\n    key: '_destroy',\\n    value: function _destroy() {\\n      this._removeSticky(true);\\n\\n      this.$element.removeClass(this.options.stickyClass + ' is-anchored is-at-top').css({\\n        height: '',\\n        top: '',\\n        bottom: '',\\n        'max-width': ''\\n      }).off('resizeme.zf.trigger').off('mutateme.zf.trigger');\\n      if (this.$anchor && this.$anchor.length) {\\n        this.$anchor.off('change.zf.sticky');\\n      }\\n      __WEBPACK_IMPORTED_MODULE_0_jquery___default()(window).off(this.scrollListener);\\n\\n      if (this.wasWrapped) {\\n        this.$element.unwrap();\\n      } else {\\n        this.$container.removeClass(this.options.containerClass).css({\\n          height: ''\\n        });\\n      }\\n    }\\n  }]);\\n\\n  return Sticky;\\n}(__WEBPACK_IMPORTED_MODULE_3__foundation_plugin__[\\\"a\\\" /* Plugin */]);\\n\\nSticky.defaults = {\\n  /**\\n   * Customizable container template. Add your own classes for styling and sizing.\\n   * @option\\n   * @type {string}\\n   * @default '&lt;div data-sticky-container&gt;&lt;/div&gt;'\\n   */\\n  container: '<div data-sticky-container></div>',\\n  /**\\n   * Location in the view the element sticks to. Can be `'top'` or `'bottom'`.\\n   * @option\\n   * @type {string}\\n   * @default 'top'\\n   */\\n  stickTo: 'top',\\n  /**\\n   * If anchored to a single element, the id of that element.\\n   * @option\\n   * @type {string}\\n   * @default ''\\n   */\\n  anchor: '',\\n  /**\\n   * If using more than one element as anchor points, the id of the top anchor.\\n   * @option\\n   * @type {string}\\n   * @default ''\\n   */\\n  topAnchor: '',\\n  /**\\n   * If using more than one element as anchor points, the id of the bottom anchor.\\n   * @option\\n   * @type {string}\\n   * @default ''\\n   */\\n  btmAnchor: '',\\n  /**\\n   * Margin, in `em`'s to apply to the top of the element when it becomes sticky.\\n   * @option\\n   * @type {number}\\n   * @default 1\\n   */\\n  marginTop: 1,\\n  /**\\n   * Margin, in `em`'s to apply to the bottom of the element when it becomes sticky.\\n   * @option\\n   * @type {number}\\n   * @default 1\\n   */\\n  marginBottom: 1,\\n  /**\\n   * Breakpoint string that is the minimum screen size an element should become sticky.\\n   * @option\\n   * @type {string}\\n   * @default 'medium'\\n   */\\n  stickyOn: 'medium',\\n  /**\\n   * Class applied to sticky element, and removed on destruction. Foundation defaults to `sticky`.\\n   * @option\\n   * @type {string}\\n   * @default 'sticky'\\n   */\\n  stickyClass: 'sticky',\\n  /**\\n   * Class applied to sticky container. Foundation defaults to `sticky-container`.\\n   * @option\\n   * @type {string}\\n   * @default 'sticky-container'\\n   */\\n  containerClass: 'sticky-container',\\n  /**\\n   * Number of scroll events between the plugin's recalculating sticky points. Setting it to `0` will cause it to recalc every scroll event, setting it to `-1` will prevent recalc on scroll.\\n   * @option\\n   * @type {number}\\n   * @default -1\\n   */\\n  checkEvery: -1\\n};\\n\\n/**\\n * Helper function to calculate em values\\n * @param Number {em} - number of em's to calculate into pixels\\n */\\nfunction emCalc(em) {\\n  return parseInt(window.getComputedStyle(document.body, null).fontSize, 10) * em;\\n}\\n\\n\\n\\n/***/ }),\\n/* 34 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return Toggler; });\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jquery__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__foundation_util_motion__ = __webpack_require__(6);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__foundation_plugin__ = __webpack_require__(2);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__foundation_util_triggers__ = __webpack_require__(5);\\n\\n\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return call && (typeof call === \\\"object\\\" || typeof call === \\\"function\\\") ? call : self; }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function, not \\\" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\n\\n\\n\\n\\n\\n/**\\n * Toggler module.\\n * @module foundation.toggler\\n * @requires foundation.util.motion\\n * @requires foundation.util.triggers\\n */\\n\\nvar Toggler = function (_Plugin) {\\n  _inherits(Toggler, _Plugin);\\n\\n  function Toggler() {\\n    _classCallCheck(this, Toggler);\\n\\n    return _possibleConstructorReturn(this, (Toggler.__proto__ || Object.getPrototypeOf(Toggler)).apply(this, arguments));\\n  }\\n\\n  _createClass(Toggler, [{\\n    key: '_setup',\\n\\n    /**\\n     * Creates a new instance of Toggler.\\n     * @class\\n     * @name Toggler\\n     * @fires Toggler#init\\n     * @param {Object} element - jQuery object to add the trigger to.\\n     * @param {Object} options - Overrides to the default plugin settings.\\n     */\\n    value: function _setup(element, options) {\\n      this.$element = element;\\n      this.options = __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.extend({}, Toggler.defaults, element.data(), options);\\n      this.className = '';\\n      this.className = 'Toggler'; // ie9 back compat\\n\\n      // Triggers init is idempotent, just need to make sure it is initialized\\n      __WEBPACK_IMPORTED_MODULE_3__foundation_util_triggers__[\\\"a\\\" /* Triggers */].init(__WEBPACK_IMPORTED_MODULE_0_jquery___default.a);\\n\\n      this._init();\\n      this._events();\\n    }\\n\\n    /**\\n     * Initializes the Toggler plugin by parsing the toggle class from data-toggler, or animation classes from data-animate.\\n     * @function\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_init',\\n    value: function _init() {\\n      var input;\\n      // Parse animation classes if they were set\\n      if (this.options.animate) {\\n        input = this.options.animate.split(' ');\\n\\n        this.animationIn = input[0];\\n        this.animationOut = input[1] || null;\\n      }\\n      // Otherwise, parse toggle class\\n      else {\\n          input = this.$element.data('toggler');\\n          // Allow for a . at the beginning of the string\\n          this.className = input[0] === '.' ? input.slice(1) : input;\\n        }\\n\\n      // Add ARIA attributes to triggers\\n      var id = this.$element[0].id;\\n      __WEBPACK_IMPORTED_MODULE_0_jquery___default()('[data-open=\\\"' + id + '\\\"], [data-close=\\\"' + id + '\\\"], [data-toggle=\\\"' + id + '\\\"]').attr('aria-controls', id);\\n      // If the target is hidden, add aria-hidden\\n      this.$element.attr('aria-expanded', this.$element.is(':hidden') ? false : true);\\n    }\\n\\n    /**\\n     * Initializes events for the toggle trigger.\\n     * @function\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_events',\\n    value: function _events() {\\n      this.$element.off('toggle.zf.trigger').on('toggle.zf.trigger', this.toggle.bind(this));\\n    }\\n\\n    /**\\n     * Toggles the target class on the target element. An event is fired from the original trigger depending on if the resultant state was \\\"on\\\" or \\\"off\\\".\\n     * @function\\n     * @fires Toggler#on\\n     * @fires Toggler#off\\n     */\\n\\n  }, {\\n    key: 'toggle',\\n    value: function toggle() {\\n      this[this.options.animate ? '_toggleAnimate' : '_toggleClass']();\\n    }\\n  }, {\\n    key: '_toggleClass',\\n    value: function _toggleClass() {\\n      this.$element.toggleClass(this.className);\\n\\n      var isOn = this.$element.hasClass(this.className);\\n      if (isOn) {\\n        /**\\n         * Fires if the target element has the class after a toggle.\\n         * @event Toggler#on\\n         */\\n        this.$element.trigger('on.zf.toggler');\\n      } else {\\n        /**\\n         * Fires if the target element does not have the class after a toggle.\\n         * @event Toggler#off\\n         */\\n        this.$element.trigger('off.zf.toggler');\\n      }\\n\\n      this._updateARIA(isOn);\\n      this.$element.find('[data-mutate]').trigger('mutateme.zf.trigger');\\n    }\\n  }, {\\n    key: '_toggleAnimate',\\n    value: function _toggleAnimate() {\\n      var _this = this;\\n\\n      if (this.$element.is(':hidden')) {\\n        __WEBPACK_IMPORTED_MODULE_1__foundation_util_motion__[\\\"a\\\" /* Motion */].animateIn(this.$element, this.animationIn, function () {\\n          _this._updateARIA(true);\\n          this.trigger('on.zf.toggler');\\n          this.find('[data-mutate]').trigger('mutateme.zf.trigger');\\n        });\\n      } else {\\n        __WEBPACK_IMPORTED_MODULE_1__foundation_util_motion__[\\\"a\\\" /* Motion */].animateOut(this.$element, this.animationOut, function () {\\n          _this._updateARIA(false);\\n          this.trigger('off.zf.toggler');\\n          this.find('[data-mutate]').trigger('mutateme.zf.trigger');\\n        });\\n      }\\n    }\\n  }, {\\n    key: '_updateARIA',\\n    value: function _updateARIA(isOn) {\\n      this.$element.attr('aria-expanded', isOn ? true : false);\\n    }\\n\\n    /**\\n     * Destroys the instance of Toggler on the element.\\n     * @function\\n     */\\n\\n  }, {\\n    key: '_destroy',\\n    value: function _destroy() {\\n      this.$element.off('.zf.toggler');\\n    }\\n  }]);\\n\\n  return Toggler;\\n}(__WEBPACK_IMPORTED_MODULE_2__foundation_plugin__[\\\"a\\\" /* Plugin */]);\\n\\nToggler.defaults = {\\n  /**\\n   * Tells the plugin if the element should animated when toggled.\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  animate: false\\n};\\n\\n\\n\\n/***/ }),\\n/* 35 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return Tooltip; });\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jquery__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__foundation_util_core__ = __webpack_require__(1);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__foundation_util_mediaQuery__ = __webpack_require__(4);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__foundation_util_triggers__ = __webpack_require__(5);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__foundation_positionable__ = __webpack_require__(15);\\n\\n\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\\\"value\\\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return call && (typeof call === \\\"object\\\" || typeof call === \\\"function\\\") ? call : self; }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function, not \\\" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\n\\n\\n\\n\\n\\n\\n\\n/**\\n * Tooltip module.\\n * @module foundation.tooltip\\n * @requires foundation.util.box\\n * @requires foundation.util.mediaQuery\\n * @requires foundation.util.triggers\\n */\\n\\nvar Tooltip = function (_Positionable) {\\n  _inherits(Tooltip, _Positionable);\\n\\n  function Tooltip() {\\n    _classCallCheck(this, Tooltip);\\n\\n    return _possibleConstructorReturn(this, (Tooltip.__proto__ || Object.getPrototypeOf(Tooltip)).apply(this, arguments));\\n  }\\n\\n  _createClass(Tooltip, [{\\n    key: '_setup',\\n\\n    /**\\n     * Creates a new instance of a Tooltip.\\n     * @class\\n     * @name Tooltip\\n     * @fires Tooltip#init\\n     * @param {jQuery} element - jQuery object to attach a tooltip to.\\n     * @param {Object} options - object to extend the default configuration.\\n     */\\n    value: function _setup(element, options) {\\n      this.$element = element;\\n      this.options = __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.extend({}, Tooltip.defaults, this.$element.data(), options);\\n      this.className = 'Tooltip'; // ie9 back compat\\n\\n      this.isActive = false;\\n      this.isClick = false;\\n\\n      // Triggers init is idempotent, just need to make sure it is initialized\\n      __WEBPACK_IMPORTED_MODULE_3__foundation_util_triggers__[\\\"a\\\" /* Triggers */].init(__WEBPACK_IMPORTED_MODULE_0_jquery___default.a);\\n\\n      this._init();\\n    }\\n\\n    /**\\n     * Initializes the tooltip by setting the creating the tip element, adding it's text, setting private variables and setting attributes on the anchor.\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_init',\\n    value: function _init() {\\n      __WEBPACK_IMPORTED_MODULE_2__foundation_util_mediaQuery__[\\\"a\\\" /* MediaQuery */]._init();\\n      var elemId = this.$element.attr('aria-describedby') || __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__foundation_util_core__[\\\"b\\\" /* GetYoDigits */])(6, 'tooltip');\\n\\n      this.options.tipText = this.options.tipText || this.$element.attr('title');\\n      this.template = this.options.template ? __WEBPACK_IMPORTED_MODULE_0_jquery___default()(this.options.template) : this._buildTemplate(elemId);\\n\\n      if (this.options.allowHtml) {\\n        this.template.appendTo(document.body).html(this.options.tipText).hide();\\n      } else {\\n        this.template.appendTo(document.body).text(this.options.tipText).hide();\\n      }\\n\\n      this.$element.attr({\\n        'title': '',\\n        'aria-describedby': elemId,\\n        'data-yeti-box': elemId,\\n        'data-toggle': elemId,\\n        'data-resize': elemId\\n      }).addClass(this.options.triggerClass);\\n\\n      _get(Tooltip.prototype.__proto__ || Object.getPrototypeOf(Tooltip.prototype), '_init', this).call(this);\\n      this._events();\\n    }\\n  }, {\\n    key: '_getDefaultPosition',\\n    value: function _getDefaultPosition() {\\n      // handle legacy classnames\\n      var position = this.$element[0].className.match(/\\\\b(top|left|right|bottom)\\\\b/g);\\n      return position ? position[0] : 'top';\\n    }\\n  }, {\\n    key: '_getDefaultAlignment',\\n    value: function _getDefaultAlignment() {\\n      return 'center';\\n    }\\n  }, {\\n    key: '_getHOffset',\\n    value: function _getHOffset() {\\n      if (this.position === 'left' || this.position === 'right') {\\n        return this.options.hOffset + this.options.tooltipWidth;\\n      } else {\\n        return this.options.hOffset;\\n      }\\n    }\\n  }, {\\n    key: '_getVOffset',\\n    value: function _getVOffset() {\\n      if (this.position === 'top' || this.position === 'bottom') {\\n        return this.options.vOffset + this.options.tooltipHeight;\\n      } else {\\n        return this.options.vOffset;\\n      }\\n    }\\n\\n    /**\\n     * builds the tooltip element, adds attributes, and returns the template.\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_buildTemplate',\\n    value: function _buildTemplate(id) {\\n      var templateClasses = (this.options.tooltipClass + ' ' + this.options.positionClass + ' ' + this.options.templateClasses).trim();\\n      var $template = __WEBPACK_IMPORTED_MODULE_0_jquery___default()('<div></div>').addClass(templateClasses).attr({\\n        'role': 'tooltip',\\n        'aria-hidden': true,\\n        'data-is-active': false,\\n        'data-is-focus': false,\\n        'id': id\\n      });\\n      return $template;\\n    }\\n\\n    /**\\n     * sets the position class of an element and recursively calls itself until there are no more possible positions to attempt, or the tooltip element is no longer colliding.\\n     * if the tooltip is larger than the screen width, default to full width - any user selected margin\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_setPosition',\\n    value: function _setPosition() {\\n      _get(Tooltip.prototype.__proto__ || Object.getPrototypeOf(Tooltip.prototype), '_setPosition', this).call(this, this.$element, this.template);\\n    }\\n\\n    /**\\n     * reveals the tooltip, and fires an event to close any other open tooltips on the page\\n     * @fires Tooltip#closeme\\n     * @fires Tooltip#show\\n     * @function\\n     */\\n\\n  }, {\\n    key: 'show',\\n    value: function show() {\\n      if (this.options.showOn !== 'all' && !__WEBPACK_IMPORTED_MODULE_2__foundation_util_mediaQuery__[\\\"a\\\" /* MediaQuery */].is(this.options.showOn)) {\\n        // console.error('The screen is too small to display this tooltip');\\n        return false;\\n      }\\n\\n      var _this = this;\\n      this.template.css('visibility', 'hidden').show();\\n      this._setPosition();\\n      this.template.removeClass('top bottom left right').addClass(this.position);\\n      this.template.removeClass('align-top align-bottom align-left align-right align-center').addClass('align-' + this.alignment);\\n\\n      /**\\n       * Fires to close all other open tooltips on the page\\n       * @event Closeme#tooltip\\n       */\\n      this.$element.trigger('closeme.zf.tooltip', this.template.attr('id'));\\n\\n      this.template.attr({\\n        'data-is-active': true,\\n        'aria-hidden': false\\n      });\\n      _this.isActive = true;\\n      // console.log(this.template);\\n      this.template.stop().hide().css('visibility', '').fadeIn(this.options.fadeInDuration, function () {\\n        //maybe do stuff?\\n      });\\n      /**\\n       * Fires when the tooltip is shown\\n       * @event Tooltip#show\\n       */\\n      this.$element.trigger('show.zf.tooltip');\\n    }\\n\\n    /**\\n     * Hides the current tooltip, and resets the positioning class if it was changed due to collision\\n     * @fires Tooltip#hide\\n     * @function\\n     */\\n\\n  }, {\\n    key: 'hide',\\n    value: function hide() {\\n      // console.log('hiding', this.$element.data('yeti-box'));\\n      var _this = this;\\n      this.template.stop().attr({\\n        'aria-hidden': true,\\n        'data-is-active': false\\n      }).fadeOut(this.options.fadeOutDuration, function () {\\n        _this.isActive = false;\\n        _this.isClick = false;\\n      });\\n      /**\\n       * fires when the tooltip is hidden\\n       * @event Tooltip#hide\\n       */\\n      this.$element.trigger('hide.zf.tooltip');\\n    }\\n\\n    /**\\n     * adds event listeners for the tooltip and its anchor\\n     * TODO combine some of the listeners like focus and mouseenter, etc.\\n     * @private\\n     */\\n\\n  }, {\\n    key: '_events',\\n    value: function _events() {\\n      var _this = this;\\n      var $template = this.template;\\n      var isFocus = false;\\n\\n      if (!this.options.disableHover) {\\n\\n        this.$element.on('mouseenter.zf.tooltip', function (e) {\\n          if (!_this.isActive) {\\n            _this.timeout = setTimeout(function () {\\n              _this.show();\\n            }, _this.options.hoverDelay);\\n          }\\n        }).on('mouseleave.zf.tooltip', function (e) {\\n          clearTimeout(_this.timeout);\\n          if (!isFocus || _this.isClick && !_this.options.clickOpen) {\\n            _this.hide();\\n          }\\n        });\\n      }\\n\\n      if (this.options.clickOpen) {\\n        this.$element.on('mousedown.zf.tooltip', function (e) {\\n          e.stopImmediatePropagation();\\n          if (_this.isClick) {\\n            //_this.hide();\\n            // _this.isClick = false;\\n          } else {\\n            _this.isClick = true;\\n            if ((_this.options.disableHover || !_this.$element.attr('tabindex')) && !_this.isActive) {\\n              _this.show();\\n            }\\n          }\\n        });\\n      } else {\\n        this.$element.on('mousedown.zf.tooltip', function (e) {\\n          e.stopImmediatePropagation();\\n          _this.isClick = true;\\n        });\\n      }\\n\\n      if (!this.options.disableForTouch) {\\n        this.$element.on('tap.zf.tooltip touchend.zf.tooltip', function (e) {\\n          _this.isActive ? _this.hide() : _this.show();\\n        });\\n      }\\n\\n      this.$element.on({\\n        // 'toggle.zf.trigger': this.toggle.bind(this),\\n        // 'close.zf.trigger': this.hide.bind(this)\\n        'close.zf.trigger': this.hide.bind(this)\\n      });\\n\\n      this.$element.on('focus.zf.tooltip', function (e) {\\n        isFocus = true;\\n        if (_this.isClick) {\\n          // If we're not showing open on clicks, we need to pretend a click-launched focus isn't\\n          // a real focus, otherwise on hover and come back we get bad behavior\\n          if (!_this.options.clickOpen) {\\n            isFocus = false;\\n          }\\n          return false;\\n        } else {\\n          _this.show();\\n        }\\n      }).on('focusout.zf.tooltip', function (e) {\\n        isFocus = false;\\n        _this.isClick = false;\\n        _this.hide();\\n      }).on('resizeme.zf.trigger', function () {\\n        if (_this.isActive) {\\n          _this._setPosition();\\n        }\\n      });\\n    }\\n\\n    /**\\n     * adds a toggle method, in addition to the static show() & hide() functions\\n     * @function\\n     */\\n\\n  }, {\\n    key: 'toggle',\\n    value: function toggle() {\\n      if (this.isActive) {\\n        this.hide();\\n      } else {\\n        this.show();\\n      }\\n    }\\n\\n    /**\\n     * Destroys an instance of tooltip, removes template element from the view.\\n     * @function\\n     */\\n\\n  }, {\\n    key: '_destroy',\\n    value: function _destroy() {\\n      this.$element.attr('title', this.template.text()).off('.zf.trigger .zf.tooltip').removeClass('has-tip top right left').removeAttr('aria-describedby aria-haspopup data-disable-hover data-resize data-toggle data-tooltip data-yeti-box');\\n\\n      this.template.remove();\\n    }\\n  }]);\\n\\n  return Tooltip;\\n}(__WEBPACK_IMPORTED_MODULE_4__foundation_positionable__[\\\"a\\\" /* Positionable */]);\\n\\nTooltip.defaults = {\\n  disableForTouch: false,\\n  /**\\n   * Time, in ms, before a tooltip should open on hover.\\n   * @option\\n   * @type {number}\\n   * @default 200\\n   */\\n  hoverDelay: 200,\\n  /**\\n   * Time, in ms, a tooltip should take to fade into view.\\n   * @option\\n   * @type {number}\\n   * @default 150\\n   */\\n  fadeInDuration: 150,\\n  /**\\n   * Time, in ms, a tooltip should take to fade out of view.\\n   * @option\\n   * @type {number}\\n   * @default 150\\n   */\\n  fadeOutDuration: 150,\\n  /**\\n   * Disables hover events from opening the tooltip if set to true\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  disableHover: false,\\n  /**\\n   * Optional addtional classes to apply to the tooltip template on init.\\n   * @option\\n   * @type {string}\\n   * @default ''\\n   */\\n  templateClasses: '',\\n  /**\\n   * Non-optional class added to tooltip templates. Foundation default is 'tooltip'.\\n   * @option\\n   * @type {string}\\n   * @default 'tooltip'\\n   */\\n  tooltipClass: 'tooltip',\\n  /**\\n   * Class applied to the tooltip anchor element.\\n   * @option\\n   * @type {string}\\n   * @default 'has-tip'\\n   */\\n  triggerClass: 'has-tip',\\n  /**\\n   * Minimum breakpoint size at which to open the tooltip.\\n   * @option\\n   * @type {string}\\n   * @default 'small'\\n   */\\n  showOn: 'small',\\n  /**\\n   * Custom template to be used to generate markup for tooltip.\\n   * @option\\n   * @type {string}\\n   * @default ''\\n   */\\n  template: '',\\n  /**\\n   * Text displayed in the tooltip template on open.\\n   * @option\\n   * @type {string}\\n   * @default ''\\n   */\\n  tipText: '',\\n  touchCloseText: 'Tap to close.',\\n  /**\\n   * Allows the tooltip to remain open if triggered with a click or touch event.\\n   * @option\\n   * @type {boolean}\\n   * @default true\\n   */\\n  clickOpen: true,\\n  /**\\n   * DEPRECATED Additional positioning classes, set by the JS\\n   * @option\\n   * @type {string}\\n   * @default ''\\n   */\\n  positionClass: '',\\n  /**\\n   * Position of tooltip. Can be left, right, bottom, top, or auto.\\n   * @option\\n   * @type {string}\\n   * @default 'auto'\\n   */\\n  position: 'auto',\\n  /**\\n   * Alignment of tooltip relative to anchor. Can be left, right, bottom, top, center, or auto.\\n   * @option\\n   * @type {string}\\n   * @default 'auto'\\n   */\\n  alignment: 'auto',\\n  /**\\n   * Allow overlap of container/window. If false, tooltip will first try to\\n   * position as defined by data-position and data-alignment, but reposition if\\n   * it would cause an overflow.  @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  allowOverlap: false,\\n  /**\\n   * Allow overlap of only the bottom of the container. This is the most common\\n   * behavior for dropdowns, allowing the dropdown to extend the bottom of the\\n   * screen but not otherwise influence or break out of the container.\\n   * Less common for tooltips.\\n   * @option\\n   * @type {boolean}\\n   * @default false\\n   */\\n  allowBottomOverlap: false,\\n  /**\\n   * Distance, in pixels, the template should push away from the anchor on the Y axis.\\n   * @option\\n   * @type {number}\\n   * @default 0\\n   */\\n  vOffset: 0,\\n  /**\\n   * Distance, in pixels, the template should push away from the anchor on the X axis\\n   * @option\\n   * @type {number}\\n   * @default 0\\n   */\\n  hOffset: 0,\\n  /**\\n   * Distance, in pixels, the template spacing auto-adjust for a vertical tooltip\\n   * @option\\n   * @type {number}\\n   * @default 14\\n   */\\n  tooltipHeight: 14,\\n  /**\\n   * Distance, in pixels, the template spacing auto-adjust for a horizontal tooltip\\n   * @option\\n   * @type {number}\\n   * @default 12\\n   */\\n  tooltipWidth: 12,\\n  /**\\n  * Allow HTML in tooltip. Warning: If you are loading user-generated content into tooltips,\\n  * allowing HTML may open yourself up to XSS attacks.\\n  * @option\\n  * @type {boolean}\\n  * @default false\\n  */\\n  allowHtml: false\\n};\\n\\n/**\\n * TODO utilize resize event trigger\\n */\\n\\n\\n\\n/***/ }),\\n/* 36 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\nmodule.exports = __webpack_require__(19);\\n\\n\\n/***/ })\\n/******/ ]);\"//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZm91bmRhdGlvbi1zaXRlcy9kaXN0L2pzL2ZvdW5kYXRpb24uanM/MWQxZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSwrQ0FBK0MsMkZBQTJGLG1HQUFtRyxzR0FBc0csMkRBQTJELGdCQUFnQiwySEFBMkgsbUZBQW1GLGlCQUFpQiwwSkFBMEosb0ZBQW9GLGlHQUFpRyxjQUFjLGdJQUFnSSx1R0FBdUcsc0pBQXNKLGNBQWMsR0FBRywwSUFBMEksMERBQTBELHVEQUF1RCwySEFBMkgsRUFBRSxnQkFBZ0IsZUFBZSxxSkFBcUosaUdBQWlHLDBCQUEwQixFQUFFLGdEQUFnRCxlQUFlLEdBQUcsMERBQTBELDZCQUE2QixlQUFlLCtIQUErSCwrREFBK0QsR0FBRywyRkFBMkYsa0lBQWtJLFlBQVksdUlBQXVJLDRCQUE0QixXQUFXLGdGQUFnRixtQkFBbUIsK0ZBQStGLFlBQVksRUFBRSxFQUFFLCtGQUErRixvQkFBb0IsRUFBRSxFQUFFLCtGQUErRixzQkFBc0IsRUFBRSxFQUFFLHlGQUF5RixzSUFBc0ksMklBQTJJLHdGQUF3RixHQUFHLG9GQUFvRixPQUFPLGlHQUFpRyxPQUFPLCtFQUErRSxPQUFPLG1GQUFtRixPQUFPLDREQUE0RCx5QkFBeUIsa0pBQWtKLEdBQUcsbUNBQW1DLHVCQUF1QixzS0FBc0sseURBQXlELGtDQUFrQyxpREFBaUQsNkJBQTZCLE9BQU8sS0FBSyxjQUFjLGlCQUFpQixLQUFLLE9BQU8sb0NBQW9DLHVEQUF1RCxPQUFPLEtBQUssNkJBQTZCLEtBQUssR0FBRyxlQUFlLGdGQUFnRixtQkFBbUIsK0ZBQStGLGVBQWUsRUFBRSxFQUFFLHlGQUF5RixzSUFBc0ksd0dBQXdHLHNDQUFzQywyQ0FBMkMsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHlEQUF5RCwyREFBMkQsRUFBRSxFQUFFLHlEQUF5RCxxRUFBcUUsNkRBQTZELG9CQUFvQixHQUFHLEVBQUUs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QkFBK0IsaUNBQWlDLFdBQVcsU0FBUyxFQUFFLE9BQU8sK0hBQStILEdBQUcsb0RBQW9ELDRCQUE0QixzQkFBc0IsU0FBUyxPQUFPLHNCQUFzQixTQUFTLE9BQU8sOEhBQThILEdBQUcsd0RBQXdELGtQQUFrUCxpQ0FBaUMsT0FBTyxLQUFLLEdBQUcscUJBQXFCLEdBQUcsbUZBQW1GLHdCQUF3Qix3SEFBd0gsT0FBTyw2SUFBNkksT0FBTyxtSkFBbUosT0FBTywwSkFBMEosUUFBUSxrS0FBa0ssT0FBTywwS0FBMEssT0FBTyxrSkFBa0osT0FBTywySkFBMkosT0FBTyxzSkFBc0osT0FBTyxtSUFBbUksT0FBTyxrTUFBa00sUUFBUSxpSkFBaUosT0FBTyx1SkFBdUosT0FBTyxzTEFBc0wsT0FBTyxpUkFBaVIsUUFBUSxnV0FBZ1csUUFBUSxxTEFBcUwsT0FBTyxpS0FBaUssT0FBTyw2SkFBNkosT0FBTyx1S0FBdUssT0FBTyxxT0FBcU8sUUFBUSxrREFBa0QsaUVBQWlFLHFFQUFxRSw2Q0FBNkMsYUFBYSxlQUFlIiwiZmlsZSI6IjUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxcbi8qKioqKiovIFxcdC8vIFRoZSBtb2R1bGUgY2FjaGVcXG4vKioqKioqLyBcXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xcbi8qKioqKiovXFxuLyoqKioqKi8gXFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cXG4vKioqKioqLyBcXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XFxuLyoqKioqKi9cXG4vKioqKioqLyBcXHRcXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcXG4vKioqKioqLyBcXHRcXHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xcbi8qKioqKiovIFxcdFxcdFxcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xcbi8qKioqKiovIFxcdFxcdH1cXG4vKioqKioqLyBcXHRcXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxcbi8qKioqKiovIFxcdFxcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcXG4vKioqKioqLyBcXHRcXHRcXHRpOiBtb2R1bGVJZCxcXG4vKioqKioqLyBcXHRcXHRcXHRsOiBmYWxzZSxcXG4vKioqKioqLyBcXHRcXHRcXHRleHBvcnRzOiB7fVxcbi8qKioqKiovIFxcdFxcdH07XFxuLyoqKioqKi9cXG4vKioqKioqLyBcXHRcXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cXG4vKioqKioqLyBcXHRcXHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcXG4vKioqKioqL1xcbi8qKioqKiovIFxcdFxcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcXG4vKioqKioqLyBcXHRcXHRtb2R1bGUubCA9IHRydWU7XFxuLyoqKioqKi9cXG4vKioqKioqLyBcXHRcXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxcbi8qKioqKiovIFxcdFxcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcXG4vKioqKioqLyBcXHR9XFxuLyoqKioqKi9cXG4vKioqKioqL1xcbi8qKioqKiovIFxcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXFxuLyoqKioqKi8gXFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcXG4vKioqKioqL1xcbi8qKioqKiovIFxcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXFxuLyoqKioqKi8gXFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcXG4vKioqKioqL1xcbi8qKioqKiovIFxcdC8vIGlkZW50aXR5IGZ1bmN0aW9uIGZvciBjYWxsaW5nIGhhcm1vbnkgaW1wb3J0cyB3aXRoIHRoZSBjb3JyZWN0IGNvbnRleHRcXG4vKioqKioqLyBcXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmkgPSBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gdmFsdWU7IH07XFxuLyoqKioqKi9cXG4vKioqKioqLyBcXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcXG4vKioqKioqLyBcXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcXG4vKioqKioqLyBcXHRcXHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XFxuLyoqKioqKi8gXFx0XFx0XFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcXG4vKioqKioqLyBcXHRcXHRcXHRcXHRjb25maWd1cmFibGU6IGZhbHNlLFxcbi8qKioqKiovIFxcdFxcdFxcdFxcdGVudW1lcmFibGU6IHRydWUsXFxuLyoqKioqKi8gXFx0XFx0XFx0XFx0Z2V0OiBnZXR0ZXJcXG4vKioqKioqLyBcXHRcXHRcXHR9KTtcXG4vKioqKioqLyBcXHRcXHR9XFxuLyoqKioqKi8gXFx0fTtcXG4vKioqKioqL1xcbi8qKioqKiovIFxcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXFxuLyoqKioqKi8gXFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XFxuLyoqKioqKi8gXFx0XFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XFxuLyoqKioqKi8gXFx0XFx0XFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcXG4vKioqKioqLyBcXHRcXHRcXHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xcbi8qKioqKiovIFxcdFxcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcXG4vKioqKioqLyBcXHRcXHRyZXR1cm4gZ2V0dGVyO1xcbi8qKioqKiovIFxcdH07XFxuLyoqKioqKi9cXG4vKioqKioqLyBcXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcXG4vKioqKioqLyBcXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XFxuLyoqKioqKi9cXG4vKioqKioqLyBcXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xcbi8qKioqKiovIFxcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFxcXCJcXFwiO1xcbi8qKioqKiovXFxuLyoqKioqKi8gXFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXFxuLyoqKioqKi8gXFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMzYpO1xcbi8qKioqKiovIH0pXFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKioqKioqLyAoW1xcbi8qIDAgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBqUXVlcnk7XFxuXFxuLyoqKi8gfSksXFxuLyogMSAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXFwidXNlIHN0cmljdFxcXCI7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiYVxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gcnRsOyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJiXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBHZXRZb0RpZ2l0czsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiY1xcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJhbnNpdGlvbmVuZDsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0ID0gX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfXyk7XFxuXFxuXFxuXFxuXFxuLy8gQ29yZSBGb3VuZGF0aW9uIFV0aWxpdGllcywgdXRpbGl6ZWQgaW4gYSBudW1iZXIgb2YgcGxhY2VzLlxcblxcbi8qKlxcbiAqIFJldHVybnMgYSBib29sZWFuIGZvciBSVEwgc3VwcG9ydFxcbiAqL1xcbmZ1bmN0aW9uIHJ0bCgpIHtcXG4gIHJldHVybiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKCdodG1sJykuYXR0cignZGlyJykgPT09ICdydGwnO1xcbn1cXG5cXG4vKipcXG4gKiByZXR1cm5zIGEgcmFuZG9tIGJhc2UtMzYgdWlkIHdpdGggbmFtZXNwYWNpbmdcXG4gKiBAZnVuY3Rpb25cXG4gKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoIC0gbnVtYmVyIG9mIHJhbmRvbSBiYXNlLTM2IGRpZ2l0cyBkZXNpcmVkLiBJbmNyZWFzZSBmb3IgbW9yZSByYW5kb20gc3RyaW5ncy5cXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlIC0gbmFtZSBvZiBwbHVnaW4gdG8gYmUgaW5jb3Jwb3JhdGVkIGluIHVpZCwgb3B0aW9uYWwuXFxuICogQGRlZmF1bHQge1N0cmluZ30gJycgLSBpZiBubyBwbHVnaW4gbmFtZSBpcyBwcm92aWRlZCwgbm90aGluZyBpcyBhcHBlbmRlZCB0byB0aGUgdWlkLlxcbiAqIEByZXR1cm5zIHtTdHJpbmd9IC0gdW5pcXVlIGlkXFxuICovXFxuZnVuY3Rpb24gR2V0WW9EaWdpdHMobGVuZ3RoLCBuYW1lc3BhY2UpIHtcXG4gIGxlbmd0aCA9IGxlbmd0aCB8fCA2O1xcbiAgcmV0dXJuIE1hdGgucm91bmQoTWF0aC5wb3coMzYsIGxlbmd0aCArIDEpIC0gTWF0aC5yYW5kb20oKSAqIE1hdGgucG93KDM2LCBsZW5ndGgpKS50b1N0cmluZygzNikuc2xpY2UoMSkgKyAobmFtZXNwYWNlID8gJy0nICsgbmFtZXNwYWNlIDogJycpO1xcbn1cXG5cXG5mdW5jdGlvbiB0cmFuc2l0aW9uZW5kKCRlbGVtKSB7XFxuICB2YXIgdHJhbnNpdGlvbnMgPSB7XFxuICAgICd0cmFuc2l0aW9uJzogJ3RyYW5zaXRpb25lbmQnLFxcbiAgICAnV2Via2l0VHJhbnNpdGlvbic6ICd3ZWJraXRUcmFuc2l0aW9uRW5kJyxcXG4gICAgJ01velRyYW5zaXRpb24nOiAndHJhbnNpdGlvbmVuZCcsXFxuICAgICdPVHJhbnNpdGlvbic6ICdvdHJhbnNpdGlvbmVuZCdcXG4gIH07XFxuICB2YXIgZWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxcbiAgICAgIGVuZDtcXG5cXG4gIGZvciAodmFyIHQgaW4gdHJhbnNpdGlvbnMpIHtcXG4gICAgaWYgKHR5cGVvZiBlbGVtLnN0eWxlW3RdICE9PSAndW5kZWZpbmVkJykge1xcbiAgICAgIGVuZCA9IHRyYW5zaXRpb25zW3RdO1xcbiAgICB9XFxuICB9XFxuICBpZiAoZW5kKSB7XFxuICAgIHJldHVybiBlbmQ7XFxuICB9IGVsc2Uge1xcbiAgICBlbmQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG4gICAgICAkZWxlbS50cmlnZ2VySGFuZGxlcigndHJhbnNpdGlvbmVuZCcsIFskZWxlbV0pO1xcbiAgICB9LCAxKTtcXG4gICAgcmV0dXJuICd0cmFuc2l0aW9uZW5kJztcXG4gIH1cXG59XFxuXFxuXFxuXFxuLyoqKi8gfSksXFxuLyogMiAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXFwidXNlIHN0cmljdFxcXCI7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiYVxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gUGx1Z2luOyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLm4oX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19mb3VuZGF0aW9uX3V0aWxfY29yZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcXG5cXG5cXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFxcXCJ2YWx1ZVxcXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcXG5cXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpOyB9IH1cXG5cXG5cXG5cXG5cXG4vLyBBYnN0cmFjdCBjbGFzcyBmb3IgcHJvdmlkaW5nIGxpZmVjeWNsZSBob29rcy4gRXhwZWN0IHBsdWdpbnMgdG8gZGVmaW5lIEFUIExFQVNUXFxuLy8ge2Z1bmN0aW9ufSBfc2V0dXAgKHJlcGxhY2VzIHByZXZpb3VzIGNvbnN0cnVjdG9yKSxcXG4vLyB7ZnVuY3Rpb259IF9kZXN0cm95IChyZXBsYWNlcyBwcmV2aW91cyBkZXN0cm95KVxcblxcbnZhciBQbHVnaW4gPSBmdW5jdGlvbiAoKSB7XFxuICBmdW5jdGlvbiBQbHVnaW4oZWxlbWVudCwgb3B0aW9ucykge1xcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGx1Z2luKTtcXG5cXG4gICAgdGhpcy5fc2V0dXAoZWxlbWVudCwgb3B0aW9ucyk7XFxuICAgIHZhciBwbHVnaW5OYW1lID0gZ2V0UGx1Z2luTmFtZSh0aGlzKTtcXG4gICAgdGhpcy51dWlkID0gX193ZWJwYWNrX3JlcXVpcmVfXy5pKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fZm91bmRhdGlvbl91dGlsX2NvcmVfX1tcXFwiYlxcXCIgLyogR2V0WW9EaWdpdHMgKi9dKSg2LCBwbHVnaW5OYW1lKTtcXG5cXG4gICAgaWYgKCF0aGlzLiRlbGVtZW50LmF0dHIoJ2RhdGEtJyArIHBsdWdpbk5hbWUpKSB7XFxuICAgICAgdGhpcy4kZWxlbWVudC5hdHRyKCdkYXRhLScgKyBwbHVnaW5OYW1lLCB0aGlzLnV1aWQpO1xcbiAgICB9XFxuICAgIGlmICghdGhpcy4kZWxlbWVudC5kYXRhKCd6ZlBsdWdpbicpKSB7XFxuICAgICAgdGhpcy4kZWxlbWVudC5kYXRhKCd6ZlBsdWdpbicsIHRoaXMpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBGaXJlcyB3aGVuIHRoZSBwbHVnaW4gaGFzIGluaXRpYWxpemVkLlxcbiAgICAgKiBAZXZlbnQgUGx1Z2luI2luaXRcXG4gICAgICovXFxuICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignaW5pdC56Zi4nICsgcGx1Z2luTmFtZSk7XFxuICB9XFxuXFxuICBfY3JlYXRlQ2xhc3MoUGx1Z2luLCBbe1xcbiAgICBrZXk6ICdkZXN0cm95JyxcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XFxuICAgICAgdGhpcy5fZGVzdHJveSgpO1xcbiAgICAgIHZhciBwbHVnaW5OYW1lID0gZ2V0UGx1Z2luTmFtZSh0aGlzKTtcXG4gICAgICB0aGlzLiRlbGVtZW50LnJlbW92ZUF0dHIoJ2RhdGEtJyArIHBsdWdpbk5hbWUpLnJlbW92ZURhdGEoJ3pmUGx1Z2luJylcXG4gICAgICAvKipcXG4gICAgICAgKiBGaXJlcyB3aGVuIHRoZSBwbHVnaW4gaGFzIGJlZW4gZGVzdHJveWVkLlxcbiAgICAgICAqIEBldmVudCBQbHVnaW4jZGVzdHJveWVkXFxuICAgICAgICovXFxuICAgICAgLnRyaWdnZXIoJ2Rlc3Ryb3llZC56Zi4nICsgcGx1Z2luTmFtZSk7XFxuICAgICAgZm9yICh2YXIgcHJvcCBpbiB0aGlzKSB7XFxuICAgICAgICB0aGlzW3Byb3BdID0gbnVsbDsgLy9jbGVhbiB1cCBzY3JpcHQgdG8gcHJlcCBmb3IgZ2FyYmFnZSBjb2xsZWN0aW9uLlxcbiAgICAgIH1cXG4gICAgfVxcbiAgfV0pO1xcblxcbiAgcmV0dXJuIFBsdWdpbjtcXG59KCk7XFxuXFxuLy8gQ29udmVydCBQYXNjYWxDYXNlIHRvIGtlYmFiLWNhc2VcXG4vLyBUaGFuayB5b3U6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzg5NTU1ODBcXG5cXG5cXG5mdW5jdGlvbiBoeXBoZW5hdGUoc3RyKSB7XFxuICByZXR1cm4gc3RyLnJlcGxhY2UoLyhbYS16XSkoW0EtWl0pL2csICckMS0kMicpLnRvTG93ZXJDYXNlKCk7XFxufVxcblxcbmZ1bmN0aW9uIGdldFBsdWdpbk5hbWUob2JqKSB7XFxuICBpZiAodHlwZW9mIG9iai5jb25zdHJ1Y3Rvci5uYW1lICE9PSAndW5kZWZpbmVkJykge1xcbiAgICByZXR1cm4gaHlwaGVuYXRlKG9iai5jb25zdHJ1Y3Rvci5uYW1lKTtcXG4gIH0gZWxzZSB7XFxuICAgIHJldHVybiBoeXBoZW5hdGUob2JqLmNsYXNzTmFtZSk7XFxuICB9XFxufVxcblxcblxcblxcbi8qKiovIH0pLFxcbi8qIDMgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImFcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIEtleWJvYXJkOyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLm4oX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19mb3VuZGF0aW9uX3V0aWxfY29yZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXFxuICogVGhpcyB1dGlsIHdhcyBjcmVhdGVkIGJ5IE1hcml1cyBPbGJlcnR6ICpcXG4gKiBQbGVhc2UgdGhhbmsgTWFyaXVzIG9uIEdpdEh1YiAvb3dsYmVydHogKlxcbiAqIG9yIHRoZSB3ZWIgaHR0cDovL3d3dy5tYXJpdXNvbGJlcnR6LmRlLyAqXFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcblxcblxcblxcblxcblxcblxcbnZhciBrZXlDb2RlcyA9IHtcXG4gIDk6ICdUQUInLFxcbiAgMTM6ICdFTlRFUicsXFxuICAyNzogJ0VTQ0FQRScsXFxuICAzMjogJ1NQQUNFJyxcXG4gIDM1OiAnRU5EJyxcXG4gIDM2OiAnSE9NRScsXFxuICAzNzogJ0FSUk9XX0xFRlQnLFxcbiAgMzg6ICdBUlJPV19VUCcsXFxuICAzOTogJ0FSUk9XX1JJR0hUJyxcXG4gIDQwOiAnQVJST1dfRE9XTidcXG59O1xcblxcbnZhciBjb21tYW5kcyA9IHt9O1xcblxcbi8vIEZ1bmN0aW9ucyBwdWxsZWQgb3V0IHRvIGJlIHJlZmVyZW5jZWFibGUgZnJvbSBpbnRlcm5hbHNcXG5mdW5jdGlvbiBmaW5kRm9jdXNhYmxlKCRlbGVtZW50KSB7XFxuICBpZiAoISRlbGVtZW50KSB7XFxuICAgIHJldHVybiBmYWxzZTtcXG4gIH1cXG4gIHJldHVybiAkZWxlbWVudC5maW5kKCdhW2hyZWZdLCBhcmVhW2hyZWZdLCBpbnB1dDpub3QoW2Rpc2FibGVkXSksIHNlbGVjdDpub3QoW2Rpc2FibGVkXSksIHRleHRhcmVhOm5vdChbZGlzYWJsZWRdKSwgYnV0dG9uOm5vdChbZGlzYWJsZWRdKSwgaWZyYW1lLCBvYmplY3QsIGVtYmVkLCAqW3RhYmluZGV4XSwgKltjb250ZW50ZWRpdGFibGVdJykuZmlsdGVyKGZ1bmN0aW9uICgpIHtcXG4gICAgaWYgKCFfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKHRoaXMpLmlzKCc6dmlzaWJsZScpIHx8IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0KCkodGhpcykuYXR0cigndGFiaW5kZXgnKSA8IDApIHtcXG4gICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH0gLy9vbmx5IGhhdmUgdmlzaWJsZSBlbGVtZW50cyBhbmQgdGhvc2UgdGhhdCBoYXZlIGEgdGFiaW5kZXggZ3JlYXRlciBvciBlcXVhbCAwXFxuICAgIHJldHVybiB0cnVlO1xcbiAgfSk7XFxufVxcblxcbmZ1bmN0aW9uIHBhcnNlS2V5KGV2ZW50KSB7XFxuICB2YXIga2V5ID0ga2V5Q29kZXNbZXZlbnQud2hpY2ggfHwgZXZlbnQua2V5Q29kZV0gfHwgU3RyaW5nLmZyb21DaGFyQ29kZShldmVudC53aGljaCkudG9VcHBlckNhc2UoKTtcXG5cXG4gIC8vIFJlbW92ZSB1bi1wcmludGFibGUgY2hhcmFjdGVycywgZS5nLiBmb3IgYGZyb21DaGFyQ29kZWAgY2FsbHMgZm9yIENUUkwgb25seSBldmVudHNcXG4gIGtleSA9IGtleS5yZXBsYWNlKC9cXFxcVysvLCAnJyk7XFxuXFxuICBpZiAoZXZlbnQuc2hpZnRLZXkpIGtleSA9ICdTSElGVF8nICsga2V5O1xcbiAgaWYgKGV2ZW50LmN0cmxLZXkpIGtleSA9ICdDVFJMXycgKyBrZXk7XFxuICBpZiAoZXZlbnQuYWx0S2V5KSBrZXkgPSAnQUxUXycgKyBrZXk7XFxuXFxuICAvLyBSZW1vdmUgdHJhaWxpbmcgdW5kZXJzY29yZSwgaW4gY2FzZSBvbmx5IG1vZGlmaWVycyB3ZXJlIHVzZWQgKGUuZy4gb25seSBgQ1RSTF9BTFRgKVxcbiAga2V5ID0ga2V5LnJlcGxhY2UoL18kLywgJycpO1xcblxcbiAgcmV0dXJuIGtleTtcXG59XFxuXFxudmFyIEtleWJvYXJkID0ge1xcbiAga2V5czogZ2V0S2V5Q29kZXMoa2V5Q29kZXMpLFxcblxcbiAgLyoqXFxuICAgKiBQYXJzZXMgdGhlIChrZXlib2FyZCkgZXZlbnQgYW5kIHJldHVybnMgYSBTdHJpbmcgdGhhdCByZXByZXNlbnRzIGl0cyBrZXlcXG4gICAqIENhbiBiZSB1c2VkIGxpa2UgRm91bmRhdGlvbi5wYXJzZUtleShldmVudCkgPT09IEZvdW5kYXRpb24ua2V5cy5TUEFDRVxcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSB0aGUgZXZlbnQgZ2VuZXJhdGVkIGJ5IHRoZSBldmVudCBoYW5kbGVyXFxuICAgKiBAcmV0dXJuIFN0cmluZyBrZXkgLSBTdHJpbmcgdGhhdCByZXByZXNlbnRzIHRoZSBrZXkgcHJlc3NlZFxcbiAgICovXFxuICBwYXJzZUtleTogcGFyc2VLZXksXFxuXFxuICAvKipcXG4gICAqIEhhbmRsZXMgdGhlIGdpdmVuIChrZXlib2FyZCkgZXZlbnRcXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gdGhlIGV2ZW50IGdlbmVyYXRlZCBieSB0aGUgZXZlbnQgaGFuZGxlclxcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNvbXBvbmVudCAtIEZvdW5kYXRpb24gY29tcG9uZW50J3MgbmFtZSwgZS5nLiBTbGlkZXIgb3IgUmV2ZWFsXFxuICAgKiBAcGFyYW0ge09iamVjdHN9IGZ1bmN0aW9ucyAtIGNvbGxlY3Rpb24gb2YgZnVuY3Rpb25zIHRoYXQgYXJlIHRvIGJlIGV4ZWN1dGVkXFxuICAgKi9cXG4gIGhhbmRsZUtleTogZnVuY3Rpb24gKGV2ZW50LCBjb21wb25lbnQsIGZ1bmN0aW9ucykge1xcbiAgICB2YXIgY29tbWFuZExpc3QgPSBjb21tYW5kc1tjb21wb25lbnRdLFxcbiAgICAgICAga2V5Q29kZSA9IHRoaXMucGFyc2VLZXkoZXZlbnQpLFxcbiAgICAgICAgY21kcyxcXG4gICAgICAgIGNvbW1hbmQsXFxuICAgICAgICBmbjtcXG5cXG4gICAgaWYgKCFjb21tYW5kTGlzdCkgcmV0dXJuIGNvbnNvbGUud2FybignQ29tcG9uZW50IG5vdCBkZWZpbmVkIScpO1xcblxcbiAgICBpZiAodHlwZW9mIGNvbW1hbmRMaXN0Lmx0ciA9PT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICAvLyB0aGlzIGNvbXBvbmVudCBkb2VzIG5vdCBkaWZmZXJlbnRpYXRlIGJldHdlZW4gbHRyIGFuZCBydGxcXG4gICAgICBjbWRzID0gY29tbWFuZExpc3Q7IC8vIHVzZSBwbGFpbiBsaXN0XFxuICAgIH0gZWxzZSB7XFxuICAgICAgLy8gbWVyZ2UgbHRyIGFuZCBydGw6IGlmIGRvY3VtZW50IGlzIHJ0bCwgcnRsIG92ZXJ3cml0ZXMgbHRyIGFuZCB2aWNlIHZlcnNhXFxuICAgICAgaWYgKF9fd2VicGFja19yZXF1aXJlX18uaShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX2ZvdW5kYXRpb25fdXRpbF9jb3JlX19bXFxcImFcXFwiIC8qIHJ0bCAqL10pKCkpIGNtZHMgPSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdC5hLmV4dGVuZCh7fSwgY29tbWFuZExpc3QubHRyLCBjb21tYW5kTGlzdC5ydGwpO2Vsc2UgY21kcyA9IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0LmEuZXh0ZW5kKHt9LCBjb21tYW5kTGlzdC5ydGwsIGNvbW1hbmRMaXN0Lmx0cik7XFxuICAgIH1cXG4gICAgY29tbWFuZCA9IGNtZHNba2V5Q29kZV07XFxuXFxuICAgIGZuID0gZnVuY3Rpb25zW2NvbW1hbmRdO1xcbiAgICBpZiAoZm4gJiYgdHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgLy8gZXhlY3V0ZSBmdW5jdGlvbiAgaWYgZXhpc3RzXFxuICAgICAgdmFyIHJldHVyblZhbHVlID0gZm4uYXBwbHkoKTtcXG4gICAgICBpZiAoZnVuY3Rpb25zLmhhbmRsZWQgfHwgdHlwZW9mIGZ1bmN0aW9ucy5oYW5kbGVkID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgICAvLyBleGVjdXRlIGZ1bmN0aW9uIHdoZW4gZXZlbnQgd2FzIGhhbmRsZWRcXG4gICAgICAgIGZ1bmN0aW9ucy5oYW5kbGVkKHJldHVyblZhbHVlKTtcXG4gICAgICB9XFxuICAgIH0gZWxzZSB7XFxuICAgICAgaWYgKGZ1bmN0aW9ucy51bmhhbmRsZWQgfHwgdHlwZW9mIGZ1bmN0aW9ucy51bmhhbmRsZWQgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICAgIC8vIGV4ZWN1dGUgZnVuY3Rpb24gd2hlbiBldmVudCB3YXMgbm90IGhhbmRsZWRcXG4gICAgICAgIGZ1bmN0aW9ucy51bmhhbmRsZWQoKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH0sXFxuXFxuXFxuICAvKipcXG4gICAqIEZpbmRzIGFsbCBmb2N1c2FibGUgZWxlbWVudHMgd2l0aGluIHRoZSBnaXZlbiBgJGVsZW1lbnRgXFxuICAgKiBAcGFyYW0ge2pRdWVyeX0gJGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIHNlYXJjaCB3aXRoaW5cXG4gICAqIEByZXR1cm4ge2pRdWVyeX0gJGZvY3VzYWJsZSAtIGFsbCBmb2N1c2FibGUgZWxlbWVudHMgd2l0aGluIGAkZWxlbWVudGBcXG4gICAqL1xcblxcbiAgZmluZEZvY3VzYWJsZTogZmluZEZvY3VzYWJsZSxcXG5cXG4gIC8qKlxcbiAgICogUmV0dXJucyB0aGUgY29tcG9uZW50IG5hbWUgbmFtZVxcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbXBvbmVudCAtIEZvdW5kYXRpb24gY29tcG9uZW50LCBlLmcuIFNsaWRlciBvciBSZXZlYWxcXG4gICAqIEByZXR1cm4gU3RyaW5nIGNvbXBvbmVudE5hbWVcXG4gICAqL1xcblxcbiAgcmVnaXN0ZXI6IGZ1bmN0aW9uIChjb21wb25lbnROYW1lLCBjbWRzKSB7XFxuICAgIGNvbW1hbmRzW2NvbXBvbmVudE5hbWVdID0gY21kcztcXG4gIH0sXFxuXFxuXFxuICAvLyBUT0RPOTQzODogVGhlc2UgcmVmZXJlbmNlcyB0byBLZXlib2FyZCBuZWVkIHRvIG5vdCByZXF1aXJlIGdsb2JhbC4gV2lsbCAndGhpcycgd29yayBpbiB0aGlzIGNvbnRleHQ/XFxuICAvL1xcbiAgLyoqXFxuICAgKiBUcmFwcyB0aGUgZm9jdXMgaW4gdGhlIGdpdmVuIGVsZW1lbnQuXFxuICAgKiBAcGFyYW0gIHtqUXVlcnl9ICRlbGVtZW50ICBqUXVlcnkgb2JqZWN0IHRvIHRyYXAgdGhlIGZvdWNzIGludG8uXFxuICAgKi9cXG4gIHRyYXBGb2N1czogZnVuY3Rpb24gKCRlbGVtZW50KSB7XFxuICAgIHZhciAkZm9jdXNhYmxlID0gZmluZEZvY3VzYWJsZSgkZWxlbWVudCksXFxuICAgICAgICAkZmlyc3RGb2N1c2FibGUgPSAkZm9jdXNhYmxlLmVxKDApLFxcbiAgICAgICAgJGxhc3RGb2N1c2FibGUgPSAkZm9jdXNhYmxlLmVxKC0xKTtcXG5cXG4gICAgJGVsZW1lbnQub24oJ2tleWRvd24uemYudHJhcGZvY3VzJywgZnVuY3Rpb24gKGV2ZW50KSB7XFxuICAgICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gJGxhc3RGb2N1c2FibGVbMF0gJiYgcGFyc2VLZXkoZXZlbnQpID09PSAnVEFCJykge1xcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgICRmaXJzdEZvY3VzYWJsZS5mb2N1cygpO1xcbiAgICAgIH0gZWxzZSBpZiAoZXZlbnQudGFyZ2V0ID09PSAkZmlyc3RGb2N1c2FibGVbMF0gJiYgcGFyc2VLZXkoZXZlbnQpID09PSAnU0hJRlRfVEFCJykge1xcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgICRsYXN0Rm9jdXNhYmxlLmZvY3VzKCk7XFxuICAgICAgfVxcbiAgICB9KTtcXG4gIH0sXFxuXFxuICAvKipcXG4gICAqIFJlbGVhc2VzIHRoZSB0cmFwcGVkIGZvY3VzIGZyb20gdGhlIGdpdmVuIGVsZW1lbnQuXFxuICAgKiBAcGFyYW0gIHtqUXVlcnl9ICRlbGVtZW50ICBqUXVlcnkgb2JqZWN0IHRvIHJlbGVhc2UgdGhlIGZvY3VzIGZvci5cXG4gICAqL1xcbiAgcmVsZWFzZUZvY3VzOiBmdW5jdGlvbiAoJGVsZW1lbnQpIHtcXG4gICAgJGVsZW1lbnQub2ZmKCdrZXlkb3duLnpmLnRyYXBmb2N1cycpO1xcbiAgfVxcbn07XFxuXFxuLypcXG4gKiBDb25zdGFudHMgZm9yIGVhc2llciBjb21wYXJpbmcuXFxuICogQ2FuIGJlIHVzZWQgbGlrZSBGb3VuZGF0aW9uLnBhcnNlS2V5KGV2ZW50KSA9PT0gRm91bmRhdGlvbi5rZXlzLlNQQUNFXFxuICovXFxuZnVuY3Rpb24gZ2V0S2V5Q29kZXMoa2NzKSB7XFxuICB2YXIgayA9IHt9O1xcbiAgZm9yICh2YXIga2MgaW4ga2NzKSB7XFxuICAgIGtba2NzW2tjXV0gPSBrY3Nba2NdO1xcbiAgfXJldHVybiBrO1xcbn1cXG5cXG5cXG5cXG4vKioqLyB9KSxcXG4vKiA0ICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJhXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBNZWRpYVF1ZXJ5OyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLm4oX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fKTtcXG5cXG5cXG5cXG5cXG4vLyBEZWZhdWx0IHNldCBvZiBtZWRpYSBxdWVyaWVzXFxudmFyIGRlZmF1bHRRdWVyaWVzID0ge1xcbiAgJ2RlZmF1bHQnOiAnb25seSBzY3JlZW4nLFxcbiAgbGFuZHNjYXBlOiAnb25seSBzY3JlZW4gYW5kIChvcmllbnRhdGlvbjogbGFuZHNjYXBlKScsXFxuICBwb3J0cmFpdDogJ29ubHkgc2NyZWVuIGFuZCAob3JpZW50YXRpb246IHBvcnRyYWl0KScsXFxuICByZXRpbmE6ICdvbmx5IHNjcmVlbiBhbmQgKC13ZWJraXQtbWluLWRldmljZS1waXhlbC1yYXRpbzogMiksJyArICdvbmx5IHNjcmVlbiBhbmQgKG1pbi0tbW96LWRldmljZS1waXhlbC1yYXRpbzogMiksJyArICdvbmx5IHNjcmVlbiBhbmQgKC1vLW1pbi1kZXZpY2UtcGl4ZWwtcmF0aW86IDIvMSksJyArICdvbmx5IHNjcmVlbiBhbmQgKG1pbi1kZXZpY2UtcGl4ZWwtcmF0aW86IDIpLCcgKyAnb25seSBzY3JlZW4gYW5kIChtaW4tcmVzb2x1dGlvbjogMTkyZHBpKSwnICsgJ29ubHkgc2NyZWVuIGFuZCAobWluLXJlc29sdXRpb246IDJkcHB4KSdcXG59O1xcblxcbi8vIG1hdGNoTWVkaWEoKSBwb2x5ZmlsbCAtIFRlc3QgYSBDU1MgbWVkaWEgdHlwZS9xdWVyeSBpbiBKUy5cXG4vLyBBdXRob3JzICYgY29weXJpZ2h0IChjKSAyMDEyOiBTY290dCBKZWhsLCBQYXVsIElyaXNoLCBOaWNob2xhcyBaYWthcywgRGF2aWQgS25pZ2h0LiBEdWFsIE1JVC9CU0QgbGljZW5zZVxcbnZhciBtYXRjaE1lZGlhID0gd2luZG93Lm1hdGNoTWVkaWEgfHwgZnVuY3Rpb24gKCkge1xcbiAgJ3VzZSBzdHJpY3QnO1xcblxcbiAgLy8gRm9yIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBtYXRjaE1lZGl1bSBhcGkgc3VjaCBhcyBJRSA5IGFuZCB3ZWJraXRcXG5cXG4gIHZhciBzdHlsZU1lZGlhID0gd2luZG93LnN0eWxlTWVkaWEgfHwgd2luZG93Lm1lZGlhO1xcblxcbiAgLy8gRm9yIHRob3NlIHRoYXQgZG9uJ3Qgc3VwcG9ydCBtYXRjaE1lZGl1bVxcbiAgaWYgKCFzdHlsZU1lZGlhKSB7XFxuICAgIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyksXFxuICAgICAgICBzY3JpcHQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2NyaXB0JylbMF0sXFxuICAgICAgICBpbmZvID0gbnVsbDtcXG5cXG4gICAgc3R5bGUudHlwZSA9ICd0ZXh0L2Nzcyc7XFxuICAgIHN0eWxlLmlkID0gJ21hdGNobWVkaWFqcy10ZXN0JztcXG5cXG4gICAgc2NyaXB0ICYmIHNjcmlwdC5wYXJlbnROb2RlICYmIHNjcmlwdC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShzdHlsZSwgc2NyaXB0KTtcXG5cXG4gICAgLy8gJ3N0eWxlLmN1cnJlbnRTdHlsZScgaXMgdXNlZCBieSBJRSA8PSA4IGFuZCAnd2luZG93LmdldENvbXB1dGVkU3R5bGUnIGZvciBhbGwgb3RoZXIgYnJvd3NlcnNcXG4gICAgaW5mbyA9ICdnZXRDb21wdXRlZFN0eWxlJyBpbiB3aW5kb3cgJiYgd2luZG93LmdldENvbXB1dGVkU3R5bGUoc3R5bGUsIG51bGwpIHx8IHN0eWxlLmN1cnJlbnRTdHlsZTtcXG5cXG4gICAgc3R5bGVNZWRpYSA9IHtcXG4gICAgICBtYXRjaE1lZGl1bTogZnVuY3Rpb24gKG1lZGlhKSB7XFxuICAgICAgICB2YXIgdGV4dCA9ICdAbWVkaWEgJyArIG1lZGlhICsgJ3sgI21hdGNobWVkaWFqcy10ZXN0IHsgd2lkdGg6IDFweDsgfSB9JztcXG5cXG4gICAgICAgIC8vICdzdHlsZS5zdHlsZVNoZWV0JyBpcyB1c2VkIGJ5IElFIDw9IDggYW5kICdzdHlsZS50ZXh0Q29udGVudCcgZm9yIGFsbCBvdGhlciBicm93c2Vyc1xcbiAgICAgICAgaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcXG4gICAgICAgICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gdGV4dDtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHN0eWxlLnRleHRDb250ZW50ID0gdGV4dDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIC8vIFRlc3QgaWYgbWVkaWEgcXVlcnkgaXMgdHJ1ZSBvciBmYWxzZVxcbiAgICAgICAgcmV0dXJuIGluZm8ud2lkdGggPT09ICcxcHgnO1xcbiAgICAgIH1cXG4gICAgfTtcXG4gIH1cXG5cXG4gIHJldHVybiBmdW5jdGlvbiAobWVkaWEpIHtcXG4gICAgcmV0dXJuIHtcXG4gICAgICBtYXRjaGVzOiBzdHlsZU1lZGlhLm1hdGNoTWVkaXVtKG1lZGlhIHx8ICdhbGwnKSxcXG4gICAgICBtZWRpYTogbWVkaWEgfHwgJ2FsbCdcXG4gICAgfTtcXG4gIH07XFxufSgpO1xcblxcbnZhciBNZWRpYVF1ZXJ5ID0ge1xcbiAgcXVlcmllczogW10sXFxuXFxuICBjdXJyZW50OiAnJyxcXG5cXG4gIC8qKlxcbiAgICogSW5pdGlhbGl6ZXMgdGhlIG1lZGlhIHF1ZXJ5IGhlbHBlciwgYnkgZXh0cmFjdGluZyB0aGUgYnJlYWtwb2ludCBsaXN0IGZyb20gdGhlIENTUyBhbmQgYWN0aXZhdGluZyB0aGUgYnJlYWtwb2ludCB3YXRjaGVyLlxcbiAgICogQGZ1bmN0aW9uXFxuICAgKiBAcHJpdmF0ZVxcbiAgICovXFxuICBfaW5pdDogZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgc2VsZiA9IHRoaXM7XFxuICAgIHZhciAkbWV0YSA9IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0KCkoJ21ldGEuZm91bmRhdGlvbi1tcScpO1xcbiAgICBpZiAoISRtZXRhLmxlbmd0aCkge1xcbiAgICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0KCkoJzxtZXRhIGNsYXNzPVxcXCJmb3VuZGF0aW9uLW1xXFxcIj4nKS5hcHBlbmRUbyhkb2N1bWVudC5oZWFkKTtcXG4gICAgfVxcblxcbiAgICB2YXIgZXh0cmFjdGVkU3R5bGVzID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSgnLmZvdW5kYXRpb24tbXEnKS5jc3MoJ2ZvbnQtZmFtaWx5Jyk7XFxuICAgIHZhciBuYW1lZFF1ZXJpZXM7XFxuXFxuICAgIG5hbWVkUXVlcmllcyA9IHBhcnNlU3R5bGVUb09iamVjdChleHRyYWN0ZWRTdHlsZXMpO1xcblxcbiAgICBmb3IgKHZhciBrZXkgaW4gbmFtZWRRdWVyaWVzKSB7XFxuICAgICAgaWYgKG5hbWVkUXVlcmllcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XFxuICAgICAgICBzZWxmLnF1ZXJpZXMucHVzaCh7XFxuICAgICAgICAgIG5hbWU6IGtleSxcXG4gICAgICAgICAgdmFsdWU6ICdvbmx5IHNjcmVlbiBhbmQgKG1pbi13aWR0aDogJyArIG5hbWVkUXVlcmllc1trZXldICsgJyknXFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgdGhpcy5jdXJyZW50ID0gdGhpcy5fZ2V0Q3VycmVudFNpemUoKTtcXG5cXG4gICAgdGhpcy5fd2F0Y2hlcigpO1xcbiAgfSxcXG5cXG5cXG4gIC8qKlxcbiAgICogQ2hlY2tzIGlmIHRoZSBzY3JlZW4gaXMgYXQgbGVhc3QgYXMgd2lkZSBhcyBhIGJyZWFrcG9pbnQuXFxuICAgKiBAZnVuY3Rpb25cXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzaXplIC0gTmFtZSBvZiB0aGUgYnJlYWtwb2ludCB0byBjaGVjay5cXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIGJyZWFrcG9pbnQgbWF0Y2hlcywgYGZhbHNlYCBpZiBpdCdzIHNtYWxsZXIuXFxuICAgKi9cXG4gIGF0TGVhc3Q6IGZ1bmN0aW9uIChzaXplKSB7XFxuICAgIHZhciBxdWVyeSA9IHRoaXMuZ2V0KHNpemUpO1xcblxcbiAgICBpZiAocXVlcnkpIHtcXG4gICAgICByZXR1cm4gbWF0Y2hNZWRpYShxdWVyeSkubWF0Y2hlcztcXG4gICAgfVxcblxcbiAgICByZXR1cm4gZmFsc2U7XFxuICB9LFxcblxcblxcbiAgLyoqXFxuICAgKiBDaGVja3MgaWYgdGhlIHNjcmVlbiBtYXRjaGVzIHRvIGEgYnJlYWtwb2ludC5cXG4gICAqIEBmdW5jdGlvblxcbiAgICogQHBhcmFtIHtTdHJpbmd9IHNpemUgLSBOYW1lIG9mIHRoZSBicmVha3BvaW50IHRvIGNoZWNrLCBlaXRoZXIgJ3NtYWxsIG9ubHknIG9yICdzbWFsbCcuIE9taXR0aW5nICdvbmx5JyBmYWxscyBiYWNrIHRvIHVzaW5nIGF0TGVhc3QoKSBtZXRob2QuXFxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBicmVha3BvaW50IG1hdGNoZXMsIGBmYWxzZWAgaWYgaXQgZG9lcyBub3QuXFxuICAgKi9cXG4gIGlzOiBmdW5jdGlvbiAoc2l6ZSkge1xcbiAgICBzaXplID0gc2l6ZS50cmltKCkuc3BsaXQoJyAnKTtcXG4gICAgaWYgKHNpemUubGVuZ3RoID4gMSAmJiBzaXplWzFdID09PSAnb25seScpIHtcXG4gICAgICBpZiAoc2l6ZVswXSA9PT0gdGhpcy5fZ2V0Q3VycmVudFNpemUoKSkgcmV0dXJuIHRydWU7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgcmV0dXJuIHRoaXMuYXRMZWFzdChzaXplWzBdKTtcXG4gICAgfVxcbiAgICByZXR1cm4gZmFsc2U7XFxuICB9LFxcblxcblxcbiAgLyoqXFxuICAgKiBHZXRzIHRoZSBtZWRpYSBxdWVyeSBvZiBhIGJyZWFrcG9pbnQuXFxuICAgKiBAZnVuY3Rpb25cXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzaXplIC0gTmFtZSBvZiB0aGUgYnJlYWtwb2ludCB0byBnZXQuXFxuICAgKiBAcmV0dXJucyB7U3RyaW5nfG51bGx9IC0gVGhlIG1lZGlhIHF1ZXJ5IG9mIHRoZSBicmVha3BvaW50LCBvciBgbnVsbGAgaWYgdGhlIGJyZWFrcG9pbnQgZG9lc24ndCBleGlzdC5cXG4gICAqL1xcbiAgZ2V0OiBmdW5jdGlvbiAoc2l6ZSkge1xcbiAgICBmb3IgKHZhciBpIGluIHRoaXMucXVlcmllcykge1xcbiAgICAgIGlmICh0aGlzLnF1ZXJpZXMuaGFzT3duUHJvcGVydHkoaSkpIHtcXG4gICAgICAgIHZhciBxdWVyeSA9IHRoaXMucXVlcmllc1tpXTtcXG4gICAgICAgIGlmIChzaXplID09PSBxdWVyeS5uYW1lKSByZXR1cm4gcXVlcnkudmFsdWU7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIHJldHVybiBudWxsO1xcbiAgfSxcXG5cXG5cXG4gIC8qKlxcbiAgICogR2V0cyB0aGUgY3VycmVudCBicmVha3BvaW50IG5hbWUgYnkgdGVzdGluZyBldmVyeSBicmVha3BvaW50IGFuZCByZXR1cm5pbmcgdGhlIGxhc3Qgb25lIHRvIG1hdGNoICh0aGUgYmlnZ2VzdCBvbmUpLlxcbiAgICogQGZ1bmN0aW9uXFxuICAgKiBAcHJpdmF0ZVxcbiAgICogQHJldHVybnMge1N0cmluZ30gTmFtZSBvZiB0aGUgY3VycmVudCBicmVha3BvaW50LlxcbiAgICovXFxuICBfZ2V0Q3VycmVudFNpemU6IGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyIG1hdGNoZWQ7XFxuXFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5xdWVyaWVzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgdmFyIHF1ZXJ5ID0gdGhpcy5xdWVyaWVzW2ldO1xcblxcbiAgICAgIGlmIChtYXRjaE1lZGlhKHF1ZXJ5LnZhbHVlKS5tYXRjaGVzKSB7XFxuICAgICAgICBtYXRjaGVkID0gcXVlcnk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGlmICh0eXBlb2YgbWF0Y2hlZCA9PT0gJ29iamVjdCcpIHtcXG4gICAgICByZXR1cm4gbWF0Y2hlZC5uYW1lO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHJldHVybiBtYXRjaGVkO1xcbiAgICB9XFxuICB9LFxcblxcblxcbiAgLyoqXFxuICAgKiBBY3RpdmF0ZXMgdGhlIGJyZWFrcG9pbnQgd2F0Y2hlciwgd2hpY2ggZmlyZXMgYW4gZXZlbnQgb24gdGhlIHdpbmRvdyB3aGVuZXZlciB0aGUgYnJlYWtwb2ludCBjaGFuZ2VzLlxcbiAgICogQGZ1bmN0aW9uXFxuICAgKiBAcHJpdmF0ZVxcbiAgICovXFxuICBfd2F0Y2hlcjogZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xcblxcbiAgICBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKHdpbmRvdykub2ZmKCdyZXNpemUuemYubWVkaWFxdWVyeScpLm9uKCdyZXNpemUuemYubWVkaWFxdWVyeScsIGZ1bmN0aW9uICgpIHtcXG4gICAgICB2YXIgbmV3U2l6ZSA9IF90aGlzLl9nZXRDdXJyZW50U2l6ZSgpLFxcbiAgICAgICAgICBjdXJyZW50U2l6ZSA9IF90aGlzLmN1cnJlbnQ7XFxuXFxuICAgICAgaWYgKG5ld1NpemUgIT09IGN1cnJlbnRTaXplKSB7XFxuICAgICAgICAvLyBDaGFuZ2UgdGhlIGN1cnJlbnQgbWVkaWEgcXVlcnlcXG4gICAgICAgIF90aGlzLmN1cnJlbnQgPSBuZXdTaXplO1xcblxcbiAgICAgICAgLy8gQnJvYWRjYXN0IHRoZSBtZWRpYSBxdWVyeSBjaGFuZ2Ugb24gdGhlIHdpbmRvd1xcbiAgICAgICAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSh3aW5kb3cpLnRyaWdnZXIoJ2NoYW5nZWQuemYubWVkaWFxdWVyeScsIFtuZXdTaXplLCBjdXJyZW50U2l6ZV0pO1xcbiAgICAgIH1cXG4gICAgfSk7XFxuICB9XFxufTtcXG5cXG4vLyBUaGFuayB5b3U6IGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvcXVlcnktc3RyaW5nXFxuZnVuY3Rpb24gcGFyc2VTdHlsZVRvT2JqZWN0KHN0cikge1xcbiAgdmFyIHN0eWxlT2JqZWN0ID0ge307XFxuXFxuICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcXG4gICAgcmV0dXJuIHN0eWxlT2JqZWN0O1xcbiAgfVxcblxcbiAgc3RyID0gc3RyLnRyaW0oKS5zbGljZSgxLCAtMSk7IC8vIGJyb3dzZXJzIHJlLXF1b3RlIHN0cmluZyBzdHlsZSB2YWx1ZXNcXG5cXG4gIGlmICghc3RyKSB7XFxuICAgIHJldHVybiBzdHlsZU9iamVjdDtcXG4gIH1cXG5cXG4gIHN0eWxlT2JqZWN0ID0gc3RyLnNwbGl0KCcmJykucmVkdWNlKGZ1bmN0aW9uIChyZXQsIHBhcmFtKSB7XFxuICAgIHZhciBwYXJ0cyA9IHBhcmFtLnJlcGxhY2UoL1xcXFwrL2csICcgJykuc3BsaXQoJz0nKTtcXG4gICAgdmFyIGtleSA9IHBhcnRzWzBdO1xcbiAgICB2YXIgdmFsID0gcGFydHNbMV07XFxuICAgIGtleSA9IGRlY29kZVVSSUNvbXBvbmVudChrZXkpO1xcblxcbiAgICAvLyBtaXNzaW5nIGA9YCBzaG91bGQgYmUgYG51bGxgOlxcbiAgICAvLyBodHRwOi8vdzMub3JnL1RSLzIwMTIvV0QtdXJsLTIwMTIwNTI0LyNjb2xsZWN0LXVybC1wYXJhbWV0ZXJzXFxuICAgIHZhbCA9IHZhbCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGRlY29kZVVSSUNvbXBvbmVudCh2YWwpO1xcblxcbiAgICBpZiAoIXJldC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XFxuICAgICAgcmV0W2tleV0gPSB2YWw7XFxuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShyZXRba2V5XSkpIHtcXG4gICAgICByZXRba2V5XS5wdXNoKHZhbCk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgcmV0W2tleV0gPSBbcmV0W2tleV0sIHZhbF07XFxuICAgIH1cXG4gICAgcmV0dXJuIHJldDtcXG4gIH0sIHt9KTtcXG5cXG4gIHJldHVybiBzdHlsZU9iamVjdDtcXG59XFxuXFxuXFxuXFxuLyoqKi8gfSksXFxuLyogNSAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXFwidXNlIHN0cmljdFxcXCI7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiYVxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gVHJpZ2dlcnM7IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCA9IF9fd2VicGFja19yZXF1aXJlX18ubihfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX2ZvdW5kYXRpb25fdXRpbF9tb3Rpb25fXyA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XFxuXFxuXFxuXFxuXFxuXFxudmFyIE11dGF0aW9uT2JzZXJ2ZXIgPSBmdW5jdGlvbiAoKSB7XFxuICB2YXIgcHJlZml4ZXMgPSBbJ1dlYktpdCcsICdNb3onLCAnTycsICdNcycsICcnXTtcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJlZml4ZXMubGVuZ3RoOyBpKyspIHtcXG4gICAgaWYgKHByZWZpeGVzW2ldICsgJ011dGF0aW9uT2JzZXJ2ZXInIGluIHdpbmRvdykge1xcbiAgICAgIHJldHVybiB3aW5kb3dbcHJlZml4ZXNbaV0gKyAnTXV0YXRpb25PYnNlcnZlciddO1xcbiAgICB9XFxuICB9XFxuICByZXR1cm4gZmFsc2U7XFxufSgpO1xcblxcbnZhciB0cmlnZ2VycyA9IGZ1bmN0aW9uIChlbCwgdHlwZSkge1xcbiAgZWwuZGF0YSh0eXBlKS5zcGxpdCgnICcpLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XFxuICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0KCkoJyMnICsgaWQpW3R5cGUgPT09ICdjbG9zZScgPyAndHJpZ2dlcicgOiAndHJpZ2dlckhhbmRsZXInXSh0eXBlICsgJy56Zi50cmlnZ2VyJywgW2VsXSk7XFxuICB9KTtcXG59O1xcblxcbnZhciBUcmlnZ2VycyA9IHtcXG4gIExpc3RlbmVyczoge1xcbiAgICBCYXNpYzoge30sXFxuICAgIEdsb2JhbDoge31cXG4gIH0sXFxuICBJbml0aWFsaXplcnM6IHt9XFxufTtcXG5cXG5UcmlnZ2Vycy5MaXN0ZW5lcnMuQmFzaWMgPSB7XFxuICBvcGVuTGlzdGVuZXI6IGZ1bmN0aW9uICgpIHtcXG4gICAgdHJpZ2dlcnMoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSh0aGlzKSwgJ29wZW4nKTtcXG4gIH0sXFxuICBjbG9zZUxpc3RlbmVyOiBmdW5jdGlvbiAoKSB7XFxuICAgIHZhciBpZCA9IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0KCkodGhpcykuZGF0YSgnY2xvc2UnKTtcXG4gICAgaWYgKGlkKSB7XFxuICAgICAgdHJpZ2dlcnMoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSh0aGlzKSwgJ2Nsb3NlJyk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSh0aGlzKS50cmlnZ2VyKCdjbG9zZS56Zi50cmlnZ2VyJyk7XFxuICAgIH1cXG4gIH0sXFxuICB0b2dnbGVMaXN0ZW5lcjogZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgaWQgPSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKHRoaXMpLmRhdGEoJ3RvZ2dsZScpO1xcbiAgICBpZiAoaWQpIHtcXG4gICAgICB0cmlnZ2VycyhfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKHRoaXMpLCAndG9nZ2xlJyk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSh0aGlzKS50cmlnZ2VyKCd0b2dnbGUuemYudHJpZ2dlcicpO1xcbiAgICB9XFxuICB9LFxcbiAgY2xvc2VhYmxlTGlzdGVuZXI6IGZ1bmN0aW9uIChlKSB7XFxuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XFxuICAgIHZhciBhbmltYXRpb24gPSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKHRoaXMpLmRhdGEoJ2Nsb3NhYmxlJyk7XFxuXFxuICAgIGlmIChhbmltYXRpb24gIT09ICcnKSB7XFxuICAgICAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19mb3VuZGF0aW9uX3V0aWxfbW90aW9uX19bXFxcImFcXFwiIC8qIE1vdGlvbiAqL10uYW5pbWF0ZU91dChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKHRoaXMpLCBhbmltYXRpb24sIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0KCkodGhpcykudHJpZ2dlcignY2xvc2VkLnpmJyk7XFxuICAgICAgfSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSh0aGlzKS5mYWRlT3V0KCkudHJpZ2dlcignY2xvc2VkLnpmJyk7XFxuICAgIH1cXG4gIH0sXFxuICB0b2dnbGVGb2N1c0xpc3RlbmVyOiBmdW5jdGlvbiAoKSB7XFxuICAgIHZhciBpZCA9IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0KCkodGhpcykuZGF0YSgndG9nZ2xlLWZvY3VzJyk7XFxuICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0KCkoJyMnICsgaWQpLnRyaWdnZXJIYW5kbGVyKCd0b2dnbGUuemYudHJpZ2dlcicsIFtfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKHRoaXMpXSk7XFxuICB9XFxufTtcXG5cXG4vLyBFbGVtZW50cyB3aXRoIFtkYXRhLW9wZW5dIHdpbGwgcmV2ZWFsIGEgcGx1Z2luIHRoYXQgc3VwcG9ydHMgaXQgd2hlbiBjbGlja2VkLlxcblRyaWdnZXJzLkluaXRpYWxpemVycy5hZGRPcGVuTGlzdGVuZXIgPSBmdW5jdGlvbiAoJGVsZW0pIHtcXG4gICRlbGVtLm9mZignY2xpY2suemYudHJpZ2dlcicsIFRyaWdnZXJzLkxpc3RlbmVycy5CYXNpYy5vcGVuTGlzdGVuZXIpO1xcbiAgJGVsZW0ub24oJ2NsaWNrLnpmLnRyaWdnZXInLCAnW2RhdGEtb3Blbl0nLCBUcmlnZ2Vycy5MaXN0ZW5lcnMuQmFzaWMub3Blbkxpc3RlbmVyKTtcXG59O1xcblxcbi8vIEVsZW1lbnRzIHdpdGggW2RhdGEtY2xvc2VdIHdpbGwgY2xvc2UgYSBwbHVnaW4gdGhhdCBzdXBwb3J0cyBpdCB3aGVuIGNsaWNrZWQuXFxuLy8gSWYgdXNlZCB3aXRob3V0IGEgdmFsdWUgb24gW2RhdGEtY2xvc2VdLCB0aGUgZXZlbnQgd2lsbCBidWJibGUsIGFsbG93aW5nIGl0IHRvIGNsb3NlIGEgcGFyZW50IGNvbXBvbmVudC5cXG5UcmlnZ2Vycy5Jbml0aWFsaXplcnMuYWRkQ2xvc2VMaXN0ZW5lciA9IGZ1bmN0aW9uICgkZWxlbSkge1xcbiAgJGVsZW0ub2ZmKCdjbGljay56Zi50cmlnZ2VyJywgVHJpZ2dlcnMuTGlzdGVuZXJzLkJhc2ljLmNsb3NlTGlzdGVuZXIpO1xcbiAgJGVsZW0ub24oJ2NsaWNrLnpmLnRyaWdnZXInLCAnW2RhdGEtY2xvc2VdJywgVHJpZ2dlcnMuTGlzdGVuZXJzLkJhc2ljLmNsb3NlTGlzdGVuZXIpO1xcbn07XFxuXFxuLy8gRWxlbWVudHMgd2l0aCBbZGF0YS10b2dnbGVdIHdpbGwgdG9nZ2xlIGEgcGx1Z2luIHRoYXQgc3VwcG9ydHMgaXQgd2hlbiBjbGlja2VkLlxcblRyaWdnZXJzLkluaXRpYWxpemVycy5hZGRUb2dnbGVMaXN0ZW5lciA9IGZ1bmN0aW9uICgkZWxlbSkge1xcbiAgJGVsZW0ub2ZmKCdjbGljay56Zi50cmlnZ2VyJywgVHJpZ2dlcnMuTGlzdGVuZXJzLkJhc2ljLnRvZ2dsZUxpc3RlbmVyKTtcXG4gICRlbGVtLm9uKCdjbGljay56Zi50cmlnZ2VyJywgJ1tkYXRhLXRvZ2dsZV0nLCBUcmlnZ2Vycy5MaXN0ZW5lcnMuQmFzaWMudG9nZ2xlTGlzdGVuZXIpO1xcbn07XFxuXFxuLy8gRWxlbWVudHMgd2l0aCBbZGF0YS1jbG9zYWJsZV0gd2lsbCByZXNwb25kIHRvIGNsb3NlLnpmLnRyaWdnZXIgZXZlbnRzLlxcblRyaWdnZXJzLkluaXRpYWxpemVycy5hZGRDbG9zZWFibGVMaXN0ZW5lciA9IGZ1bmN0aW9uICgkZWxlbSkge1xcbiAgJGVsZW0ub2ZmKCdjbG9zZS56Zi50cmlnZ2VyJywgVHJpZ2dlcnMuTGlzdGVuZXJzLkJhc2ljLmNsb3NlYWJsZUxpc3RlbmVyKTtcXG4gICRlbGVtLm9uKCdjbG9zZS56Zi50cmlnZ2VyJywgJ1tkYXRhLWNsb3NlYWJsZV0sIFtkYXRhLWNsb3NhYmxlXScsIFRyaWdnZXJzLkxpc3RlbmVycy5CYXNpYy5jbG9zZWFibGVMaXN0ZW5lcik7XFxufTtcXG5cXG4vLyBFbGVtZW50cyB3aXRoIFtkYXRhLXRvZ2dsZS1mb2N1c10gd2lsbCByZXNwb25kIHRvIGNvbWluZyBpbiBhbmQgb3V0IG9mIGZvY3VzXFxuVHJpZ2dlcnMuSW5pdGlhbGl6ZXJzLmFkZFRvZ2dsZUZvY3VzTGlzdGVuZXIgPSBmdW5jdGlvbiAoJGVsZW0pIHtcXG4gICRlbGVtLm9mZignZm9jdXMuemYudHJpZ2dlciBibHVyLnpmLnRyaWdnZXInLCBUcmlnZ2Vycy5MaXN0ZW5lcnMuQmFzaWMudG9nZ2xlRm9jdXNMaXN0ZW5lcik7XFxuICAkZWxlbS5vbignZm9jdXMuemYudHJpZ2dlciBibHVyLnpmLnRyaWdnZXInLCAnW2RhdGEtdG9nZ2xlLWZvY3VzXScsIFRyaWdnZXJzLkxpc3RlbmVycy5CYXNpYy50b2dnbGVGb2N1c0xpc3RlbmVyKTtcXG59O1xcblxcbi8vIE1vcmUgR2xvYmFsL2NvbXBsZXggbGlzdGVuZXJzIGFuZCB0cmlnZ2Vyc1xcblRyaWdnZXJzLkxpc3RlbmVycy5HbG9iYWwgPSB7XFxuICByZXNpemVMaXN0ZW5lcjogZnVuY3Rpb24gKCRub2Rlcykge1xcbiAgICBpZiAoIU11dGF0aW9uT2JzZXJ2ZXIpIHtcXG4gICAgICAvL2ZhbGxiYWNrIGZvciBJRSA5XFxuICAgICAgJG5vZGVzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSh0aGlzKS50cmlnZ2VySGFuZGxlcigncmVzaXplbWUuemYudHJpZ2dlcicpO1xcbiAgICAgIH0pO1xcbiAgICB9XFxuICAgIC8vdHJpZ2dlciBhbGwgbGlzdGVuaW5nIGVsZW1lbnRzIGFuZCBzaWduYWwgYSByZXNpemUgZXZlbnRcXG4gICAgJG5vZGVzLmF0dHIoJ2RhdGEtZXZlbnRzJywgXFxcInJlc2l6ZVxcXCIpO1xcbiAgfSxcXG4gIHNjcm9sbExpc3RlbmVyOiBmdW5jdGlvbiAoJG5vZGVzKSB7XFxuICAgIGlmICghTXV0YXRpb25PYnNlcnZlcikge1xcbiAgICAgIC8vZmFsbGJhY2sgZm9yIElFIDlcXG4gICAgICAkbm9kZXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKHRoaXMpLnRyaWdnZXJIYW5kbGVyKCdzY3JvbGxtZS56Zi50cmlnZ2VyJyk7XFxuICAgICAgfSk7XFxuICAgIH1cXG4gICAgLy90cmlnZ2VyIGFsbCBsaXN0ZW5pbmcgZWxlbWVudHMgYW5kIHNpZ25hbCBhIHNjcm9sbCBldmVudFxcbiAgICAkbm9kZXMuYXR0cignZGF0YS1ldmVudHMnLCBcXFwic2Nyb2xsXFxcIik7XFxuICB9LFxcbiAgY2xvc2VNZUxpc3RlbmVyOiBmdW5jdGlvbiAoZSwgcGx1Z2luSWQpIHtcXG4gICAgdmFyIHBsdWdpbiA9IGUubmFtZXNwYWNlLnNwbGl0KCcuJylbMF07XFxuICAgIHZhciBwbHVnaW5zID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSgnW2RhdGEtJyArIHBsdWdpbiArICddJykubm90KCdbZGF0YS15ZXRpLWJveD1cXFwiJyArIHBsdWdpbklkICsgJ1xcXCJdJyk7XFxuXFxuICAgIHBsdWdpbnMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgdmFyIF90aGlzID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSh0aGlzKTtcXG4gICAgICBfdGhpcy50cmlnZ2VySGFuZGxlcignY2xvc2UuemYudHJpZ2dlcicsIFtfdGhpc10pO1xcbiAgICB9KTtcXG4gIH1cXG59O1xcblxcbi8vIEdsb2JhbCwgcGFyc2VzIHdob2xlIGRvY3VtZW50LlxcblRyaWdnZXJzLkluaXRpYWxpemVycy5hZGRDbG9zZW1lTGlzdGVuZXIgPSBmdW5jdGlvbiAocGx1Z2luTmFtZSkge1xcbiAgdmFyIHlldGlCb3hlcyA9IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0KCkoJ1tkYXRhLXlldGktYm94XScpLFxcbiAgICAgIHBsdWdOYW1lcyA9IFsnZHJvcGRvd24nLCAndG9vbHRpcCcsICdyZXZlYWwnXTtcXG5cXG4gIGlmIChwbHVnaW5OYW1lKSB7XFxuICAgIGlmICh0eXBlb2YgcGx1Z2luTmFtZSA9PT0gJ3N0cmluZycpIHtcXG4gICAgICBwbHVnTmFtZXMucHVzaChwbHVnaW5OYW1lKTtcXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcGx1Z2luTmFtZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHBsdWdpbk5hbWVbMF0gPT09ICdzdHJpbmcnKSB7XFxuICAgICAgcGx1Z05hbWVzLmNvbmNhdChwbHVnaW5OYW1lKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBjb25zb2xlLmVycm9yKCdQbHVnaW4gbmFtZXMgbXVzdCBiZSBzdHJpbmdzJyk7XFxuICAgIH1cXG4gIH1cXG4gIGlmICh5ZXRpQm94ZXMubGVuZ3RoKSB7XFxuICAgIHZhciBsaXN0ZW5lcnMgPSBwbHVnTmFtZXMubWFwKGZ1bmN0aW9uIChuYW1lKSB7XFxuICAgICAgcmV0dXJuICdjbG9zZW1lLnpmLicgKyBuYW1lO1xcbiAgICB9KS5qb2luKCcgJyk7XFxuXFxuICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0KCkod2luZG93KS5vZmYobGlzdGVuZXJzKS5vbihsaXN0ZW5lcnMsIFRyaWdnZXJzLkxpc3RlbmVycy5HbG9iYWwuY2xvc2VNZUxpc3RlbmVyKTtcXG4gIH1cXG59O1xcblxcbmZ1bmN0aW9uIGRlYm91bmNlR2xvYmFsTGlzdGVuZXIoZGVib3VuY2UsIHRyaWdnZXIsIGxpc3RlbmVyKSB7XFxuICB2YXIgdGltZXIgPSB2b2lkIDAsXFxuICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMyk7XFxuICBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKHdpbmRvdykub2ZmKHRyaWdnZXIpLm9uKHRyaWdnZXIsIGZ1bmN0aW9uIChlKSB7XFxuICAgIGlmICh0aW1lcikge1xcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XFxuICAgIH1cXG4gICAgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG4gICAgICBsaXN0ZW5lci5hcHBseShudWxsLCBhcmdzKTtcXG4gICAgfSwgZGVib3VuY2UgfHwgMTApOyAvL2RlZmF1bHQgdGltZSB0byBlbWl0IHNjcm9sbCBldmVudFxcbiAgfSk7XFxufVxcblxcblRyaWdnZXJzLkluaXRpYWxpemVycy5hZGRSZXNpemVMaXN0ZW5lciA9IGZ1bmN0aW9uIChkZWJvdW5jZSkge1xcbiAgdmFyICRub2RlcyA9IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0KCkoJ1tkYXRhLXJlc2l6ZV0nKTtcXG4gIGlmICgkbm9kZXMubGVuZ3RoKSB7XFxuICAgIGRlYm91bmNlR2xvYmFsTGlzdGVuZXIoZGVib3VuY2UsICdyZXNpemUuemYudHJpZ2dlcicsIFRyaWdnZXJzLkxpc3RlbmVycy5HbG9iYWwucmVzaXplTGlzdGVuZXIsICRub2Rlcyk7XFxuICB9XFxufTtcXG5cXG5UcmlnZ2Vycy5Jbml0aWFsaXplcnMuYWRkU2Nyb2xsTGlzdGVuZXIgPSBmdW5jdGlvbiAoZGVib3VuY2UpIHtcXG4gIHZhciAkbm9kZXMgPSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKCdbZGF0YS1zY3JvbGxdJyk7XFxuICBpZiAoJG5vZGVzLmxlbmd0aCkge1xcbiAgICBkZWJvdW5jZUdsb2JhbExpc3RlbmVyKGRlYm91bmNlLCAnc2Nyb2xsLnpmLnRyaWdnZXInLCBUcmlnZ2Vycy5MaXN0ZW5lcnMuR2xvYmFsLnNjcm9sbExpc3RlbmVyLCAkbm9kZXMpO1xcbiAgfVxcbn07XFxuXFxuVHJpZ2dlcnMuSW5pdGlhbGl6ZXJzLmFkZE11dGF0aW9uRXZlbnRzTGlzdGVuZXIgPSBmdW5jdGlvbiAoJGVsZW0pIHtcXG4gIGlmICghTXV0YXRpb25PYnNlcnZlcikge1xcbiAgICByZXR1cm4gZmFsc2U7XFxuICB9XFxuICB2YXIgJG5vZGVzID0gJGVsZW0uZmluZCgnW2RhdGEtcmVzaXplXSwgW2RhdGEtc2Nyb2xsXSwgW2RhdGEtbXV0YXRlXScpO1xcblxcbiAgLy9lbGVtZW50IGNhbGxiYWNrXFxuICB2YXIgbGlzdGVuaW5nRWxlbWVudHNNdXRhdGlvbiA9IGZ1bmN0aW9uIChtdXRhdGlvblJlY29yZHNMaXN0KSB7XFxuICAgIHZhciAkdGFyZ2V0ID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKShtdXRhdGlvblJlY29yZHNMaXN0WzBdLnRhcmdldCk7XFxuXFxuICAgIC8vdHJpZ2dlciB0aGUgZXZlbnQgaGFuZGxlciBmb3IgdGhlIGVsZW1lbnQgZGVwZW5kaW5nIG9uIHR5cGVcXG4gICAgc3dpdGNoIChtdXRhdGlvblJlY29yZHNMaXN0WzBdLnR5cGUpIHtcXG4gICAgICBjYXNlIFxcXCJhdHRyaWJ1dGVzXFxcIjpcXG4gICAgICAgIGlmICgkdGFyZ2V0LmF0dHIoXFxcImRhdGEtZXZlbnRzXFxcIikgPT09IFxcXCJzY3JvbGxcXFwiICYmIG11dGF0aW9uUmVjb3Jkc0xpc3RbMF0uYXR0cmlidXRlTmFtZSA9PT0gXFxcImRhdGEtZXZlbnRzXFxcIikge1xcbiAgICAgICAgICAkdGFyZ2V0LnRyaWdnZXJIYW5kbGVyKCdzY3JvbGxtZS56Zi50cmlnZ2VyJywgWyR0YXJnZXQsIHdpbmRvdy5wYWdlWU9mZnNldF0pO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKCR0YXJnZXQuYXR0cihcXFwiZGF0YS1ldmVudHNcXFwiKSA9PT0gXFxcInJlc2l6ZVxcXCIgJiYgbXV0YXRpb25SZWNvcmRzTGlzdFswXS5hdHRyaWJ1dGVOYW1lID09PSBcXFwiZGF0YS1ldmVudHNcXFwiKSB7XFxuICAgICAgICAgICR0YXJnZXQudHJpZ2dlckhhbmRsZXIoJ3Jlc2l6ZW1lLnpmLnRyaWdnZXInLCBbJHRhcmdldF0pO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKG11dGF0aW9uUmVjb3Jkc0xpc3RbMF0uYXR0cmlidXRlTmFtZSA9PT0gXFxcInN0eWxlXFxcIikge1xcbiAgICAgICAgICAkdGFyZ2V0LmNsb3Nlc3QoXFxcIltkYXRhLW11dGF0ZV1cXFwiKS5hdHRyKFxcXCJkYXRhLWV2ZW50c1xcXCIsIFxcXCJtdXRhdGVcXFwiKTtcXG4gICAgICAgICAgJHRhcmdldC5jbG9zZXN0KFxcXCJbZGF0YS1tdXRhdGVdXFxcIikudHJpZ2dlckhhbmRsZXIoJ211dGF0ZW1lLnpmLnRyaWdnZXInLCBbJHRhcmdldC5jbG9zZXN0KFxcXCJbZGF0YS1tdXRhdGVdXFxcIildKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGJyZWFrO1xcblxcbiAgICAgIGNhc2UgXFxcImNoaWxkTGlzdFxcXCI6XFxuICAgICAgICAkdGFyZ2V0LmNsb3Nlc3QoXFxcIltkYXRhLW11dGF0ZV1cXFwiKS5hdHRyKFxcXCJkYXRhLWV2ZW50c1xcXCIsIFxcXCJtdXRhdGVcXFwiKTtcXG4gICAgICAgICR0YXJnZXQuY2xvc2VzdChcXFwiW2RhdGEtbXV0YXRlXVxcXCIpLnRyaWdnZXJIYW5kbGVyKCdtdXRhdGVtZS56Zi50cmlnZ2VyJywgWyR0YXJnZXQuY2xvc2VzdChcXFwiW2RhdGEtbXV0YXRlXVxcXCIpXSk7XFxuICAgICAgICBicmVhaztcXG5cXG4gICAgICBkZWZhdWx0OlxcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIC8vbm90aGluZ1xcbiAgICB9XFxuICB9O1xcblxcbiAgaWYgKCRub2Rlcy5sZW5ndGgpIHtcXG4gICAgLy9mb3IgZWFjaCBlbGVtZW50IHRoYXQgbmVlZHMgdG8gbGlzdGVuIGZvciByZXNpemluZywgc2Nyb2xsaW5nLCBvciBtdXRhdGlvbiBhZGQgYSBzaW5nbGUgb2JzZXJ2ZXJcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gJG5vZGVzLmxlbmd0aCAtIDE7IGkrKykge1xcbiAgICAgIHZhciBlbGVtZW50T2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihsaXN0ZW5pbmdFbGVtZW50c011dGF0aW9uKTtcXG4gICAgICBlbGVtZW50T2JzZXJ2ZXIub2JzZXJ2ZSgkbm9kZXNbaV0sIHsgYXR0cmlidXRlczogdHJ1ZSwgY2hpbGRMaXN0OiB0cnVlLCBjaGFyYWN0ZXJEYXRhOiBmYWxzZSwgc3VidHJlZTogdHJ1ZSwgYXR0cmlidXRlRmlsdGVyOiBbXFxcImRhdGEtZXZlbnRzXFxcIiwgXFxcInN0eWxlXFxcIl0gfSk7XFxuICAgIH1cXG4gIH1cXG59O1xcblxcblRyaWdnZXJzLkluaXRpYWxpemVycy5hZGRTaW1wbGVMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XFxuICB2YXIgJGRvY3VtZW50ID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKShkb2N1bWVudCk7XFxuXFxuICBUcmlnZ2Vycy5Jbml0aWFsaXplcnMuYWRkT3Blbkxpc3RlbmVyKCRkb2N1bWVudCk7XFxuICBUcmlnZ2Vycy5Jbml0aWFsaXplcnMuYWRkQ2xvc2VMaXN0ZW5lcigkZG9jdW1lbnQpO1xcbiAgVHJpZ2dlcnMuSW5pdGlhbGl6ZXJzLmFkZFRvZ2dsZUxpc3RlbmVyKCRkb2N1bWVudCk7XFxuICBUcmlnZ2Vycy5Jbml0aWFsaXplcnMuYWRkQ2xvc2VhYmxlTGlzdGVuZXIoJGRvY3VtZW50KTtcXG4gIFRyaWdnZXJzLkluaXRpYWxpemVycy5hZGRUb2dnbGVGb2N1c0xpc3RlbmVyKCRkb2N1bWVudCk7XFxufTtcXG5cXG5UcmlnZ2Vycy5Jbml0aWFsaXplcnMuYWRkR2xvYmFsTGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xcbiAgdmFyICRkb2N1bWVudCA9IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0KCkoZG9jdW1lbnQpO1xcbiAgVHJpZ2dlcnMuSW5pdGlhbGl6ZXJzLmFkZE11dGF0aW9uRXZlbnRzTGlzdGVuZXIoJGRvY3VtZW50KTtcXG4gIFRyaWdnZXJzLkluaXRpYWxpemVycy5hZGRSZXNpemVMaXN0ZW5lcigpO1xcbiAgVHJpZ2dlcnMuSW5pdGlhbGl6ZXJzLmFkZFNjcm9sbExpc3RlbmVyKCk7XFxuICBUcmlnZ2Vycy5Jbml0aWFsaXplcnMuYWRkQ2xvc2VtZUxpc3RlbmVyKCk7XFxufTtcXG5cXG5UcmlnZ2Vycy5pbml0ID0gZnVuY3Rpb24gKCQsIEZvdW5kYXRpb24pIHtcXG4gIGlmICh0eXBlb2YgJC50cmlnZ2Vyc0luaXRpYWxpemVkID09PSAndW5kZWZpbmVkJykge1xcbiAgICB2YXIgJGRvY3VtZW50ID0gJChkb2N1bWVudCk7XFxuXFxuICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcXFwiY29tcGxldGVcXFwiKSB7XFxuICAgICAgVHJpZ2dlcnMuSW5pdGlhbGl6ZXJzLmFkZFNpbXBsZUxpc3RlbmVycygpO1xcbiAgICAgIFRyaWdnZXJzLkluaXRpYWxpemVycy5hZGRHbG9iYWxMaXN0ZW5lcnMoKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAkKHdpbmRvdykub24oJ2xvYWQnLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICBUcmlnZ2Vycy5Jbml0aWFsaXplcnMuYWRkU2ltcGxlTGlzdGVuZXJzKCk7XFxuICAgICAgICBUcmlnZ2Vycy5Jbml0aWFsaXplcnMuYWRkR2xvYmFsTGlzdGVuZXJzKCk7XFxuICAgICAgfSk7XFxuICAgIH1cXG5cXG4gICAgJC50cmlnZ2Vyc0luaXRpYWxpemVkID0gdHJ1ZTtcXG4gIH1cXG5cXG4gIGlmIChGb3VuZGF0aW9uKSB7XFxuICAgIEZvdW5kYXRpb24uVHJpZ2dlcnMgPSBUcmlnZ2VycztcXG4gICAgLy8gTGVnYWN5IGluY2x1ZGVkIHRvIGJlIGJhY2t3YXJkcyBjb21wYXRpYmxlIGZvciBub3cuXFxuICAgIEZvdW5kYXRpb24uSUhlYXJZb3UgPSBUcmlnZ2Vycy5Jbml0aWFsaXplcnMuYWRkR2xvYmFsTGlzdGVuZXJzO1xcbiAgfVxcbn07XFxuXFxuXFxuXFxuLyoqKi8gfSksXFxuLyogNiAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXFwidXNlIHN0cmljdFxcXCI7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiYlxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gTW92ZTsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiYVxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gTW90aW9uOyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLm4oX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19mb3VuZGF0aW9uX3V0aWxfY29yZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcXG5cXG5cXG5cXG5cXG5cXG4vKipcXG4gKiBNb3Rpb24gbW9kdWxlLlxcbiAqIEBtb2R1bGUgZm91bmRhdGlvbi5tb3Rpb25cXG4gKi9cXG5cXG52YXIgaW5pdENsYXNzZXMgPSBbJ211aS1lbnRlcicsICdtdWktbGVhdmUnXTtcXG52YXIgYWN0aXZlQ2xhc3NlcyA9IFsnbXVpLWVudGVyLWFjdGl2ZScsICdtdWktbGVhdmUtYWN0aXZlJ107XFxuXFxudmFyIE1vdGlvbiA9IHtcXG4gIGFuaW1hdGVJbjogZnVuY3Rpb24gKGVsZW1lbnQsIGFuaW1hdGlvbiwgY2IpIHtcXG4gICAgYW5pbWF0ZSh0cnVlLCBlbGVtZW50LCBhbmltYXRpb24sIGNiKTtcXG4gIH0sXFxuXFxuICBhbmltYXRlT3V0OiBmdW5jdGlvbiAoZWxlbWVudCwgYW5pbWF0aW9uLCBjYikge1xcbiAgICBhbmltYXRlKGZhbHNlLCBlbGVtZW50LCBhbmltYXRpb24sIGNiKTtcXG4gIH1cXG59O1xcblxcbmZ1bmN0aW9uIE1vdmUoZHVyYXRpb24sIGVsZW0sIGZuKSB7XFxuICB2YXIgYW5pbSxcXG4gICAgICBwcm9nLFxcbiAgICAgIHN0YXJ0ID0gbnVsbDtcXG4gIC8vIGNvbnNvbGUubG9nKCdjYWxsZWQnKTtcXG5cXG4gIGlmIChkdXJhdGlvbiA9PT0gMCkge1xcbiAgICBmbi5hcHBseShlbGVtKTtcXG4gICAgZWxlbS50cmlnZ2VyKCdmaW5pc2hlZC56Zi5hbmltYXRlJywgW2VsZW1dKS50cmlnZ2VySGFuZGxlcignZmluaXNoZWQuemYuYW5pbWF0ZScsIFtlbGVtXSk7XFxuICAgIHJldHVybjtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIG1vdmUodHMpIHtcXG4gICAgaWYgKCFzdGFydCkgc3RhcnQgPSB0cztcXG4gICAgLy8gY29uc29sZS5sb2coc3RhcnQsIHRzKTtcXG4gICAgcHJvZyA9IHRzIC0gc3RhcnQ7XFxuICAgIGZuLmFwcGx5KGVsZW0pO1xcblxcbiAgICBpZiAocHJvZyA8IGR1cmF0aW9uKSB7XFxuICAgICAgYW5pbSA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUobW92ZSwgZWxlbSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKGFuaW0pO1xcbiAgICAgIGVsZW0udHJpZ2dlcignZmluaXNoZWQuemYuYW5pbWF0ZScsIFtlbGVtXSkudHJpZ2dlckhhbmRsZXIoJ2ZpbmlzaGVkLnpmLmFuaW1hdGUnLCBbZWxlbV0pO1xcbiAgICB9XFxuICB9XFxuICBhbmltID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShtb3ZlKTtcXG59XFxuXFxuLyoqXFxuICogQW5pbWF0ZXMgYW4gZWxlbWVudCBpbiBvciBvdXQgdXNpbmcgYSBDU1MgdHJhbnNpdGlvbiBjbGFzcy5cXG4gKiBAZnVuY3Rpb25cXG4gKiBAcHJpdmF0ZVxcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNJbiAtIERlZmluZXMgaWYgdGhlIGFuaW1hdGlvbiBpcyBpbiBvciBvdXQuXFxuICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnQgLSBqUXVlcnkgb3IgSFRNTCBvYmplY3QgdG8gYW5pbWF0ZS5cXG4gKiBAcGFyYW0ge1N0cmluZ30gYW5pbWF0aW9uIC0gQ1NTIGNsYXNzIHRvIHVzZS5cXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiAtIENhbGxiYWNrIHRvIHJ1biB3aGVuIGFuaW1hdGlvbiBpcyBmaW5pc2hlZC5cXG4gKi9cXG5mdW5jdGlvbiBhbmltYXRlKGlzSW4sIGVsZW1lbnQsIGFuaW1hdGlvbiwgY2IpIHtcXG4gIGVsZW1lbnQgPSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKGVsZW1lbnQpLmVxKDApO1xcblxcbiAgaWYgKCFlbGVtZW50Lmxlbmd0aCkgcmV0dXJuO1xcblxcbiAgdmFyIGluaXRDbGFzcyA9IGlzSW4gPyBpbml0Q2xhc3Nlc1swXSA6IGluaXRDbGFzc2VzWzFdO1xcbiAgdmFyIGFjdGl2ZUNsYXNzID0gaXNJbiA/IGFjdGl2ZUNsYXNzZXNbMF0gOiBhY3RpdmVDbGFzc2VzWzFdO1xcblxcbiAgLy8gU2V0IHVwIHRoZSBhbmltYXRpb25cXG4gIHJlc2V0KCk7XFxuXFxuICBlbGVtZW50LmFkZENsYXNzKGFuaW1hdGlvbikuY3NzKCd0cmFuc2l0aW9uJywgJ25vbmUnKTtcXG5cXG4gIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XFxuICAgIGVsZW1lbnQuYWRkQ2xhc3MoaW5pdENsYXNzKTtcXG4gICAgaWYgKGlzSW4pIGVsZW1lbnQuc2hvdygpO1xcbiAgfSk7XFxuXFxuICAvLyBTdGFydCB0aGUgYW5pbWF0aW9uXFxuICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xcbiAgICBlbGVtZW50WzBdLm9mZnNldFdpZHRoO1xcbiAgICBlbGVtZW50LmNzcygndHJhbnNpdGlvbicsICcnKS5hZGRDbGFzcyhhY3RpdmVDbGFzcyk7XFxuICB9KTtcXG5cXG4gIC8vIENsZWFuIHVwIHRoZSBhbmltYXRpb24gd2hlbiBpdCBmaW5pc2hlc1xcbiAgZWxlbWVudC5vbmUoX193ZWJwYWNrX3JlcXVpcmVfXy5pKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fZm91bmRhdGlvbl91dGlsX2NvcmVfX1tcXFwiY1xcXCIgLyogdHJhbnNpdGlvbmVuZCAqL10pKGVsZW1lbnQpLCBmaW5pc2gpO1xcblxcbiAgLy8gSGlkZXMgdGhlIGVsZW1lbnQgKGZvciBvdXQgYW5pbWF0aW9ucyksIHJlc2V0cyB0aGUgZWxlbWVudCwgYW5kIHJ1bnMgYSBjYWxsYmFja1xcbiAgZnVuY3Rpb24gZmluaXNoKCkge1xcbiAgICBpZiAoIWlzSW4pIGVsZW1lbnQuaGlkZSgpO1xcbiAgICByZXNldCgpO1xcbiAgICBpZiAoY2IpIGNiLmFwcGx5KGVsZW1lbnQpO1xcbiAgfVxcblxcbiAgLy8gUmVzZXRzIHRyYW5zaXRpb25zIGFuZCByZW1vdmVzIG1vdGlvbi1zcGVjaWZpYyBjbGFzc2VzXFxuICBmdW5jdGlvbiByZXNldCgpIHtcXG4gICAgZWxlbWVudFswXS5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSAwO1xcbiAgICBlbGVtZW50LnJlbW92ZUNsYXNzKGluaXRDbGFzcyArICcgJyArIGFjdGl2ZUNsYXNzICsgJyAnICsgYW5pbWF0aW9uKTtcXG4gIH1cXG59XFxuXFxuXFxuXFxuLyoqKi8gfSksXFxuLyogNyAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXFwidXNlIHN0cmljdFxcXCI7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiYVxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gQm94OyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19mb3VuZGF0aW9uX3V0aWxfY29yZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcXG5cXG5cXG5cXG5cXG52YXIgQm94ID0ge1xcbiAgSW1Ob3RUb3VjaGluZ1lvdTogSW1Ob3RUb3VjaGluZ1lvdSxcXG4gIE92ZXJsYXBBcmVhOiBPdmVybGFwQXJlYSxcXG4gIEdldERpbWVuc2lvbnM6IEdldERpbWVuc2lvbnMsXFxuICBHZXRPZmZzZXRzOiBHZXRPZmZzZXRzLFxcbiAgR2V0RXhwbGljaXRPZmZzZXRzOiBHZXRFeHBsaWNpdE9mZnNldHNcXG59O1xcblxcbi8qKlxcbiAqIENvbXBhcmVzIHRoZSBkaW1lbnNpb25zIG9mIGFuIGVsZW1lbnQgdG8gYSBjb250YWluZXIgYW5kIGRldGVybWluZXMgY29sbGlzaW9uIGV2ZW50cyB3aXRoIGNvbnRhaW5lci5cXG4gKiBAZnVuY3Rpb25cXG4gKiBAcGFyYW0ge2pRdWVyeX0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gdGVzdCBmb3IgY29sbGlzaW9ucy5cXG4gKiBAcGFyYW0ge2pRdWVyeX0gcGFyZW50IC0galF1ZXJ5IG9iamVjdCB0byB1c2UgYXMgYm91bmRpbmcgY29udGFpbmVyLlxcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gbHJPbmx5IC0gc2V0IHRvIHRydWUgdG8gY2hlY2sgbGVmdCBhbmQgcmlnaHQgdmFsdWVzIG9ubHkuXFxuICogQHBhcmFtIHtCb29sZWFufSB0Yk9ubHkgLSBzZXQgdG8gdHJ1ZSB0byBjaGVjayB0b3AgYW5kIGJvdHRvbSB2YWx1ZXMgb25seS5cXG4gKiBAZGVmYXVsdCBpZiBubyBwYXJlbnQgb2JqZWN0IHBhc3NlZCwgZGV0ZWN0cyBjb2xsaXNpb25zIHdpdGggYHdpbmRvd2AuXFxuICogQHJldHVybnMge0Jvb2xlYW59IC0gdHJ1ZSBpZiBjb2xsaXNpb24gZnJlZSwgZmFsc2UgaWYgYSBjb2xsaXNpb24gaW4gYW55IGRpcmVjdGlvbi5cXG4gKi9cXG5mdW5jdGlvbiBJbU5vdFRvdWNoaW5nWW91KGVsZW1lbnQsIHBhcmVudCwgbHJPbmx5LCB0Yk9ubHksIGlnbm9yZUJvdHRvbSkge1xcbiAgcmV0dXJuIE92ZXJsYXBBcmVhKGVsZW1lbnQsIHBhcmVudCwgbHJPbmx5LCB0Yk9ubHksIGlnbm9yZUJvdHRvbSkgPT09IDA7XFxufTtcXG5cXG5mdW5jdGlvbiBPdmVybGFwQXJlYShlbGVtZW50LCBwYXJlbnQsIGxyT25seSwgdGJPbmx5LCBpZ25vcmVCb3R0b20pIHtcXG4gIHZhciBlbGVEaW1zID0gR2V0RGltZW5zaW9ucyhlbGVtZW50KSxcXG4gICAgICB0b3BPdmVyLFxcbiAgICAgIGJvdHRvbU92ZXIsXFxuICAgICAgbGVmdE92ZXIsXFxuICAgICAgcmlnaHRPdmVyO1xcbiAgaWYgKHBhcmVudCkge1xcbiAgICB2YXIgcGFyRGltcyA9IEdldERpbWVuc2lvbnMocGFyZW50KTtcXG5cXG4gICAgYm90dG9tT3ZlciA9IHBhckRpbXMuaGVpZ2h0ICsgcGFyRGltcy5vZmZzZXQudG9wIC0gKGVsZURpbXMub2Zmc2V0LnRvcCArIGVsZURpbXMuaGVpZ2h0KTtcXG4gICAgdG9wT3ZlciA9IGVsZURpbXMub2Zmc2V0LnRvcCAtIHBhckRpbXMub2Zmc2V0LnRvcDtcXG4gICAgbGVmdE92ZXIgPSBlbGVEaW1zLm9mZnNldC5sZWZ0IC0gcGFyRGltcy5vZmZzZXQubGVmdDtcXG4gICAgcmlnaHRPdmVyID0gcGFyRGltcy53aWR0aCArIHBhckRpbXMub2Zmc2V0LmxlZnQgLSAoZWxlRGltcy5vZmZzZXQubGVmdCArIGVsZURpbXMud2lkdGgpO1xcbiAgfSBlbHNlIHtcXG4gICAgYm90dG9tT3ZlciA9IGVsZURpbXMud2luZG93RGltcy5oZWlnaHQgKyBlbGVEaW1zLndpbmRvd0RpbXMub2Zmc2V0LnRvcCAtIChlbGVEaW1zLm9mZnNldC50b3AgKyBlbGVEaW1zLmhlaWdodCk7XFxuICAgIHRvcE92ZXIgPSBlbGVEaW1zLm9mZnNldC50b3AgLSBlbGVEaW1zLndpbmRvd0RpbXMub2Zmc2V0LnRvcDtcXG4gICAgbGVmdE92ZXIgPSBlbGVEaW1zLm9mZnNldC5sZWZ0IC0gZWxlRGltcy53aW5kb3dEaW1zLm9mZnNldC5sZWZ0O1xcbiAgICByaWdodE92ZXIgPSBlbGVEaW1zLndpbmRvd0RpbXMud2lkdGggLSAoZWxlRGltcy5vZmZzZXQubGVmdCArIGVsZURpbXMud2lkdGgpO1xcbiAgfVxcblxcbiAgYm90dG9tT3ZlciA9IGlnbm9yZUJvdHRvbSA/IDAgOiBNYXRoLm1pbihib3R0b21PdmVyLCAwKTtcXG4gIHRvcE92ZXIgPSBNYXRoLm1pbih0b3BPdmVyLCAwKTtcXG4gIGxlZnRPdmVyID0gTWF0aC5taW4obGVmdE92ZXIsIDApO1xcbiAgcmlnaHRPdmVyID0gTWF0aC5taW4ocmlnaHRPdmVyLCAwKTtcXG5cXG4gIGlmIChsck9ubHkpIHtcXG4gICAgcmV0dXJuIGxlZnRPdmVyICsgcmlnaHRPdmVyO1xcbiAgfVxcbiAgaWYgKHRiT25seSkge1xcbiAgICByZXR1cm4gdG9wT3ZlciArIGJvdHRvbU92ZXI7XFxuICB9XFxuXFxuICAvLyB1c2Ugc3VtIG9mIHNxdWFyZXMgYi9jIHdlIGNhcmUgYWJvdXQgb3ZlcmxhcCBhcmVhLlxcbiAgcmV0dXJuIE1hdGguc3FydCh0b3BPdmVyICogdG9wT3ZlciArIGJvdHRvbU92ZXIgKiBib3R0b21PdmVyICsgbGVmdE92ZXIgKiBsZWZ0T3ZlciArIHJpZ2h0T3ZlciAqIHJpZ2h0T3Zlcik7XFxufVxcblxcbi8qKlxcbiAqIFVzZXMgbmF0aXZlIG1ldGhvZHMgdG8gcmV0dXJuIGFuIG9iamVjdCBvZiBkaW1lbnNpb24gdmFsdWVzLlxcbiAqIEBmdW5jdGlvblxcbiAqIEBwYXJhbSB7alF1ZXJ5IHx8IEhUTUx9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IG9yIERPTSBlbGVtZW50IGZvciB3aGljaCB0byBnZXQgdGhlIGRpbWVuc2lvbnMuIENhbiBiZSBhbnkgZWxlbWVudCBvdGhlciB0aGF0IGRvY3VtZW50IG9yIHdpbmRvdy5cXG4gKiBAcmV0dXJucyB7T2JqZWN0fSAtIG5lc3RlZCBvYmplY3Qgb2YgaW50ZWdlciBwaXhlbCB2YWx1ZXNcXG4gKiBUT0RPIC0gaWYgZWxlbWVudCBpcyB3aW5kb3csIHJldHVybiBvbmx5IHRob3NlIHZhbHVlcy5cXG4gKi9cXG5mdW5jdGlvbiBHZXREaW1lbnNpb25zKGVsZW0sIHRlc3QpIHtcXG4gIGVsZW0gPSBlbGVtLmxlbmd0aCA/IGVsZW1bMF0gOiBlbGVtO1xcblxcbiAgaWYgKGVsZW0gPT09IHdpbmRvdyB8fCBlbGVtID09PSBkb2N1bWVudCkge1xcbiAgICB0aHJvdyBuZXcgRXJyb3IoXFxcIkknbSBzb3JyeSwgRGF2ZS4gSSdtIGFmcmFpZCBJIGNhbid0IGRvIHRoYXQuXFxcIik7XFxuICB9XFxuXFxuICB2YXIgcmVjdCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXFxuICAgICAgcGFyUmVjdCA9IGVsZW0ucGFyZW50Tm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcXG4gICAgICB3aW5SZWN0ID0gZG9jdW1lbnQuYm9keS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcXG4gICAgICB3aW5ZID0gd2luZG93LnBhZ2VZT2Zmc2V0LFxcbiAgICAgIHdpblggPSB3aW5kb3cucGFnZVhPZmZzZXQ7XFxuXFxuICByZXR1cm4ge1xcbiAgICB3aWR0aDogcmVjdC53aWR0aCxcXG4gICAgaGVpZ2h0OiByZWN0LmhlaWdodCxcXG4gICAgb2Zmc2V0OiB7XFxuICAgICAgdG9wOiByZWN0LnRvcCArIHdpblksXFxuICAgICAgbGVmdDogcmVjdC5sZWZ0ICsgd2luWFxcbiAgICB9LFxcbiAgICBwYXJlbnREaW1zOiB7XFxuICAgICAgd2lkdGg6IHBhclJlY3Qud2lkdGgsXFxuICAgICAgaGVpZ2h0OiBwYXJSZWN0LmhlaWdodCxcXG4gICAgICBvZmZzZXQ6IHtcXG4gICAgICAgIHRvcDogcGFyUmVjdC50b3AgKyB3aW5ZLFxcbiAgICAgICAgbGVmdDogcGFyUmVjdC5sZWZ0ICsgd2luWFxcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgd2luZG93RGltczoge1xcbiAgICAgIHdpZHRoOiB3aW5SZWN0LndpZHRoLFxcbiAgICAgIGhlaWdodDogd2luUmVjdC5oZWlnaHQsXFxuICAgICAgb2Zmc2V0OiB7XFxuICAgICAgICB0b3A6IHdpblksXFxuICAgICAgICBsZWZ0OiB3aW5YXFxuICAgICAgfVxcbiAgICB9XFxuICB9O1xcbn1cXG5cXG4vKipcXG4gKiBSZXR1cm5zIGFuIG9iamVjdCBvZiB0b3AgYW5kIGxlZnQgaW50ZWdlciBwaXhlbCB2YWx1ZXMgZm9yIGR5bmFtaWNhbGx5IHJlbmRlcmVkIGVsZW1lbnRzLFxcbiAqIHN1Y2ggYXM6IFRvb2x0aXAsIFJldmVhbCwgYW5kIERyb3Bkb3duLiBNYWludGFpbmVkIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSwgYW5kIHdoZXJlXFxuICogeW91IGRvbid0IGtub3cgYWxpZ25tZW50LCBidXQgZ2VuZXJhbGx5IGZyb21cXG4gKiA2LjQgZm9yd2FyZCB5b3Ugc2hvdWxkIHVzZSBHZXRFeHBsaWNpdE9mZnNldHMsIGFzIEdldE9mZnNldHMgY29uZmxhdGVzIHBvc2l0aW9uIGFuZCBhbGlnbm1lbnQuXFxuICogQGZ1bmN0aW9uXFxuICogQHBhcmFtIHtqUXVlcnl9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IGZvciB0aGUgZWxlbWVudCBiZWluZyBwb3NpdGlvbmVkLlxcbiAqIEBwYXJhbSB7alF1ZXJ5fSBhbmNob3IgLSBqUXVlcnkgb2JqZWN0IGZvciB0aGUgZWxlbWVudCdzIGFuY2hvciBwb2ludC5cXG4gKiBAcGFyYW0ge1N0cmluZ30gcG9zaXRpb24gLSBhIHN0cmluZyByZWxhdGluZyB0byB0aGUgZGVzaXJlZCBwb3NpdGlvbiBvZiB0aGUgZWxlbWVudCwgcmVsYXRpdmUgdG8gaXQncyBhbmNob3JcXG4gKiBAcGFyYW0ge051bWJlcn0gdk9mZnNldCAtIGludGVnZXIgcGl4ZWwgdmFsdWUgb2YgZGVzaXJlZCB2ZXJ0aWNhbCBzZXBhcmF0aW9uIGJldHdlZW4gYW5jaG9yIGFuZCBlbGVtZW50LlxcbiAqIEBwYXJhbSB7TnVtYmVyfSBoT2Zmc2V0IC0gaW50ZWdlciBwaXhlbCB2YWx1ZSBvZiBkZXNpcmVkIGhvcml6b250YWwgc2VwYXJhdGlvbiBiZXR3ZWVuIGFuY2hvciBhbmQgZWxlbWVudC5cXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlzT3ZlcmZsb3cgLSBpZiBhIGNvbGxpc2lvbiBldmVudCBpcyBkZXRlY3RlZCwgc2V0cyB0byB0cnVlIHRvIGRlZmF1bHQgdGhlIGVsZW1lbnQgdG8gZnVsbCB3aWR0aCAtIGFueSBkZXNpcmVkIG9mZnNldC5cXG4gKiBUT0RPIGFsdGVyL3Jld3JpdGUgdG8gd29yayB3aXRoIGBlbWAgdmFsdWVzIGFzIHdlbGwvaW5zdGVhZCBvZiBwaXhlbHNcXG4gKi9cXG5mdW5jdGlvbiBHZXRPZmZzZXRzKGVsZW1lbnQsIGFuY2hvciwgcG9zaXRpb24sIHZPZmZzZXQsIGhPZmZzZXQsIGlzT3ZlcmZsb3cpIHtcXG4gIGNvbnNvbGUubG9nKFxcXCJOT1RFOiBHZXRPZmZzZXRzIGlzIGRlcHJlY2F0ZWQgaW4gZmF2b3Igb2YgR2V0RXhwbGljaXRPZmZzZXRzIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gNi41XFxcIik7XFxuICBzd2l0Y2ggKHBvc2l0aW9uKSB7XFxuICAgIGNhc2UgJ3RvcCc6XFxuICAgICAgcmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18uaShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX2ZvdW5kYXRpb25fdXRpbF9jb3JlX19bXFxcImFcXFwiIC8qIHJ0bCAqL10pKCkgPyBHZXRFeHBsaWNpdE9mZnNldHMoZWxlbWVudCwgYW5jaG9yLCAndG9wJywgJ2xlZnQnLCB2T2Zmc2V0LCBoT2Zmc2V0LCBpc092ZXJmbG93KSA6IEdldEV4cGxpY2l0T2Zmc2V0cyhlbGVtZW50LCBhbmNob3IsICd0b3AnLCAncmlnaHQnLCB2T2Zmc2V0LCBoT2Zmc2V0LCBpc092ZXJmbG93KTtcXG4gICAgY2FzZSAnYm90dG9tJzpcXG4gICAgICByZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXy5pKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fZm91bmRhdGlvbl91dGlsX2NvcmVfX1tcXFwiYVxcXCIgLyogcnRsICovXSkoKSA/IEdldEV4cGxpY2l0T2Zmc2V0cyhlbGVtZW50LCBhbmNob3IsICdib3R0b20nLCAnbGVmdCcsIHZPZmZzZXQsIGhPZmZzZXQsIGlzT3ZlcmZsb3cpIDogR2V0RXhwbGljaXRPZmZzZXRzKGVsZW1lbnQsIGFuY2hvciwgJ2JvdHRvbScsICdyaWdodCcsIHZPZmZzZXQsIGhPZmZzZXQsIGlzT3ZlcmZsb3cpO1xcbiAgICBjYXNlICdjZW50ZXIgdG9wJzpcXG4gICAgICByZXR1cm4gR2V0RXhwbGljaXRPZmZzZXRzKGVsZW1lbnQsIGFuY2hvciwgJ3RvcCcsICdjZW50ZXInLCB2T2Zmc2V0LCBoT2Zmc2V0LCBpc092ZXJmbG93KTtcXG4gICAgY2FzZSAnY2VudGVyIGJvdHRvbSc6XFxuICAgICAgcmV0dXJuIEdldEV4cGxpY2l0T2Zmc2V0cyhlbGVtZW50LCBhbmNob3IsICdib3R0b20nLCAnY2VudGVyJywgdk9mZnNldCwgaE9mZnNldCwgaXNPdmVyZmxvdyk7XFxuICAgIGNhc2UgJ2NlbnRlciBsZWZ0JzpcXG4gICAgICByZXR1cm4gR2V0RXhwbGljaXRPZmZzZXRzKGVsZW1lbnQsIGFuY2hvciwgJ2xlZnQnLCAnY2VudGVyJywgdk9mZnNldCwgaE9mZnNldCwgaXNPdmVyZmxvdyk7XFxuICAgIGNhc2UgJ2NlbnRlciByaWdodCc6XFxuICAgICAgcmV0dXJuIEdldEV4cGxpY2l0T2Zmc2V0cyhlbGVtZW50LCBhbmNob3IsICdyaWdodCcsICdjZW50ZXInLCB2T2Zmc2V0LCBoT2Zmc2V0LCBpc092ZXJmbG93KTtcXG4gICAgY2FzZSAnbGVmdCBib3R0b20nOlxcbiAgICAgIHJldHVybiBHZXRFeHBsaWNpdE9mZnNldHMoZWxlbWVudCwgYW5jaG9yLCAnYm90dG9tJywgJ2xlZnQnLCB2T2Zmc2V0LCBoT2Zmc2V0LCBpc092ZXJmbG93KTtcXG4gICAgY2FzZSAncmlnaHQgYm90dG9tJzpcXG4gICAgICByZXR1cm4gR2V0RXhwbGljaXRPZmZzZXRzKGVsZW1lbnQsIGFuY2hvciwgJ2JvdHRvbScsICdyaWdodCcsIHZPZmZzZXQsIGhPZmZzZXQsIGlzT3ZlcmZsb3cpO1xcbiAgICAvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eS4uLiB0aGlzIGFsb25nIHdpdGggdGhlIHJldmVhbCBhbmQgcmV2ZWFsIGZ1bGxcXG4gICAgLy8gY2xhc3NlcyBhcmUgdGhlIG9ubHkgb25lcyB0aGF0IGRpZG4ndCByZWZlcmVuY2UgYW5jaG9yXFxuICAgIGNhc2UgJ2NlbnRlcic6XFxuICAgICAgcmV0dXJuIHtcXG4gICAgICAgIGxlZnQ6ICRlbGVEaW1zLndpbmRvd0RpbXMub2Zmc2V0LmxlZnQgKyAkZWxlRGltcy53aW5kb3dEaW1zLndpZHRoIC8gMiAtICRlbGVEaW1zLndpZHRoIC8gMiArIGhPZmZzZXQsXFxuICAgICAgICB0b3A6ICRlbGVEaW1zLndpbmRvd0RpbXMub2Zmc2V0LnRvcCArICRlbGVEaW1zLndpbmRvd0RpbXMuaGVpZ2h0IC8gMiAtICgkZWxlRGltcy5oZWlnaHQgLyAyICsgdk9mZnNldClcXG4gICAgICB9O1xcbiAgICBjYXNlICdyZXZlYWwnOlxcbiAgICAgIHJldHVybiB7XFxuICAgICAgICBsZWZ0OiAoJGVsZURpbXMud2luZG93RGltcy53aWR0aCAtICRlbGVEaW1zLndpZHRoKSAvIDIgKyBoT2Zmc2V0LFxcbiAgICAgICAgdG9wOiAkZWxlRGltcy53aW5kb3dEaW1zLm9mZnNldC50b3AgKyB2T2Zmc2V0XFxuICAgICAgfTtcXG4gICAgY2FzZSAncmV2ZWFsIGZ1bGwnOlxcbiAgICAgIHJldHVybiB7XFxuICAgICAgICBsZWZ0OiAkZWxlRGltcy53aW5kb3dEaW1zLm9mZnNldC5sZWZ0LFxcbiAgICAgICAgdG9wOiAkZWxlRGltcy53aW5kb3dEaW1zLm9mZnNldC50b3BcXG4gICAgICB9O1xcbiAgICAgIGJyZWFrO1xcbiAgICBkZWZhdWx0OlxcbiAgICAgIHJldHVybiB7XFxuICAgICAgICBsZWZ0OiBfX3dlYnBhY2tfcmVxdWlyZV9fLmkoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19mb3VuZGF0aW9uX3V0aWxfY29yZV9fW1xcXCJhXFxcIiAvKiBydGwgKi9dKSgpID8gJGFuY2hvckRpbXMub2Zmc2V0LmxlZnQgLSAkZWxlRGltcy53aWR0aCArICRhbmNob3JEaW1zLndpZHRoIC0gaE9mZnNldCA6ICRhbmNob3JEaW1zLm9mZnNldC5sZWZ0ICsgaE9mZnNldCxcXG4gICAgICAgIHRvcDogJGFuY2hvckRpbXMub2Zmc2V0LnRvcCArICRhbmNob3JEaW1zLmhlaWdodCArIHZPZmZzZXRcXG4gICAgICB9O1xcblxcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBHZXRFeHBsaWNpdE9mZnNldHMoZWxlbWVudCwgYW5jaG9yLCBwb3NpdGlvbiwgYWxpZ25tZW50LCB2T2Zmc2V0LCBoT2Zmc2V0LCBpc092ZXJmbG93KSB7XFxuICB2YXIgJGVsZURpbXMgPSBHZXREaW1lbnNpb25zKGVsZW1lbnQpLFxcbiAgICAgICRhbmNob3JEaW1zID0gYW5jaG9yID8gR2V0RGltZW5zaW9ucyhhbmNob3IpIDogbnVsbDtcXG5cXG4gIHZhciB0b3BWYWwsIGxlZnRWYWw7XFxuXFxuICAvLyBzZXQgcG9zaXRpb24gcmVsYXRlZCBhdHRyaWJ1dGVcXG5cXG4gIHN3aXRjaCAocG9zaXRpb24pIHtcXG4gICAgY2FzZSAndG9wJzpcXG4gICAgICB0b3BWYWwgPSAkYW5jaG9yRGltcy5vZmZzZXQudG9wIC0gKCRlbGVEaW1zLmhlaWdodCArIHZPZmZzZXQpO1xcbiAgICAgIGJyZWFrO1xcbiAgICBjYXNlICdib3R0b20nOlxcbiAgICAgIHRvcFZhbCA9ICRhbmNob3JEaW1zLm9mZnNldC50b3AgKyAkYW5jaG9yRGltcy5oZWlnaHQgKyB2T2Zmc2V0O1xcbiAgICAgIGJyZWFrO1xcbiAgICBjYXNlICdsZWZ0JzpcXG4gICAgICBsZWZ0VmFsID0gJGFuY2hvckRpbXMub2Zmc2V0LmxlZnQgLSAoJGVsZURpbXMud2lkdGggKyBoT2Zmc2V0KTtcXG4gICAgICBicmVhaztcXG4gICAgY2FzZSAncmlnaHQnOlxcbiAgICAgIGxlZnRWYWwgPSAkYW5jaG9yRGltcy5vZmZzZXQubGVmdCArICRhbmNob3JEaW1zLndpZHRoICsgaE9mZnNldDtcXG4gICAgICBicmVhaztcXG4gIH1cXG5cXG4gIC8vIHNldCBhbGlnbm1lbnQgcmVsYXRlZCBhdHRyaWJ1dGVcXG4gIHN3aXRjaCAocG9zaXRpb24pIHtcXG4gICAgY2FzZSAndG9wJzpcXG4gICAgY2FzZSAnYm90dG9tJzpcXG4gICAgICBzd2l0Y2ggKGFsaWdubWVudCkge1xcbiAgICAgICAgY2FzZSAnbGVmdCc6XFxuICAgICAgICAgIGxlZnRWYWwgPSAkYW5jaG9yRGltcy5vZmZzZXQubGVmdCArIGhPZmZzZXQ7XFxuICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgY2FzZSAncmlnaHQnOlxcbiAgICAgICAgICBsZWZ0VmFsID0gJGFuY2hvckRpbXMub2Zmc2V0LmxlZnQgLSAkZWxlRGltcy53aWR0aCArICRhbmNob3JEaW1zLndpZHRoIC0gaE9mZnNldDtcXG4gICAgICAgICAgYnJlYWs7XFxuICAgICAgICBjYXNlICdjZW50ZXInOlxcbiAgICAgICAgICBsZWZ0VmFsID0gaXNPdmVyZmxvdyA/IGhPZmZzZXQgOiAkYW5jaG9yRGltcy5vZmZzZXQubGVmdCArICRhbmNob3JEaW1zLndpZHRoIC8gMiAtICRlbGVEaW1zLndpZHRoIC8gMiArIGhPZmZzZXQ7XFxuICAgICAgICAgIGJyZWFrO1xcbiAgICAgIH1cXG4gICAgICBicmVhaztcXG4gICAgY2FzZSAncmlnaHQnOlxcbiAgICBjYXNlICdsZWZ0JzpcXG4gICAgICBzd2l0Y2ggKGFsaWdubWVudCkge1xcbiAgICAgICAgY2FzZSAnYm90dG9tJzpcXG4gICAgICAgICAgdG9wVmFsID0gJGFuY2hvckRpbXMub2Zmc2V0LnRvcCAtIHZPZmZzZXQgKyAkYW5jaG9yRGltcy5oZWlnaHQgLSAkZWxlRGltcy5oZWlnaHQ7XFxuICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgY2FzZSAndG9wJzpcXG4gICAgICAgICAgdG9wVmFsID0gJGFuY2hvckRpbXMub2Zmc2V0LnRvcCArIHZPZmZzZXQ7XFxuICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgY2FzZSAnY2VudGVyJzpcXG4gICAgICAgICAgdG9wVmFsID0gJGFuY2hvckRpbXMub2Zmc2V0LnRvcCArIHZPZmZzZXQgKyAkYW5jaG9yRGltcy5oZWlnaHQgLyAyIC0gJGVsZURpbXMuaGVpZ2h0IC8gMjtcXG4gICAgICAgICAgYnJlYWs7XFxuICAgICAgfVxcbiAgICAgIGJyZWFrO1xcbiAgfVxcbiAgcmV0dXJuIHsgdG9wOiB0b3BWYWwsIGxlZnQ6IGxlZnRWYWwgfTtcXG59XFxuXFxuXFxuXFxuLyoqKi8gfSksXFxuLyogOCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXFwidXNlIHN0cmljdFxcXCI7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiYVxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gb25JbWFnZXNMb2FkZWQ7IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCA9IF9fd2VicGFja19yZXF1aXJlX18ubihfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X18pO1xcblxcblxcblxcblxcbi8qKlxcbiAqIFJ1bnMgYSBjYWxsYmFjayBmdW5jdGlvbiB3aGVuIGltYWdlcyBhcmUgZnVsbHkgbG9hZGVkLlxcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbWFnZXMgLSBJbWFnZShzKSB0byBjaGVjayBpZiBsb2FkZWQuXFxuICogQHBhcmFtIHtGdW5jfSBjYWxsYmFjayAtIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgd2hlbiBpbWFnZSBpcyBmdWxseSBsb2FkZWQuXFxuICovXFxuZnVuY3Rpb24gb25JbWFnZXNMb2FkZWQoaW1hZ2VzLCBjYWxsYmFjaykge1xcbiAgdmFyIHNlbGYgPSB0aGlzLFxcbiAgICAgIHVubG9hZGVkID0gaW1hZ2VzLmxlbmd0aDtcXG5cXG4gIGlmICh1bmxvYWRlZCA9PT0gMCkge1xcbiAgICBjYWxsYmFjaygpO1xcbiAgfVxcblxcbiAgaW1hZ2VzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAvLyBDaGVjayBpZiBpbWFnZSBpcyBsb2FkZWRcXG4gICAgaWYgKHRoaXMuY29tcGxldGUgJiYgdGhpcy5uYXR1cmFsV2lkdGggIT09IHVuZGVmaW5lZCkge1xcbiAgICAgIHNpbmdsZUltYWdlTG9hZGVkKCk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgLy8gSWYgdGhlIGFib3ZlIGNoZWNrIGZhaWxlZCwgc2ltdWxhdGUgbG9hZGluZyBvbiBkZXRhY2hlZCBlbGVtZW50LlxcbiAgICAgIHZhciBpbWFnZSA9IG5ldyBJbWFnZSgpO1xcbiAgICAgIC8vIFN0aWxsIGNvdW50IGltYWdlIGFzIGxvYWRlZCBpZiBpdCBmaW5hbGl6ZXMgd2l0aCBhbiBlcnJvci5cXG4gICAgICB2YXIgZXZlbnRzID0gXFxcImxvYWQuemYuaW1hZ2VzIGVycm9yLnpmLmltYWdlc1xcXCI7XFxuICAgICAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKShpbWFnZSkub25lKGV2ZW50cywgZnVuY3Rpb24gbWUoZXZlbnQpIHtcXG4gICAgICAgIC8vIFVuYmluZCB0aGUgZXZlbnQgbGlzdGVuZXJzLiBXZSdyZSB1c2luZyAnb25lJyBidXQgb25seSBvbmUgb2YgdGhlIHR3byBldmVudHMgd2lsbCBoYXZlIGZpcmVkLlxcbiAgICAgICAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSh0aGlzKS5vZmYoZXZlbnRzLCBtZSk7XFxuICAgICAgICBzaW5nbGVJbWFnZUxvYWRlZCgpO1xcbiAgICAgIH0pO1xcbiAgICAgIGltYWdlLnNyYyA9IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0KCkodGhpcykuYXR0cignc3JjJyk7XFxuICAgIH1cXG4gIH0pO1xcblxcbiAgZnVuY3Rpb24gc2luZ2xlSW1hZ2VMb2FkZWQoKSB7XFxuICAgIHVubG9hZGVkLS07XFxuICAgIGlmICh1bmxvYWRlZCA9PT0gMCkge1xcbiAgICAgIGNhbGxiYWNrKCk7XFxuICAgIH1cXG4gIH1cXG59XFxuXFxuXFxuXFxuLyoqKi8gfSksXFxuLyogOSAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXFwidXNlIHN0cmljdFxcXCI7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiYVxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gTmVzdDsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0ID0gX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfXyk7XFxuXFxuXFxuXFxuXFxudmFyIE5lc3QgPSB7XFxuICBGZWF0aGVyOiBmdW5jdGlvbiAobWVudSkge1xcbiAgICB2YXIgdHlwZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJ3pmJztcXG5cXG4gICAgbWVudS5hdHRyKCdyb2xlJywgJ21lbnViYXInKTtcXG5cXG4gICAgdmFyIGl0ZW1zID0gbWVudS5maW5kKCdsaScpLmF0dHIoeyAncm9sZSc6ICdtZW51aXRlbScgfSksXFxuICAgICAgICBzdWJNZW51Q2xhc3MgPSAnaXMtJyArIHR5cGUgKyAnLXN1Ym1lbnUnLFxcbiAgICAgICAgc3ViSXRlbUNsYXNzID0gc3ViTWVudUNsYXNzICsgJy1pdGVtJyxcXG4gICAgICAgIGhhc1N1YkNsYXNzID0gJ2lzLScgKyB0eXBlICsgJy1zdWJtZW51LXBhcmVudCcsXFxuICAgICAgICBhcHBseUFyaWEgPSB0eXBlICE9PSAnYWNjb3JkaW9uJzsgLy8gQWNjb3JkaW9ucyBoYW5kbGUgdGhlaXIgb3duIEFSSUEgYXR0cml1dGVzLlxcblxcbiAgICBpdGVtcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICB2YXIgJGl0ZW0gPSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKHRoaXMpLFxcbiAgICAgICAgICAkc3ViID0gJGl0ZW0uY2hpbGRyZW4oJ3VsJyk7XFxuXFxuICAgICAgaWYgKCRzdWIubGVuZ3RoKSB7XFxuICAgICAgICAkaXRlbS5hZGRDbGFzcyhoYXNTdWJDbGFzcyk7XFxuICAgICAgICAkc3ViLmFkZENsYXNzKCdzdWJtZW51ICcgKyBzdWJNZW51Q2xhc3MpLmF0dHIoeyAnZGF0YS1zdWJtZW51JzogJycgfSk7XFxuICAgICAgICBpZiAoYXBwbHlBcmlhKSB7XFxuICAgICAgICAgICRpdGVtLmF0dHIoe1xcbiAgICAgICAgICAgICdhcmlhLWhhc3BvcHVwJzogdHJ1ZSxcXG4gICAgICAgICAgICAnYXJpYS1sYWJlbCc6ICRpdGVtLmNoaWxkcmVuKCdhOmZpcnN0JykudGV4dCgpXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgICAvLyBOb3RlOiAgRHJpbGxkb3ducyBiZWhhdmUgZGlmZmVyZW50bHkgaW4gaG93IHRoZXkgaGlkZSwgYW5kIHNvIG5lZWRcXG4gICAgICAgICAgLy8gYWRkaXRpb25hbCBhdHRyaWJ1dGVzLiAgV2Ugc2hvdWxkIGxvb2sgaWYgdGhpcyBwb3NzaWJseSBvdmVyLWdlbmVyYWxpemVkXFxuICAgICAgICAgIC8vIHV0aWxpdHkgKE5lc3QpIGlzIGFwcHJvcHJpYXRlIHdoZW4gd2UgcmV3b3JrIG1lbnVzIGluIDYuNFxcbiAgICAgICAgICBpZiAodHlwZSA9PT0gJ2RyaWxsZG93bicpIHtcXG4gICAgICAgICAgICAkaXRlbS5hdHRyKHsgJ2FyaWEtZXhwYW5kZWQnOiBmYWxzZSB9KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgJHN1Yi5hZGRDbGFzcygnc3VibWVudSAnICsgc3ViTWVudUNsYXNzKS5hdHRyKHtcXG4gICAgICAgICAgJ2RhdGEtc3VibWVudSc6ICcnLFxcbiAgICAgICAgICAncm9sZSc6ICdtZW51J1xcbiAgICAgICAgfSk7XFxuICAgICAgICBpZiAodHlwZSA9PT0gJ2RyaWxsZG93bicpIHtcXG4gICAgICAgICAgJHN1Yi5hdHRyKHsgJ2FyaWEtaGlkZGVuJzogdHJ1ZSB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCRpdGVtLnBhcmVudCgnW2RhdGEtc3VibWVudV0nKS5sZW5ndGgpIHtcXG4gICAgICAgICRpdGVtLmFkZENsYXNzKCdpcy1zdWJtZW51LWl0ZW0gJyArIHN1Ykl0ZW1DbGFzcyk7XFxuICAgICAgfVxcbiAgICB9KTtcXG5cXG4gICAgcmV0dXJuO1xcbiAgfSxcXG4gIEJ1cm46IGZ1bmN0aW9uIChtZW51LCB0eXBlKSB7XFxuICAgIHZhciAvL2l0ZW1zID0gbWVudS5maW5kKCdsaScpLFxcbiAgICBzdWJNZW51Q2xhc3MgPSAnaXMtJyArIHR5cGUgKyAnLXN1Ym1lbnUnLFxcbiAgICAgICAgc3ViSXRlbUNsYXNzID0gc3ViTWVudUNsYXNzICsgJy1pdGVtJyxcXG4gICAgICAgIGhhc1N1YkNsYXNzID0gJ2lzLScgKyB0eXBlICsgJy1zdWJtZW51LXBhcmVudCc7XFxuXFxuICAgIG1lbnUuZmluZCgnPmxpLCAubWVudSwgLm1lbnUgPiBsaScpLnJlbW92ZUNsYXNzKHN1Yk1lbnVDbGFzcyArICcgJyArIHN1Ykl0ZW1DbGFzcyArICcgJyArIGhhc1N1YkNsYXNzICsgJyBpcy1zdWJtZW51LWl0ZW0gc3VibWVudSBpcy1hY3RpdmUnKS5yZW1vdmVBdHRyKCdkYXRhLXN1Ym1lbnUnKS5jc3MoJ2Rpc3BsYXknLCAnJyk7XFxuICB9XFxufTtcXG5cXG5cXG5cXG4vKioqLyB9KSxcXG4vKiAxMCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXFwidXNlIHN0cmljdFxcXCI7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiYVxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gVG91Y2g7IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCA9IF9fd2VicGFja19yZXF1aXJlX18ubihfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X18pO1xcbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXFxcInZhbHVlXFxcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xcblxcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7IH0gfVxcblxcbi8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcXG4vLyoqV29yayBpbnNwaXJlZCBieSBtdWx0aXBsZSBqcXVlcnkgc3dpcGUgcGx1Z2lucyoqXFxuLy8qKkRvbmUgYnkgWW9oYWkgQXJhcmF0ICoqKioqKioqKioqKioqKioqKioqKioqKioqKlxcbi8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcXG5cXG5cXG5cXG52YXIgVG91Y2ggPSB7fTtcXG5cXG52YXIgc3RhcnRQb3NYLFxcbiAgICBzdGFydFBvc1ksXFxuICAgIHN0YXJ0VGltZSxcXG4gICAgZWxhcHNlZFRpbWUsXFxuICAgIGlzTW92aW5nID0gZmFsc2U7XFxuXFxuZnVuY3Rpb24gb25Ub3VjaEVuZCgpIHtcXG4gIC8vICBhbGVydCh0aGlzKTtcXG4gIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgb25Ub3VjaE1vdmUpO1xcbiAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIG9uVG91Y2hFbmQpO1xcbiAgaXNNb3ZpbmcgPSBmYWxzZTtcXG59XFxuXFxuZnVuY3Rpb24gb25Ub3VjaE1vdmUoZSkge1xcbiAgaWYgKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0LmEuc3BvdFN3aXBlLnByZXZlbnREZWZhdWx0KSB7XFxuICAgIGUucHJldmVudERlZmF1bHQoKTtcXG4gIH1cXG4gIGlmIChpc01vdmluZykge1xcbiAgICB2YXIgeCA9IGUudG91Y2hlc1swXS5wYWdlWDtcXG4gICAgdmFyIHkgPSBlLnRvdWNoZXNbMF0ucGFnZVk7XFxuICAgIHZhciBkeCA9IHN0YXJ0UG9zWCAtIHg7XFxuICAgIHZhciBkeSA9IHN0YXJ0UG9zWSAtIHk7XFxuICAgIHZhciBkaXI7XFxuICAgIGVsYXBzZWRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSBzdGFydFRpbWU7XFxuICAgIGlmIChNYXRoLmFicyhkeCkgPj0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQuYS5zcG90U3dpcGUubW92ZVRocmVzaG9sZCAmJiBlbGFwc2VkVGltZSA8PSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdC5hLnNwb3RTd2lwZS50aW1lVGhyZXNob2xkKSB7XFxuICAgICAgZGlyID0gZHggPiAwID8gJ2xlZnQnIDogJ3JpZ2h0JztcXG4gICAgfVxcbiAgICAvLyBlbHNlIGlmKE1hdGguYWJzKGR5KSA+PSAkLnNwb3RTd2lwZS5tb3ZlVGhyZXNob2xkICYmIGVsYXBzZWRUaW1lIDw9ICQuc3BvdFN3aXBlLnRpbWVUaHJlc2hvbGQpIHtcXG4gICAgLy8gICBkaXIgPSBkeSA+IDAgPyAnZG93bicgOiAndXAnO1xcbiAgICAvLyB9XFxuICAgIGlmIChkaXIpIHtcXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgb25Ub3VjaEVuZC5jYWxsKHRoaXMpO1xcbiAgICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0KCkodGhpcykudHJpZ2dlcignc3dpcGUnLCBkaXIpLnRyaWdnZXIoJ3N3aXBlJyArIGRpcik7XFxuICAgIH1cXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gb25Ub3VjaFN0YXJ0KGUpIHtcXG4gIGlmIChlLnRvdWNoZXMubGVuZ3RoID09IDEpIHtcXG4gICAgc3RhcnRQb3NYID0gZS50b3VjaGVzWzBdLnBhZ2VYO1xcbiAgICBzdGFydFBvc1kgPSBlLnRvdWNoZXNbMF0ucGFnZVk7XFxuICAgIGlzTW92aW5nID0gdHJ1ZTtcXG4gICAgc3RhcnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XFxuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgb25Ub3VjaE1vdmUsIGZhbHNlKTtcXG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIG9uVG91Y2hFbmQsIGZhbHNlKTtcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gaW5pdCgpIHtcXG4gIHRoaXMuYWRkRXZlbnRMaXN0ZW5lciAmJiB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBvblRvdWNoU3RhcnQsIGZhbHNlKTtcXG59XFxuXFxuZnVuY3Rpb24gdGVhcmRvd24oKSB7XFxuICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBvblRvdWNoU3RhcnQpO1xcbn1cXG5cXG52YXIgU3BvdFN3aXBlID0gZnVuY3Rpb24gKCkge1xcbiAgZnVuY3Rpb24gU3BvdFN3aXBlKCQpIHtcXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNwb3RTd2lwZSk7XFxuXFxuICAgIHRoaXMudmVyc2lvbiA9ICcxLjAuMCc7XFxuICAgIHRoaXMuZW5hYmxlZCA9ICdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcXG4gICAgdGhpcy5wcmV2ZW50RGVmYXVsdCA9IGZhbHNlO1xcbiAgICB0aGlzLm1vdmVUaHJlc2hvbGQgPSA3NTtcXG4gICAgdGhpcy50aW1lVGhyZXNob2xkID0gMjAwO1xcbiAgICB0aGlzLiQgPSAkO1xcbiAgICB0aGlzLl9pbml0KCk7XFxuICB9XFxuXFxuICBfY3JlYXRlQ2xhc3MoU3BvdFN3aXBlLCBbe1xcbiAgICBrZXk6ICdfaW5pdCcsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdCgpIHtcXG4gICAgICB2YXIgJCA9IHRoaXMuJDtcXG4gICAgICAkLmV2ZW50LnNwZWNpYWwuc3dpcGUgPSB7IHNldHVwOiBpbml0IH07XFxuXFxuICAgICAgJC5lYWNoKFsnbGVmdCcsICd1cCcsICdkb3duJywgJ3JpZ2h0J10sIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICQuZXZlbnQuc3BlY2lhbFsnc3dpcGUnICsgdGhpc10gPSB7IHNldHVwOiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgJCh0aGlzKS5vbignc3dpcGUnLCAkLm5vb3ApO1xcbiAgICAgICAgICB9IH07XFxuICAgICAgfSk7XFxuICAgIH1cXG4gIH1dKTtcXG5cXG4gIHJldHVybiBTcG90U3dpcGU7XFxufSgpO1xcblxcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXFxuICogQXMgZmFyIGFzIEkgY2FuIHRlbGwsIGJvdGggc2V0dXBTcG90U3dpcGUgYW5kICAgICpcXG4gKiBzZXR1cFRvdWNoSGFuZGxlciBzaG91bGQgYmUgaWRlbXBvdGVudCwgICAgICAgICAgKlxcbiAqIGJlY2F1c2UgdGhleSBkaXJlY3RseSByZXBsYWNlIGZ1bmN0aW9ucyAmICAgICAgICAqXFxuICogdmFsdWVzLCBhbmQgZG8gbm90IGFkZCBldmVudCBoYW5kbGVycyBkaXJlY3RseS4gICpcXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG5cXG5Ub3VjaC5zZXR1cFNwb3RTd2lwZSA9IGZ1bmN0aW9uICgkKSB7XFxuICAkLnNwb3RTd2lwZSA9IG5ldyBTcG90U3dpcGUoJCk7XFxufTtcXG5cXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxcbiAqIE1ldGhvZCBmb3IgYWRkaW5nIHBzZXVkbyBkcmFnIGV2ZW50cyB0byBlbGVtZW50cyAqXFxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG5Ub3VjaC5zZXR1cFRvdWNoSGFuZGxlciA9IGZ1bmN0aW9uICgkKSB7XFxuICAkLmZuLmFkZFRvdWNoID0gZnVuY3Rpb24gKCkge1xcbiAgICB0aGlzLmVhY2goZnVuY3Rpb24gKGksIGVsKSB7XFxuICAgICAgJChlbCkuYmluZCgndG91Y2hzdGFydCB0b3VjaG1vdmUgdG91Y2hlbmQgdG91Y2hjYW5jZWwnLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAvL3dlIHBhc3MgdGhlIG9yaWdpbmFsIGV2ZW50IG9iamVjdCBiZWNhdXNlIHRoZSBqUXVlcnkgZXZlbnRcXG4gICAgICAgIC8vb2JqZWN0IGlzIG5vcm1hbGl6ZWQgdG8gdzNjIHNwZWNzIGFuZCBkb2VzIG5vdCBwcm92aWRlIHRoZSBUb3VjaExpc3RcXG4gICAgICAgIGhhbmRsZVRvdWNoKGV2ZW50KTtcXG4gICAgICB9KTtcXG4gICAgfSk7XFxuXFxuICAgIHZhciBoYW5kbGVUb3VjaCA9IGZ1bmN0aW9uIChldmVudCkge1xcbiAgICAgIHZhciB0b3VjaGVzID0gZXZlbnQuY2hhbmdlZFRvdWNoZXMsXFxuICAgICAgICAgIGZpcnN0ID0gdG91Y2hlc1swXSxcXG4gICAgICAgICAgZXZlbnRUeXBlcyA9IHtcXG4gICAgICAgIHRvdWNoc3RhcnQ6ICdtb3VzZWRvd24nLFxcbiAgICAgICAgdG91Y2htb3ZlOiAnbW91c2Vtb3ZlJyxcXG4gICAgICAgIHRvdWNoZW5kOiAnbW91c2V1cCdcXG4gICAgICB9LFxcbiAgICAgICAgICB0eXBlID0gZXZlbnRUeXBlc1tldmVudC50eXBlXSxcXG4gICAgICAgICAgc2ltdWxhdGVkRXZlbnQ7XFxuXFxuICAgICAgaWYgKCdNb3VzZUV2ZW50JyBpbiB3aW5kb3cgJiYgdHlwZW9mIHdpbmRvdy5Nb3VzZUV2ZW50ID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgICBzaW11bGF0ZWRFdmVudCA9IG5ldyB3aW5kb3cuTW91c2VFdmVudCh0eXBlLCB7XFxuICAgICAgICAgICdidWJibGVzJzogdHJ1ZSxcXG4gICAgICAgICAgJ2NhbmNlbGFibGUnOiB0cnVlLFxcbiAgICAgICAgICAnc2NyZWVuWCc6IGZpcnN0LnNjcmVlblgsXFxuICAgICAgICAgICdzY3JlZW5ZJzogZmlyc3Quc2NyZWVuWSxcXG4gICAgICAgICAgJ2NsaWVudFgnOiBmaXJzdC5jbGllbnRYLFxcbiAgICAgICAgICAnY2xpZW50WSc6IGZpcnN0LmNsaWVudFlcXG4gICAgICAgIH0pO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBzaW11bGF0ZWRFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdNb3VzZUV2ZW50Jyk7XFxuICAgICAgICBzaW11bGF0ZWRFdmVudC5pbml0TW91c2VFdmVudCh0eXBlLCB0cnVlLCB0cnVlLCB3aW5kb3csIDEsIGZpcnN0LnNjcmVlblgsIGZpcnN0LnNjcmVlblksIGZpcnN0LmNsaWVudFgsIGZpcnN0LmNsaWVudFksIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAwIC8qbGVmdCovLCBudWxsKTtcXG4gICAgICB9XFxuICAgICAgZmlyc3QudGFyZ2V0LmRpc3BhdGNoRXZlbnQoc2ltdWxhdGVkRXZlbnQpO1xcbiAgICB9O1xcbiAgfTtcXG59O1xcblxcblRvdWNoLmluaXQgPSBmdW5jdGlvbiAoJCkge1xcbiAgaWYgKHR5cGVvZiAkLnNwb3RTd2lwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgVG91Y2guc2V0dXBTcG90U3dpcGUoJCk7XFxuICAgIFRvdWNoLnNldHVwVG91Y2hIYW5kbGVyKCQpO1xcbiAgfVxcbn07XFxuXFxuXFxuXFxuLyoqKi8gfSksXFxuLyogMTEgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImFcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIEFjY29yZGlvbjsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0ID0gX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfXyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fZm91bmRhdGlvbl91dGlsX2tleWJvYXJkX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX2ZvdW5kYXRpb25fdXRpbF9jb3JlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX2ZvdW5kYXRpb25fcGx1Z2luX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xcblxcblxcbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXFxcInZhbHVlXFxcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xcblxcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7IH0gfVxcblxcbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcXFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXFxcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcXFwib2JqZWN0XFxcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXFxcImZ1bmN0aW9uXFxcIikgPyBjYWxsIDogc2VsZjsgfVxcblxcbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFxcXCJmdW5jdGlvblxcXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFxcXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XFxuXFxuXFxuXFxuXFxuXFxuXFxuLyoqXFxuICogQWNjb3JkaW9uIG1vZHVsZS5cXG4gKiBAbW9kdWxlIGZvdW5kYXRpb24uYWNjb3JkaW9uXFxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5rZXlib2FyZFxcbiAqL1xcblxcbnZhciBBY2NvcmRpb24gPSBmdW5jdGlvbiAoX1BsdWdpbikge1xcbiAgX2luaGVyaXRzKEFjY29yZGlvbiwgX1BsdWdpbik7XFxuXFxuICBmdW5jdGlvbiBBY2NvcmRpb24oKSB7XFxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBY2NvcmRpb24pO1xcblxcbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEFjY29yZGlvbi5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEFjY29yZGlvbikpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xcbiAgfVxcblxcbiAgX2NyZWF0ZUNsYXNzKEFjY29yZGlvbiwgW3tcXG4gICAga2V5OiAnX3NldHVwJyxcXG5cXG4gICAgLyoqXFxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgYW4gYWNjb3JkaW9uLlxcbiAgICAgKiBAY2xhc3NcXG4gICAgICogQG5hbWUgQWNjb3JkaW9uXFxuICAgICAqIEBmaXJlcyBBY2NvcmRpb24jaW5pdFxcbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gbWFrZSBpbnRvIGFuIGFjY29yZGlvbi5cXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBhIHBsYWluIG9iamVjdCB3aXRoIHNldHRpbmdzIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IG9wdGlvbnMuXFxuICAgICAqL1xcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwKGVsZW1lbnQsIG9wdGlvbnMpIHtcXG4gICAgICB0aGlzLiRlbGVtZW50ID0gZWxlbWVudDtcXG4gICAgICB0aGlzLm9wdGlvbnMgPSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdC5hLmV4dGVuZCh7fSwgQWNjb3JkaW9uLmRlZmF1bHRzLCB0aGlzLiRlbGVtZW50LmRhdGEoKSwgb3B0aW9ucyk7XFxuXFxuICAgICAgdGhpcy5jbGFzc05hbWUgPSAnQWNjb3JkaW9uJzsgLy8gaWU5IGJhY2sgY29tcGF0XFxuICAgICAgdGhpcy5faW5pdCgpO1xcblxcbiAgICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fZm91bmRhdGlvbl91dGlsX2tleWJvYXJkX19bXFxcImFcXFwiIC8qIEtleWJvYXJkICovXS5yZWdpc3RlcignQWNjb3JkaW9uJywge1xcbiAgICAgICAgJ0VOVEVSJzogJ3RvZ2dsZScsXFxuICAgICAgICAnU1BBQ0UnOiAndG9nZ2xlJyxcXG4gICAgICAgICdBUlJPV19ET1dOJzogJ25leHQnLFxcbiAgICAgICAgJ0FSUk9XX1VQJzogJ3ByZXZpb3VzJ1xcbiAgICAgIH0pO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgYWNjb3JkaW9uIGJ5IGFuaW1hdGluZyB0aGUgcHJlc2V0IGFjdGl2ZSBwYW5lKHMpLlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAnX2luaXQnLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXQoKSB7XFxuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XFxuXFxuICAgICAgdGhpcy4kZWxlbWVudC5hdHRyKCdyb2xlJywgJ3RhYmxpc3QnKTtcXG4gICAgICB0aGlzLiR0YWJzID0gdGhpcy4kZWxlbWVudC5jaGlsZHJlbignW2RhdGEtYWNjb3JkaW9uLWl0ZW1dJyk7XFxuXFxuICAgICAgdGhpcy4kdGFicy5lYWNoKGZ1bmN0aW9uIChpZHgsIGVsKSB7XFxuICAgICAgICB2YXIgJGVsID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKShlbCksXFxuICAgICAgICAgICAgJGNvbnRlbnQgPSAkZWwuY2hpbGRyZW4oJ1tkYXRhLXRhYi1jb250ZW50XScpLFxcbiAgICAgICAgICAgIGlkID0gJGNvbnRlbnRbMF0uaWQgfHwgX193ZWJwYWNrX3JlcXVpcmVfXy5pKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fZm91bmRhdGlvbl91dGlsX2NvcmVfX1tcXFwiYlxcXCIgLyogR2V0WW9EaWdpdHMgKi9dKSg2LCAnYWNjb3JkaW9uJyksXFxuICAgICAgICAgICAgbGlua0lkID0gZWwuaWQgfHwgaWQgKyAnLWxhYmVsJztcXG5cXG4gICAgICAgICRlbC5maW5kKCdhOmZpcnN0JykuYXR0cih7XFxuICAgICAgICAgICdhcmlhLWNvbnRyb2xzJzogaWQsXFxuICAgICAgICAgICdyb2xlJzogJ3RhYicsXFxuICAgICAgICAgICdpZCc6IGxpbmtJZCxcXG4gICAgICAgICAgJ2FyaWEtZXhwYW5kZWQnOiBmYWxzZSxcXG4gICAgICAgICAgJ2FyaWEtc2VsZWN0ZWQnOiBmYWxzZVxcbiAgICAgICAgfSk7XFxuXFxuICAgICAgICAkY29udGVudC5hdHRyKHsgJ3JvbGUnOiAndGFicGFuZWwnLCAnYXJpYS1sYWJlbGxlZGJ5JzogbGlua0lkLCAnYXJpYS1oaWRkZW4nOiB0cnVlLCAnaWQnOiBpZCB9KTtcXG4gICAgICB9KTtcXG4gICAgICB2YXIgJGluaXRBY3RpdmUgPSB0aGlzLiRlbGVtZW50LmZpbmQoJy5pcy1hY3RpdmUnKS5jaGlsZHJlbignW2RhdGEtdGFiLWNvbnRlbnRdJyk7XFxuICAgICAgdGhpcy5maXJzdFRpbWVJbml0ID0gdHJ1ZTtcXG4gICAgICBpZiAoJGluaXRBY3RpdmUubGVuZ3RoKSB7XFxuICAgICAgICB0aGlzLmRvd24oJGluaXRBY3RpdmUsIHRoaXMuZmlyc3RUaW1lSW5pdCk7XFxuICAgICAgICB0aGlzLmZpcnN0VGltZUluaXQgPSBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5fY2hlY2tEZWVwTGluayA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciBhbmNob3IgPSB3aW5kb3cubG9jYXRpb24uaGFzaDtcXG4gICAgICAgIC8vbmVlZCBhIGhhc2ggYW5kIGEgcmVsZXZhbnQgYW5jaG9yIGluIHRoaXMgdGFic2V0XFxuICAgICAgICBpZiAoYW5jaG9yLmxlbmd0aCkge1xcbiAgICAgICAgICB2YXIgJGxpbmsgPSBfdGhpczMuJGVsZW1lbnQuZmluZCgnW2hyZWYkPVxcXCInICsgYW5jaG9yICsgJ1xcXCJdJyksXFxuICAgICAgICAgICAgICAkYW5jaG9yID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKShhbmNob3IpO1xcblxcbiAgICAgICAgICBpZiAoJGxpbmsubGVuZ3RoICYmICRhbmNob3IpIHtcXG4gICAgICAgICAgICBpZiAoISRsaW5rLnBhcmVudCgnW2RhdGEtYWNjb3JkaW9uLWl0ZW1dJykuaGFzQ2xhc3MoJ2lzLWFjdGl2ZScpKSB7XFxuICAgICAgICAgICAgICBfdGhpczMuZG93bigkYW5jaG9yLCBfdGhpczMuZmlyc3RUaW1lSW5pdCk7XFxuICAgICAgICAgICAgICBfdGhpczMuZmlyc3RUaW1lSW5pdCA9IGZhbHNlO1xcbiAgICAgICAgICAgIH07XFxuXFxuICAgICAgICAgICAgLy9yb2xsIHVwIGEgbGl0dGxlIHRvIHNob3cgdGhlIHRpdGxlc1xcbiAgICAgICAgICAgIGlmIChfdGhpczMub3B0aW9ucy5kZWVwTGlua1NtdWRnZSkge1xcbiAgICAgICAgICAgICAgdmFyIF90aGlzID0gX3RoaXMzO1xcbiAgICAgICAgICAgICAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSh3aW5kb3cpLmxvYWQoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gX3RoaXMuJGVsZW1lbnQub2Zmc2V0KCk7XFxuICAgICAgICAgICAgICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0KCkoJ2h0bWwsIGJvZHknKS5hbmltYXRlKHsgc2Nyb2xsVG9wOiBvZmZzZXQudG9wIH0sIF90aGlzLm9wdGlvbnMuZGVlcExpbmtTbXVkZ2VEZWxheSk7XFxuICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgLyoqXFxuICAgICAgICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHpwbHVnaW4gaGFzIGRlZXBsaW5rZWQgYXQgcGFnZWxvYWRcXG4gICAgICAgICAgICAgICogQGV2ZW50IEFjY29yZGlvbiNkZWVwbGlua1xcbiAgICAgICAgICAgICAgKi9cXG4gICAgICAgICAgICBfdGhpczMuJGVsZW1lbnQudHJpZ2dlcignZGVlcGxpbmsuemYuYWNjb3JkaW9uJywgWyRsaW5rLCAkYW5jaG9yXSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9O1xcblxcbiAgICAgIC8vdXNlIGJyb3dzZXIgdG8gb3BlbiBhIHRhYiwgaWYgaXQgZXhpc3RzIGluIHRoaXMgdGFic2V0XFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5kZWVwTGluaykge1xcbiAgICAgICAgdGhpcy5fY2hlY2tEZWVwTGluaygpO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9ldmVudHMoKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQWRkcyBldmVudCBoYW5kbGVycyBmb3IgaXRlbXMgd2l0aGluIHRoZSBhY2NvcmRpb24uXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6ICdfZXZlbnRzJyxcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9ldmVudHMoKSB7XFxuICAgICAgdmFyIF90aGlzID0gdGhpcztcXG5cXG4gICAgICB0aGlzLiR0YWJzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyICRlbGVtID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSh0aGlzKTtcXG4gICAgICAgIHZhciAkdGFiQ29udGVudCA9ICRlbGVtLmNoaWxkcmVuKCdbZGF0YS10YWItY29udGVudF0nKTtcXG4gICAgICAgIGlmICgkdGFiQ29udGVudC5sZW5ndGgpIHtcXG4gICAgICAgICAgJGVsZW0uY2hpbGRyZW4oJ2EnKS5vZmYoJ2NsaWNrLnpmLmFjY29yZGlvbiBrZXlkb3duLnpmLmFjY29yZGlvbicpLm9uKCdjbGljay56Zi5hY2NvcmRpb24nLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgICAgICBfdGhpcy50b2dnbGUoJHRhYkNvbnRlbnQpO1xcbiAgICAgICAgICB9KS5vbigna2V5ZG93bi56Zi5hY2NvcmRpb24nLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fZm91bmRhdGlvbl91dGlsX2tleWJvYXJkX19bXFxcImFcXFwiIC8qIEtleWJvYXJkICovXS5oYW5kbGVLZXkoZSwgJ0FjY29yZGlvbicsIHtcXG4gICAgICAgICAgICAgIHRvZ2dsZTogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICBfdGhpcy50b2dnbGUoJHRhYkNvbnRlbnQpO1xcbiAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICAgdmFyICRhID0gJGVsZW0ubmV4dCgpLmZpbmQoJ2EnKS5mb2N1cygpO1xcbiAgICAgICAgICAgICAgICBpZiAoIV90aGlzLm9wdGlvbnMubXVsdGlFeHBhbmQpIHtcXG4gICAgICAgICAgICAgICAgICAkYS50cmlnZ2VyKCdjbGljay56Zi5hY2NvcmRpb24nKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgIHByZXZpb3VzOiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgIHZhciAkYSA9ICRlbGVtLnByZXYoKS5maW5kKCdhJykuZm9jdXMoKTtcXG4gICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5vcHRpb25zLm11bHRpRXhwYW5kKSB7XFxuICAgICAgICAgICAgICAgICAgJGEudHJpZ2dlcignY2xpY2suemYuYWNjb3JkaW9uJyk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICBoYW5kbGVkOiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5kZWVwTGluaykge1xcbiAgICAgICAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIHRoaXMuX2NoZWNrRGVlcExpbmspO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogVG9nZ2xlcyB0aGUgc2VsZWN0ZWQgY29udGVudCBwYW5lJ3Mgb3Blbi9jbG9zZSBzdGF0ZS5cXG4gICAgICogQHBhcmFtIHtqUXVlcnl9ICR0YXJnZXQgLSBqUXVlcnkgb2JqZWN0IG9mIHRoZSBwYW5lIHRvIHRvZ2dsZSAoYC5hY2NvcmRpb24tY29udGVudGApLlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogJ3RvZ2dsZScsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b2dnbGUoJHRhcmdldCkge1xcbiAgICAgIGlmICgkdGFyZ2V0LmNsb3Nlc3QoJ1tkYXRhLWFjY29yZGlvbl0nKS5pcygnW2Rpc2FibGVkXScpKSB7XFxuICAgICAgICBjb25zb2xlLmluZm8oJ0Nhbm5vdCB0b2dnbGUgYW4gYWNjb3JkaW9uIHRoYXQgaXMgZGlzYWJsZWQuJyk7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcbiAgICAgIGlmICgkdGFyZ2V0LnBhcmVudCgpLmhhc0NsYXNzKCdpcy1hY3RpdmUnKSkge1xcbiAgICAgICAgdGhpcy51cCgkdGFyZ2V0KTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdGhpcy5kb3duKCR0YXJnZXQpO1xcbiAgICAgIH1cXG4gICAgICAvL2VpdGhlciByZXBsYWNlIG9yIHVwZGF0ZSBicm93c2VyIGhpc3RvcnlcXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmRlZXBMaW5rKSB7XFxuICAgICAgICB2YXIgYW5jaG9yID0gJHRhcmdldC5wcmV2KCdhJykuYXR0cignaHJlZicpO1xcblxcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy51cGRhdGVIaXN0b3J5KSB7XFxuICAgICAgICAgIGhpc3RvcnkucHVzaFN0YXRlKHt9LCAnJywgYW5jaG9yKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIGhpc3RvcnkucmVwbGFjZVN0YXRlKHt9LCAnJywgYW5jaG9yKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIE9wZW5zIHRoZSBhY2NvcmRpb24gdGFiIGRlZmluZWQgYnkgYCR0YXJnZXRgLlxcbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gJHRhcmdldCAtIEFjY29yZGlvbiBwYW5lIHRvIG9wZW4gKGAuYWNjb3JkaW9uLWNvbnRlbnRgKS5cXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBmaXJzdFRpbWUgLSBmbGFnIHRvIGRldGVybWluZSBpZiByZWZsb3cgc2hvdWxkIGhhcHBlbi5cXG4gICAgICogQGZpcmVzIEFjY29yZGlvbiNkb3duXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAnZG93bicsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkb3duKCR0YXJnZXQsIGZpcnN0VGltZSkge1xcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIGNoZWNraW5nIGZpcnN0VGltZSBhbGxvd3MgZm9yIGluaXRpYWwgcmVuZGVyIG9mIHRoZSBhY2NvcmRpb25cXG4gICAgICAgKiB0byByZW5kZXIgcHJlc2V0IGlzLWFjdGl2ZSBwYW5lcy5cXG4gICAgICAgKi9cXG4gICAgICBpZiAoJHRhcmdldC5jbG9zZXN0KCdbZGF0YS1hY2NvcmRpb25dJykuaXMoJ1tkaXNhYmxlZF0nKSAmJiAhZmlyc3RUaW1lKSB7XFxuICAgICAgICBjb25zb2xlLmluZm8oJ0Nhbm5vdCBjYWxsIGRvd24gb24gYW4gYWNjb3JkaW9uIHRoYXQgaXMgZGlzYWJsZWQuJyk7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcbiAgICAgICR0YXJnZXQuYXR0cignYXJpYS1oaWRkZW4nLCBmYWxzZSkucGFyZW50KCdbZGF0YS10YWItY29udGVudF0nKS5hZGRCYWNrKCkucGFyZW50KCkuYWRkQ2xhc3MoJ2lzLWFjdGl2ZScpO1xcblxcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLm11bHRpRXhwYW5kICYmICFmaXJzdFRpbWUpIHtcXG4gICAgICAgIHZhciAkY3VycmVudEFjdGl2ZSA9IHRoaXMuJGVsZW1lbnQuY2hpbGRyZW4oJy5pcy1hY3RpdmUnKS5jaGlsZHJlbignW2RhdGEtdGFiLWNvbnRlbnRdJyk7XFxuICAgICAgICBpZiAoJGN1cnJlbnRBY3RpdmUubGVuZ3RoKSB7XFxuICAgICAgICAgIHRoaXMudXAoJGN1cnJlbnRBY3RpdmUubm90KCR0YXJnZXQpKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgJHRhcmdldC5zbGlkZURvd24odGhpcy5vcHRpb25zLnNsaWRlU3BlZWQsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgdGFiIGlzIGRvbmUgb3BlbmluZy5cXG4gICAgICAgICAqIEBldmVudCBBY2NvcmRpb24jZG93blxcbiAgICAgICAgICovXFxuICAgICAgICBfdGhpczQuJGVsZW1lbnQudHJpZ2dlcignZG93bi56Zi5hY2NvcmRpb24nLCBbJHRhcmdldF0pO1xcbiAgICAgIH0pO1xcblxcbiAgICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0KCkoJyMnICsgJHRhcmdldC5hdHRyKCdhcmlhLWxhYmVsbGVkYnknKSkuYXR0cih7XFxuICAgICAgICAnYXJpYS1leHBhbmRlZCc6IHRydWUsXFxuICAgICAgICAnYXJpYS1zZWxlY3RlZCc6IHRydWVcXG4gICAgICB9KTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQ2xvc2VzIHRoZSB0YWIgZGVmaW5lZCBieSBgJHRhcmdldGAuXFxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSAkdGFyZ2V0IC0gQWNjb3JkaW9uIHRhYiB0byBjbG9zZSAoYC5hY2NvcmRpb24tY29udGVudGApLlxcbiAgICAgKiBAZmlyZXMgQWNjb3JkaW9uI3VwXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAndXAnLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXAoJHRhcmdldCkge1xcbiAgICAgIGlmICgkdGFyZ2V0LmNsb3Nlc3QoJ1tkYXRhLWFjY29yZGlvbl0nKS5pcygnW2Rpc2FibGVkXScpKSB7XFxuICAgICAgICBjb25zb2xlLmluZm8oJ0Nhbm5vdCBjYWxsIHVwIG9uIGFuIGFjY29yZGlvbiB0aGF0IGlzIGRpc2FibGVkLicpO1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgJGF1bnRzID0gJHRhcmdldC5wYXJlbnQoKS5zaWJsaW5ncygpLFxcbiAgICAgICAgICBfdGhpcyA9IHRoaXM7XFxuXFxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuYWxsb3dBbGxDbG9zZWQgJiYgISRhdW50cy5oYXNDbGFzcygnaXMtYWN0aXZlJykgfHwgISR0YXJnZXQucGFyZW50KCkuaGFzQ2xhc3MoJ2lzLWFjdGl2ZScpKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgICR0YXJnZXQuc2xpZGVVcChfdGhpcy5vcHRpb25zLnNsaWRlU3BlZWQsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgdGFiIGlzIGRvbmUgY29sbGFwc2luZyB1cC5cXG4gICAgICAgICAqIEBldmVudCBBY2NvcmRpb24jdXBcXG4gICAgICAgICAqL1xcbiAgICAgICAgX3RoaXMuJGVsZW1lbnQudHJpZ2dlcigndXAuemYuYWNjb3JkaW9uJywgWyR0YXJnZXRdKTtcXG4gICAgICB9KTtcXG5cXG4gICAgICAkdGFyZ2V0LmF0dHIoJ2FyaWEtaGlkZGVuJywgdHJ1ZSkucGFyZW50KCkucmVtb3ZlQ2xhc3MoJ2lzLWFjdGl2ZScpO1xcblxcbiAgICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0KCkoJyMnICsgJHRhcmdldC5hdHRyKCdhcmlhLWxhYmVsbGVkYnknKSkuYXR0cih7XFxuICAgICAgICAnYXJpYS1leHBhbmRlZCc6IGZhbHNlLFxcbiAgICAgICAgJ2FyaWEtc2VsZWN0ZWQnOiBmYWxzZVxcbiAgICAgIH0pO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBEZXN0cm95cyBhbiBpbnN0YW5jZSBvZiBhbiBhY2NvcmRpb24uXFxuICAgICAqIEBmaXJlcyBBY2NvcmRpb24jZGVzdHJveWVkXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAnX2Rlc3Ryb3knLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Rlc3Ryb3koKSB7XFxuICAgICAgdGhpcy4kZWxlbWVudC5maW5kKCdbZGF0YS10YWItY29udGVudF0nKS5zdG9wKHRydWUpLnNsaWRlVXAoMCkuY3NzKCdkaXNwbGF5JywgJycpO1xcbiAgICAgIHRoaXMuJGVsZW1lbnQuZmluZCgnYScpLm9mZignLnpmLmFjY29yZGlvbicpO1xcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGVlcExpbmspIHtcXG4gICAgICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0KCkod2luZG93KS5vZmYoJ3BvcHN0YXRlJywgdGhpcy5fY2hlY2tEZWVwTGluayk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XSk7XFxuXFxuICByZXR1cm4gQWNjb3JkaW9uO1xcbn0oX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19mb3VuZGF0aW9uX3BsdWdpbl9fW1xcXCJhXFxcIiAvKiBQbHVnaW4gKi9dKTtcXG5cXG5BY2NvcmRpb24uZGVmYXVsdHMgPSB7XFxuICAvKipcXG4gICAqIEFtb3VudCBvZiB0aW1lIHRvIGFuaW1hdGUgdGhlIG9wZW5pbmcgb2YgYW4gYWNjb3JkaW9uIHBhbmUuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7bnVtYmVyfVxcbiAgICogQGRlZmF1bHQgMjUwXFxuICAgKi9cXG4gIHNsaWRlU3BlZWQ6IDI1MCxcXG4gIC8qKlxcbiAgICogQWxsb3cgdGhlIGFjY29yZGlvbiB0byBoYXZlIG11bHRpcGxlIG9wZW4gcGFuZXMuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IGZhbHNlXFxuICAgKi9cXG4gIG11bHRpRXhwYW5kOiBmYWxzZSxcXG4gIC8qKlxcbiAgICogQWxsb3cgdGhlIGFjY29yZGlvbiB0byBjbG9zZSBhbGwgcGFuZXMuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IGZhbHNlXFxuICAgKi9cXG4gIGFsbG93QWxsQ2xvc2VkOiBmYWxzZSxcXG4gIC8qKlxcbiAgICogQWxsb3dzIHRoZSB3aW5kb3cgdG8gc2Nyb2xsIHRvIGNvbnRlbnQgb2YgcGFuZSBzcGVjaWZpZWQgYnkgaGFzaCBhbmNob3JcXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtib29sZWFufVxcbiAgICogQGRlZmF1bHQgZmFsc2VcXG4gICAqL1xcbiAgZGVlcExpbms6IGZhbHNlLFxcblxcbiAgLyoqXFxuICAgKiBBZGp1c3QgdGhlIGRlZXAgbGluayBzY3JvbGwgdG8gbWFrZSBzdXJlIHRoZSB0b3Agb2YgdGhlIGFjY29yZGlvbiBwYW5lbCBpcyB2aXNpYmxlXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IGZhbHNlXFxuICAgKi9cXG4gIGRlZXBMaW5rU211ZGdlOiBmYWxzZSxcXG5cXG4gIC8qKlxcbiAgICogQW5pbWF0aW9uIHRpbWUgKG1zKSBmb3IgdGhlIGRlZXAgbGluayBhZGp1c3RtZW50XFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7bnVtYmVyfVxcbiAgICogQGRlZmF1bHQgMzAwXFxuICAgKi9cXG4gIGRlZXBMaW5rU211ZGdlRGVsYXk6IDMwMCxcXG5cXG4gIC8qKlxcbiAgICogVXBkYXRlIHRoZSBicm93c2VyIGhpc3Rvcnkgd2l0aCB0aGUgb3BlbiBhY2NvcmRpb25cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtib29sZWFufVxcbiAgICogQGRlZmF1bHQgZmFsc2VcXG4gICAqL1xcbiAgdXBkYXRlSGlzdG9yeTogZmFsc2VcXG59O1xcblxcblxcblxcbi8qKiovIH0pLFxcbi8qIDEyICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJhXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBBY2NvcmRpb25NZW51OyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLm4oX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19mb3VuZGF0aW9uX3V0aWxfa2V5Ym9hcmRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fZm91bmRhdGlvbl91dGlsX25lc3RfXyA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fZm91bmRhdGlvbl91dGlsX2NvcmVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fZm91bmRhdGlvbl9wbHVnaW5fXyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XFxuXFxuXFxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcXFwidmFsdWVcXFwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XFxuXFxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTsgfSB9XFxuXFxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFxcXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcXFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFxcXCJvYmplY3RcXFwiIHx8IHR5cGVvZiBjYWxsID09PSBcXFwiZnVuY3Rpb25cXFwiKSA/IGNhbGwgOiBzZWxmOyB9XFxuXFxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXFxcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG4vKipcXG4gKiBBY2NvcmRpb25NZW51IG1vZHVsZS5cXG4gKiBAbW9kdWxlIGZvdW5kYXRpb24uYWNjb3JkaW9uTWVudVxcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwua2V5Ym9hcmRcXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLm5lc3RcXG4gKi9cXG5cXG52YXIgQWNjb3JkaW9uTWVudSA9IGZ1bmN0aW9uIChfUGx1Z2luKSB7XFxuICBfaW5oZXJpdHMoQWNjb3JkaW9uTWVudSwgX1BsdWdpbik7XFxuXFxuICBmdW5jdGlvbiBBY2NvcmRpb25NZW51KCkge1xcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQWNjb3JkaW9uTWVudSk7XFxuXFxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoQWNjb3JkaW9uTWVudS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEFjY29yZGlvbk1lbnUpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcXG4gIH1cXG5cXG4gIF9jcmVhdGVDbGFzcyhBY2NvcmRpb25NZW51LCBbe1xcbiAgICBrZXk6ICdfc2V0dXAnLFxcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBhbiBhY2NvcmRpb24gbWVudS5cXG4gICAgICogQGNsYXNzXFxuICAgICAqIEBuYW1lIEFjY29yZGlvbk1lbnVcXG4gICAgICogQGZpcmVzIEFjY29yZGlvbk1lbnUjaW5pdFxcbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gbWFrZSBpbnRvIGFuIGFjY29yZGlvbiBtZW51LlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlcyB0byB0aGUgZGVmYXVsdCBwbHVnaW4gc2V0dGluZ3MuXFxuICAgICAqL1xcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwKGVsZW1lbnQsIG9wdGlvbnMpIHtcXG4gICAgICB0aGlzLiRlbGVtZW50ID0gZWxlbWVudDtcXG4gICAgICB0aGlzLm9wdGlvbnMgPSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdC5hLmV4dGVuZCh7fSwgQWNjb3JkaW9uTWVudS5kZWZhdWx0cywgdGhpcy4kZWxlbWVudC5kYXRhKCksIG9wdGlvbnMpO1xcbiAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ0FjY29yZGlvbk1lbnUnOyAvLyBpZTkgYmFjayBjb21wYXRcXG5cXG4gICAgICBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX2ZvdW5kYXRpb25fdXRpbF9uZXN0X19bXFxcImFcXFwiIC8qIE5lc3QgKi9dLkZlYXRoZXIodGhpcy4kZWxlbWVudCwgJ2FjY29yZGlvbicpO1xcblxcbiAgICAgIHRoaXMuX2luaXQoKTtcXG5cXG4gICAgICBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX2ZvdW5kYXRpb25fdXRpbF9rZXlib2FyZF9fW1xcXCJhXFxcIiAvKiBLZXlib2FyZCAqL10ucmVnaXN0ZXIoJ0FjY29yZGlvbk1lbnUnLCB7XFxuICAgICAgICAnRU5URVInOiAndG9nZ2xlJyxcXG4gICAgICAgICdTUEFDRSc6ICd0b2dnbGUnLFxcbiAgICAgICAgJ0FSUk9XX1JJR0hUJzogJ29wZW4nLFxcbiAgICAgICAgJ0FSUk9XX1VQJzogJ3VwJyxcXG4gICAgICAgICdBUlJPV19ET1dOJzogJ2Rvd24nLFxcbiAgICAgICAgJ0FSUk9XX0xFRlQnOiAnY2xvc2UnLFxcbiAgICAgICAgJ0VTQ0FQRSc6ICdjbG9zZUFsbCdcXG4gICAgICB9KTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIGFjY29yZGlvbiBtZW51IGJ5IGhpZGluZyBhbGwgbmVzdGVkIG1lbnVzLlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAnX2luaXQnLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXQoKSB7XFxuICAgICAgdmFyIF90aGlzID0gdGhpcztcXG5cXG4gICAgICB0aGlzLiRlbGVtZW50LmZpbmQoJ1tkYXRhLXN1Ym1lbnVdJykubm90KCcuaXMtYWN0aXZlJykuc2xpZGVVcCgwKTsgLy8uZmluZCgnYScpLmNzcygncGFkZGluZy1sZWZ0JywgJzFyZW0nKTtcXG4gICAgICB0aGlzLiRlbGVtZW50LmF0dHIoe1xcbiAgICAgICAgJ3JvbGUnOiAndHJlZScsXFxuICAgICAgICAnYXJpYS1tdWx0aXNlbGVjdGFibGUnOiB0aGlzLm9wdGlvbnMubXVsdGlPcGVuXFxuICAgICAgfSk7XFxuXFxuICAgICAgdGhpcy4kbWVudUxpbmtzID0gdGhpcy4kZWxlbWVudC5maW5kKCcuaXMtYWNjb3JkaW9uLXN1Ym1lbnUtcGFyZW50Jyk7XFxuICAgICAgdGhpcy4kbWVudUxpbmtzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIGxpbmtJZCA9IHRoaXMuaWQgfHwgX193ZWJwYWNrX3JlcXVpcmVfXy5pKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fZm91bmRhdGlvbl91dGlsX2NvcmVfX1tcXFwiYlxcXCIgLyogR2V0WW9EaWdpdHMgKi9dKSg2LCAnYWNjLW1lbnUtbGluaycpLFxcbiAgICAgICAgICAgICRlbGVtID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSh0aGlzKSxcXG4gICAgICAgICAgICAkc3ViID0gJGVsZW0uY2hpbGRyZW4oJ1tkYXRhLXN1Ym1lbnVdJyksXFxuICAgICAgICAgICAgc3ViSWQgPSAkc3ViWzBdLmlkIHx8IF9fd2VicGFja19yZXF1aXJlX18uaShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX2ZvdW5kYXRpb25fdXRpbF9jb3JlX19bXFxcImJcXFwiIC8qIEdldFlvRGlnaXRzICovXSkoNiwgJ2FjYy1tZW51JyksXFxuICAgICAgICAgICAgaXNBY3RpdmUgPSAkc3ViLmhhc0NsYXNzKCdpcy1hY3RpdmUnKTtcXG5cXG4gICAgICAgIGlmIChfdGhpcy5vcHRpb25zLnN1Ym1lbnVUb2dnbGUpIHtcXG4gICAgICAgICAgJGVsZW0uYWRkQ2xhc3MoJ2hhcy1zdWJtZW51LXRvZ2dsZScpO1xcbiAgICAgICAgICAkZWxlbS5jaGlsZHJlbignYScpLmFmdGVyKCc8YnV0dG9uIGlkPVxcXCInICsgbGlua0lkICsgJ1xcXCIgY2xhc3M9XFxcInN1Ym1lbnUtdG9nZ2xlXFxcIiBhcmlhLWNvbnRyb2xzPVxcXCInICsgc3ViSWQgKyAnXFxcIiBhcmlhLWV4cGFuZGVkPVxcXCInICsgaXNBY3RpdmUgKyAnXFxcIiB0aXRsZT1cXFwiJyArIF90aGlzLm9wdGlvbnMuc3VibWVudVRvZ2dsZVRleHQgKyAnXFxcIj48c3BhbiBjbGFzcz1cXFwic3VibWVudS10b2dnbGUtdGV4dFxcXCI+JyArIF90aGlzLm9wdGlvbnMuc3VibWVudVRvZ2dsZVRleHQgKyAnPC9zcGFuPjwvYnV0dG9uPicpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgJGVsZW0uYXR0cih7XFxuICAgICAgICAgICAgJ2FyaWEtY29udHJvbHMnOiBzdWJJZCxcXG4gICAgICAgICAgICAnYXJpYS1leHBhbmRlZCc6IGlzQWN0aXZlLFxcbiAgICAgICAgICAgICdpZCc6IGxpbmtJZFxcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICAgICRzdWIuYXR0cih7XFxuICAgICAgICAgICdhcmlhLWxhYmVsbGVkYnknOiBsaW5rSWQsXFxuICAgICAgICAgICdhcmlhLWhpZGRlbic6ICFpc0FjdGl2ZSxcXG4gICAgICAgICAgJ3JvbGUnOiAnZ3JvdXAnLFxcbiAgICAgICAgICAnaWQnOiBzdWJJZFxcbiAgICAgICAgfSk7XFxuICAgICAgfSk7XFxuICAgICAgdGhpcy4kZWxlbWVudC5maW5kKCdsaScpLmF0dHIoe1xcbiAgICAgICAgJ3JvbGUnOiAndHJlZWl0ZW0nXFxuICAgICAgfSk7XFxuICAgICAgdmFyIGluaXRQYW5lcyA9IHRoaXMuJGVsZW1lbnQuZmluZCgnLmlzLWFjdGl2ZScpO1xcbiAgICAgIGlmIChpbml0UGFuZXMubGVuZ3RoKSB7XFxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xcbiAgICAgICAgaW5pdFBhbmVzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICBfdGhpcy5kb3duKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0KCkodGhpcykpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfVxcbiAgICAgIHRoaXMuX2V2ZW50cygpO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBBZGRzIGV2ZW50IGhhbmRsZXJzIGZvciBpdGVtcyB3aXRoaW4gdGhlIG1lbnUuXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6ICdfZXZlbnRzJyxcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9ldmVudHMoKSB7XFxuICAgICAgdmFyIF90aGlzID0gdGhpcztcXG5cXG4gICAgICB0aGlzLiRlbGVtZW50LmZpbmQoJ2xpJykuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgJHN1Ym1lbnUgPSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKHRoaXMpLmNoaWxkcmVuKCdbZGF0YS1zdWJtZW51XScpO1xcblxcbiAgICAgICAgaWYgKCRzdWJtZW51Lmxlbmd0aCkge1xcbiAgICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy5zdWJtZW51VG9nZ2xlKSB7XFxuICAgICAgICAgICAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSh0aGlzKS5jaGlsZHJlbignLnN1Ym1lbnUtdG9nZ2xlJykub2ZmKCdjbGljay56Zi5hY2NvcmRpb25NZW51Jykub24oJ2NsaWNrLnpmLmFjY29yZGlvbk1lbnUnLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgICAgICAgX3RoaXMudG9nZ2xlKCRzdWJtZW51KTtcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKHRoaXMpLmNoaWxkcmVuKCdhJykub2ZmKCdjbGljay56Zi5hY2NvcmRpb25NZW51Jykub24oJ2NsaWNrLnpmLmFjY29yZGlvbk1lbnUnLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgICAgICAgX3RoaXMudG9nZ2xlKCRzdWJtZW51KTtcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH0pLm9uKCdrZXlkb3duLnpmLmFjY29yZGlvbm1lbnUnLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgdmFyICRlbGVtZW50ID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSh0aGlzKSxcXG4gICAgICAgICAgICAkZWxlbWVudHMgPSAkZWxlbWVudC5wYXJlbnQoJ3VsJykuY2hpbGRyZW4oJ2xpJyksXFxuICAgICAgICAgICAgJHByZXZFbGVtZW50LFxcbiAgICAgICAgICAgICRuZXh0RWxlbWVudCxcXG4gICAgICAgICAgICAkdGFyZ2V0ID0gJGVsZW1lbnQuY2hpbGRyZW4oJ1tkYXRhLXN1Ym1lbnVdJyk7XFxuXFxuICAgICAgICAkZWxlbWVudHMuZWFjaChmdW5jdGlvbiAoaSkge1xcbiAgICAgICAgICBpZiAoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSh0aGlzKS5pcygkZWxlbWVudCkpIHtcXG4gICAgICAgICAgICAkcHJldkVsZW1lbnQgPSAkZWxlbWVudHMuZXEoTWF0aC5tYXgoMCwgaSAtIDEpKS5maW5kKCdhJykuZmlyc3QoKTtcXG4gICAgICAgICAgICAkbmV4dEVsZW1lbnQgPSAkZWxlbWVudHMuZXEoTWF0aC5taW4oaSArIDEsICRlbGVtZW50cy5sZW5ndGggLSAxKSkuZmluZCgnYScpLmZpcnN0KCk7XFxuXFxuICAgICAgICAgICAgaWYgKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0KCkodGhpcykuY2hpbGRyZW4oJ1tkYXRhLXN1Ym1lbnVdOnZpc2libGUnKS5sZW5ndGgpIHtcXG4gICAgICAgICAgICAgIC8vIGhhcyBvcGVuIHN1YiBtZW51XFxuICAgICAgICAgICAgICAkbmV4dEVsZW1lbnQgPSAkZWxlbWVudC5maW5kKCdsaTpmaXJzdC1jaGlsZCcpLmZpbmQoJ2EnKS5maXJzdCgpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpZiAoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSh0aGlzKS5pcygnOmZpcnN0LWNoaWxkJykpIHtcXG4gICAgICAgICAgICAgIC8vIGlzIGZpcnN0IGVsZW1lbnQgb2Ygc3ViIG1lbnVcXG4gICAgICAgICAgICAgICRwcmV2RWxlbWVudCA9ICRlbGVtZW50LnBhcmVudHMoJ2xpJykuZmlyc3QoKS5maW5kKCdhJykuZmlyc3QoKTtcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCRwcmV2RWxlbWVudC5wYXJlbnRzKCdsaScpLmZpcnN0KCkuY2hpbGRyZW4oJ1tkYXRhLXN1Ym1lbnVdOnZpc2libGUnKS5sZW5ndGgpIHtcXG4gICAgICAgICAgICAgIC8vIGlmIHByZXZpb3VzIGVsZW1lbnQgaGFzIG9wZW4gc3ViIG1lbnVcXG4gICAgICAgICAgICAgICRwcmV2RWxlbWVudCA9ICRwcmV2RWxlbWVudC5wYXJlbnRzKCdsaScpLmZpbmQoJ2xpOmxhc3QtY2hpbGQnKS5maW5kKCdhJykuZmlyc3QoKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaWYgKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0KCkodGhpcykuaXMoJzpsYXN0LWNoaWxkJykpIHtcXG4gICAgICAgICAgICAgIC8vIGlzIGxhc3QgZWxlbWVudCBvZiBzdWIgbWVudVxcbiAgICAgICAgICAgICAgJG5leHRFbGVtZW50ID0gJGVsZW1lbnQucGFyZW50cygnbGknKS5maXJzdCgpLm5leHQoJ2xpJykuZmluZCgnYScpLmZpcnN0KCk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuXFxuICAgICAgICBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX2ZvdW5kYXRpb25fdXRpbF9rZXlib2FyZF9fW1xcXCJhXFxcIiAvKiBLZXlib2FyZCAqL10uaGFuZGxlS2V5KGUsICdBY2NvcmRpb25NZW51Jywge1xcbiAgICAgICAgICBvcGVuOiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgaWYgKCR0YXJnZXQuaXMoJzpoaWRkZW4nKSkge1xcbiAgICAgICAgICAgICAgX3RoaXMuZG93bigkdGFyZ2V0KTtcXG4gICAgICAgICAgICAgICR0YXJnZXQuZmluZCgnbGknKS5maXJzdCgpLmZpbmQoJ2EnKS5maXJzdCgpLmZvY3VzKCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9LFxcbiAgICAgICAgICBjbG9zZTogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIGlmICgkdGFyZ2V0Lmxlbmd0aCAmJiAhJHRhcmdldC5pcygnOmhpZGRlbicpKSB7XFxuICAgICAgICAgICAgICAvLyBjbG9zZSBhY3RpdmUgc3ViIG9mIHRoaXMgaXRlbVxcbiAgICAgICAgICAgICAgX3RoaXMudXAoJHRhcmdldCk7XFxuICAgICAgICAgICAgfSBlbHNlIGlmICgkZWxlbWVudC5wYXJlbnQoJ1tkYXRhLXN1Ym1lbnVdJykubGVuZ3RoKSB7XFxuICAgICAgICAgICAgICAvLyBjbG9zZSBjdXJyZW50bHkgb3BlbiBzdWJcXG4gICAgICAgICAgICAgIF90aGlzLnVwKCRlbGVtZW50LnBhcmVudCgnW2RhdGEtc3VibWVudV0nKSk7XFxuICAgICAgICAgICAgICAkZWxlbWVudC5wYXJlbnRzKCdsaScpLmZpcnN0KCkuZmluZCgnYScpLmZpcnN0KCkuZm9jdXMoKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH0sXFxuICAgICAgICAgIHVwOiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgJHByZXZFbGVtZW50LmZvY3VzKCk7XFxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgICAgIH0sXFxuICAgICAgICAgIGRvd246IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAkbmV4dEVsZW1lbnQuZm9jdXMoKTtcXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICAgICAgfSxcXG4gICAgICAgICAgdG9nZ2xlOiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMuc3VibWVudVRvZ2dsZSkge1xcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpZiAoJGVsZW1lbnQuY2hpbGRyZW4oJ1tkYXRhLXN1Ym1lbnVdJykubGVuZ3RoKSB7XFxuICAgICAgICAgICAgICBfdGhpcy50b2dnbGUoJGVsZW1lbnQuY2hpbGRyZW4oJ1tkYXRhLXN1Ym1lbnVdJykpO1xcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9LFxcbiAgICAgICAgICBjbG9zZUFsbDogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIF90aGlzLmhpZGVBbGwoKTtcXG4gICAgICAgICAgfSxcXG4gICAgICAgICAgaGFuZGxlZDogZnVuY3Rpb24gKHByZXZlbnREZWZhdWx0KSB7XFxuICAgICAgICAgICAgaWYgKHByZXZlbnREZWZhdWx0KSB7XFxuICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICAgIH0pOyAvLy5hdHRyKCd0YWJpbmRleCcsIDApO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDbG9zZXMgYWxsIHBhbmVzIG9mIHRoZSBtZW51LlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogJ2hpZGVBbGwnLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGlkZUFsbCgpIHtcXG4gICAgICB0aGlzLnVwKHRoaXMuJGVsZW1lbnQuZmluZCgnW2RhdGEtc3VibWVudV0nKSk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIE9wZW5zIGFsbCBwYW5lcyBvZiB0aGUgbWVudS5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6ICdzaG93QWxsJyxcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNob3dBbGwoKSB7XFxuICAgICAgdGhpcy5kb3duKHRoaXMuJGVsZW1lbnQuZmluZCgnW2RhdGEtc3VibWVudV0nKSk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIFRvZ2dsZXMgdGhlIG9wZW4vY2xvc2Ugc3RhdGUgb2YgYSBzdWJtZW51LlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQHBhcmFtIHtqUXVlcnl9ICR0YXJnZXQgLSB0aGUgc3VibWVudSB0byB0b2dnbGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogJ3RvZ2dsZScsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b2dnbGUoJHRhcmdldCkge1xcbiAgICAgIGlmICghJHRhcmdldC5pcygnOmFuaW1hdGVkJykpIHtcXG4gICAgICAgIGlmICghJHRhcmdldC5pcygnOmhpZGRlbicpKSB7XFxuICAgICAgICAgIHRoaXMudXAoJHRhcmdldCk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICB0aGlzLmRvd24oJHRhcmdldCk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBPcGVucyB0aGUgc3ViLW1lbnUgZGVmaW5lZCBieSBgJHRhcmdldGAuXFxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSAkdGFyZ2V0IC0gU3ViLW1lbnUgdG8gb3Blbi5cXG4gICAgICogQGZpcmVzIEFjY29yZGlvbk1lbnUjZG93blxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAnZG93bicsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkb3duKCR0YXJnZXQpIHtcXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xcblxcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLm11bHRpT3Blbikge1xcbiAgICAgICAgdGhpcy51cCh0aGlzLiRlbGVtZW50LmZpbmQoJy5pcy1hY3RpdmUnKS5ub3QoJHRhcmdldC5wYXJlbnRzVW50aWwodGhpcy4kZWxlbWVudCkuYWRkKCR0YXJnZXQpKSk7XFxuICAgICAgfVxcblxcbiAgICAgICR0YXJnZXQuYWRkQ2xhc3MoJ2lzLWFjdGl2ZScpLmF0dHIoeyAnYXJpYS1oaWRkZW4nOiBmYWxzZSB9KTtcXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnN1Ym1lbnVUb2dnbGUpIHtcXG4gICAgICAgICR0YXJnZXQucHJldignLnN1Ym1lbnUtdG9nZ2xlJykuYXR0cih7ICdhcmlhLWV4cGFuZGVkJzogdHJ1ZSB9KTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgJHRhcmdldC5wYXJlbnQoJy5pcy1hY2NvcmRpb24tc3VibWVudS1wYXJlbnQnKS5hdHRyKHsgJ2FyaWEtZXhwYW5kZWQnOiB0cnVlIH0pO1xcbiAgICAgIH1cXG5cXG4gICAgICAkdGFyZ2V0LnNsaWRlRG93bihfdGhpcy5vcHRpb25zLnNsaWRlU3BlZWQsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgbWVudSBpcyBkb25lIG9wZW5pbmcuXFxuICAgICAgICAgKiBAZXZlbnQgQWNjb3JkaW9uTWVudSNkb3duXFxuICAgICAgICAgKi9cXG4gICAgICAgIF90aGlzLiRlbGVtZW50LnRyaWdnZXIoJ2Rvd24uemYuYWNjb3JkaW9uTWVudScsIFskdGFyZ2V0XSk7XFxuICAgICAgfSk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIENsb3NlcyB0aGUgc3ViLW1lbnUgZGVmaW5lZCBieSBgJHRhcmdldGAuIEFsbCBzdWItbWVudXMgaW5zaWRlIHRoZSB0YXJnZXQgd2lsbCBiZSBjbG9zZWQgYXMgd2VsbC5cXG4gICAgICogQHBhcmFtIHtqUXVlcnl9ICR0YXJnZXQgLSBTdWItbWVudSB0byBjbG9zZS5cXG4gICAgICogQGZpcmVzIEFjY29yZGlvbk1lbnUjdXBcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogJ3VwJyxcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwKCR0YXJnZXQpIHtcXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xcbiAgICAgICR0YXJnZXQuc2xpZGVVcChfdGhpcy5vcHRpb25zLnNsaWRlU3BlZWQsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgbWVudSBpcyBkb25lIGNvbGxhcHNpbmcgdXAuXFxuICAgICAgICAgKiBAZXZlbnQgQWNjb3JkaW9uTWVudSN1cFxcbiAgICAgICAgICovXFxuICAgICAgICBfdGhpcy4kZWxlbWVudC50cmlnZ2VyKCd1cC56Zi5hY2NvcmRpb25NZW51JywgWyR0YXJnZXRdKTtcXG4gICAgICB9KTtcXG5cXG4gICAgICB2YXIgJG1lbnVzID0gJHRhcmdldC5maW5kKCdbZGF0YS1zdWJtZW51XScpLnNsaWRlVXAoMCkuYWRkQmFjaygpLmF0dHIoJ2FyaWEtaGlkZGVuJywgdHJ1ZSk7XFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdWJtZW51VG9nZ2xlKSB7XFxuICAgICAgICAkbWVudXMucHJldignLnN1Ym1lbnUtdG9nZ2xlJykuYXR0cignYXJpYS1leHBhbmRlZCcsIGZhbHNlKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgJG1lbnVzLnBhcmVudCgnLmlzLWFjY29yZGlvbi1zdWJtZW51LXBhcmVudCcpLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCBmYWxzZSk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBEZXN0cm95cyBhbiBpbnN0YW5jZSBvZiBhY2NvcmRpb24gbWVudS5cXG4gICAgICogQGZpcmVzIEFjY29yZGlvbk1lbnUjZGVzdHJveWVkXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6ICdfZGVzdHJveScsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVzdHJveSgpIHtcXG4gICAgICB0aGlzLiRlbGVtZW50LmZpbmQoJ1tkYXRhLXN1Ym1lbnVdJykuc2xpZGVEb3duKDApLmNzcygnZGlzcGxheScsICcnKTtcXG4gICAgICB0aGlzLiRlbGVtZW50LmZpbmQoJ2EnKS5vZmYoJ2NsaWNrLnpmLmFjY29yZGlvbk1lbnUnKTtcXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnN1Ym1lbnVUb2dnbGUpIHtcXG4gICAgICAgIHRoaXMuJGVsZW1lbnQuZmluZCgnLmhhcy1zdWJtZW51LXRvZ2dsZScpLnJlbW92ZUNsYXNzKCdoYXMtc3VibWVudS10b2dnbGUnKTtcXG4gICAgICAgIHRoaXMuJGVsZW1lbnQuZmluZCgnLnN1Ym1lbnUtdG9nZ2xlJykucmVtb3ZlKCk7XFxuICAgICAgfVxcblxcbiAgICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fZm91bmRhdGlvbl91dGlsX25lc3RfX1tcXFwiYVxcXCIgLyogTmVzdCAqL10uQnVybih0aGlzLiRlbGVtZW50LCAnYWNjb3JkaW9uJyk7XFxuICAgIH1cXG4gIH1dKTtcXG5cXG4gIHJldHVybiBBY2NvcmRpb25NZW51O1xcbn0oX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19mb3VuZGF0aW9uX3BsdWdpbl9fW1xcXCJhXFxcIiAvKiBQbHVnaW4gKi9dKTtcXG5cXG5BY2NvcmRpb25NZW51LmRlZmF1bHRzID0ge1xcbiAgLyoqXFxuICAgKiBBbW91bnQgb2YgdGltZSB0byBhbmltYXRlIHRoZSBvcGVuaW5nIG9mIGEgc3VibWVudSBpbiBtcy5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtudW1iZXJ9XFxuICAgKiBAZGVmYXVsdCAyNTBcXG4gICAqL1xcbiAgc2xpZGVTcGVlZDogMjUwLFxcbiAgLyoqXFxuICAgKiBBZGRzIGEgc2VwYXJhdGUgc3VibWVudSB0b2dnbGUgYnV0dG9uLiBUaGlzIGFsbG93cyB0aGUgcGFyZW50IGl0ZW0gdG8gaGF2ZSBhIGxpbmsuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAZXhhbXBsZSB0cnVlXFxuICAgKi9cXG4gIHN1Ym1lbnVUb2dnbGU6IGZhbHNlLFxcbiAgLyoqXFxuICAgKiBUaGUgdGV4dCB1c2VkIGZvciB0aGUgc3VibWVudSB0b2dnbGUgaWYgZW5hYmxlZC4gVGhpcyBpcyB1c2VkIGZvciBzY3JlZW4gcmVhZGVycyBvbmx5LlxcbiAgICogQG9wdGlvblxcbiAgICogQGV4YW1wbGUgdHJ1ZVxcbiAgICovXFxuICBzdWJtZW51VG9nZ2xlVGV4dDogJ1RvZ2dsZSBtZW51JyxcXG4gIC8qKlxcbiAgICogQWxsb3cgdGhlIG1lbnUgdG8gaGF2ZSBtdWx0aXBsZSBvcGVuIHBhbmVzLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge2Jvb2xlYW59XFxuICAgKiBAZGVmYXVsdCB0cnVlXFxuICAgKi9cXG4gIG11bHRpT3BlbjogdHJ1ZVxcbn07XFxuXFxuXFxuXFxuLyoqKi8gfSksXFxuLyogMTMgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImFcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIERyaWxsZG93bjsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0ID0gX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfXyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fZm91bmRhdGlvbl91dGlsX2tleWJvYXJkX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX2ZvdW5kYXRpb25fdXRpbF9uZXN0X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX2ZvdW5kYXRpb25fdXRpbF9jb3JlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX2ZvdW5kYXRpb25fdXRpbF9ib3hfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fZm91bmRhdGlvbl9wbHVnaW5fXyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XFxuXFxuXFxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcXFwidmFsdWVcXFwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XFxuXFxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTsgfSB9XFxuXFxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFxcXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcXFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFxcXCJvYmplY3RcXFwiIHx8IHR5cGVvZiBjYWxsID09PSBcXFwiZnVuY3Rpb25cXFwiKSA/IGNhbGwgOiBzZWxmOyB9XFxuXFxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXFxcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG4vKipcXG4gKiBEcmlsbGRvd24gbW9kdWxlLlxcbiAqIEBtb2R1bGUgZm91bmRhdGlvbi5kcmlsbGRvd25cXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLmtleWJvYXJkXFxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5uZXN0XFxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5ib3hcXG4gKi9cXG5cXG52YXIgRHJpbGxkb3duID0gZnVuY3Rpb24gKF9QbHVnaW4pIHtcXG4gIF9pbmhlcml0cyhEcmlsbGRvd24sIF9QbHVnaW4pO1xcblxcbiAgZnVuY3Rpb24gRHJpbGxkb3duKCkge1xcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRHJpbGxkb3duKTtcXG5cXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChEcmlsbGRvd24uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihEcmlsbGRvd24pKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcXG4gIH1cXG5cXG4gIF9jcmVhdGVDbGFzcyhEcmlsbGRvd24sIFt7XFxuICAgIGtleTogJ19zZXR1cCcsXFxuXFxuICAgIC8qKlxcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIGEgZHJpbGxkb3duIG1lbnUuXFxuICAgICAqIEBjbGFzc1xcbiAgICAgKiBAbmFtZSBEcmlsbGRvd25cXG4gICAgICogQHBhcmFtIHtqUXVlcnl9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIG1ha2UgaW50byBhbiBhY2NvcmRpb24gbWVudS5cXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZXMgdG8gdGhlIGRlZmF1bHQgcGx1Z2luIHNldHRpbmdzLlxcbiAgICAgKi9cXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cChlbGVtZW50LCBvcHRpb25zKSB7XFxuICAgICAgdGhpcy4kZWxlbWVudCA9IGVsZW1lbnQ7XFxuICAgICAgdGhpcy5vcHRpb25zID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQuYS5leHRlbmQoe30sIERyaWxsZG93bi5kZWZhdWx0cywgdGhpcy4kZWxlbWVudC5kYXRhKCksIG9wdGlvbnMpO1xcbiAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ0RyaWxsZG93bic7IC8vIGllOSBiYWNrIGNvbXBhdFxcblxcbiAgICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fZm91bmRhdGlvbl91dGlsX25lc3RfX1tcXFwiYVxcXCIgLyogTmVzdCAqL10uRmVhdGhlcih0aGlzLiRlbGVtZW50LCAnZHJpbGxkb3duJyk7XFxuXFxuICAgICAgdGhpcy5faW5pdCgpO1xcblxcbiAgICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fZm91bmRhdGlvbl91dGlsX2tleWJvYXJkX19bXFxcImFcXFwiIC8qIEtleWJvYXJkICovXS5yZWdpc3RlcignRHJpbGxkb3duJywge1xcbiAgICAgICAgJ0VOVEVSJzogJ29wZW4nLFxcbiAgICAgICAgJ1NQQUNFJzogJ29wZW4nLFxcbiAgICAgICAgJ0FSUk9XX1JJR0hUJzogJ25leHQnLFxcbiAgICAgICAgJ0FSUk9XX1VQJzogJ3VwJyxcXG4gICAgICAgICdBUlJPV19ET1dOJzogJ2Rvd24nLFxcbiAgICAgICAgJ0FSUk9XX0xFRlQnOiAncHJldmlvdXMnLFxcbiAgICAgICAgJ0VTQ0FQRSc6ICdjbG9zZScsXFxuICAgICAgICAnVEFCJzogJ2Rvd24nLFxcbiAgICAgICAgJ1NISUZUX1RBQic6ICd1cCdcXG4gICAgICB9KTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIGRyaWxsZG93biBieSBjcmVhdGluZyBqUXVlcnkgY29sbGVjdGlvbnMgb2YgZWxlbWVudHNcXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogJ19pbml0JyxcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0KCkge1xcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0b0FwcGx5Q2xhc3MpIHtcXG4gICAgICAgIHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3MoJ2RyaWxsZG93bicpO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLiRlbGVtZW50LmF0dHIoe1xcbiAgICAgICAgJ3JvbGUnOiAndHJlZScsXFxuICAgICAgICAnYXJpYS1tdWx0aXNlbGVjdGFibGUnOiBmYWxzZVxcbiAgICAgIH0pO1xcbiAgICAgIHRoaXMuJHN1Ym1lbnVBbmNob3JzID0gdGhpcy4kZWxlbWVudC5maW5kKCdsaS5pcy1kcmlsbGRvd24tc3VibWVudS1wYXJlbnQnKS5jaGlsZHJlbignYScpO1xcbiAgICAgIHRoaXMuJHN1Ym1lbnVzID0gdGhpcy4kc3VibWVudUFuY2hvcnMucGFyZW50KCdsaScpLmNoaWxkcmVuKCdbZGF0YS1zdWJtZW51XScpLmF0dHIoJ3JvbGUnLCAnZ3JvdXAnKTtcXG4gICAgICB0aGlzLiRtZW51SXRlbXMgPSB0aGlzLiRlbGVtZW50LmZpbmQoJ2xpJykubm90KCcuanMtZHJpbGxkb3duLWJhY2snKS5hdHRyKCdyb2xlJywgJ3RyZWVpdGVtJykuZmluZCgnYScpO1xcbiAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cignZGF0YS1tdXRhdGUnLCB0aGlzLiRlbGVtZW50LmF0dHIoJ2RhdGEtZHJpbGxkb3duJykgfHwgX193ZWJwYWNrX3JlcXVpcmVfXy5pKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fZm91bmRhdGlvbl91dGlsX2NvcmVfX1tcXFwiYlxcXCIgLyogR2V0WW9EaWdpdHMgKi9dKSg2LCAnZHJpbGxkb3duJykpO1xcblxcbiAgICAgIHRoaXMuX3ByZXBhcmVNZW51KCk7XFxuICAgICAgdGhpcy5fcmVnaXN0ZXJFdmVudHMoKTtcXG5cXG4gICAgICB0aGlzLl9rZXlib2FyZEV2ZW50cygpO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBwcmVwYXJlcyBkcmlsbGRvd24gbWVudSBieSBzZXR0aW5nIGF0dHJpYnV0ZXMgdG8gbGlua3MgYW5kIGVsZW1lbnRzXFxuICAgICAqIHNldHMgYSBtaW4gaGVpZ2h0IHRvIHByZXZlbnQgY29udGVudCBqdW1waW5nXFxuICAgICAqIHdyYXBzIHRoZSBlbGVtZW50IGlmIG5vdCBhbHJlYWR5IHdyYXBwZWRcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6ICdfcHJlcGFyZU1lbnUnLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3ByZXBhcmVNZW51KCkge1xcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuICAgICAgLy8gaWYoIXRoaXMub3B0aW9ucy5ob2xkT3Blbil7XFxuICAgICAgLy8gICB0aGlzLl9tZW51TGlua0V2ZW50cygpO1xcbiAgICAgIC8vIH1cXG4gICAgICB0aGlzLiRzdWJtZW51QW5jaG9ycy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciAkbGluayA9IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0KCkodGhpcyk7XFxuICAgICAgICB2YXIgJHN1YiA9ICRsaW5rLnBhcmVudCgpO1xcbiAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMucGFyZW50TGluaykge1xcbiAgICAgICAgICAkbGluay5jbG9uZSgpLnByZXBlbmRUbygkc3ViLmNoaWxkcmVuKCdbZGF0YS1zdWJtZW51XScpKS53cmFwKCc8bGkgY2xhc3M9XFxcImlzLXN1Ym1lbnUtcGFyZW50LWl0ZW0gaXMtc3VibWVudS1pdGVtIGlzLWRyaWxsZG93bi1zdWJtZW51LWl0ZW1cXFwiIHJvbGU9XFxcIm1lbnUtaXRlbVxcXCI+PC9saT4nKTtcXG4gICAgICAgIH1cXG4gICAgICAgICRsaW5rLmRhdGEoJ3NhdmVkSHJlZicsICRsaW5rLmF0dHIoJ2hyZWYnKSkucmVtb3ZlQXR0cignaHJlZicpLmF0dHIoJ3RhYmluZGV4JywgMCk7XFxuICAgICAgICAkbGluay5jaGlsZHJlbignW2RhdGEtc3VibWVudV0nKS5hdHRyKHtcXG4gICAgICAgICAgJ2FyaWEtaGlkZGVuJzogdHJ1ZSxcXG4gICAgICAgICAgJ3RhYmluZGV4JzogMCxcXG4gICAgICAgICAgJ3JvbGUnOiAnZ3JvdXAnXFxuICAgICAgICB9KTtcXG4gICAgICAgIF90aGlzLl9ldmVudHMoJGxpbmspO1xcbiAgICAgIH0pO1xcbiAgICAgIHRoaXMuJHN1Ym1lbnVzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyICRtZW51ID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSh0aGlzKSxcXG4gICAgICAgICAgICAkYmFjayA9ICRtZW51LmZpbmQoJy5qcy1kcmlsbGRvd24tYmFjaycpO1xcbiAgICAgICAgaWYgKCEkYmFjay5sZW5ndGgpIHtcXG4gICAgICAgICAgc3dpdGNoIChfdGhpcy5vcHRpb25zLmJhY2tCdXR0b25Qb3NpdGlvbikge1xcbiAgICAgICAgICAgIGNhc2UgXFxcImJvdHRvbVxcXCI6XFxuICAgICAgICAgICAgICAkbWVudS5hcHBlbmQoX3RoaXMub3B0aW9ucy5iYWNrQnV0dG9uKTtcXG4gICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgIGNhc2UgXFxcInRvcFxcXCI6XFxuICAgICAgICAgICAgICAkbWVudS5wcmVwZW5kKF90aGlzLm9wdGlvbnMuYmFja0J1dHRvbik7XFxuICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICBkZWZhdWx0OlxcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcXFwiVW5zdXBwb3J0ZWQgYmFja0J1dHRvblBvc2l0aW9uIHZhbHVlICdcXFwiICsgX3RoaXMub3B0aW9ucy5iYWNrQnV0dG9uUG9zaXRpb24gKyBcXFwiJ1xcXCIpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBfdGhpcy5fYmFjaygkbWVudSk7XFxuICAgICAgfSk7XFxuXFxuICAgICAgdGhpcy4kc3VibWVudXMuYWRkQ2xhc3MoJ2ludmlzaWJsZScpO1xcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLmF1dG9IZWlnaHQpIHtcXG4gICAgICAgIHRoaXMuJHN1Ym1lbnVzLmFkZENsYXNzKCdkcmlsbGRvd24tc3VibWVudS1jb3Zlci1wcmV2aW91cycpO1xcbiAgICAgIH1cXG5cXG4gICAgICAvLyBjcmVhdGUgYSB3cmFwcGVyIG9uIGVsZW1lbnQgaWYgaXQgZG9lc24ndCBleGlzdC5cXG4gICAgICBpZiAoIXRoaXMuJGVsZW1lbnQucGFyZW50KCkuaGFzQ2xhc3MoJ2lzLWRyaWxsZG93bicpKSB7XFxuICAgICAgICB0aGlzLiR3cmFwcGVyID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSh0aGlzLm9wdGlvbnMud3JhcHBlcikuYWRkQ2xhc3MoJ2lzLWRyaWxsZG93bicpO1xcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hbmltYXRlSGVpZ2h0KSB0aGlzLiR3cmFwcGVyLmFkZENsYXNzKCdhbmltYXRlLWhlaWdodCcpO1xcbiAgICAgICAgdGhpcy4kZWxlbWVudC53cmFwKHRoaXMuJHdyYXBwZXIpO1xcbiAgICAgIH1cXG4gICAgICAvLyBzZXQgd3JhcHBlclxcbiAgICAgIHRoaXMuJHdyYXBwZXIgPSB0aGlzLiRlbGVtZW50LnBhcmVudCgpO1xcbiAgICAgIHRoaXMuJHdyYXBwZXIuY3NzKHRoaXMuX2dldE1heERpbXMoKSk7XFxuICAgIH1cXG4gIH0sIHtcXG4gICAga2V5OiAnX3Jlc2l6ZScsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVzaXplKCkge1xcbiAgICAgIHRoaXMuJHdyYXBwZXIuY3NzKHsgJ21heC13aWR0aCc6ICdub25lJywgJ21pbi1oZWlnaHQnOiAnbm9uZScgfSk7XFxuICAgICAgLy8gX2dldE1heERpbXMgaGFzIHNpZGUgZWZmZWN0cyAoYm9vKSBidXQgY2FsbGluZyBpdCBzaG91bGQgdXBkYXRlIGFsbCBvdGhlciBuZWNlc3NhcnkgaGVpZ2h0cyAmIHdpZHRoc1xcbiAgICAgIHRoaXMuJHdyYXBwZXIuY3NzKHRoaXMuX2dldE1heERpbXMoKSk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIEFkZHMgZXZlbnQgaGFuZGxlcnMgdG8gZWxlbWVudHMgaW4gdGhlIG1lbnUuXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gJGVsZW0gLSB0aGUgY3VycmVudCBtZW51IGl0ZW0gdG8gYWRkIGhhbmRsZXJzIHRvLlxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAnX2V2ZW50cycsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZXZlbnRzKCRlbGVtKSB7XFxuICAgICAgdmFyIF90aGlzID0gdGhpcztcXG5cXG4gICAgICAkZWxlbS5vZmYoJ2NsaWNrLnpmLmRyaWxsZG93bicpLm9uKCdjbGljay56Zi5kcmlsbGRvd24nLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgaWYgKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0KCkoZS50YXJnZXQpLnBhcmVudHNVbnRpbCgndWwnLCAnbGknKS5oYXNDbGFzcygnaXMtZHJpbGxkb3duLXN1Ym1lbnUtcGFyZW50JykpIHtcXG4gICAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcXG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgLy8gaWYoZS50YXJnZXQgIT09IGUuY3VycmVudFRhcmdldC5maXJzdEVsZW1lbnRDaGlsZCl7XFxuICAgICAgICAvLyAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgIC8vIH1cXG4gICAgICAgIF90aGlzLl9zaG93KCRlbGVtLnBhcmVudCgnbGknKSk7XFxuXFxuICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2spIHtcXG4gICAgICAgICAgdmFyICRib2R5ID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSgnYm9keScpO1xcbiAgICAgICAgICAkYm9keS5vZmYoJy56Zi5kcmlsbGRvd24nKS5vbignY2xpY2suemYuZHJpbGxkb3duJywgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgICAgICBpZiAoZS50YXJnZXQgPT09IF90aGlzLiRlbGVtZW50WzBdIHx8IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0LmEuY29udGFpbnMoX3RoaXMuJGVsZW1lbnRbMF0sIGUudGFyZ2V0KSkge1xcbiAgICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICAgICAgX3RoaXMuX2hpZGVBbGwoKTtcXG4gICAgICAgICAgICAkYm9keS5vZmYoJy56Zi5kcmlsbGRvd24nKTtcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIEFkZHMgZXZlbnQgaGFuZGxlcnMgdG8gdGhlIG1lbnUgZWxlbWVudC5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6ICdfcmVnaXN0ZXJFdmVudHMnLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlZ2lzdGVyRXZlbnRzKCkge1xcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2Nyb2xsVG9wKSB7XFxuICAgICAgICB0aGlzLl9iaW5kSGFuZGxlciA9IHRoaXMuX3Njcm9sbFRvcC5iaW5kKHRoaXMpO1xcbiAgICAgICAgdGhpcy4kZWxlbWVudC5vbignb3Blbi56Zi5kcmlsbGRvd24gaGlkZS56Zi5kcmlsbGRvd24gY2xvc2VkLnpmLmRyaWxsZG93bicsIHRoaXMuX2JpbmRIYW5kbGVyKTtcXG4gICAgICB9XFxuICAgICAgdGhpcy4kZWxlbWVudC5vbignbXV0YXRlbWUuemYudHJpZ2dlcicsIHRoaXMuX3Jlc2l6ZS5iaW5kKHRoaXMpKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogU2Nyb2xsIHRvIFRvcCBvZiBFbGVtZW50IG9yIGRhdGEtc2Nyb2xsLXRvcC1lbGVtZW50XFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAZmlyZXMgRHJpbGxkb3duI3Njcm9sbG1lXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6ICdfc2Nyb2xsVG9wJyxcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zY3JvbGxUb3AoKSB7XFxuICAgICAgdmFyIF90aGlzID0gdGhpcztcXG4gICAgICB2YXIgJHNjcm9sbFRvcEVsZW1lbnQgPSBfdGhpcy5vcHRpb25zLnNjcm9sbFRvcEVsZW1lbnQgIT0gJycgPyBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKF90aGlzLm9wdGlvbnMuc2Nyb2xsVG9wRWxlbWVudCkgOiBfdGhpcy4kZWxlbWVudCxcXG4gICAgICAgICAgc2Nyb2xsUG9zID0gcGFyc2VJbnQoJHNjcm9sbFRvcEVsZW1lbnQub2Zmc2V0KCkudG9wICsgX3RoaXMub3B0aW9ucy5zY3JvbGxUb3BPZmZzZXQsIDEwKTtcXG4gICAgICBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKCdodG1sLCBib2R5Jykuc3RvcCh0cnVlKS5hbmltYXRlKHsgc2Nyb2xsVG9wOiBzY3JvbGxQb3MgfSwgX3RoaXMub3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbiwgX3RoaXMub3B0aW9ucy5hbmltYXRpb25FYXNpbmcsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIC8qKlxcbiAgICAgICAgICAqIEZpcmVzIGFmdGVyIHRoZSBtZW51IGhhcyBzY3JvbGxlZFxcbiAgICAgICAgICAqIEBldmVudCBEcmlsbGRvd24jc2Nyb2xsbWVcXG4gICAgICAgICAgKi9cXG4gICAgICAgIGlmICh0aGlzID09PSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKCdodG1sJylbMF0pIF90aGlzLiRlbGVtZW50LnRyaWdnZXIoJ3Njcm9sbG1lLnpmLmRyaWxsZG93bicpO1xcbiAgICAgIH0pO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBBZGRzIGtleWRvd24gZXZlbnQgbGlzdGVuZXIgdG8gYGxpYCdzIGluIHRoZSBtZW51LlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAnX2tleWJvYXJkRXZlbnRzJyxcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9rZXlib2FyZEV2ZW50cygpIHtcXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xcblxcbiAgICAgIHRoaXMuJG1lbnVJdGVtcy5hZGQodGhpcy4kZWxlbWVudC5maW5kKCcuanMtZHJpbGxkb3duLWJhY2sgPiBhLCAuaXMtc3VibWVudS1wYXJlbnQtaXRlbSA+IGEnKSkub24oJ2tleWRvd24uemYuZHJpbGxkb3duJywgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgIHZhciAkZWxlbWVudCA9IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0KCkodGhpcyksXFxuICAgICAgICAgICAgJGVsZW1lbnRzID0gJGVsZW1lbnQucGFyZW50KCdsaScpLnBhcmVudCgndWwnKS5jaGlsZHJlbignbGknKS5jaGlsZHJlbignYScpLFxcbiAgICAgICAgICAgICRwcmV2RWxlbWVudCxcXG4gICAgICAgICAgICAkbmV4dEVsZW1lbnQ7XFxuXFxuICAgICAgICAkZWxlbWVudHMuZWFjaChmdW5jdGlvbiAoaSkge1xcbiAgICAgICAgICBpZiAoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSh0aGlzKS5pcygkZWxlbWVudCkpIHtcXG4gICAgICAgICAgICAkcHJldkVsZW1lbnQgPSAkZWxlbWVudHMuZXEoTWF0aC5tYXgoMCwgaSAtIDEpKTtcXG4gICAgICAgICAgICAkbmV4dEVsZW1lbnQgPSAkZWxlbWVudHMuZXEoTWF0aC5taW4oaSArIDEsICRlbGVtZW50cy5sZW5ndGggLSAxKSk7XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG5cXG4gICAgICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fZm91bmRhdGlvbl91dGlsX2tleWJvYXJkX19bXFxcImFcXFwiIC8qIEtleWJvYXJkICovXS5oYW5kbGVLZXkoZSwgJ0RyaWxsZG93bicsIHtcXG4gICAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIGlmICgkZWxlbWVudC5pcyhfdGhpcy4kc3VibWVudUFuY2hvcnMpKSB7XFxuICAgICAgICAgICAgICBfdGhpcy5fc2hvdygkZWxlbWVudC5wYXJlbnQoJ2xpJykpO1xcbiAgICAgICAgICAgICAgJGVsZW1lbnQucGFyZW50KCdsaScpLm9uZShfX3dlYnBhY2tfcmVxdWlyZV9fLmkoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19mb3VuZGF0aW9uX3V0aWxfY29yZV9fW1xcXCJjXFxcIiAvKiB0cmFuc2l0aW9uZW5kICovXSkoJGVsZW1lbnQpLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgICRlbGVtZW50LnBhcmVudCgnbGknKS5maW5kKCd1bCBsaSBhJykuZmlsdGVyKF90aGlzLiRtZW51SXRlbXMpLmZpcnN0KCkuZm9jdXMoKTtcXG4gICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9LFxcbiAgICAgICAgICBwcmV2aW91czogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIF90aGlzLl9oaWRlKCRlbGVtZW50LnBhcmVudCgnbGknKS5wYXJlbnQoJ3VsJykpO1xcbiAgICAgICAgICAgICRlbGVtZW50LnBhcmVudCgnbGknKS5wYXJlbnQoJ3VsJykub25lKF9fd2VicGFja19yZXF1aXJlX18uaShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX2ZvdW5kYXRpb25fdXRpbF9jb3JlX19bXFxcImNcXFwiIC8qIHRyYW5zaXRpb25lbmQgKi9dKSgkZWxlbWVudCksIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICAkZWxlbWVudC5wYXJlbnQoJ2xpJykucGFyZW50KCd1bCcpLnBhcmVudCgnbGknKS5jaGlsZHJlbignYScpLmZpcnN0KCkuZm9jdXMoKTtcXG4gICAgICAgICAgICAgIH0sIDEpO1xcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgICAgICB9LFxcbiAgICAgICAgICB1cDogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICRwcmV2RWxlbWVudC5mb2N1cygpO1xcbiAgICAgICAgICAgIC8vIERvbid0IHRhcCBmb2N1cyBvbiBmaXJzdCBlbGVtZW50IGluIHJvb3QgdWxcXG4gICAgICAgICAgICByZXR1cm4gISRlbGVtZW50LmlzKF90aGlzLiRlbGVtZW50LmZpbmQoJz4gbGk6Zmlyc3QtY2hpbGQgPiBhJykpO1xcbiAgICAgICAgICB9LFxcbiAgICAgICAgICBkb3duOiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgJG5leHRFbGVtZW50LmZvY3VzKCk7XFxuICAgICAgICAgICAgLy8gRG9uJ3QgdGFwIGZvY3VzIG9uIGxhc3QgZWxlbWVudCBpbiByb290IHVsXFxuICAgICAgICAgICAgcmV0dXJuICEkZWxlbWVudC5pcyhfdGhpcy4kZWxlbWVudC5maW5kKCc+IGxpOmxhc3QtY2hpbGQgPiBhJykpO1xcbiAgICAgICAgICB9LFxcbiAgICAgICAgICBjbG9zZTogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIC8vIERvbid0IGNsb3NlIG9uIGVsZW1lbnQgaW4gcm9vdCB1bFxcbiAgICAgICAgICAgIGlmICghJGVsZW1lbnQuaXMoX3RoaXMuJGVsZW1lbnQuZmluZCgnPiBsaSA+IGEnKSkpIHtcXG4gICAgICAgICAgICAgIF90aGlzLl9oaWRlKCRlbGVtZW50LnBhcmVudCgpLnBhcmVudCgpKTtcXG4gICAgICAgICAgICAgICRlbGVtZW50LnBhcmVudCgpLnBhcmVudCgpLnNpYmxpbmdzKCdhJykuZm9jdXMoKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH0sXFxuICAgICAgICAgIG9wZW46IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICBpZiAoISRlbGVtZW50LmlzKF90aGlzLiRtZW51SXRlbXMpKSB7XFxuICAgICAgICAgICAgICAvLyBub3QgbWVudSBpdGVtIG1lYW5zIGJhY2sgYnV0dG9uXFxuICAgICAgICAgICAgICBfdGhpcy5faGlkZSgkZWxlbWVudC5wYXJlbnQoJ2xpJykucGFyZW50KCd1bCcpKTtcXG4gICAgICAgICAgICAgICRlbGVtZW50LnBhcmVudCgnbGknKS5wYXJlbnQoJ3VsJykub25lKF9fd2VicGFja19yZXF1aXJlX18uaShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX2ZvdW5kYXRpb25fdXRpbF9jb3JlX19bXFxcImNcXFwiIC8qIHRyYW5zaXRpb25lbmQgKi9dKSgkZWxlbWVudCksIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgICAgJGVsZW1lbnQucGFyZW50KCdsaScpLnBhcmVudCgndWwnKS5wYXJlbnQoJ2xpJykuY2hpbGRyZW4oJ2EnKS5maXJzdCgpLmZvY3VzKCk7XFxuICAgICAgICAgICAgICAgIH0sIDEpO1xcbiAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCRlbGVtZW50LmlzKF90aGlzLiRzdWJtZW51QW5jaG9ycykpIHtcXG4gICAgICAgICAgICAgIF90aGlzLl9zaG93KCRlbGVtZW50LnBhcmVudCgnbGknKSk7XFxuICAgICAgICAgICAgICAkZWxlbWVudC5wYXJlbnQoJ2xpJykub25lKF9fd2VicGFja19yZXF1aXJlX18uaShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX2ZvdW5kYXRpb25fdXRpbF9jb3JlX19bXFxcImNcXFwiIC8qIHRyYW5zaXRpb25lbmQgKi9dKSgkZWxlbWVudCksIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICAgJGVsZW1lbnQucGFyZW50KCdsaScpLmZpbmQoJ3VsIGxpIGEnKS5maWx0ZXIoX3RoaXMuJG1lbnVJdGVtcykuZmlyc3QoKS5mb2N1cygpO1xcbiAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH0sXFxuICAgICAgICAgIGhhbmRsZWQ6IGZ1bmN0aW9uIChwcmV2ZW50RGVmYXVsdCkge1xcbiAgICAgICAgICAgIGlmIChwcmV2ZW50RGVmYXVsdCkge1xcbiAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgICB9KTsgLy8gZW5kIGtleWJvYXJkQWNjZXNzXFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIENsb3NlcyBhbGwgb3BlbiBlbGVtZW50cywgYW5kIHJldHVybnMgdG8gcm9vdCBtZW51LlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQGZpcmVzIERyaWxsZG93biNjbG9zZWRcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogJ19oaWRlQWxsJyxcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9oaWRlQWxsKCkge1xcbiAgICAgIHZhciAkZWxlbSA9IHRoaXMuJGVsZW1lbnQuZmluZCgnLmlzLWRyaWxsZG93bi1zdWJtZW51LmlzLWFjdGl2ZScpLmFkZENsYXNzKCdpcy1jbG9zaW5nJyk7XFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvSGVpZ2h0KSB0aGlzLiR3cmFwcGVyLmNzcyh7IGhlaWdodDogJGVsZW0ucGFyZW50KCkuY2xvc2VzdCgndWwnKS5kYXRhKCdjYWxjSGVpZ2h0JykgfSk7XFxuICAgICAgJGVsZW0ub25lKF9fd2VicGFja19yZXF1aXJlX18uaShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX2ZvdW5kYXRpb25fdXRpbF9jb3JlX19bXFxcImNcXFwiIC8qIHRyYW5zaXRpb25lbmQgKi9dKSgkZWxlbSksIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICAkZWxlbS5yZW1vdmVDbGFzcygnaXMtYWN0aXZlIGlzLWNsb3NpbmcnKTtcXG4gICAgICB9KTtcXG4gICAgICAvKipcXG4gICAgICAgKiBGaXJlcyB3aGVuIHRoZSBtZW51IGlzIGZ1bGx5IGNsb3NlZC5cXG4gICAgICAgKiBAZXZlbnQgRHJpbGxkb3duI2Nsb3NlZFxcbiAgICAgICAqL1xcbiAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignY2xvc2VkLnpmLmRyaWxsZG93bicpO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBBZGRzIGV2ZW50IGxpc3RlbmVyIGZvciBlYWNoIGBiYWNrYCBidXR0b24sIGFuZCBjbG9zZXMgb3BlbiBtZW51cy5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBmaXJlcyBEcmlsbGRvd24jYmFja1xcbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gJGVsZW0gLSB0aGUgY3VycmVudCBzdWItbWVudSB0byBhZGQgYGJhY2tgIGV2ZW50LlxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAnX2JhY2snLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2JhY2soJGVsZW0pIHtcXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xcbiAgICAgICRlbGVtLm9mZignY2xpY2suemYuZHJpbGxkb3duJyk7XFxuICAgICAgJGVsZW0uY2hpbGRyZW4oJy5qcy1kcmlsbGRvd24tYmFjaycpLm9uKCdjbGljay56Zi5kcmlsbGRvd24nLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdtb3VzZXVwIG9uIGJhY2snKTtcXG4gICAgICAgIF90aGlzLl9oaWRlKCRlbGVtKTtcXG5cXG4gICAgICAgIC8vIElmIHRoZXJlIGlzIGEgcGFyZW50IHN1Ym1lbnUsIGNhbGwgc2hvd1xcbiAgICAgICAgdmFyIHBhcmVudFN1Yk1lbnUgPSAkZWxlbS5wYXJlbnQoJ2xpJykucGFyZW50KCd1bCcpLnBhcmVudCgnbGknKTtcXG4gICAgICAgIGlmIChwYXJlbnRTdWJNZW51Lmxlbmd0aCkge1xcbiAgICAgICAgICBfdGhpcy5fc2hvdyhwYXJlbnRTdWJNZW51KTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQWRkcyBldmVudCBsaXN0ZW5lciB0byBtZW51IGl0ZW1zIHcvbyBzdWJtZW51cyB0byBjbG9zZSBvcGVuIG1lbnVzIG9uIGNsaWNrLlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogJ19tZW51TGlua0V2ZW50cycsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbWVudUxpbmtFdmVudHMoKSB7XFxuICAgICAgdmFyIF90aGlzID0gdGhpcztcXG4gICAgICB0aGlzLiRtZW51SXRlbXMubm90KCcuaXMtZHJpbGxkb3duLXN1Ym1lbnUtcGFyZW50Jykub2ZmKCdjbGljay56Zi5kcmlsbGRvd24nKS5vbignY2xpY2suemYuZHJpbGxkb3duJywgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgIC8vIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XFxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgX3RoaXMuX2hpZGVBbGwoKTtcXG4gICAgICAgIH0sIDApO1xcbiAgICAgIH0pO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBPcGVucyBhIHN1Ym1lbnUuXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAZmlyZXMgRHJpbGxkb3duI29wZW5cXG4gICAgICogQHBhcmFtIHtqUXVlcnl9ICRlbGVtIC0gdGhlIGN1cnJlbnQgZWxlbWVudCB3aXRoIGEgc3VibWVudSB0byBvcGVuLCBpLmUuIHRoZSBgbGlgIHRhZy5cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogJ19zaG93JyxcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zaG93KCRlbGVtKSB7XFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvSGVpZ2h0KSB0aGlzLiR3cmFwcGVyLmNzcyh7IGhlaWdodDogJGVsZW0uY2hpbGRyZW4oJ1tkYXRhLXN1Ym1lbnVdJykuZGF0YSgnY2FsY0hlaWdodCcpIH0pO1xcbiAgICAgICRlbGVtLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCB0cnVlKTtcXG4gICAgICAkZWxlbS5jaGlsZHJlbignW2RhdGEtc3VibWVudV0nKS5hZGRDbGFzcygnaXMtYWN0aXZlJykucmVtb3ZlQ2xhc3MoJ2ludmlzaWJsZScpLmF0dHIoJ2FyaWEtaGlkZGVuJywgZmFsc2UpO1xcbiAgICAgIC8qKlxcbiAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHN1Ym1lbnUgaGFzIG9wZW5lZC5cXG4gICAgICAgKiBAZXZlbnQgRHJpbGxkb3duI29wZW5cXG4gICAgICAgKi9cXG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ29wZW4uemYuZHJpbGxkb3duJywgWyRlbGVtXSk7XFxuICAgIH1cXG4gIH0sIHtcXG4gICAga2V5OiAnX2hpZGUnLFxcblxcblxcbiAgICAvKipcXG4gICAgICogSGlkZXMgYSBzdWJtZW51XFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAZmlyZXMgRHJpbGxkb3duI2hpZGVcXG4gICAgICogQHBhcmFtIHtqUXVlcnl9ICRlbGVtIC0gdGhlIGN1cnJlbnQgc3ViLW1lbnUgdG8gaGlkZSwgaS5lLiB0aGUgYHVsYCB0YWcuXFxuICAgICAqL1xcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2hpZGUoJGVsZW0pIHtcXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmF1dG9IZWlnaHQpIHRoaXMuJHdyYXBwZXIuY3NzKHsgaGVpZ2h0OiAkZWxlbS5wYXJlbnQoKS5jbG9zZXN0KCd1bCcpLmRhdGEoJ2NhbGNIZWlnaHQnKSB9KTtcXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xcbiAgICAgICRlbGVtLnBhcmVudCgnbGknKS5hdHRyKCdhcmlhLWV4cGFuZGVkJywgZmFsc2UpO1xcbiAgICAgICRlbGVtLmF0dHIoJ2FyaWEtaGlkZGVuJywgdHJ1ZSkuYWRkQ2xhc3MoJ2lzLWNsb3NpbmcnKTtcXG4gICAgICAkZWxlbS5hZGRDbGFzcygnaXMtY2xvc2luZycpLm9uZShfX3dlYnBhY2tfcmVxdWlyZV9fLmkoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19mb3VuZGF0aW9uX3V0aWxfY29yZV9fW1xcXCJjXFxcIiAvKiB0cmFuc2l0aW9uZW5kICovXSkoJGVsZW0pLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAkZWxlbS5yZW1vdmVDbGFzcygnaXMtYWN0aXZlIGlzLWNsb3NpbmcnKTtcXG4gICAgICAgICRlbGVtLmJsdXIoKS5hZGRDbGFzcygnaW52aXNpYmxlJyk7XFxuICAgICAgfSk7XFxuICAgICAgLyoqXFxuICAgICAgICogRmlyZXMgd2hlbiB0aGUgc3VibWVudSBoYXMgY2xvc2VkLlxcbiAgICAgICAqIEBldmVudCBEcmlsbGRvd24jaGlkZVxcbiAgICAgICAqL1xcbiAgICAgICRlbGVtLnRyaWdnZXIoJ2hpZGUuemYuZHJpbGxkb3duJywgWyRlbGVtXSk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIEl0ZXJhdGVzIHRocm91Z2ggdGhlIG5lc3RlZCBtZW51cyB0byBjYWxjdWxhdGUgdGhlIG1pbi1oZWlnaHQsIGFuZCBtYXgtd2lkdGggZm9yIHRoZSBtZW51LlxcbiAgICAgKiBQcmV2ZW50cyBjb250ZW50IGp1bXBpbmcuXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAnX2dldE1heERpbXMnLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldE1heERpbXMoKSB7XFxuICAgICAgdmFyIG1heEhlaWdodCA9IDAsXFxuICAgICAgICAgIHJlc3VsdCA9IHt9LFxcbiAgICAgICAgICBfdGhpcyA9IHRoaXM7XFxuICAgICAgdGhpcy4kc3VibWVudXMuYWRkKHRoaXMuJGVsZW1lbnQpLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIG51bU9mRWxlbXMgPSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKHRoaXMpLmNoaWxkcmVuKCdsaScpLmxlbmd0aDtcXG4gICAgICAgIHZhciBoZWlnaHQgPSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX2ZvdW5kYXRpb25fdXRpbF9ib3hfX1tcXFwiYVxcXCIgLyogQm94ICovXS5HZXREaW1lbnNpb25zKHRoaXMpLmhlaWdodDtcXG4gICAgICAgIG1heEhlaWdodCA9IGhlaWdodCA+IG1heEhlaWdodCA/IGhlaWdodCA6IG1heEhlaWdodDtcXG4gICAgICAgIGlmIChfdGhpcy5vcHRpb25zLmF1dG9IZWlnaHQpIHtcXG4gICAgICAgICAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSh0aGlzKS5kYXRhKCdjYWxjSGVpZ2h0JywgaGVpZ2h0KTtcXG4gICAgICAgICAgaWYgKCFfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKHRoaXMpLmhhc0NsYXNzKCdpcy1kcmlsbGRvd24tc3VibWVudScpKSByZXN1bHRbJ2hlaWdodCddID0gaGVpZ2h0O1xcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcblxcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLmF1dG9IZWlnaHQpIHJlc3VsdFsnbWluLWhlaWdodCddID0gbWF4SGVpZ2h0ICsgJ3B4JztcXG5cXG4gICAgICByZXN1bHRbJ21heC13aWR0aCddID0gdGhpcy4kZWxlbWVudFswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCArICdweCc7XFxuXFxuICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogRGVzdHJveXMgdGhlIERyaWxsZG93biBNZW51XFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAnX2Rlc3Ryb3knLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Rlc3Ryb3koKSB7XFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zY3JvbGxUb3ApIHRoaXMuJGVsZW1lbnQub2ZmKCcuemYuZHJpbGxkb3duJywgdGhpcy5fYmluZEhhbmRsZXIpO1xcbiAgICAgIHRoaXMuX2hpZGVBbGwoKTtcXG4gICAgICB0aGlzLiRlbGVtZW50Lm9mZignbXV0YXRlbWUuemYudHJpZ2dlcicpO1xcbiAgICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fZm91bmRhdGlvbl91dGlsX25lc3RfX1tcXFwiYVxcXCIgLyogTmVzdCAqL10uQnVybih0aGlzLiRlbGVtZW50LCAnZHJpbGxkb3duJyk7XFxuICAgICAgdGhpcy4kZWxlbWVudC51bndyYXAoKS5maW5kKCcuanMtZHJpbGxkb3duLWJhY2ssIC5pcy1zdWJtZW51LXBhcmVudC1pdGVtJykucmVtb3ZlKCkuZW5kKCkuZmluZCgnLmlzLWFjdGl2ZSwgLmlzLWNsb3NpbmcsIC5pcy1kcmlsbGRvd24tc3VibWVudScpLnJlbW92ZUNsYXNzKCdpcy1hY3RpdmUgaXMtY2xvc2luZyBpcy1kcmlsbGRvd24tc3VibWVudScpLmVuZCgpLmZpbmQoJ1tkYXRhLXN1Ym1lbnVdJykucmVtb3ZlQXR0cignYXJpYS1oaWRkZW4gdGFiaW5kZXggcm9sZScpO1xcbiAgICAgIHRoaXMuJHN1Ym1lbnVBbmNob3JzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSh0aGlzKS5vZmYoJy56Zi5kcmlsbGRvd24nKTtcXG4gICAgICB9KTtcXG5cXG4gICAgICB0aGlzLiRzdWJtZW51cy5yZW1vdmVDbGFzcygnZHJpbGxkb3duLXN1Ym1lbnUtY292ZXItcHJldmlvdXMgaW52aXNpYmxlJyk7XFxuXFxuICAgICAgdGhpcy4kZWxlbWVudC5maW5kKCdhJykuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgJGxpbmsgPSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKHRoaXMpO1xcbiAgICAgICAgJGxpbmsucmVtb3ZlQXR0cigndGFiaW5kZXgnKTtcXG4gICAgICAgIGlmICgkbGluay5kYXRhKCdzYXZlZEhyZWYnKSkge1xcbiAgICAgICAgICAkbGluay5hdHRyKCdocmVmJywgJGxpbmsuZGF0YSgnc2F2ZWRIcmVmJykpLnJlbW92ZURhdGEoJ3NhdmVkSHJlZicpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcbiAgICB9XFxuICB9XSk7XFxuXFxuICByZXR1cm4gRHJpbGxkb3duO1xcbn0oX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19mb3VuZGF0aW9uX3BsdWdpbl9fW1xcXCJhXFxcIiAvKiBQbHVnaW4gKi9dKTtcXG5cXG5EcmlsbGRvd24uZGVmYXVsdHMgPSB7XFxuICAvKipcXG4gICAqIERyaWxsZG93bnMgZGVwZW5kIG9uIHN0eWxlcyBpbiBvcmRlciB0byBmdW5jdGlvbiBwcm9wZXJseTsgaW4gdGhlIGRlZmF1bHQgYnVpbGQgb2YgRm91bmRhdGlvbiB0aGVzZSBhcmVcXG4gICAqIG9uIHRoZSBgZHJpbGxkb3duYCBjbGFzcy4gVGhpcyBvcHRpb24gYXV0by1hcHBsaWVzIHRoaXMgY2xhc3MgdG8gdGhlIGRyaWxsZG93biB1cG9uIGluaXRpYWxpemF0aW9uLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge2Jvb2xpYW59XFxuICAgKiBAZGVmYXVsdCB0cnVlXFxuICAgKi9cXG4gIGF1dG9BcHBseUNsYXNzOiB0cnVlLFxcbiAgLyoqXFxuICAgKiBNYXJrdXAgdXNlZCBmb3IgSlMgZ2VuZXJhdGVkIGJhY2sgYnV0dG9uLiBQcmVwZW5kZWQgIG9yIGFwcGVuZGVkIChzZWUgYmFja0J1dHRvblBvc2l0aW9uKSB0byBzdWJtZW51IGxpc3RzIGFuZCBkZWxldGVkIG9uIGBkZXN0cm95YCBtZXRob2QsICdqcy1kcmlsbGRvd24tYmFjaycgY2xhc3MgcmVxdWlyZWQuIFJlbW92ZSB0aGUgYmFja3NsYXNoIChgXFxcXGApIGlmIGNvcHkgYW5kIHBhc3RpbmcuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7c3RyaW5nfVxcbiAgICogQGRlZmF1bHQgJzxsaSBjbGFzcz1cXFwianMtZHJpbGxkb3duLWJhY2tcXFwiPjxhIHRhYmluZGV4PVxcXCIwXFxcIj5CYWNrPC9hPjwvbGk+J1xcbiAgICovXFxuICBiYWNrQnV0dG9uOiAnPGxpIGNsYXNzPVxcXCJqcy1kcmlsbGRvd24tYmFja1xcXCI+PGEgdGFiaW5kZXg9XFxcIjBcXFwiPkJhY2s8L2E+PC9saT4nLFxcbiAgLyoqXFxuICAgKiBQb3NpdGlvbiB0aGUgYmFjayBidXR0b24gZWl0aGVyIGF0IHRoZSB0b3Agb3IgYm90dG9tIG9mIGRyaWxsZG93biBzdWJtZW51cy4gQ2FuIGJlIGAnbGVmdCdgIG9yIGAnYm90dG9tJ2AuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7c3RyaW5nfVxcbiAgICogQGRlZmF1bHQgdG9wXFxuICAgKi9cXG4gIGJhY2tCdXR0b25Qb3NpdGlvbjogJ3RvcCcsXFxuICAvKipcXG4gICAqIE1hcmt1cCB1c2VkIHRvIHdyYXAgZHJpbGxkb3duIG1lbnUuIFVzZSBhIGNsYXNzIG5hbWUgZm9yIGluZGVwZW5kZW50IHN0eWxpbmc7IHRoZSBKUyBhcHBsaWVkIGNsYXNzOiBgaXMtZHJpbGxkb3duYCBpcyByZXF1aXJlZC4gUmVtb3ZlIHRoZSBiYWNrc2xhc2ggKGBcXFxcYCkgaWYgY29weSBhbmQgcGFzdGluZy5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtzdHJpbmd9XFxuICAgKiBAZGVmYXVsdCAnPGRpdj48L2Rpdj4nXFxuICAgKi9cXG4gIHdyYXBwZXI6ICc8ZGl2PjwvZGl2PicsXFxuICAvKipcXG4gICAqIEFkZHMgdGhlIHBhcmVudCBsaW5rIHRvIHRoZSBzdWJtZW51LlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge2Jvb2xlYW59XFxuICAgKiBAZGVmYXVsdCBmYWxzZVxcbiAgICovXFxuICBwYXJlbnRMaW5rOiBmYWxzZSxcXG4gIC8qKlxcbiAgICogQWxsb3cgdGhlIG1lbnUgdG8gcmV0dXJuIHRvIHJvb3QgbGlzdCBvbiBib2R5IGNsaWNrLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge2Jvb2xlYW59XFxuICAgKiBAZGVmYXVsdCBmYWxzZVxcbiAgICovXFxuICBjbG9zZU9uQ2xpY2s6IGZhbHNlLFxcbiAgLyoqXFxuICAgKiBBbGxvdyB0aGUgbWVudSB0byBhdXRvIGFkanVzdCBoZWlnaHQuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IGZhbHNlXFxuICAgKi9cXG4gIGF1dG9IZWlnaHQ6IGZhbHNlLFxcbiAgLyoqXFxuICAgKiBBbmltYXRlIHRoZSBhdXRvIGFkanVzdCBoZWlnaHQuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IGZhbHNlXFxuICAgKi9cXG4gIGFuaW1hdGVIZWlnaHQ6IGZhbHNlLFxcbiAgLyoqXFxuICAgKiBTY3JvbGwgdG8gdGhlIHRvcCBvZiB0aGUgbWVudSBhZnRlciBvcGVuaW5nIGEgc3VibWVudSBvciBuYXZpZ2F0aW5nIGJhY2sgdXNpbmcgdGhlIG1lbnUgYmFjayBidXR0b25cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtib29sZWFufVxcbiAgICogQGRlZmF1bHQgZmFsc2VcXG4gICAqL1xcbiAgc2Nyb2xsVG9wOiBmYWxzZSxcXG4gIC8qKlxcbiAgICogU3RyaW5nIGpxdWVyeSBzZWxlY3RvciAoZm9yIGV4YW1wbGUgJ2JvZHknKSBvZiBlbGVtZW50IHRvIHRha2Ugb2Zmc2V0KCkudG9wIGZyb20sIGlmIGVtcHR5IHN0cmluZyB0aGUgZHJpbGxkb3duIG1lbnUgb2Zmc2V0KCkudG9wIGlzIHRha2VuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7c3RyaW5nfVxcbiAgICogQGRlZmF1bHQgJydcXG4gICAqL1xcbiAgc2Nyb2xsVG9wRWxlbWVudDogJycsXFxuICAvKipcXG4gICAqIFNjcm9sbFRvcCBvZmZzZXRcXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtudW1iZXJ9XFxuICAgKiBAZGVmYXVsdCAwXFxuICAgKi9cXG4gIHNjcm9sbFRvcE9mZnNldDogMCxcXG4gIC8qKlxcbiAgICogU2Nyb2xsIGFuaW1hdGlvbiBkdXJhdGlvblxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge251bWJlcn1cXG4gICAqIEBkZWZhdWx0IDUwMFxcbiAgICovXFxuICBhbmltYXRpb25EdXJhdGlvbjogNTAwLFxcbiAgLyoqXFxuICAgKiBTY3JvbGwgYW5pbWF0aW9uIGVhc2luZy4gQ2FuIGJlIGAnc3dpbmcnYCBvciBgJ2xpbmVhcidgLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge3N0cmluZ31cXG4gICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vYXBpLmpxdWVyeS5jb20vYW5pbWF0ZXxKUXVlcnkgYW5pbWF0ZX1cXG4gICAqIEBkZWZhdWx0ICdzd2luZydcXG4gICAqL1xcbiAgYW5pbWF0aW9uRWFzaW5nOiAnc3dpbmcnXFxuICAvLyBob2xkT3BlbjogZmFsc2VcXG59O1xcblxcblxcblxcbi8qKiovIH0pLFxcbi8qIDE0ICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJhXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBEcm9wZG93bk1lbnU7IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCA9IF9fd2VicGFja19yZXF1aXJlX18ubihfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX2ZvdW5kYXRpb25fdXRpbF9rZXlib2FyZF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19mb3VuZGF0aW9uX3V0aWxfbmVzdF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19mb3VuZGF0aW9uX3V0aWxfYm94X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX2ZvdW5kYXRpb25fdXRpbF9jb3JlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX2ZvdW5kYXRpb25fcGx1Z2luX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xcblxcblxcbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXFxcInZhbHVlXFxcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xcblxcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7IH0gfVxcblxcbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcXFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXFxcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcXFwib2JqZWN0XFxcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXFxcImZ1bmN0aW9uXFxcIikgPyBjYWxsIDogc2VsZjsgfVxcblxcbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFxcXCJmdW5jdGlvblxcXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFxcXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuLyoqXFxuICogRHJvcGRvd25NZW51IG1vZHVsZS5cXG4gKiBAbW9kdWxlIGZvdW5kYXRpb24uZHJvcGRvd24tbWVudVxcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwua2V5Ym9hcmRcXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLmJveFxcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwubmVzdFxcbiAqL1xcblxcbnZhciBEcm9wZG93bk1lbnUgPSBmdW5jdGlvbiAoX1BsdWdpbikge1xcbiAgX2luaGVyaXRzKERyb3Bkb3duTWVudSwgX1BsdWdpbik7XFxuXFxuICBmdW5jdGlvbiBEcm9wZG93bk1lbnUoKSB7XFxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEcm9wZG93bk1lbnUpO1xcblxcbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKERyb3Bkb3duTWVudS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKERyb3Bkb3duTWVudSkpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xcbiAgfVxcblxcbiAgX2NyZWF0ZUNsYXNzKERyb3Bkb3duTWVudSwgW3tcXG4gICAga2V5OiAnX3NldHVwJyxcXG5cXG4gICAgLyoqXFxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgRHJvcGRvd25NZW51LlxcbiAgICAgKiBAY2xhc3NcXG4gICAgICogQG5hbWUgRHJvcGRvd25NZW51XFxuICAgICAqIEBmaXJlcyBEcm9wZG93bk1lbnUjaW5pdFxcbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gbWFrZSBpbnRvIGEgZHJvcGRvd24gbWVudS5cXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZXMgdG8gdGhlIGRlZmF1bHQgcGx1Z2luIHNldHRpbmdzLlxcbiAgICAgKi9cXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cChlbGVtZW50LCBvcHRpb25zKSB7XFxuICAgICAgdGhpcy4kZWxlbWVudCA9IGVsZW1lbnQ7XFxuICAgICAgdGhpcy5vcHRpb25zID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQuYS5leHRlbmQoe30sIERyb3Bkb3duTWVudS5kZWZhdWx0cywgdGhpcy4kZWxlbWVudC5kYXRhKCksIG9wdGlvbnMpO1xcbiAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ0Ryb3Bkb3duTWVudSc7IC8vIGllOSBiYWNrIGNvbXBhdFxcblxcbiAgICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fZm91bmRhdGlvbl91dGlsX25lc3RfX1tcXFwiYVxcXCIgLyogTmVzdCAqL10uRmVhdGhlcih0aGlzLiRlbGVtZW50LCAnZHJvcGRvd24nKTtcXG4gICAgICB0aGlzLl9pbml0KCk7XFxuXFxuICAgICAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19mb3VuZGF0aW9uX3V0aWxfa2V5Ym9hcmRfX1tcXFwiYVxcXCIgLyogS2V5Ym9hcmQgKi9dLnJlZ2lzdGVyKCdEcm9wZG93bk1lbnUnLCB7XFxuICAgICAgICAnRU5URVInOiAnb3BlbicsXFxuICAgICAgICAnU1BBQ0UnOiAnb3BlbicsXFxuICAgICAgICAnQVJST1dfUklHSFQnOiAnbmV4dCcsXFxuICAgICAgICAnQVJST1dfVVAnOiAndXAnLFxcbiAgICAgICAgJ0FSUk9XX0RPV04nOiAnZG93bicsXFxuICAgICAgICAnQVJST1dfTEVGVCc6ICdwcmV2aW91cycsXFxuICAgICAgICAnRVNDQVBFJzogJ2Nsb3NlJ1xcbiAgICAgIH0pO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgcGx1Z2luLCBhbmQgY2FsbHMgX3ByZXBhcmVNZW51XFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAnX2luaXQnLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXQoKSB7XFxuICAgICAgdmFyIHN1YnMgPSB0aGlzLiRlbGVtZW50LmZpbmQoJ2xpLmlzLWRyb3Bkb3duLXN1Ym1lbnUtcGFyZW50Jyk7XFxuICAgICAgdGhpcy4kZWxlbWVudC5jaGlsZHJlbignLmlzLWRyb3Bkb3duLXN1Ym1lbnUtcGFyZW50JykuY2hpbGRyZW4oJy5pcy1kcm9wZG93bi1zdWJtZW51JykuYWRkQ2xhc3MoJ2ZpcnN0LXN1YicpO1xcblxcbiAgICAgIHRoaXMuJG1lbnVJdGVtcyA9IHRoaXMuJGVsZW1lbnQuZmluZCgnW3JvbGU9XFxcIm1lbnVpdGVtXFxcIl0nKTtcXG4gICAgICB0aGlzLiR0YWJzID0gdGhpcy4kZWxlbWVudC5jaGlsZHJlbignW3JvbGU9XFxcIm1lbnVpdGVtXFxcIl0nKTtcXG4gICAgICB0aGlzLiR0YWJzLmZpbmQoJ3VsLmlzLWRyb3Bkb3duLXN1Ym1lbnUnKS5hZGRDbGFzcyh0aGlzLm9wdGlvbnMudmVydGljYWxDbGFzcyk7XFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5hbGlnbm1lbnQgPT09ICdhdXRvJykge1xcbiAgICAgICAgaWYgKHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3ModGhpcy5vcHRpb25zLnJpZ2h0Q2xhc3MpIHx8IF9fd2VicGFja19yZXF1aXJlX18uaShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX2ZvdW5kYXRpb25fdXRpbF9jb3JlX19bXFxcImFcXFwiIC8qIHJ0bCAqL10pKCkgfHwgdGhpcy4kZWxlbWVudC5wYXJlbnRzKCcudG9wLWJhci1yaWdodCcpLmlzKCcqJykpIHtcXG4gICAgICAgICAgdGhpcy5vcHRpb25zLmFsaWdubWVudCA9ICdyaWdodCc7XFxuICAgICAgICAgIHN1YnMuYWRkQ2xhc3MoJ29wZW5zLWxlZnQnKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHRoaXMub3B0aW9ucy5hbGlnbm1lbnQgPSAnbGVmdCc7XFxuICAgICAgICAgIHN1YnMuYWRkQ2xhc3MoJ29wZW5zLXJpZ2h0Jyk7XFxuICAgICAgICB9XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYWxpZ25tZW50ID09PSAncmlnaHQnKSB7XFxuICAgICAgICAgIHN1YnMuYWRkQ2xhc3MoJ29wZW5zLWxlZnQnKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHN1YnMuYWRkQ2xhc3MoJ29wZW5zLXJpZ2h0Jyk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIHRoaXMuY2hhbmdlZCA9IGZhbHNlO1xcbiAgICAgIHRoaXMuX2V2ZW50cygpO1xcbiAgICB9XFxuICB9LCB7XFxuICAgIGtleTogJ19pc1ZlcnRpY2FsJyxcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pc1ZlcnRpY2FsKCkge1xcbiAgICAgIHJldHVybiB0aGlzLiR0YWJzLmNzcygnZGlzcGxheScpID09PSAnYmxvY2snIHx8IHRoaXMuJGVsZW1lbnQuY3NzKCdmbGV4LWRpcmVjdGlvbicpID09PSAnY29sdW1uJztcXG4gICAgfVxcbiAgfSwge1xcbiAgICBrZXk6ICdfaXNSdGwnLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2lzUnRsKCkge1xcbiAgICAgIHJldHVybiB0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKCdhbGlnbi1yaWdodCcpIHx8IF9fd2VicGFja19yZXF1aXJlX18uaShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX2ZvdW5kYXRpb25fdXRpbF9jb3JlX19bXFxcImFcXFwiIC8qIHJ0bCAqL10pKCkgJiYgIXRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2FsaWduLWxlZnQnKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQWRkcyBldmVudCBsaXN0ZW5lcnMgdG8gZWxlbWVudHMgd2l0aGluIHRoZSBtZW51XFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAnX2V2ZW50cycsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZXZlbnRzKCkge1xcbiAgICAgIHZhciBfdGhpcyA9IHRoaXMsXFxuICAgICAgICAgIGhhc1RvdWNoID0gJ29udG91Y2hzdGFydCcgaW4gd2luZG93IHx8IHR5cGVvZiB3aW5kb3cub250b3VjaHN0YXJ0ICE9PSAndW5kZWZpbmVkJyxcXG4gICAgICAgICAgcGFyQ2xhc3MgPSAnaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnQnO1xcblxcbiAgICAgIC8vIHVzZWQgZm9yIG9uQ2xpY2sgYW5kIGluIHRoZSBrZXlib2FyZCBoYW5kbGVyc1xcbiAgICAgIHZhciBoYW5kbGVDbGlja0ZuID0gZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgIHZhciAkZWxlbSA9IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0KCkoZS50YXJnZXQpLnBhcmVudHNVbnRpbCgndWwnLCAnLicgKyBwYXJDbGFzcyksXFxuICAgICAgICAgICAgaGFzU3ViID0gJGVsZW0uaGFzQ2xhc3MocGFyQ2xhc3MpLFxcbiAgICAgICAgICAgIGhhc0NsaWNrZWQgPSAkZWxlbS5hdHRyKCdkYXRhLWlzLWNsaWNrJykgPT09ICd0cnVlJyxcXG4gICAgICAgICAgICAkc3ViID0gJGVsZW0uY2hpbGRyZW4oJy5pcy1kcm9wZG93bi1zdWJtZW51Jyk7XFxuXFxuICAgICAgICBpZiAoaGFzU3ViKSB7XFxuICAgICAgICAgIGlmIChoYXNDbGlja2VkKSB7XFxuICAgICAgICAgICAgaWYgKCFfdGhpcy5vcHRpb25zLmNsb3NlT25DbGljayB8fCAhX3RoaXMub3B0aW9ucy5jbGlja09wZW4gJiYgIWhhc1RvdWNoIHx8IF90aGlzLm9wdGlvbnMuZm9yY2VGb2xsb3cgJiYgaGFzVG91Y2gpIHtcXG4gICAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcXG4gICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgICAgICAgIF90aGlzLl9oaWRlKCRlbGVtKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XFxuICAgICAgICAgICAgX3RoaXMuX3Nob3coJHN1Yik7XFxuICAgICAgICAgICAgJGVsZW0uYWRkKCRlbGVtLnBhcmVudHNVbnRpbChfdGhpcy4kZWxlbWVudCwgJy4nICsgcGFyQ2xhc3MpKS5hdHRyKCdkYXRhLWlzLWNsaWNrJywgdHJ1ZSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9O1xcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuY2xpY2tPcGVuIHx8IGhhc1RvdWNoKSB7XFxuICAgICAgICB0aGlzLiRtZW51SXRlbXMub24oJ2NsaWNrLnpmLmRyb3Bkb3dubWVudSB0b3VjaHN0YXJ0LnpmLmRyb3Bkb3dubWVudScsIGhhbmRsZUNsaWNrRm4pO1xcbiAgICAgIH1cXG5cXG4gICAgICAvLyBIYW5kbGUgTGVhZiBlbGVtZW50IENsaWNrc1xcbiAgICAgIGlmIChfdGhpcy5vcHRpb25zLmNsb3NlT25DbGlja0luc2lkZSkge1xcbiAgICAgICAgdGhpcy4kbWVudUl0ZW1zLm9uKCdjbGljay56Zi5kcm9wZG93bm1lbnUnLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgICB2YXIgJGVsZW0gPSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKHRoaXMpLFxcbiAgICAgICAgICAgICAgaGFzU3ViID0gJGVsZW0uaGFzQ2xhc3MocGFyQ2xhc3MpO1xcbiAgICAgICAgICBpZiAoIWhhc1N1Yikge1xcbiAgICAgICAgICAgIF90aGlzLl9oaWRlKCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5kaXNhYmxlSG92ZXIpIHtcXG4gICAgICAgIHRoaXMuJG1lbnVJdGVtcy5vbignbW91c2VlbnRlci56Zi5kcm9wZG93bm1lbnUnLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgICB2YXIgJGVsZW0gPSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKHRoaXMpLFxcbiAgICAgICAgICAgICAgaGFzU3ViID0gJGVsZW0uaGFzQ2xhc3MocGFyQ2xhc3MpO1xcblxcbiAgICAgICAgICBpZiAoaGFzU3ViKSB7XFxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KCRlbGVtLmRhdGEoJ19kZWxheScpKTtcXG4gICAgICAgICAgICAkZWxlbS5kYXRhKCdfZGVsYXknLCBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgIF90aGlzLl9zaG93KCRlbGVtLmNoaWxkcmVuKCcuaXMtZHJvcGRvd24tc3VibWVudScpKTtcXG4gICAgICAgICAgICB9LCBfdGhpcy5vcHRpb25zLmhvdmVyRGVsYXkpKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSkub24oJ21vdXNlbGVhdmUuemYuZHJvcGRvd25tZW51JywgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgICAgdmFyICRlbGVtID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSh0aGlzKSxcXG4gICAgICAgICAgICAgIGhhc1N1YiA9ICRlbGVtLmhhc0NsYXNzKHBhckNsYXNzKTtcXG4gICAgICAgICAgaWYgKGhhc1N1YiAmJiBfdGhpcy5vcHRpb25zLmF1dG9jbG9zZSkge1xcbiAgICAgICAgICAgIGlmICgkZWxlbS5hdHRyKCdkYXRhLWlzLWNsaWNrJykgPT09ICd0cnVlJyAmJiBfdGhpcy5vcHRpb25zLmNsaWNrT3Blbikge1xcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoJGVsZW0uZGF0YSgnX2RlbGF5JykpO1xcbiAgICAgICAgICAgICRlbGVtLmRhdGEoJ19kZWxheScsIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgX3RoaXMuX2hpZGUoJGVsZW0pO1xcbiAgICAgICAgICAgIH0sIF90aGlzLm9wdGlvbnMuY2xvc2luZ1RpbWUpKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgICAgfVxcbiAgICAgIHRoaXMuJG1lbnVJdGVtcy5vbigna2V5ZG93bi56Zi5kcm9wZG93bm1lbnUnLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgdmFyICRlbGVtZW50ID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKShlLnRhcmdldCkucGFyZW50c1VudGlsKCd1bCcsICdbcm9sZT1cXFwibWVudWl0ZW1cXFwiXScpLFxcbiAgICAgICAgICAgIGlzVGFiID0gX3RoaXMuJHRhYnMuaW5kZXgoJGVsZW1lbnQpID4gLTEsXFxuICAgICAgICAgICAgJGVsZW1lbnRzID0gaXNUYWIgPyBfdGhpcy4kdGFicyA6ICRlbGVtZW50LnNpYmxpbmdzKCdsaScpLmFkZCgkZWxlbWVudCksXFxuICAgICAgICAgICAgJHByZXZFbGVtZW50LFxcbiAgICAgICAgICAgICRuZXh0RWxlbWVudDtcXG5cXG4gICAgICAgICRlbGVtZW50cy5lYWNoKGZ1bmN0aW9uIChpKSB7XFxuICAgICAgICAgIGlmIChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKHRoaXMpLmlzKCRlbGVtZW50KSkge1xcbiAgICAgICAgICAgICRwcmV2RWxlbWVudCA9ICRlbGVtZW50cy5lcShpIC0gMSk7XFxuICAgICAgICAgICAgJG5leHRFbGVtZW50ID0gJGVsZW1lbnRzLmVxKGkgKyAxKTtcXG4gICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcblxcbiAgICAgICAgdmFyIG5leHRTaWJsaW5nID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICBpZiAoISRlbGVtZW50LmlzKCc6bGFzdC1jaGlsZCcpKSB7XFxuICAgICAgICAgICAgJG5leHRFbGVtZW50LmNoaWxkcmVuKCdhOmZpcnN0JykuZm9jdXMoKTtcXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0sXFxuICAgICAgICAgICAgcHJldlNpYmxpbmcgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICRwcmV2RWxlbWVudC5jaGlsZHJlbignYTpmaXJzdCcpLmZvY3VzKCk7XFxuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgIH0sXFxuICAgICAgICAgICAgb3BlblN1YiA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgdmFyICRzdWIgPSAkZWxlbWVudC5jaGlsZHJlbigndWwuaXMtZHJvcGRvd24tc3VibWVudScpO1xcbiAgICAgICAgICBpZiAoJHN1Yi5sZW5ndGgpIHtcXG4gICAgICAgICAgICBfdGhpcy5fc2hvdygkc3ViKTtcXG4gICAgICAgICAgICAkZWxlbWVudC5maW5kKCdsaSA+IGE6Zmlyc3QnKS5mb2N1cygpO1xcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0sXFxuICAgICAgICAgICAgY2xvc2VTdWIgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIC8vaWYgKCRlbGVtZW50LmlzKCc6Zmlyc3QtY2hpbGQnKSkge1xcbiAgICAgICAgICB2YXIgY2xvc2UgPSAkZWxlbWVudC5wYXJlbnQoJ3VsJykucGFyZW50KCdsaScpO1xcbiAgICAgICAgICBjbG9zZS5jaGlsZHJlbignYTpmaXJzdCcpLmZvY3VzKCk7XFxuICAgICAgICAgIF90aGlzLl9oaWRlKGNsb3NlKTtcXG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgICAvL31cXG4gICAgICAgIH07XFxuICAgICAgICB2YXIgZnVuY3Rpb25zID0ge1xcbiAgICAgICAgICBvcGVuOiBvcGVuU3ViLFxcbiAgICAgICAgICBjbG9zZTogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIF90aGlzLl9oaWRlKF90aGlzLiRlbGVtZW50KTtcXG4gICAgICAgICAgICBfdGhpcy4kbWVudUl0ZW1zLmVxKDApLmNoaWxkcmVuKCdhJykuZm9jdXMoKTsgLy8gZm9jdXMgdG8gZmlyc3QgZWxlbWVudFxcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgICAgfSxcXG4gICAgICAgICAgaGFuZGxlZDogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH07XFxuXFxuICAgICAgICBpZiAoaXNUYWIpIHtcXG4gICAgICAgICAgaWYgKF90aGlzLl9pc1ZlcnRpY2FsKCkpIHtcXG4gICAgICAgICAgICAvLyB2ZXJ0aWNhbCBtZW51XFxuICAgICAgICAgICAgaWYgKF90aGlzLl9pc1J0bCgpKSB7XFxuICAgICAgICAgICAgICAvLyByaWdodCBhbGlnbmVkXFxuICAgICAgICAgICAgICBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdC5hLmV4dGVuZChmdW5jdGlvbnMsIHtcXG4gICAgICAgICAgICAgICAgZG93bjogbmV4dFNpYmxpbmcsXFxuICAgICAgICAgICAgICAgIHVwOiBwcmV2U2libGluZyxcXG4gICAgICAgICAgICAgICAgbmV4dDogY2xvc2VTdWIsXFxuICAgICAgICAgICAgICAgIHByZXZpb3VzOiBvcGVuU3ViXFxuICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgLy8gbGVmdCBhbGlnbmVkXFxuICAgICAgICAgICAgICBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdC5hLmV4dGVuZChmdW5jdGlvbnMsIHtcXG4gICAgICAgICAgICAgICAgZG93bjogbmV4dFNpYmxpbmcsXFxuICAgICAgICAgICAgICAgIHVwOiBwcmV2U2libGluZyxcXG4gICAgICAgICAgICAgICAgbmV4dDogb3BlblN1YixcXG4gICAgICAgICAgICAgICAgcHJldmlvdXM6IGNsb3NlU3ViXFxuICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgLy8gaG9yaXpvbnRhbCBtZW51XFxuICAgICAgICAgICAgaWYgKF90aGlzLl9pc1J0bCgpKSB7XFxuICAgICAgICAgICAgICAvLyByaWdodCBhbGlnbmVkXFxuICAgICAgICAgICAgICBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdC5hLmV4dGVuZChmdW5jdGlvbnMsIHtcXG4gICAgICAgICAgICAgICAgbmV4dDogcHJldlNpYmxpbmcsXFxuICAgICAgICAgICAgICAgIHByZXZpb3VzOiBuZXh0U2libGluZyxcXG4gICAgICAgICAgICAgICAgZG93bjogb3BlblN1YixcXG4gICAgICAgICAgICAgICAgdXA6IGNsb3NlU3ViXFxuICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgLy8gbGVmdCBhbGlnbmVkXFxuICAgICAgICAgICAgICBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdC5hLmV4dGVuZChmdW5jdGlvbnMsIHtcXG4gICAgICAgICAgICAgICAgbmV4dDogbmV4dFNpYmxpbmcsXFxuICAgICAgICAgICAgICAgIHByZXZpb3VzOiBwcmV2U2libGluZyxcXG4gICAgICAgICAgICAgICAgZG93bjogb3BlblN1YixcXG4gICAgICAgICAgICAgICAgdXA6IGNsb3NlU3ViXFxuICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIC8vIG5vdCB0YWJzIC0+IG9uZSBzdWJcXG4gICAgICAgICAgaWYgKF90aGlzLl9pc1J0bCgpKSB7XFxuICAgICAgICAgICAgLy8gcmlnaHQgYWxpZ25lZFxcbiAgICAgICAgICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0LmEuZXh0ZW5kKGZ1bmN0aW9ucywge1xcbiAgICAgICAgICAgICAgbmV4dDogY2xvc2VTdWIsXFxuICAgICAgICAgICAgICBwcmV2aW91czogb3BlblN1YixcXG4gICAgICAgICAgICAgIGRvd246IG5leHRTaWJsaW5nLFxcbiAgICAgICAgICAgICAgdXA6IHByZXZTaWJsaW5nXFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgLy8gbGVmdCBhbGlnbmVkXFxuICAgICAgICAgICAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQuYS5leHRlbmQoZnVuY3Rpb25zLCB7XFxuICAgICAgICAgICAgICBuZXh0OiBvcGVuU3ViLFxcbiAgICAgICAgICAgICAgcHJldmlvdXM6IGNsb3NlU3ViLFxcbiAgICAgICAgICAgICAgZG93bjogbmV4dFNpYmxpbmcsXFxuICAgICAgICAgICAgICB1cDogcHJldlNpYmxpbmdcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19mb3VuZGF0aW9uX3V0aWxfa2V5Ym9hcmRfX1tcXFwiYVxcXCIgLyogS2V5Ym9hcmQgKi9dLmhhbmRsZUtleShlLCAnRHJvcGRvd25NZW51JywgZnVuY3Rpb25zKTtcXG4gICAgICB9KTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQWRkcyBhbiBldmVudCBoYW5kbGVyIHRvIHRoZSBib2R5IHRvIGNsb3NlIGFueSBkcm9wZG93bnMgb24gYSBjbGljay5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6ICdfYWRkQm9keUhhbmRsZXInLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2FkZEJvZHlIYW5kbGVyKCkge1xcbiAgICAgIHZhciAkYm9keSA9IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0KCkoZG9jdW1lbnQuYm9keSksXFxuICAgICAgICAgIF90aGlzID0gdGhpcztcXG4gICAgICAkYm9keS5vZmYoJ21vdXNldXAuemYuZHJvcGRvd25tZW51IHRvdWNoZW5kLnpmLmRyb3Bkb3dubWVudScpLm9uKCdtb3VzZXVwLnpmLmRyb3Bkb3dubWVudSB0b3VjaGVuZC56Zi5kcm9wZG93bm1lbnUnLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgdmFyICRsaW5rID0gX3RoaXMuJGVsZW1lbnQuZmluZChlLnRhcmdldCk7XFxuICAgICAgICBpZiAoJGxpbmsubGVuZ3RoKSB7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIF90aGlzLl9oaWRlKCk7XFxuICAgICAgICAkYm9keS5vZmYoJ21vdXNldXAuemYuZHJvcGRvd25tZW51IHRvdWNoZW5kLnpmLmRyb3Bkb3dubWVudScpO1xcbiAgICAgIH0pO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBPcGVucyBhIGRyb3Bkb3duIHBhbmUsIGFuZCBjaGVja3MgZm9yIGNvbGxpc2lvbnMgZmlyc3QuXFxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSAkc3ViIC0gdWwgZWxlbWVudCB0aGF0IGlzIGEgc3VibWVudSB0byBzaG93XFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAZmlyZXMgRHJvcGRvd25NZW51I3Nob3dcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogJ19zaG93JyxcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zaG93KCRzdWIpIHtcXG4gICAgICB2YXIgaWR4ID0gdGhpcy4kdGFicy5pbmRleCh0aGlzLiR0YWJzLmZpbHRlcihmdW5jdGlvbiAoaSwgZWwpIHtcXG4gICAgICAgIHJldHVybiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKGVsKS5maW5kKCRzdWIpLmxlbmd0aCA+IDA7XFxuICAgICAgfSkpO1xcbiAgICAgIHZhciAkc2licyA9ICRzdWIucGFyZW50KCdsaS5pcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudCcpLnNpYmxpbmdzKCdsaS5pcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudCcpO1xcbiAgICAgIHRoaXMuX2hpZGUoJHNpYnMsIGlkeCk7XFxuICAgICAgJHN1Yi5jc3MoJ3Zpc2liaWxpdHknLCAnaGlkZGVuJykuYWRkQ2xhc3MoJ2pzLWRyb3Bkb3duLWFjdGl2ZScpLnBhcmVudCgnbGkuaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnQnKS5hZGRDbGFzcygnaXMtYWN0aXZlJyk7XFxuICAgICAgdmFyIGNsZWFyID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19mb3VuZGF0aW9uX3V0aWxfYm94X19bXFxcImFcXFwiIC8qIEJveCAqL10uSW1Ob3RUb3VjaGluZ1lvdSgkc3ViLCBudWxsLCB0cnVlKTtcXG4gICAgICBpZiAoIWNsZWFyKSB7XFxuICAgICAgICB2YXIgb2xkQ2xhc3MgPSB0aGlzLm9wdGlvbnMuYWxpZ25tZW50ID09PSAnbGVmdCcgPyAnLXJpZ2h0JyA6ICctbGVmdCcsXFxuICAgICAgICAgICAgJHBhcmVudExpID0gJHN1Yi5wYXJlbnQoJy5pcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudCcpO1xcbiAgICAgICAgJHBhcmVudExpLnJlbW92ZUNsYXNzKCdvcGVucycgKyBvbGRDbGFzcykuYWRkQ2xhc3MoJ29wZW5zLScgKyB0aGlzLm9wdGlvbnMuYWxpZ25tZW50KTtcXG4gICAgICAgIGNsZWFyID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19mb3VuZGF0aW9uX3V0aWxfYm94X19bXFxcImFcXFwiIC8qIEJveCAqL10uSW1Ob3RUb3VjaGluZ1lvdSgkc3ViLCBudWxsLCB0cnVlKTtcXG4gICAgICAgIGlmICghY2xlYXIpIHtcXG4gICAgICAgICAgJHBhcmVudExpLnJlbW92ZUNsYXNzKCdvcGVucy0nICsgdGhpcy5vcHRpb25zLmFsaWdubWVudCkuYWRkQ2xhc3MoJ29wZW5zLWlubmVyJyk7XFxuICAgICAgICB9XFxuICAgICAgICB0aGlzLmNoYW5nZWQgPSB0cnVlO1xcbiAgICAgIH1cXG4gICAgICAkc3ViLmNzcygndmlzaWJpbGl0eScsICcnKTtcXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmNsb3NlT25DbGljaykge1xcbiAgICAgICAgdGhpcy5fYWRkQm9keUhhbmRsZXIoKTtcXG4gICAgICB9XFxuICAgICAgLyoqXFxuICAgICAgICogRmlyZXMgd2hlbiB0aGUgbmV3IGRyb3Bkb3duIHBhbmUgaXMgdmlzaWJsZS5cXG4gICAgICAgKiBAZXZlbnQgRHJvcGRvd25NZW51I3Nob3dcXG4gICAgICAgKi9cXG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ3Nob3cuemYuZHJvcGRvd25tZW51JywgWyRzdWJdKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogSGlkZXMgYSBzaW5nbGUsIGN1cnJlbnRseSBvcGVuIGRyb3Bkb3duIHBhbmUsIGlmIHBhc3NlZCBhIHBhcmFtZXRlciwgb3RoZXJ3aXNlLCBoaWRlcyBldmVyeXRoaW5nLlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQHBhcmFtIHtqUXVlcnl9ICRlbGVtIC0gZWxlbWVudCB3aXRoIGEgc3VibWVudSB0byBoaWRlXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpZHggLSBpbmRleCBvZiB0aGUgJHRhYnMgY29sbGVjdGlvbiB0byBoaWRlXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6ICdfaGlkZScsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaGlkZSgkZWxlbSwgaWR4KSB7XFxuICAgICAgdmFyICR0b0Nsb3NlO1xcbiAgICAgIGlmICgkZWxlbSAmJiAkZWxlbS5sZW5ndGgpIHtcXG4gICAgICAgICR0b0Nsb3NlID0gJGVsZW07XFxuICAgICAgfSBlbHNlIGlmIChpZHggIT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgJHRvQ2xvc2UgPSB0aGlzLiR0YWJzLm5vdChmdW5jdGlvbiAoaSwgZWwpIHtcXG4gICAgICAgICAgcmV0dXJuIGkgPT09IGlkeDtcXG4gICAgICAgIH0pO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICAkdG9DbG9zZSA9IHRoaXMuJGVsZW1lbnQ7XFxuICAgICAgfVxcbiAgICAgIHZhciBzb21ldGhpbmdUb0Nsb3NlID0gJHRvQ2xvc2UuaGFzQ2xhc3MoJ2lzLWFjdGl2ZScpIHx8ICR0b0Nsb3NlLmZpbmQoJy5pcy1hY3RpdmUnKS5sZW5ndGggPiAwO1xcblxcbiAgICAgIGlmIChzb21ldGhpbmdUb0Nsb3NlKSB7XFxuICAgICAgICAkdG9DbG9zZS5maW5kKCdsaS5pcy1hY3RpdmUnKS5hZGQoJHRvQ2xvc2UpLmF0dHIoe1xcbiAgICAgICAgICAnZGF0YS1pcy1jbGljayc6IGZhbHNlXFxuICAgICAgICB9KS5yZW1vdmVDbGFzcygnaXMtYWN0aXZlJyk7XFxuXFxuICAgICAgICAkdG9DbG9zZS5maW5kKCd1bC5qcy1kcm9wZG93bi1hY3RpdmUnKS5yZW1vdmVDbGFzcygnanMtZHJvcGRvd24tYWN0aXZlJyk7XFxuXFxuICAgICAgICBpZiAodGhpcy5jaGFuZ2VkIHx8ICR0b0Nsb3NlLmZpbmQoJ29wZW5zLWlubmVyJykubGVuZ3RoKSB7XFxuICAgICAgICAgIHZhciBvbGRDbGFzcyA9IHRoaXMub3B0aW9ucy5hbGlnbm1lbnQgPT09ICdsZWZ0JyA/ICdyaWdodCcgOiAnbGVmdCc7XFxuICAgICAgICAgICR0b0Nsb3NlLmZpbmQoJ2xpLmlzLWRyb3Bkb3duLXN1Ym1lbnUtcGFyZW50JykuYWRkKCR0b0Nsb3NlKS5yZW1vdmVDbGFzcygnb3BlbnMtaW5uZXIgb3BlbnMtJyArIHRoaXMub3B0aW9ucy5hbGlnbm1lbnQpLmFkZENsYXNzKCdvcGVucy0nICsgb2xkQ2xhc3MpO1xcbiAgICAgICAgICB0aGlzLmNoYW5nZWQgPSBmYWxzZTtcXG4gICAgICAgIH1cXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgb3BlbiBtZW51cyBhcmUgY2xvc2VkLlxcbiAgICAgICAgICogQGV2ZW50IERyb3Bkb3duTWVudSNoaWRlXFxuICAgICAgICAgKi9cXG4gICAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignaGlkZS56Zi5kcm9wZG93bm1lbnUnLCBbJHRvQ2xvc2VdKTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIERlc3Ryb3lzIHRoZSBwbHVnaW4uXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAnX2Rlc3Ryb3knLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Rlc3Ryb3koKSB7XFxuICAgICAgdGhpcy4kbWVudUl0ZW1zLm9mZignLnpmLmRyb3Bkb3dubWVudScpLnJlbW92ZUF0dHIoJ2RhdGEtaXMtY2xpY2snKS5yZW1vdmVDbGFzcygnaXMtcmlnaHQtYXJyb3cgaXMtbGVmdC1hcnJvdyBpcy1kb3duLWFycm93IG9wZW5zLXJpZ2h0IG9wZW5zLWxlZnQgb3BlbnMtaW5uZXInKTtcXG4gICAgICBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKGRvY3VtZW50LmJvZHkpLm9mZignLnpmLmRyb3Bkb3dubWVudScpO1xcbiAgICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fZm91bmRhdGlvbl91dGlsX25lc3RfX1tcXFwiYVxcXCIgLyogTmVzdCAqL10uQnVybih0aGlzLiRlbGVtZW50LCAnZHJvcGRvd24nKTtcXG4gICAgfVxcbiAgfV0pO1xcblxcbiAgcmV0dXJuIERyb3Bkb3duTWVudTtcXG59KF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fZm91bmRhdGlvbl9wbHVnaW5fX1tcXFwiYVxcXCIgLyogUGx1Z2luICovXSk7XFxuXFxuLyoqXFxuICogRGVmYXVsdCBzZXR0aW5ncyBmb3IgcGx1Z2luXFxuICovXFxuXFxuXFxuRHJvcGRvd25NZW51LmRlZmF1bHRzID0ge1xcbiAgLyoqXFxuICAgKiBEaXNhbGxvd3MgaG92ZXIgZXZlbnRzIGZyb20gb3BlbmluZyBzdWJtZW51c1xcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge2Jvb2xlYW59XFxuICAgKiBAZGVmYXVsdCBmYWxzZVxcbiAgICovXFxuICBkaXNhYmxlSG92ZXI6IGZhbHNlLFxcbiAgLyoqXFxuICAgKiBBbGxvdyBhIHN1Ym1lbnUgdG8gYXV0b21hdGljYWxseSBjbG9zZSBvbiBhIG1vdXNlbGVhdmUgZXZlbnQsIGlmIG5vdCBjbGlja2VkIG9wZW4uXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IHRydWVcXG4gICAqL1xcbiAgYXV0b2Nsb3NlOiB0cnVlLFxcbiAgLyoqXFxuICAgKiBBbW91bnQgb2YgdGltZSB0byBkZWxheSBvcGVuaW5nIGEgc3VibWVudSBvbiBob3ZlciBldmVudC5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtudW1iZXJ9XFxuICAgKiBAZGVmYXVsdCA1MFxcbiAgICovXFxuICBob3ZlckRlbGF5OiA1MCxcXG4gIC8qKlxcbiAgICogQWxsb3cgYSBzdWJtZW51IHRvIG9wZW4vcmVtYWluIG9wZW4gb24gcGFyZW50IGNsaWNrIGV2ZW50LiBBbGxvd3MgY3Vyc29yIHRvIG1vdmUgYXdheSBmcm9tIG1lbnUuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IGZhbHNlXFxuICAgKi9cXG4gIGNsaWNrT3BlbjogZmFsc2UsXFxuICAvKipcXG4gICAqIEFtb3VudCBvZiB0aW1lIHRvIGRlbGF5IGNsb3NpbmcgYSBzdWJtZW51IG9uIGEgbW91c2VsZWF2ZSBldmVudC5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtudW1iZXJ9XFxuICAgKiBAZGVmYXVsdCA1MDBcXG4gICAqL1xcblxcbiAgY2xvc2luZ1RpbWU6IDUwMCxcXG4gIC8qKlxcbiAgICogUG9zaXRpb24gb2YgdGhlIG1lbnUgcmVsYXRpdmUgdG8gd2hhdCBkaXJlY3Rpb24gdGhlIHN1Ym1lbnVzIHNob3VsZCBvcGVuLiBIYW5kbGVkIGJ5IEpTLiBDYW4gYmUgYCdhdXRvJ2AsIGAnbGVmdCdgIG9yIGAncmlnaHQnYC5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtzdHJpbmd9XFxuICAgKiBAZGVmYXVsdCAnYXV0bydcXG4gICAqL1xcbiAgYWxpZ25tZW50OiAnYXV0bycsXFxuICAvKipcXG4gICAqIEFsbG93IGNsaWNrcyBvbiB0aGUgYm9keSB0byBjbG9zZSBhbnkgb3BlbiBzdWJtZW51cy5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtib29sZWFufVxcbiAgICogQGRlZmF1bHQgdHJ1ZVxcbiAgICovXFxuICBjbG9zZU9uQ2xpY2s6IHRydWUsXFxuICAvKipcXG4gICAqIEFsbG93IGNsaWNrcyBvbiBsZWFmIGFuY2hvciBsaW5rcyB0byBjbG9zZSBhbnkgb3BlbiBzdWJtZW51cy5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtib29sZWFufVxcbiAgICogQGRlZmF1bHQgdHJ1ZVxcbiAgICovXFxuICBjbG9zZU9uQ2xpY2tJbnNpZGU6IHRydWUsXFxuICAvKipcXG4gICAqIENsYXNzIGFwcGxpZWQgdG8gdmVydGljYWwgb3JpZW50ZWQgbWVudXMsIEZvdW5kYXRpb24gZGVmYXVsdCBpcyBgdmVydGljYWxgLiBVcGRhdGUgdGhpcyBpZiB1c2luZyB5b3VyIG93biBjbGFzcy5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtzdHJpbmd9XFxuICAgKiBAZGVmYXVsdCAndmVydGljYWwnXFxuICAgKi9cXG4gIHZlcnRpY2FsQ2xhc3M6ICd2ZXJ0aWNhbCcsXFxuICAvKipcXG4gICAqIENsYXNzIGFwcGxpZWQgdG8gcmlnaHQtc2lkZSBvcmllbnRlZCBtZW51cywgRm91bmRhdGlvbiBkZWZhdWx0IGlzIGBhbGlnbi1yaWdodGAuIFVwZGF0ZSB0aGlzIGlmIHVzaW5nIHlvdXIgb3duIGNsYXNzLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge3N0cmluZ31cXG4gICAqIEBkZWZhdWx0ICdhbGlnbi1yaWdodCdcXG4gICAqL1xcbiAgcmlnaHRDbGFzczogJ2FsaWduLXJpZ2h0JyxcXG4gIC8qKlxcbiAgICogQm9vbGVhbiB0byBmb3JjZSBvdmVyaWRlIHRoZSBjbGlja2luZyBvZiBsaW5rcyB0byBwZXJmb3JtIGRlZmF1bHQgYWN0aW9uLCBvbiBzZWNvbmQgdG91Y2ggZXZlbnQgZm9yIG1vYmlsZS5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtib29sZWFufVxcbiAgICogQGRlZmF1bHQgdHJ1ZVxcbiAgICovXFxuICBmb3JjZUZvbGxvdzogdHJ1ZVxcbn07XFxuXFxuXFxuXFxuLyoqKi8gfSksXFxuLyogMTUgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImFcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFBvc2l0aW9uYWJsZTsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fZm91bmRhdGlvbl91dGlsX2JveF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19mb3VuZGF0aW9uX3BsdWdpbl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19mb3VuZGF0aW9uX3V0aWxfY29yZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcXG5cXG5cXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFxcXCJ2YWx1ZVxcXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcXG5cXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpOyB9IH1cXG5cXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXFxcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFxcXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXFxcIm9iamVjdFxcXCIgfHwgdHlwZW9mIGNhbGwgPT09IFxcXCJmdW5jdGlvblxcXCIpID8gY2FsbCA6IHNlbGY7IH1cXG5cXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcXFwiZnVuY3Rpb25cXFwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcXFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxcblxcblxcblxcblxcblxcbnZhciBQT1NJVElPTlMgPSBbJ2xlZnQnLCAncmlnaHQnLCAndG9wJywgJ2JvdHRvbSddO1xcbnZhciBWRVJUSUNBTF9BTElHTk1FTlRTID0gWyd0b3AnLCAnYm90dG9tJywgJ2NlbnRlciddO1xcbnZhciBIT1JJWk9OVEFMX0FMSUdOTUVOVFMgPSBbJ2xlZnQnLCAncmlnaHQnLCAnY2VudGVyJ107XFxuXFxudmFyIEFMSUdOTUVOVFMgPSB7XFxuICAnbGVmdCc6IFZFUlRJQ0FMX0FMSUdOTUVOVFMsXFxuICAncmlnaHQnOiBWRVJUSUNBTF9BTElHTk1FTlRTLFxcbiAgJ3RvcCc6IEhPUklaT05UQUxfQUxJR05NRU5UUyxcXG4gICdib3R0b20nOiBIT1JJWk9OVEFMX0FMSUdOTUVOVFNcXG59O1xcblxcbmZ1bmN0aW9uIG5leHRJdGVtKGl0ZW0sIGFycmF5KSB7XFxuICB2YXIgY3VycmVudElkeCA9IGFycmF5LmluZGV4T2YoaXRlbSk7XFxuICBpZiAoY3VycmVudElkeCA9PT0gYXJyYXkubGVuZ3RoIC0gMSkge1xcbiAgICByZXR1cm4gYXJyYXlbMF07XFxuICB9IGVsc2Uge1xcbiAgICByZXR1cm4gYXJyYXlbY3VycmVudElkeCArIDFdO1xcbiAgfVxcbn1cXG5cXG52YXIgUG9zaXRpb25hYmxlID0gZnVuY3Rpb24gKF9QbHVnaW4pIHtcXG4gIF9pbmhlcml0cyhQb3NpdGlvbmFibGUsIF9QbHVnaW4pO1xcblxcbiAgZnVuY3Rpb24gUG9zaXRpb25hYmxlKCkge1xcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUG9zaXRpb25hYmxlKTtcXG5cXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChQb3NpdGlvbmFibGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihQb3NpdGlvbmFibGUpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcXG4gIH1cXG5cXG4gIF9jcmVhdGVDbGFzcyhQb3NpdGlvbmFibGUsIFt7XFxuICAgIGtleTogJ19pbml0JyxcXG5cXG4gICAgLyoqXFxuICAgICAqIEFic3RyYWN0IGNsYXNzIGVuY2Fwc3VsYXRpbmcgdGhlIHRldGhlci1saWtlIGV4cGxpY2l0IHBvc2l0aW9uaW5nIGxvZ2ljXFxuICAgICAqIGluY2x1ZGluZyByZXBvc2l0aW9uaW5nIGJhc2VkIG9uIG92ZXJsYXAuXFxuICAgICAqIEV4cGVjdHMgY2xhc3NlcyB0byBkZWZpbmUgZGVmYXVsdHMgZm9yIHZPZmZzZXQsIGhPZmZzZXQsIHBvc2l0aW9uLFxcbiAgICAgKiBhbGlnbm1lbnQsIGFsbG93T3ZlcmxhcCwgYW5kIGFsbG93Qm90dG9tT3ZlcmxhcC4gVGhleSBjYW4gZG8gdGhpcyBieVxcbiAgICAgKiBleHRlbmRpbmcgdGhlIGRlZmF1bHRzLCBvciAoZm9yIG5vdyByZWNvbW1lbmRlZCBkdWUgdG8gdGhlIHdheSBkb2NzIGFyZVxcbiAgICAgKiBnZW5lcmF0ZWQpIGJ5IGV4cGxpY2l0bHkgZGVjbGFyaW5nIHRoZW0uXFxuICAgICAqXFxuICAgICAqKi9cXG5cXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0KCkge1xcbiAgICAgIHRoaXMudHJpZWRQb3NpdGlvbnMgPSB7fTtcXG4gICAgICB0aGlzLnBvc2l0aW9uID0gdGhpcy5vcHRpb25zLnBvc2l0aW9uID09PSAnYXV0bycgPyB0aGlzLl9nZXREZWZhdWx0UG9zaXRpb24oKSA6IHRoaXMub3B0aW9ucy5wb3NpdGlvbjtcXG4gICAgICB0aGlzLmFsaWdubWVudCA9IHRoaXMub3B0aW9ucy5hbGlnbm1lbnQgPT09ICdhdXRvJyA/IHRoaXMuX2dldERlZmF1bHRBbGlnbm1lbnQoKSA6IHRoaXMub3B0aW9ucy5hbGlnbm1lbnQ7XFxuICAgIH1cXG4gIH0sIHtcXG4gICAga2V5OiAnX2dldERlZmF1bHRQb3NpdGlvbicsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0RGVmYXVsdFBvc2l0aW9uKCkge1xcbiAgICAgIHJldHVybiAnYm90dG9tJztcXG4gICAgfVxcbiAgfSwge1xcbiAgICBrZXk6ICdfZ2V0RGVmYXVsdEFsaWdubWVudCcsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0RGVmYXVsdEFsaWdubWVudCgpIHtcXG4gICAgICBzd2l0Y2ggKHRoaXMucG9zaXRpb24pIHtcXG4gICAgICAgIGNhc2UgJ2JvdHRvbSc6XFxuICAgICAgICBjYXNlICd0b3AnOlxcbiAgICAgICAgICByZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXy5pKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fZm91bmRhdGlvbl91dGlsX2NvcmVfX1tcXFwiYVxcXCIgLyogcnRsICovXSkoKSA/ICdyaWdodCcgOiAnbGVmdCc7XFxuICAgICAgICBjYXNlICdsZWZ0JzpcXG4gICAgICAgIGNhc2UgJ3JpZ2h0JzpcXG4gICAgICAgICAgcmV0dXJuICdib3R0b20nO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQWRqdXN0cyB0aGUgcG9zaXRpb25hYmxlIHBvc3NpYmxlIHBvc2l0aW9ucyBieSBpdGVyYXRpbmcgdGhyb3VnaCBhbGlnbm1lbnRzXFxuICAgICAqIGFuZCBwb3NpdGlvbnMuXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAnX3JlcG9zaXRpb24nLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlcG9zaXRpb24oKSB7XFxuICAgICAgaWYgKHRoaXMuX2FsaWdubWVudHNFeGhhdXN0ZWQodGhpcy5wb3NpdGlvbikpIHtcXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBuZXh0SXRlbSh0aGlzLnBvc2l0aW9uLCBQT1NJVElPTlMpO1xcbiAgICAgICAgdGhpcy5hbGlnbm1lbnQgPSBBTElHTk1FTlRTW3RoaXMucG9zaXRpb25dWzBdO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB0aGlzLl9yZWFsaWduKCk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBBZGp1c3RzIHRoZSBkcm9wZG93biBwYW5lIHBvc3NpYmxlIHBvc2l0aW9ucyBieSBpdGVyYXRpbmcgdGhyb3VnaCBhbGlnbm1lbnRzXFxuICAgICAqIG9uIHRoZSBjdXJyZW50IHBvc2l0aW9uLlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogJ19yZWFsaWduJyxcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZWFsaWduKCkge1xcbiAgICAgIHRoaXMuX2FkZFRyaWVkUG9zaXRpb24odGhpcy5wb3NpdGlvbiwgdGhpcy5hbGlnbm1lbnQpO1xcbiAgICAgIHRoaXMuYWxpZ25tZW50ID0gbmV4dEl0ZW0odGhpcy5hbGlnbm1lbnQsIEFMSUdOTUVOVFNbdGhpcy5wb3NpdGlvbl0pO1xcbiAgICB9XFxuICB9LCB7XFxuICAgIGtleTogJ19hZGRUcmllZFBvc2l0aW9uJyxcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hZGRUcmllZFBvc2l0aW9uKHBvc2l0aW9uLCBhbGlnbm1lbnQpIHtcXG4gICAgICB0aGlzLnRyaWVkUG9zaXRpb25zW3Bvc2l0aW9uXSA9IHRoaXMudHJpZWRQb3NpdGlvbnNbcG9zaXRpb25dIHx8IFtdO1xcbiAgICAgIHRoaXMudHJpZWRQb3NpdGlvbnNbcG9zaXRpb25dLnB1c2goYWxpZ25tZW50KTtcXG4gICAgfVxcbiAgfSwge1xcbiAgICBrZXk6ICdfcG9zaXRpb25zRXhoYXVzdGVkJyxcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wb3NpdGlvbnNFeGhhdXN0ZWQoKSB7XFxuICAgICAgdmFyIGlzRXhoYXVzdGVkID0gdHJ1ZTtcXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IFBPU0lUSU9OUy5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgaXNFeGhhdXN0ZWQgPSBpc0V4aGF1c3RlZCAmJiB0aGlzLl9hbGlnbm1lbnRzRXhoYXVzdGVkKFBPU0lUSU9OU1tpXSk7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBpc0V4aGF1c3RlZDtcXG4gICAgfVxcbiAgfSwge1xcbiAgICBrZXk6ICdfYWxpZ25tZW50c0V4aGF1c3RlZCcsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYWxpZ25tZW50c0V4aGF1c3RlZChwb3NpdGlvbikge1xcbiAgICAgIHJldHVybiB0aGlzLnRyaWVkUG9zaXRpb25zW3Bvc2l0aW9uXSAmJiB0aGlzLnRyaWVkUG9zaXRpb25zW3Bvc2l0aW9uXS5sZW5ndGggPT0gQUxJR05NRU5UU1twb3NpdGlvbl0ubGVuZ3RoO1xcbiAgICB9XFxuXFxuICAgIC8vIFdoZW4gd2UncmUgdHJ5aW5nIHRvIGNlbnRlciwgd2UgZG9uJ3Qgd2FudCB0byBhcHBseSBvZmZzZXQgdGhhdCdzIGdvaW5nIHRvXFxuICAgIC8vIHRha2UgdXMganVzdCBvZmYgY2VudGVyLCBzbyB3cmFwIGFyb3VuZCB0byByZXR1cm4gMCBmb3IgdGhlIGFwcHJvcHJpYXRlXFxuICAgIC8vIG9mZnNldCBpbiB0aG9zZSBhbGlnbm1lbnRzLiAgVE9ETzogRmlndXJlIG91dCBpZiB3ZSB3YW50IHRvIG1ha2UgdGhpc1xcbiAgICAvLyBjb25maWd1cmFibGUgYmVoYXZpb3IuLi4gaXQgZmVlbHMgbW9yZSBpbnR1aXRpdmUsIGVzcGVjaWFsbHkgZm9yIHRvb2x0aXBzLCBidXRcXG4gICAgLy8gaXQncyBwb3NzaWJsZSBzb21lb25lIG1pZ2h0IGFjdHVhbGx5IHdhbnQgdG8gc3RhcnQgZnJvbSBjZW50ZXIgYW5kIHRoZW4gbnVkZ2VcXG4gICAgLy8gc2xpZ2h0bHkgb2ZmLlxcblxcbiAgfSwge1xcbiAgICBrZXk6ICdfZ2V0Vk9mZnNldCcsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0Vk9mZnNldCgpIHtcXG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnZPZmZzZXQ7XFxuICAgIH1cXG4gIH0sIHtcXG4gICAga2V5OiAnX2dldEhPZmZzZXQnLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEhPZmZzZXQoKSB7XFxuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5oT2Zmc2V0O1xcbiAgICB9XFxuICB9LCB7XFxuICAgIGtleTogJ19zZXRQb3NpdGlvbicsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0UG9zaXRpb24oJGFuY2hvciwgJGVsZW1lbnQsICRwYXJlbnQpIHtcXG4gICAgICBpZiAoJGFuY2hvci5hdHRyKCdhcmlhLWV4cGFuZGVkJykgPT09ICdmYWxzZScpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuICAgICAgdmFyICRlbGVEaW1zID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19mb3VuZGF0aW9uX3V0aWxfYm94X19bXFxcImFcXFwiIC8qIEJveCAqL10uR2V0RGltZW5zaW9ucygkZWxlbWVudCksXFxuICAgICAgICAgICRhbmNob3JEaW1zID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19mb3VuZGF0aW9uX3V0aWxfYm94X19bXFxcImFcXFwiIC8qIEJveCAqL10uR2V0RGltZW5zaW9ucygkYW5jaG9yKTtcXG5cXG4gICAgICAkZWxlbWVudC5vZmZzZXQoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19mb3VuZGF0aW9uX3V0aWxfYm94X19bXFxcImFcXFwiIC8qIEJveCAqL10uR2V0RXhwbGljaXRPZmZzZXRzKCRlbGVtZW50LCAkYW5jaG9yLCB0aGlzLnBvc2l0aW9uLCB0aGlzLmFsaWdubWVudCwgdGhpcy5fZ2V0Vk9mZnNldCgpLCB0aGlzLl9nZXRIT2Zmc2V0KCkpKTtcXG5cXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5hbGxvd092ZXJsYXApIHtcXG4gICAgICAgIHZhciBvdmVybGFwcyA9IHt9O1xcbiAgICAgICAgdmFyIG1pbk92ZXJsYXAgPSAxMDAwMDAwMDA7XFxuICAgICAgICAvLyBkZWZhdWx0IGNvb3JkaW5hdGVzIHRvIGhvdyB3ZSBzdGFydCwgaW4gY2FzZSB3ZSBjYW4ndCBmaWd1cmUgb3V0IGJldHRlclxcbiAgICAgICAgdmFyIG1pbkNvb3JkaW5hdGVzID0geyBwb3NpdGlvbjogdGhpcy5wb3NpdGlvbiwgYWxpZ25tZW50OiB0aGlzLmFsaWdubWVudCB9O1xcbiAgICAgICAgd2hpbGUgKCF0aGlzLl9wb3NpdGlvbnNFeGhhdXN0ZWQoKSkge1xcbiAgICAgICAgICB2YXIgb3ZlcmxhcCA9IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fZm91bmRhdGlvbl91dGlsX2JveF9fW1xcXCJhXFxcIiAvKiBCb3ggKi9dLk92ZXJsYXBBcmVhKCRlbGVtZW50LCAkcGFyZW50LCBmYWxzZSwgZmFsc2UsIHRoaXMub3B0aW9ucy5hbGxvd0JvdHRvbU92ZXJsYXApO1xcbiAgICAgICAgICBpZiAob3ZlcmxhcCA9PT0gMCkge1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpZiAob3ZlcmxhcCA8IG1pbk92ZXJsYXApIHtcXG4gICAgICAgICAgICBtaW5PdmVybGFwID0gb3ZlcmxhcDtcXG4gICAgICAgICAgICBtaW5Db29yZGluYXRlcyA9IHsgcG9zaXRpb246IHRoaXMucG9zaXRpb24sIGFsaWdubWVudDogdGhpcy5hbGlnbm1lbnQgfTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICB0aGlzLl9yZXBvc2l0aW9uKCk7XFxuXFxuICAgICAgICAgICRlbGVtZW50Lm9mZnNldChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX2ZvdW5kYXRpb25fdXRpbF9ib3hfX1tcXFwiYVxcXCIgLyogQm94ICovXS5HZXRFeHBsaWNpdE9mZnNldHMoJGVsZW1lbnQsICRhbmNob3IsIHRoaXMucG9zaXRpb24sIHRoaXMuYWxpZ25tZW50LCB0aGlzLl9nZXRWT2Zmc2V0KCksIHRoaXMuX2dldEhPZmZzZXQoKSkpO1xcbiAgICAgICAgfVxcbiAgICAgICAgLy8gSWYgd2UgZ2V0IHRocm91Z2ggdGhlIGVudGlyZSBsb29wLCB0aGVyZSB3YXMgbm8gbm9uLW92ZXJsYXBwaW5nXFxuICAgICAgICAvLyBwb3NpdGlvbiBhdmFpbGFibGUuIFBpY2sgdGhlIHZlcnNpb24gd2l0aCBsZWFzdCBvdmVybGFwLlxcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IG1pbkNvb3JkaW5hdGVzLnBvc2l0aW9uO1xcbiAgICAgICAgdGhpcy5hbGlnbm1lbnQgPSBtaW5Db29yZGluYXRlcy5hbGlnbm1lbnQ7XFxuICAgICAgICAkZWxlbWVudC5vZmZzZXQoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19mb3VuZGF0aW9uX3V0aWxfYm94X19bXFxcImFcXFwiIC8qIEJveCAqL10uR2V0RXhwbGljaXRPZmZzZXRzKCRlbGVtZW50LCAkYW5jaG9yLCB0aGlzLnBvc2l0aW9uLCB0aGlzLmFsaWdubWVudCwgdGhpcy5fZ2V0Vk9mZnNldCgpLCB0aGlzLl9nZXRIT2Zmc2V0KCkpKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1dKTtcXG5cXG4gIHJldHVybiBQb3NpdGlvbmFibGU7XFxufShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX2ZvdW5kYXRpb25fcGx1Z2luX19bXFxcImFcXFwiIC8qIFBsdWdpbiAqL10pO1xcblxcblBvc2l0aW9uYWJsZS5kZWZhdWx0cyA9IHtcXG4gIC8qKlxcbiAgICogUG9zaXRpb24gb2YgcG9zaXRpb25hYmxlIHJlbGF0aXZlIHRvIGFuY2hvci4gQ2FuIGJlIGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgb3IgYXV0by5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtzdHJpbmd9XFxuICAgKiBAZGVmYXVsdCAnYXV0bydcXG4gICAqL1xcbiAgcG9zaXRpb246ICdhdXRvJyxcXG4gIC8qKlxcbiAgICogQWxpZ25tZW50IG9mIHBvc2l0aW9uYWJsZSByZWxhdGl2ZSB0byBhbmNob3IuIENhbiBiZSBsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIGNlbnRlciwgb3IgYXV0by5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtzdHJpbmd9XFxuICAgKiBAZGVmYXVsdCAnYXV0bydcXG4gICAqL1xcbiAgYWxpZ25tZW50OiAnYXV0bycsXFxuICAvKipcXG4gICAqIEFsbG93IG92ZXJsYXAgb2YgY29udGFpbmVyL3dpbmRvdy4gSWYgZmFsc2UsIGRyb3Bkb3duIHBvc2l0aW9uYWJsZSBmaXJzdFxcbiAgICogdHJ5IHRvIHBvc2l0aW9uIGFzIGRlZmluZWQgYnkgZGF0YS1wb3NpdGlvbiBhbmQgZGF0YS1hbGlnbm1lbnQsIGJ1dFxcbiAgICogcmVwb3NpdGlvbiBpZiBpdCB3b3VsZCBjYXVzZSBhbiBvdmVyZmxvdy5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtib29sZWFufVxcbiAgICogQGRlZmF1bHQgZmFsc2VcXG4gICAqL1xcbiAgYWxsb3dPdmVybGFwOiBmYWxzZSxcXG4gIC8qKlxcbiAgICogQWxsb3cgb3ZlcmxhcCBvZiBvbmx5IHRoZSBib3R0b20gb2YgdGhlIGNvbnRhaW5lci4gVGhpcyBpcyB0aGUgbW9zdCBjb21tb25cXG4gICAqIGJlaGF2aW9yIGZvciBkcm9wZG93bnMsIGFsbG93aW5nIHRoZSBkcm9wZG93biB0byBleHRlbmQgdGhlIGJvdHRvbSBvZiB0aGVcXG4gICAqIHNjcmVlbiBidXQgbm90IG90aGVyd2lzZSBpbmZsdWVuY2Ugb3IgYnJlYWsgb3V0IG9mIHRoZSBjb250YWluZXIuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IHRydWVcXG4gICAqL1xcbiAgYWxsb3dCb3R0b21PdmVybGFwOiB0cnVlLFxcbiAgLyoqXFxuICAgKiBOdW1iZXIgb2YgcGl4ZWxzIHRoZSBwb3NpdGlvbmFibGUgc2hvdWxkIGJlIHNlcGFyYXRlZCB2ZXJ0aWNhbGx5IGZyb20gYW5jaG9yXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7bnVtYmVyfVxcbiAgICogQGRlZmF1bHQgMFxcbiAgICovXFxuICB2T2Zmc2V0OiAwLFxcbiAgLyoqXFxuICAgKiBOdW1iZXIgb2YgcGl4ZWxzIHRoZSBwb3NpdGlvbmFibGUgc2hvdWxkIGJlIHNlcGFyYXRlZCBob3Jpem9udGFsbHkgZnJvbSBhbmNob3JcXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtudW1iZXJ9XFxuICAgKiBAZGVmYXVsdCAwXFxuICAgKi9cXG4gIGhPZmZzZXQ6IDBcXG59O1xcblxcblxcblxcbi8qKiovIH0pLFxcbi8qIDE2ICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJhXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBTbW9vdGhTY3JvbGw7IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCA9IF9fd2VicGFja19yZXF1aXJlX18ubihfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX2ZvdW5kYXRpb25fdXRpbF9jb3JlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX2ZvdW5kYXRpb25fcGx1Z2luX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xcblxcblxcbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXFxcInZhbHVlXFxcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xcblxcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7IH0gfVxcblxcbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcXFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXFxcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcXFwib2JqZWN0XFxcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXFxcImZ1bmN0aW9uXFxcIikgPyBjYWxsIDogc2VsZjsgfVxcblxcbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFxcXCJmdW5jdGlvblxcXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFxcXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XFxuXFxuXFxuXFxuXFxuXFxuLyoqXFxuICogU21vb3RoU2Nyb2xsIG1vZHVsZS5cXG4gKiBAbW9kdWxlIGZvdW5kYXRpb24uc21vb3RoLXNjcm9sbFxcbiAqL1xcblxcbnZhciBTbW9vdGhTY3JvbGwgPSBmdW5jdGlvbiAoX1BsdWdpbikge1xcbiAgICBfaW5oZXJpdHMoU21vb3RoU2Nyb2xsLCBfUGx1Z2luKTtcXG5cXG4gICAgZnVuY3Rpb24gU21vb3RoU2Nyb2xsKCkge1xcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNtb290aFNjcm9sbCk7XFxuXFxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFNtb290aFNjcm9sbC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFNtb290aFNjcm9sbCkpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xcbiAgICB9XFxuXFxuICAgIF9jcmVhdGVDbGFzcyhTbW9vdGhTY3JvbGwsIFt7XFxuICAgICAgICBrZXk6ICdfc2V0dXAnLFxcblxcbiAgICAgICAgLyoqXFxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIFNtb290aFNjcm9sbC5cXG4gICAgICAgICAqIEBjbGFzc1xcbiAgICAgICAgICogQG5hbWUgU21vb3RoU2Nyb2xsXFxuICAgICAgICAgKiBAZmlyZXMgU21vb3RoU2Nyb2xsI2luaXRcXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBhZGQgdGhlIHRyaWdnZXIgdG8uXFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlcyB0byB0aGUgZGVmYXVsdCBwbHVnaW4gc2V0dGluZ3MuXFxuICAgICAgICAgKi9cXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0dXAoZWxlbWVudCwgb3B0aW9ucykge1xcbiAgICAgICAgICAgIHRoaXMuJGVsZW1lbnQgPSBlbGVtZW50O1xcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0LmEuZXh0ZW5kKHt9LCBTbW9vdGhTY3JvbGwuZGVmYXVsdHMsIHRoaXMuJGVsZW1lbnQuZGF0YSgpLCBvcHRpb25zKTtcXG4gICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9ICdTbW9vdGhTY3JvbGwnOyAvLyBpZTkgYmFjayBjb21wYXRcXG5cXG4gICAgICAgICAgICB0aGlzLl9pbml0KCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICAvKipcXG4gICAgICAgICAqIEluaXRpYWxpemUgdGhlIFNtb290aFNjcm9sbCBwbHVnaW5cXG4gICAgICAgICAqIEBwcml2YXRlXFxuICAgICAgICAgKi9cXG5cXG4gICAgfSwge1xcbiAgICAgICAga2V5OiAnX2luaXQnLFxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0KCkge1xcbiAgICAgICAgICAgIHZhciBpZCA9IHRoaXMuJGVsZW1lbnRbMF0uaWQgfHwgX193ZWJwYWNrX3JlcXVpcmVfXy5pKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fZm91bmRhdGlvbl91dGlsX2NvcmVfX1tcXFwiYlxcXCIgLyogR2V0WW9EaWdpdHMgKi9dKSg2LCAnc21vb3RoLXNjcm9sbCcpO1xcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuICAgICAgICAgICAgdGhpcy4kZWxlbWVudC5hdHRyKHtcXG4gICAgICAgICAgICAgICAgJ2lkJzogaWRcXG4gICAgICAgICAgICB9KTtcXG5cXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMoKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogSW5pdGlhbGl6ZXMgZXZlbnRzIGZvciBTbW9vdGhTY3JvbGwuXFxuICAgICAgICAgKiBAcHJpdmF0ZVxcbiAgICAgICAgICovXFxuXFxuICAgIH0sIHtcXG4gICAgICAgIGtleTogJ19ldmVudHMnLFxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9ldmVudHMoKSB7XFxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcXG5cXG4gICAgICAgICAgICAvLyBjbGljayBoYW5kbGVyIGZ1bmN0aW9uLlxcbiAgICAgICAgICAgIHZhciBoYW5kbGVMaW5rQ2xpY2sgPSBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgICAgICAgICAvLyBleGl0IGZ1bmN0aW9uIGlmIHRoZSBldmVudCBzb3VyY2UgaXNuJ3QgY29taW5nIGZyb20gYW4gYW5jaG9yIHdpdGggaHJlZiBhdHRyaWJ1dGUgc3RhcnRzIHdpdGggJyMnXFxuICAgICAgICAgICAgICAgIGlmICghX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSh0aGlzKS5pcygnYVtocmVmXj1cXFwiI1xcXCJdJykpIHtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICB2YXIgYXJyaXZhbCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdocmVmJyk7XFxuXFxuICAgICAgICAgICAgICAgIF90aGlzLl9pblRyYW5zaXRpb24gPSB0cnVlO1xcblxcbiAgICAgICAgICAgICAgICBTbW9vdGhTY3JvbGwuc2Nyb2xsVG9Mb2MoYXJyaXZhbCwgX3RoaXMub3B0aW9ucywgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2luVHJhbnNpdGlvbiA9IGZhbHNlO1xcbiAgICAgICAgICAgICAgICB9KTtcXG5cXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgICAgIH07XFxuXFxuICAgICAgICAgICAgdGhpcy4kZWxlbWVudC5vbignY2xpY2suemYuc21vb3RoU2Nyb2xsJywgaGFuZGxlTGlua0NsaWNrKTtcXG4gICAgICAgICAgICB0aGlzLiRlbGVtZW50Lm9uKCdjbGljay56Zi5zbW9vdGhTY3JvbGwnLCAnYVtocmVmXj1cXFwiI1xcXCJdJywgaGFuZGxlTGlua0NsaWNrKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogRnVuY3Rpb24gdG8gc2Nyb2xsIHRvIGEgZ2l2ZW4gbG9jYXRpb24gb24gdGhlIHBhZ2UuXFxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gbG9jIC0gQSBwcm9wZXJseSBmb3JtYXR0ZWQgalF1ZXJ5IGlkIHNlbGVjdG9yLiBFeGFtcGxlOiAnI2ZvbydcXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgdG8gdXNlLlxcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBUaGUgY2FsbGJhY2sgZnVuY3Rpb24uXFxuICAgICAgICAgKiBAc3RhdGljXFxuICAgICAgICAgKiBAZnVuY3Rpb25cXG4gICAgICAgICAqL1xcblxcbiAgICB9XSwgW3tcXG4gICAgICAgIGtleTogJ3Njcm9sbFRvTG9jJyxcXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzY3JvbGxUb0xvYyhsb2MpIHtcXG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogU21vb3RoU2Nyb2xsLmRlZmF1bHRzO1xcbiAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3VtZW50c1syXTtcXG5cXG4gICAgICAgICAgICAvLyBEbyBub3RoaW5nIGlmIHRhcmdldCBkb2VzIG5vdCBleGlzdCB0byBwcmV2ZW50IGVycm9yc1xcbiAgICAgICAgICAgIGlmICghX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKShsb2MpLmxlbmd0aCkge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIHZhciBzY3JvbGxQb3MgPSBNYXRoLnJvdW5kKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0KCkobG9jKS5vZmZzZXQoKS50b3AgLSBvcHRpb25zLnRocmVzaG9sZCAvIDIgLSBvcHRpb25zLm9mZnNldCk7XFxuXFxuICAgICAgICAgICAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSgnaHRtbCwgYm9keScpLnN0b3AodHJ1ZSkuYW5pbWF0ZSh7IHNjcm9sbFRvcDogc2Nyb2xsUG9zIH0sIG9wdGlvbnMuYW5pbWF0aW9uRHVyYXRpb24sIG9wdGlvbnMuYW5pbWF0aW9uRWFzaW5nLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjayAmJiB0eXBlb2YgY2FsbGJhY2sgPT0gXFxcImZ1bmN0aW9uXFxcIikge1xcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICB9XSk7XFxuXFxuICAgIHJldHVybiBTbW9vdGhTY3JvbGw7XFxufShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX2ZvdW5kYXRpb25fcGx1Z2luX19bXFxcImFcXFwiIC8qIFBsdWdpbiAqL10pO1xcblxcbi8qKlxcbiAqIERlZmF1bHQgc2V0dGluZ3MgZm9yIHBsdWdpbi5cXG4gKi9cXG5cXG5cXG5TbW9vdGhTY3JvbGwuZGVmYXVsdHMgPSB7XFxuICAgIC8qKlxcbiAgICAgKiBBbW91bnQgb2YgdGltZSwgaW4gbXMsIHRoZSBhbmltYXRlZCBzY3JvbGxpbmcgc2hvdWxkIHRha2UgYmV0d2VlbiBsb2NhdGlvbnMuXFxuICAgICAqIEBvcHRpb25cXG4gICAgICogQHR5cGUge251bWJlcn1cXG4gICAgICogQGRlZmF1bHQgNTAwXFxuICAgICAqL1xcbiAgICBhbmltYXRpb25EdXJhdGlvbjogNTAwLFxcbiAgICAvKipcXG4gICAgICogQW5pbWF0aW9uIHN0eWxlIHRvIHVzZSB3aGVuIHNjcm9sbGluZyBiZXR3ZWVuIGxvY2F0aW9ucy4gQ2FuIGJlIGAnc3dpbmcnYCBvciBgJ2xpbmVhcidgLlxcbiAgICAgKiBAb3B0aW9uXFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XFxuICAgICAqIEBkZWZhdWx0ICdsaW5lYXInXFxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vYXBpLmpxdWVyeS5jb20vYW5pbWF0ZXxKcXVlcnkgYW5pbWF0ZX1cXG4gICAgICovXFxuICAgIGFuaW1hdGlvbkVhc2luZzogJ2xpbmVhcicsXFxuICAgIC8qKlxcbiAgICAgKiBOdW1iZXIgb2YgcGl4ZWxzIHRvIHVzZSBhcyBhIG1hcmtlciBmb3IgbG9jYXRpb24gY2hhbmdlcy5cXG4gICAgICogQG9wdGlvblxcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxcbiAgICAgKiBAZGVmYXVsdCA1MFxcbiAgICAgKi9cXG4gICAgdGhyZXNob2xkOiA1MCxcXG4gICAgLyoqXFxuICAgICAqIE51bWJlciBvZiBwaXhlbHMgdG8gb2Zmc2V0IHRoZSBzY3JvbGwgb2YgdGhlIHBhZ2Ugb24gaXRlbSBjbGljayBpZiB1c2luZyBhIHN0aWNreSBuYXYgYmFyLlxcbiAgICAgKiBAb3B0aW9uXFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XFxuICAgICAqIEBkZWZhdWx0IDBcXG4gICAgICovXFxuICAgIG9mZnNldDogMFxcbn07XFxuXFxuXFxuXFxuLyoqKi8gfSksXFxuLyogMTcgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImFcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFRhYnM7IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCA9IF9fd2VicGFja19yZXF1aXJlX18ubihfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX2ZvdW5kYXRpb25fdXRpbF9rZXlib2FyZF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19mb3VuZGF0aW9uX3V0aWxfaW1hZ2VMb2FkZXJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fZm91bmRhdGlvbl9wbHVnaW5fXyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XFxuXFxuXFxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcXFwidmFsdWVcXFwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XFxuXFxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTsgfSB9XFxuXFxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFxcXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcXFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFxcXCJvYmplY3RcXFwiIHx8IHR5cGVvZiBjYWxsID09PSBcXFwiZnVuY3Rpb25cXFwiKSA/IGNhbGwgOiBzZWxmOyB9XFxuXFxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXFxcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cXG5cXG5cXG5cXG5cXG5cXG4vKipcXG4gKiBUYWJzIG1vZHVsZS5cXG4gKiBAbW9kdWxlIGZvdW5kYXRpb24udGFic1xcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwua2V5Ym9hcmRcXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLmltYWdlTG9hZGVyIGlmIHRhYnMgY29udGFpbiBpbWFnZXNcXG4gKi9cXG5cXG52YXIgVGFicyA9IGZ1bmN0aW9uIChfUGx1Z2luKSB7XFxuICBfaW5oZXJpdHMoVGFicywgX1BsdWdpbik7XFxuXFxuICBmdW5jdGlvbiBUYWJzKCkge1xcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGFicyk7XFxuXFxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoVGFicy5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFRhYnMpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcXG4gIH1cXG5cXG4gIF9jcmVhdGVDbGFzcyhUYWJzLCBbe1xcbiAgICBrZXk6ICdfc2V0dXAnLFxcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiB0YWJzLlxcbiAgICAgKiBAY2xhc3NcXG4gICAgICogQG5hbWUgVGFic1xcbiAgICAgKiBAZmlyZXMgVGFicyNpbml0XFxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBtYWtlIGludG8gdGFicy5cXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZXMgdG8gdGhlIGRlZmF1bHQgcGx1Z2luIHNldHRpbmdzLlxcbiAgICAgKi9cXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cChlbGVtZW50LCBvcHRpb25zKSB7XFxuICAgICAgdGhpcy4kZWxlbWVudCA9IGVsZW1lbnQ7XFxuICAgICAgdGhpcy5vcHRpb25zID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQuYS5leHRlbmQoe30sIFRhYnMuZGVmYXVsdHMsIHRoaXMuJGVsZW1lbnQuZGF0YSgpLCBvcHRpb25zKTtcXG4gICAgICB0aGlzLmNsYXNzTmFtZSA9ICdUYWJzJzsgLy8gaWU5IGJhY2sgY29tcGF0XFxuXFxuICAgICAgdGhpcy5faW5pdCgpO1xcbiAgICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fZm91bmRhdGlvbl91dGlsX2tleWJvYXJkX19bXFxcImFcXFwiIC8qIEtleWJvYXJkICovXS5yZWdpc3RlcignVGFicycsIHtcXG4gICAgICAgICdFTlRFUic6ICdvcGVuJyxcXG4gICAgICAgICdTUEFDRSc6ICdvcGVuJyxcXG4gICAgICAgICdBUlJPV19SSUdIVCc6ICduZXh0JyxcXG4gICAgICAgICdBUlJPV19VUCc6ICdwcmV2aW91cycsXFxuICAgICAgICAnQVJST1dfRE9XTic6ICduZXh0JyxcXG4gICAgICAgICdBUlJPV19MRUZUJzogJ3ByZXZpb3VzJ1xcbiAgICAgICAgLy8gJ1RBQic6ICduZXh0JyxcXG4gICAgICAgIC8vICdTSElGVF9UQUInOiAncHJldmlvdXMnXFxuICAgICAgfSk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIEluaXRpYWxpemVzIHRoZSB0YWJzIGJ5IHNob3dpbmcgYW5kIGZvY3VzaW5nIChpZiBhdXRvRm9jdXM9dHJ1ZSkgdGhlIHByZXNldCBhY3RpdmUgdGFiLlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAnX2luaXQnLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXQoKSB7XFxuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XFxuXFxuICAgICAgdmFyIF90aGlzID0gdGhpcztcXG5cXG4gICAgICB0aGlzLiRlbGVtZW50LmF0dHIoeyAncm9sZSc6ICd0YWJsaXN0JyB9KTtcXG4gICAgICB0aGlzLiR0YWJUaXRsZXMgPSB0aGlzLiRlbGVtZW50LmZpbmQoJy4nICsgdGhpcy5vcHRpb25zLmxpbmtDbGFzcyk7XFxuICAgICAgdGhpcy4kdGFiQ29udGVudCA9IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0KCkoJ1tkYXRhLXRhYnMtY29udGVudD1cXFwiJyArIHRoaXMuJGVsZW1lbnRbMF0uaWQgKyAnXFxcIl0nKTtcXG5cXG4gICAgICB0aGlzLiR0YWJUaXRsZXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgJGVsZW0gPSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKHRoaXMpLFxcbiAgICAgICAgICAgICRsaW5rID0gJGVsZW0uZmluZCgnYScpLFxcbiAgICAgICAgICAgIGlzQWN0aXZlID0gJGVsZW0uaGFzQ2xhc3MoJycgKyBfdGhpcy5vcHRpb25zLmxpbmtBY3RpdmVDbGFzcyksXFxuICAgICAgICAgICAgaGFzaCA9ICRsaW5rLmF0dHIoJ2RhdGEtdGFicy10YXJnZXQnKSB8fCAkbGlua1swXS5oYXNoLnNsaWNlKDEpLFxcbiAgICAgICAgICAgIGxpbmtJZCA9ICRsaW5rWzBdLmlkID8gJGxpbmtbMF0uaWQgOiBoYXNoICsgJy1sYWJlbCcsXFxuICAgICAgICAgICAgJHRhYkNvbnRlbnQgPSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKCcjJyArIGhhc2gpO1xcblxcbiAgICAgICAgJGVsZW0uYXR0cih7ICdyb2xlJzogJ3ByZXNlbnRhdGlvbicgfSk7XFxuXFxuICAgICAgICAkbGluay5hdHRyKHtcXG4gICAgICAgICAgJ3JvbGUnOiAndGFiJyxcXG4gICAgICAgICAgJ2FyaWEtY29udHJvbHMnOiBoYXNoLFxcbiAgICAgICAgICAnYXJpYS1zZWxlY3RlZCc6IGlzQWN0aXZlLFxcbiAgICAgICAgICAnaWQnOiBsaW5rSWQsXFxuICAgICAgICAgICd0YWJpbmRleCc6IGlzQWN0aXZlID8gJzAnIDogJy0xJ1xcbiAgICAgICAgfSk7XFxuXFxuICAgICAgICAkdGFiQ29udGVudC5hdHRyKHtcXG4gICAgICAgICAgJ3JvbGUnOiAndGFicGFuZWwnLFxcbiAgICAgICAgICAnYXJpYS1sYWJlbGxlZGJ5JzogbGlua0lkXFxuICAgICAgICB9KTtcXG5cXG4gICAgICAgIGlmICghaXNBY3RpdmUpIHtcXG4gICAgICAgICAgJHRhYkNvbnRlbnQuYXR0cignYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKGlzQWN0aXZlICYmIF90aGlzLm9wdGlvbnMuYXV0b0ZvY3VzKSB7XFxuICAgICAgICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0KCkod2luZG93KS5sb2FkKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKCdodG1sLCBib2R5JykuYW5pbWF0ZSh7IHNjcm9sbFRvcDogJGVsZW0ub2Zmc2V0KCkudG9wIH0sIF90aGlzLm9wdGlvbnMuZGVlcExpbmtTbXVkZ2VEZWxheSwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgJGxpbmsuZm9jdXMoKTtcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5tYXRjaEhlaWdodCkge1xcbiAgICAgICAgdmFyICRpbWFnZXMgPSB0aGlzLiR0YWJDb250ZW50LmZpbmQoJ2ltZycpO1xcblxcbiAgICAgICAgaWYgKCRpbWFnZXMubGVuZ3RoKSB7XFxuICAgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18uaShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX2ZvdW5kYXRpb25fdXRpbF9pbWFnZUxvYWRlcl9fW1xcXCJhXFxcIiAvKiBvbkltYWdlc0xvYWRlZCAqL10pKCRpbWFnZXMsIHRoaXMuX3NldEhlaWdodC5iaW5kKHRoaXMpKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHRoaXMuX3NldEhlaWdodCgpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICAvL2N1cnJlbnQgY29udGV4dC1ib3VuZCBmdW5jdGlvbiB0byBvcGVuIHRhYnMgb24gcGFnZSBsb2FkIG9yIGhpc3RvcnkgcG9wc3RhdGVcXG4gICAgICB0aGlzLl9jaGVja0RlZXBMaW5rID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIGFuY2hvciA9IHdpbmRvdy5sb2NhdGlvbi5oYXNoO1xcbiAgICAgICAgLy9uZWVkIGEgaGFzaCBhbmQgYSByZWxldmFudCBhbmNob3IgaW4gdGhpcyB0YWJzZXRcXG4gICAgICAgIGlmIChhbmNob3IubGVuZ3RoKSB7XFxuICAgICAgICAgIHZhciAkbGluayA9IF90aGlzMy4kZWxlbWVudC5maW5kKCdbaHJlZiQ9XFxcIicgKyBhbmNob3IgKyAnXFxcIl0nKTtcXG4gICAgICAgICAgaWYgKCRsaW5rLmxlbmd0aCkge1xcbiAgICAgICAgICAgIF90aGlzMy5zZWxlY3RUYWIoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKShhbmNob3IpLCB0cnVlKTtcXG5cXG4gICAgICAgICAgICAvL3JvbGwgdXAgYSBsaXR0bGUgdG8gc2hvdyB0aGUgdGl0bGVzXFxuICAgICAgICAgICAgaWYgKF90aGlzMy5vcHRpb25zLmRlZXBMaW5rU211ZGdlKSB7XFxuICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gX3RoaXMzLiRlbGVtZW50Lm9mZnNldCgpO1xcbiAgICAgICAgICAgICAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSgnaHRtbCwgYm9keScpLmFuaW1hdGUoeyBzY3JvbGxUb3A6IG9mZnNldC50b3AgfSwgX3RoaXMzLm9wdGlvbnMuZGVlcExpbmtTbXVkZ2VEZWxheSk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIC8qKlxcbiAgICAgICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSB6cGx1Z2luIGhhcyBkZWVwbGlua2VkIGF0IHBhZ2Vsb2FkXFxuICAgICAgICAgICAgICAqIEBldmVudCBUYWJzI2RlZXBsaW5rXFxuICAgICAgICAgICAgICAqL1xcbiAgICAgICAgICAgIF90aGlzMy4kZWxlbWVudC50cmlnZ2VyKCdkZWVwbGluay56Zi50YWJzJywgWyRsaW5rLCBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKGFuY2hvcildKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH07XFxuXFxuICAgICAgLy91c2UgYnJvd3NlciB0byBvcGVuIGEgdGFiLCBpZiBpdCBleGlzdHMgaW4gdGhpcyB0YWJzZXRcXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmRlZXBMaW5rKSB7XFxuICAgICAgICB0aGlzLl9jaGVja0RlZXBMaW5rKCk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX2V2ZW50cygpO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBBZGRzIGV2ZW50IGhhbmRsZXJzIGZvciBpdGVtcyB3aXRoaW4gdGhlIHRhYnMuXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6ICdfZXZlbnRzJyxcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9ldmVudHMoKSB7XFxuICAgICAgdGhpcy5fYWRkS2V5SGFuZGxlcigpO1xcbiAgICAgIHRoaXMuX2FkZENsaWNrSGFuZGxlcigpO1xcbiAgICAgIHRoaXMuX3NldEhlaWdodE1xSGFuZGxlciA9IG51bGw7XFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5tYXRjaEhlaWdodCkge1xcbiAgICAgICAgdGhpcy5fc2V0SGVpZ2h0TXFIYW5kbGVyID0gdGhpcy5fc2V0SGVpZ2h0LmJpbmQodGhpcyk7XFxuXFxuICAgICAgICBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKHdpbmRvdykub24oJ2NoYW5nZWQuemYubWVkaWFxdWVyeScsIHRoaXMuX3NldEhlaWdodE1xSGFuZGxlcik7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGVlcExpbmspIHtcXG4gICAgICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0KCkod2luZG93KS5vbigncG9wc3RhdGUnLCB0aGlzLl9jaGVja0RlZXBMaW5rKTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIEFkZHMgY2xpY2sgaGFuZGxlcnMgZm9yIGl0ZW1zIHdpdGhpbiB0aGUgdGFicy5cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogJ19hZGRDbGlja0hhbmRsZXInLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2FkZENsaWNrSGFuZGxlcigpIHtcXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xcblxcbiAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKCdjbGljay56Zi50YWJzJykub24oJ2NsaWNrLnpmLnRhYnMnLCAnLicgKyB0aGlzLm9wdGlvbnMubGlua0NsYXNzLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcXG4gICAgICAgIF90aGlzLl9oYW5kbGVUYWJDaGFuZ2UoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSh0aGlzKSk7XFxuICAgICAgfSk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIEFkZHMga2V5Ym9hcmQgZXZlbnQgaGFuZGxlcnMgZm9yIGl0ZW1zIHdpdGhpbiB0aGUgdGFicy5cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogJ19hZGRLZXlIYW5kbGVyJyxcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hZGRLZXlIYW5kbGVyKCkge1xcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuXFxuICAgICAgdGhpcy4kdGFiVGl0bGVzLm9mZigna2V5ZG93bi56Zi50YWJzJykub24oJ2tleWRvd24uemYudGFicycsIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICBpZiAoZS53aGljaCA9PT0gOSkgcmV0dXJuO1xcblxcbiAgICAgICAgdmFyICRlbGVtZW50ID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSh0aGlzKSxcXG4gICAgICAgICAgICAkZWxlbWVudHMgPSAkZWxlbWVudC5wYXJlbnQoJ3VsJykuY2hpbGRyZW4oJ2xpJyksXFxuICAgICAgICAgICAgJHByZXZFbGVtZW50LFxcbiAgICAgICAgICAgICRuZXh0RWxlbWVudDtcXG5cXG4gICAgICAgICRlbGVtZW50cy5lYWNoKGZ1bmN0aW9uIChpKSB7XFxuICAgICAgICAgIGlmIChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKHRoaXMpLmlzKCRlbGVtZW50KSkge1xcbiAgICAgICAgICAgIGlmIChfdGhpcy5vcHRpb25zLndyYXBPbktleXMpIHtcXG4gICAgICAgICAgICAgICRwcmV2RWxlbWVudCA9IGkgPT09IDAgPyAkZWxlbWVudHMubGFzdCgpIDogJGVsZW1lbnRzLmVxKGkgLSAxKTtcXG4gICAgICAgICAgICAgICRuZXh0RWxlbWVudCA9IGkgPT09ICRlbGVtZW50cy5sZW5ndGggLSAxID8gJGVsZW1lbnRzLmZpcnN0KCkgOiAkZWxlbWVudHMuZXEoaSArIDEpO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAkcHJldkVsZW1lbnQgPSAkZWxlbWVudHMuZXEoTWF0aC5tYXgoMCwgaSAtIDEpKTtcXG4gICAgICAgICAgICAgICRuZXh0RWxlbWVudCA9ICRlbGVtZW50cy5lcShNYXRoLm1pbihpICsgMSwgJGVsZW1lbnRzLmxlbmd0aCAtIDEpKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG5cXG4gICAgICAgIC8vIGhhbmRsZSBrZXlib2FyZCBldmVudCB3aXRoIGtleWJvYXJkIHV0aWxcXG4gICAgICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fZm91bmRhdGlvbl91dGlsX2tleWJvYXJkX19bXFxcImFcXFwiIC8qIEtleWJvYXJkICovXS5oYW5kbGVLZXkoZSwgJ1RhYnMnLCB7XFxuICAgICAgICAgIG9wZW46IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAkZWxlbWVudC5maW5kKCdbcm9sZT1cXFwidGFiXFxcIl0nKS5mb2N1cygpO1xcbiAgICAgICAgICAgIF90aGlzLl9oYW5kbGVUYWJDaGFuZ2UoJGVsZW1lbnQpO1xcbiAgICAgICAgICB9LFxcbiAgICAgICAgICBwcmV2aW91czogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICRwcmV2RWxlbWVudC5maW5kKCdbcm9sZT1cXFwidGFiXFxcIl0nKS5mb2N1cygpO1xcbiAgICAgICAgICAgIF90aGlzLl9oYW5kbGVUYWJDaGFuZ2UoJHByZXZFbGVtZW50KTtcXG4gICAgICAgICAgfSxcXG4gICAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICRuZXh0RWxlbWVudC5maW5kKCdbcm9sZT1cXFwidGFiXFxcIl0nKS5mb2N1cygpO1xcbiAgICAgICAgICAgIF90aGlzLl9oYW5kbGVUYWJDaGFuZ2UoJG5leHRFbGVtZW50KTtcXG4gICAgICAgICAgfSxcXG4gICAgICAgICAgaGFuZGxlZDogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XFxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgICB9KTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogT3BlbnMgdGhlIHRhYiBgJHRhcmdldENvbnRlbnRgIGRlZmluZWQgYnkgYCR0YXJnZXRgLiBDb2xsYXBzZXMgYWN0aXZlIHRhYi5cXG4gICAgICogQHBhcmFtIHtqUXVlcnl9ICR0YXJnZXQgLSBUYWIgdG8gb3Blbi5cXG4gICAgICogQHBhcmFtIHtib29sZWFufSBoaXN0b3J5SGFuZGxlZCAtIGJyb3dzZXIgaGFzIGFscmVhZHkgaGFuZGxlZCBhIGhpc3RvcnkgdXBkYXRlXFxuICAgICAqIEBmaXJlcyBUYWJzI2NoYW5nZVxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogJ19oYW5kbGVUYWJDaGFuZ2UnLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZVRhYkNoYW5nZSgkdGFyZ2V0LCBoaXN0b3J5SGFuZGxlZCkge1xcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIENoZWNrIGZvciBhY3RpdmUgY2xhc3Mgb24gdGFyZ2V0LiBDb2xsYXBzZSBpZiBleGlzdHMuXFxuICAgICAgICovXFxuICAgICAgaWYgKCR0YXJnZXQuaGFzQ2xhc3MoJycgKyB0aGlzLm9wdGlvbnMubGlua0FjdGl2ZUNsYXNzKSkge1xcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hY3RpdmVDb2xsYXBzZSkge1xcbiAgICAgICAgICB0aGlzLl9jb2xsYXBzZVRhYigkdGFyZ2V0KTtcXG5cXG4gICAgICAgICAgLyoqXFxuICAgICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHpwbHVnaW4gaGFzIHN1Y2Nlc3NmdWxseSBjb2xsYXBzZWQgdGFicy5cXG4gICAgICAgICAgICogQGV2ZW50IFRhYnMjY29sbGFwc2VcXG4gICAgICAgICAgICovXFxuICAgICAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignY29sbGFwc2UuemYudGFicycsIFskdGFyZ2V0XSk7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIHZhciAkb2xkVGFiID0gdGhpcy4kZWxlbWVudC5maW5kKCcuJyArIHRoaXMub3B0aW9ucy5saW5rQ2xhc3MgKyAnLicgKyB0aGlzLm9wdGlvbnMubGlua0FjdGl2ZUNsYXNzKSxcXG4gICAgICAgICAgJHRhYkxpbmsgPSAkdGFyZ2V0LmZpbmQoJ1tyb2xlPVxcXCJ0YWJcXFwiXScpLFxcbiAgICAgICAgICBoYXNoID0gJHRhYkxpbmsuYXR0cignZGF0YS10YWJzLXRhcmdldCcpIHx8ICR0YWJMaW5rWzBdLmhhc2guc2xpY2UoMSksXFxuICAgICAgICAgICR0YXJnZXRDb250ZW50ID0gdGhpcy4kdGFiQ29udGVudC5maW5kKCcjJyArIGhhc2gpO1xcblxcbiAgICAgIC8vY2xvc2Ugb2xkIHRhYlxcbiAgICAgIHRoaXMuX2NvbGxhcHNlVGFiKCRvbGRUYWIpO1xcblxcbiAgICAgIC8vb3BlbiBuZXcgdGFiXFxuICAgICAgdGhpcy5fb3BlblRhYigkdGFyZ2V0KTtcXG5cXG4gICAgICAvL2VpdGhlciByZXBsYWNlIG9yIHVwZGF0ZSBicm93c2VyIGhpc3RvcnlcXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmRlZXBMaW5rICYmICFoaXN0b3J5SGFuZGxlZCkge1xcbiAgICAgICAgdmFyIGFuY2hvciA9ICR0YXJnZXQuZmluZCgnYScpLmF0dHIoJ2hyZWYnKTtcXG5cXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudXBkYXRlSGlzdG9yeSkge1xcbiAgICAgICAgICBoaXN0b3J5LnB1c2hTdGF0ZSh7fSwgJycsIGFuY2hvcik7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBoaXN0b3J5LnJlcGxhY2VTdGF0ZSh7fSwgJycsIGFuY2hvcik7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHBsdWdpbiBoYXMgc3VjY2Vzc2Z1bGx5IGNoYW5nZWQgdGFicy5cXG4gICAgICAgKiBAZXZlbnQgVGFicyNjaGFuZ2VcXG4gICAgICAgKi9cXG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ2NoYW5nZS56Zi50YWJzJywgWyR0YXJnZXQsICR0YXJnZXRDb250ZW50XSk7XFxuXFxuICAgICAgLy9maXJlIHRvIGNoaWxkcmVuIGEgbXV0YXRpb24gZXZlbnRcXG4gICAgICAkdGFyZ2V0Q29udGVudC5maW5kKFxcXCJbZGF0YS1tdXRhdGVdXFxcIikudHJpZ2dlcihcXFwibXV0YXRlbWUuemYudHJpZ2dlclxcXCIpO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBPcGVucyB0aGUgdGFiIGAkdGFyZ2V0Q29udGVudGAgZGVmaW5lZCBieSBgJHRhcmdldGAuXFxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSAkdGFyZ2V0IC0gVGFiIHRvIE9wZW4uXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAnX29wZW5UYWInLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29wZW5UYWIoJHRhcmdldCkge1xcbiAgICAgIHZhciAkdGFiTGluayA9ICR0YXJnZXQuZmluZCgnW3JvbGU9XFxcInRhYlxcXCJdJyksXFxuICAgICAgICAgIGhhc2ggPSAkdGFiTGluay5hdHRyKCdkYXRhLXRhYnMtdGFyZ2V0JykgfHwgJHRhYkxpbmtbMF0uaGFzaC5zbGljZSgxKSxcXG4gICAgICAgICAgJHRhcmdldENvbnRlbnQgPSB0aGlzLiR0YWJDb250ZW50LmZpbmQoJyMnICsgaGFzaCk7XFxuXFxuICAgICAgJHRhcmdldC5hZGRDbGFzcygnJyArIHRoaXMub3B0aW9ucy5saW5rQWN0aXZlQ2xhc3MpO1xcblxcbiAgICAgICR0YWJMaW5rLmF0dHIoe1xcbiAgICAgICAgJ2FyaWEtc2VsZWN0ZWQnOiAndHJ1ZScsXFxuICAgICAgICAndGFiaW5kZXgnOiAnMCdcXG4gICAgICB9KTtcXG5cXG4gICAgICAkdGFyZ2V0Q29udGVudC5hZGRDbGFzcygnJyArIHRoaXMub3B0aW9ucy5wYW5lbEFjdGl2ZUNsYXNzKS5yZW1vdmVBdHRyKCdhcmlhLWhpZGRlbicpO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDb2xsYXBzZXMgYCR0YXJnZXRDb250ZW50YCBkZWZpbmVkIGJ5IGAkdGFyZ2V0YC5cXG4gICAgICogQHBhcmFtIHtqUXVlcnl9ICR0YXJnZXQgLSBUYWIgdG8gT3Blbi5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6ICdfY29sbGFwc2VUYWInLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NvbGxhcHNlVGFiKCR0YXJnZXQpIHtcXG4gICAgICB2YXIgJHRhcmdldF9hbmNob3IgPSAkdGFyZ2V0LnJlbW92ZUNsYXNzKCcnICsgdGhpcy5vcHRpb25zLmxpbmtBY3RpdmVDbGFzcykuZmluZCgnW3JvbGU9XFxcInRhYlxcXCJdJykuYXR0cih7XFxuICAgICAgICAnYXJpYS1zZWxlY3RlZCc6ICdmYWxzZScsXFxuICAgICAgICAndGFiaW5kZXgnOiAtMVxcbiAgICAgIH0pO1xcblxcbiAgICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0KCkoJyMnICsgJHRhcmdldF9hbmNob3IuYXR0cignYXJpYS1jb250cm9scycpKS5yZW1vdmVDbGFzcygnJyArIHRoaXMub3B0aW9ucy5wYW5lbEFjdGl2ZUNsYXNzKS5hdHRyKHsgJ2FyaWEtaGlkZGVuJzogJ3RydWUnIH0pO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBQdWJsaWMgbWV0aG9kIGZvciBzZWxlY3RpbmcgYSBjb250ZW50IHBhbmUgdG8gZGlzcGxheS5cXG4gICAgICogQHBhcmFtIHtqUXVlcnkgfCBTdHJpbmd9IGVsZW0gLSBqUXVlcnkgb2JqZWN0IG9yIHN0cmluZyBvZiB0aGUgaWQgb2YgdGhlIHBhbmUgdG8gZGlzcGxheS5cXG4gICAgICogQHBhcmFtIHtib29sZWFufSBoaXN0b3J5SGFuZGxlZCAtIGJyb3dzZXIgaGFzIGFscmVhZHkgaGFuZGxlZCBhIGhpc3RvcnkgdXBkYXRlXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAnc2VsZWN0VGFiJyxcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlbGVjdFRhYihlbGVtLCBoaXN0b3J5SGFuZGxlZCkge1xcbiAgICAgIHZhciBpZFN0cjtcXG5cXG4gICAgICBpZiAodHlwZW9mIGVsZW0gPT09ICdvYmplY3QnKSB7XFxuICAgICAgICBpZFN0ciA9IGVsZW1bMF0uaWQ7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGlkU3RyID0gZWxlbTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGlkU3RyLmluZGV4T2YoJyMnKSA8IDApIHtcXG4gICAgICAgIGlkU3RyID0gJyMnICsgaWRTdHI7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciAkdGFyZ2V0ID0gdGhpcy4kdGFiVGl0bGVzLmZpbmQoJ1tocmVmJD1cXFwiJyArIGlkU3RyICsgJ1xcXCJdJykucGFyZW50KCcuJyArIHRoaXMub3B0aW9ucy5saW5rQ2xhc3MpO1xcblxcbiAgICAgIHRoaXMuX2hhbmRsZVRhYkNoYW5nZSgkdGFyZ2V0LCBoaXN0b3J5SGFuZGxlZCk7XFxuICAgIH1cXG4gIH0sIHtcXG4gICAga2V5OiAnX3NldEhlaWdodCcsXFxuXFxuICAgIC8qKlxcbiAgICAgKiBTZXRzIHRoZSBoZWlnaHQgb2YgZWFjaCBwYW5lbCB0byB0aGUgaGVpZ2h0IG9mIHRoZSB0YWxsZXN0IHBhbmVsLlxcbiAgICAgKiBJZiBlbmFibGVkIGluIG9wdGlvbnMsIGdldHMgY2FsbGVkIG9uIG1lZGlhIHF1ZXJ5IGNoYW5nZS5cXG4gICAgICogSWYgbG9hZGluZyBjb250ZW50IHZpYSBleHRlcm5hbCBzb3VyY2UsIGNhbiBiZSBjYWxsZWQgZGlyZWN0bHkgb3Igd2l0aCBfcmVmbG93LlxcbiAgICAgKiBJZiBlbmFibGVkIHdpdGggYGRhdGEtbWF0Y2gtaGVpZ2h0PVxcXCJ0cnVlXFxcImAsIHRhYnMgc2V0cyB0byBlcXVhbCBoZWlnaHRcXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldEhlaWdodCgpIHtcXG4gICAgICB2YXIgbWF4ID0gMCxcXG4gICAgICAgICAgX3RoaXMgPSB0aGlzOyAvLyBMb2NrIGRvd24gdGhlIGB0aGlzYCB2YWx1ZSBmb3IgdGhlIHJvb3QgdGFicyBvYmplY3RcXG5cXG4gICAgICB0aGlzLiR0YWJDb250ZW50LmZpbmQoJy4nICsgdGhpcy5vcHRpb25zLnBhbmVsQ2xhc3MpLmNzcygnaGVpZ2h0JywgJycpLmVhY2goZnVuY3Rpb24gKCkge1xcblxcbiAgICAgICAgdmFyIHBhbmVsID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSh0aGlzKSxcXG4gICAgICAgICAgICBpc0FjdGl2ZSA9IHBhbmVsLmhhc0NsYXNzKCcnICsgX3RoaXMub3B0aW9ucy5wYW5lbEFjdGl2ZUNsYXNzKTsgLy8gZ2V0IHRoZSBvcHRpb25zIGZyb20gdGhlIHBhcmVudCBpbnN0ZWFkIG9mIHRyeWluZyB0byBnZXQgdGhlbSBmcm9tIHRoZSBjaGlsZFxcblxcbiAgICAgICAgaWYgKCFpc0FjdGl2ZSkge1xcbiAgICAgICAgICBwYW5lbC5jc3MoeyAndmlzaWJpbGl0eSc6ICdoaWRkZW4nLCAnZGlzcGxheSc6ICdibG9jaycgfSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB2YXIgdGVtcCA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xcblxcbiAgICAgICAgaWYgKCFpc0FjdGl2ZSkge1xcbiAgICAgICAgICBwYW5lbC5jc3Moe1xcbiAgICAgICAgICAgICd2aXNpYmlsaXR5JzogJycsXFxuICAgICAgICAgICAgJ2Rpc3BsYXknOiAnJ1xcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIG1heCA9IHRlbXAgPiBtYXggPyB0ZW1wIDogbWF4O1xcbiAgICAgIH0pLmNzcygnaGVpZ2h0JywgbWF4ICsgJ3B4Jyk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIERlc3Ryb3lzIGFuIGluc3RhbmNlIG9mIGFuIHRhYnMuXFxuICAgICAqIEBmaXJlcyBUYWJzI2Rlc3Ryb3llZFxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAnX2Rlc3Ryb3knLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Rlc3Ryb3koKSB7XFxuICAgICAgdGhpcy4kZWxlbWVudC5maW5kKCcuJyArIHRoaXMub3B0aW9ucy5saW5rQ2xhc3MpLm9mZignLnpmLnRhYnMnKS5oaWRlKCkuZW5kKCkuZmluZCgnLicgKyB0aGlzLm9wdGlvbnMucGFuZWxDbGFzcykuaGlkZSgpO1xcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubWF0Y2hIZWlnaHQpIHtcXG4gICAgICAgIGlmICh0aGlzLl9zZXRIZWlnaHRNcUhhbmRsZXIgIT0gbnVsbCkge1xcbiAgICAgICAgICBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKHdpbmRvdykub2ZmKCdjaGFuZ2VkLnpmLm1lZGlhcXVlcnknLCB0aGlzLl9zZXRIZWlnaHRNcUhhbmRsZXIpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmRlZXBMaW5rKSB7XFxuICAgICAgICBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKHdpbmRvdykub2ZmKCdwb3BzdGF0ZScsIHRoaXMuX2NoZWNrRGVlcExpbmspO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfV0pO1xcblxcbiAgcmV0dXJuIFRhYnM7XFxufShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX2ZvdW5kYXRpb25fcGx1Z2luX19bXFxcImFcXFwiIC8qIFBsdWdpbiAqL10pO1xcblxcblRhYnMuZGVmYXVsdHMgPSB7XFxuICAvKipcXG4gICAqIEFsbG93cyB0aGUgd2luZG93IHRvIHNjcm9sbCB0byBjb250ZW50IG9mIHBhbmUgc3BlY2lmaWVkIGJ5IGhhc2ggYW5jaG9yXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IGZhbHNlXFxuICAgKi9cXG4gIGRlZXBMaW5rOiBmYWxzZSxcXG5cXG4gIC8qKlxcbiAgICogQWRqdXN0IHRoZSBkZWVwIGxpbmsgc2Nyb2xsIHRvIG1ha2Ugc3VyZSB0aGUgdG9wIG9mIHRoZSB0YWIgcGFuZWwgaXMgdmlzaWJsZVxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge2Jvb2xlYW59XFxuICAgKiBAZGVmYXVsdCBmYWxzZVxcbiAgICovXFxuICBkZWVwTGlua1NtdWRnZTogZmFsc2UsXFxuXFxuICAvKipcXG4gICAqIEFuaW1hdGlvbiB0aW1lIChtcykgZm9yIHRoZSBkZWVwIGxpbmsgYWRqdXN0bWVudFxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge251bWJlcn1cXG4gICAqIEBkZWZhdWx0IDMwMFxcbiAgICovXFxuICBkZWVwTGlua1NtdWRnZURlbGF5OiAzMDAsXFxuXFxuICAvKipcXG4gICAqIFVwZGF0ZSB0aGUgYnJvd3NlciBoaXN0b3J5IHdpdGggdGhlIG9wZW4gdGFiXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IGZhbHNlXFxuICAgKi9cXG4gIHVwZGF0ZUhpc3Rvcnk6IGZhbHNlLFxcblxcbiAgLyoqXFxuICAgKiBBbGxvd3MgdGhlIHdpbmRvdyB0byBzY3JvbGwgdG8gY29udGVudCBvZiBhY3RpdmUgcGFuZSBvbiBsb2FkIGlmIHNldCB0byB0cnVlLlxcbiAgICogTm90IHJlY29tbWVuZGVkIGlmIG1vcmUgdGhhbiBvbmUgdGFiIHBhbmVsIHBlciBwYWdlLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge2Jvb2xlYW59XFxuICAgKiBAZGVmYXVsdCBmYWxzZVxcbiAgICovXFxuICBhdXRvRm9jdXM6IGZhbHNlLFxcblxcbiAgLyoqXFxuICAgKiBBbGxvd3Mga2V5Ym9hcmQgaW5wdXQgdG8gJ3dyYXAnIGFyb3VuZCB0aGUgdGFiIGxpbmtzLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge2Jvb2xlYW59XFxuICAgKiBAZGVmYXVsdCB0cnVlXFxuICAgKi9cXG4gIHdyYXBPbktleXM6IHRydWUsXFxuXFxuICAvKipcXG4gICAqIEFsbG93cyB0aGUgdGFiIGNvbnRlbnQgcGFuZXMgdG8gbWF0Y2ggaGVpZ2h0cyBpZiBzZXQgdG8gdHJ1ZS5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtib29sZWFufVxcbiAgICogQGRlZmF1bHQgZmFsc2VcXG4gICAqL1xcbiAgbWF0Y2hIZWlnaHQ6IGZhbHNlLFxcblxcbiAgLyoqXFxuICAgKiBBbGxvd3MgYWN0aXZlIHRhYnMgdG8gY29sbGFwc2Ugd2hlbiBjbGlja2VkLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge2Jvb2xlYW59XFxuICAgKiBAZGVmYXVsdCBmYWxzZVxcbiAgICovXFxuICBhY3RpdmVDb2xsYXBzZTogZmFsc2UsXFxuXFxuICAvKipcXG4gICAqIENsYXNzIGFwcGxpZWQgdG8gYGxpYCdzIGluIHRhYiBsaW5rIGxpc3QuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7c3RyaW5nfVxcbiAgICogQGRlZmF1bHQgJ3RhYnMtdGl0bGUnXFxuICAgKi9cXG4gIGxpbmtDbGFzczogJ3RhYnMtdGl0bGUnLFxcblxcbiAgLyoqXFxuICAgKiBDbGFzcyBhcHBsaWVkIHRvIHRoZSBhY3RpdmUgYGxpYCBpbiB0YWIgbGluayBsaXN0LlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge3N0cmluZ31cXG4gICAqIEBkZWZhdWx0ICdpcy1hY3RpdmUnXFxuICAgKi9cXG4gIGxpbmtBY3RpdmVDbGFzczogJ2lzLWFjdGl2ZScsXFxuXFxuICAvKipcXG4gICAqIENsYXNzIGFwcGxpZWQgdG8gdGhlIGNvbnRlbnQgY29udGFpbmVycy5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtzdHJpbmd9XFxuICAgKiBAZGVmYXVsdCAndGFicy1wYW5lbCdcXG4gICAqL1xcbiAgcGFuZWxDbGFzczogJ3RhYnMtcGFuZWwnLFxcblxcbiAgLyoqXFxuICAgKiBDbGFzcyBhcHBsaWVkIHRvIHRoZSBhY3RpdmUgY29udGVudCBjb250YWluZXIuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7c3RyaW5nfVxcbiAgICogQGRlZmF1bHQgJ2lzLWFjdGl2ZSdcXG4gICAqL1xcbiAgcGFuZWxBY3RpdmVDbGFzczogJ2lzLWFjdGl2ZSdcXG59O1xcblxcblxcblxcbi8qKiovIH0pLFxcbi8qIDE4ICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJhXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBUaW1lcjsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0ID0gX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfXyk7XFxuXFxuXFxuXFxuXFxuZnVuY3Rpb24gVGltZXIoZWxlbSwgb3B0aW9ucywgY2IpIHtcXG4gIHZhciBfdGhpcyA9IHRoaXMsXFxuICAgICAgZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uLFxcbiAgICAgIC8vb3B0aW9ucyBpcyBhbiBvYmplY3QgZm9yIGVhc2lseSBhZGRpbmcgZmVhdHVyZXMgbGF0ZXIuXFxuICBuYW1lU3BhY2UgPSBPYmplY3Qua2V5cyhlbGVtLmRhdGEoKSlbMF0gfHwgJ3RpbWVyJyxcXG4gICAgICByZW1haW4gPSAtMSxcXG4gICAgICBzdGFydCxcXG4gICAgICB0aW1lcjtcXG5cXG4gIHRoaXMuaXNQYXVzZWQgPSBmYWxzZTtcXG5cXG4gIHRoaXMucmVzdGFydCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgcmVtYWluID0gLTE7XFxuICAgIGNsZWFyVGltZW91dCh0aW1lcik7XFxuICAgIHRoaXMuc3RhcnQoKTtcXG4gIH07XFxuXFxuICB0aGlzLnN0YXJ0ID0gZnVuY3Rpb24gKCkge1xcbiAgICB0aGlzLmlzUGF1c2VkID0gZmFsc2U7XFxuICAgIC8vIGlmKCFlbGVtLmRhdGEoJ3BhdXNlZCcpKXsgcmV0dXJuIGZhbHNlOyB9Ly9tYXliZSBpbXBsZW1lbnQgdGhpcyBzYW5pdHkgY2hlY2sgaWYgdXNlZCBmb3Igb3RoZXIgdGhpbmdzLlxcbiAgICBjbGVhclRpbWVvdXQodGltZXIpO1xcbiAgICByZW1haW4gPSByZW1haW4gPD0gMCA/IGR1cmF0aW9uIDogcmVtYWluO1xcbiAgICBlbGVtLmRhdGEoJ3BhdXNlZCcsIGZhbHNlKTtcXG4gICAgc3RhcnQgPSBEYXRlLm5vdygpO1xcbiAgICB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICAgIGlmIChvcHRpb25zLmluZmluaXRlKSB7XFxuICAgICAgICBfdGhpcy5yZXN0YXJ0KCk7IC8vcmVydW4gdGhlIHRpbWVyLlxcbiAgICAgIH1cXG4gICAgICBpZiAoY2IgJiYgdHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgICBjYigpO1xcbiAgICAgIH1cXG4gICAgfSwgcmVtYWluKTtcXG4gICAgZWxlbS50cmlnZ2VyKCd0aW1lcnN0YXJ0LnpmLicgKyBuYW1lU3BhY2UpO1xcbiAgfTtcXG5cXG4gIHRoaXMucGF1c2UgPSBmdW5jdGlvbiAoKSB7XFxuICAgIHRoaXMuaXNQYXVzZWQgPSB0cnVlO1xcbiAgICAvL2lmKGVsZW0uZGF0YSgncGF1c2VkJykpeyByZXR1cm4gZmFsc2U7IH0vL21heWJlIGltcGxlbWVudCB0aGlzIHNhbml0eSBjaGVjayBpZiB1c2VkIGZvciBvdGhlciB0aGluZ3MuXFxuICAgIGNsZWFyVGltZW91dCh0aW1lcik7XFxuICAgIGVsZW0uZGF0YSgncGF1c2VkJywgdHJ1ZSk7XFxuICAgIHZhciBlbmQgPSBEYXRlLm5vdygpO1xcbiAgICByZW1haW4gPSByZW1haW4gLSAoZW5kIC0gc3RhcnQpO1xcbiAgICBlbGVtLnRyaWdnZXIoJ3RpbWVycGF1c2VkLnpmLicgKyBuYW1lU3BhY2UpO1xcbiAgfTtcXG59XFxuXFxuXFxuXFxuLyoqKi8gfSksXFxuLyogMTkgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiX19lc01vZHVsZVxcXCIsIHsgdmFsdWU6IHRydWUgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0ID0gX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfXyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fZm91bmRhdGlvbl9jb3JlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19mb3VuZGF0aW9uX3V0aWxfY29yZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19mb3VuZGF0aW9uX3V0aWxfYm94X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX2ZvdW5kYXRpb25fdXRpbF9pbWFnZUxvYWRlcl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19mb3VuZGF0aW9uX3V0aWxfa2V5Ym9hcmRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fZm91bmRhdGlvbl91dGlsX21lZGlhUXVlcnlfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fZm91bmRhdGlvbl91dGlsX21vdGlvbl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X19mb3VuZGF0aW9uX3V0aWxfbmVzdF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X19mb3VuZGF0aW9uX3V0aWxfdGltZXJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX19mb3VuZGF0aW9uX3V0aWxfdG91Y2hfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzExX19mb3VuZGF0aW9uX3V0aWxfdHJpZ2dlcnNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTJfX2ZvdW5kYXRpb25fYWJpZGVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEzX19mb3VuZGF0aW9uX2FjY29yZGlvbl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTRfX2ZvdW5kYXRpb25fYWNjb3JkaW9uTWVudV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTVfX2ZvdW5kYXRpb25fZHJpbGxkb3duX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNl9fZm91bmRhdGlvbl9kcm9wZG93bl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTdfX2ZvdW5kYXRpb25fZHJvcGRvd25NZW51X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xOF9fZm91bmRhdGlvbl9lcXVhbGl6ZXJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMjMpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE5X19mb3VuZGF0aW9uX2ludGVyY2hhbmdlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yMF9fZm91bmRhdGlvbl9tYWdlbGxhbl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMjFfX2ZvdW5kYXRpb25fb2ZmY2FudmFzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yMl9fZm91bmRhdGlvbl9vcmJpdF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMjNfX2ZvdW5kYXRpb25fcmVzcG9uc2l2ZU1lbnVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMjkpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzI0X19mb3VuZGF0aW9uX3Jlc3BvbnNpdmVUb2dnbGVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMzApO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzI1X19mb3VuZGF0aW9uX3JldmVhbF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMjZfX2ZvdW5kYXRpb25fc2xpZGVyX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yN19fZm91bmRhdGlvbl9zbW9vdGhTY3JvbGxfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzI4X19mb3VuZGF0aW9uX3N0aWNreV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMjlfX2ZvdW5kYXRpb25fdGFic19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMzBfX2ZvdW5kYXRpb25fdG9nZ2xlcl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNCk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMzFfX2ZvdW5kYXRpb25fdG9vbHRpcF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMzJfX2ZvdW5kYXRpb25fcmVzcG9uc2l2ZUFjY29yZGlvblRhYnNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpO1xcblxcblxcblxcbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fZm91bmRhdGlvbl9jb3JlX19bXFxcImFcXFwiIC8qIEZvdW5kYXRpb24gKi9dLmFkZFRvSnF1ZXJ5KF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0LmEpO1xcblxcbi8vIEFkZCBGb3VuZGF0aW9uIFV0aWxzIHRvIEZvdW5kYXRpb24gZ2xvYmFsIG5hbWVzcGFjZSBmb3IgYmFja3dhcmRzXFxuLy8gY29tcGF0aWJpbGl0eS5cXG5cXG5cXG5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX2ZvdW5kYXRpb25fY29yZV9fW1xcXCJhXFxcIiAvKiBGb3VuZGF0aW9uICovXS5ydGwgPSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX2ZvdW5kYXRpb25fdXRpbF9jb3JlX19bXFxcImFcXFwiIC8qIHJ0bCAqL107XFxuX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19mb3VuZGF0aW9uX2NvcmVfX1tcXFwiYVxcXCIgLyogRm91bmRhdGlvbiAqL10uR2V0WW9EaWdpdHMgPSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX2ZvdW5kYXRpb25fdXRpbF9jb3JlX19bXFxcImJcXFwiIC8qIEdldFlvRGlnaXRzICovXTtcXG5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX2ZvdW5kYXRpb25fY29yZV9fW1xcXCJhXFxcIiAvKiBGb3VuZGF0aW9uICovXS50cmFuc2l0aW9uZW5kID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19mb3VuZGF0aW9uX3V0aWxfY29yZV9fW1xcXCJjXFxcIiAvKiB0cmFuc2l0aW9uZW5kICovXTtcXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX2ZvdW5kYXRpb25fY29yZV9fW1xcXCJhXFxcIiAvKiBGb3VuZGF0aW9uICovXS5Cb3ggPSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX2ZvdW5kYXRpb25fdXRpbF9ib3hfX1tcXFwiYVxcXCIgLyogQm94ICovXTtcXG5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX2ZvdW5kYXRpb25fY29yZV9fW1xcXCJhXFxcIiAvKiBGb3VuZGF0aW9uICovXS5vbkltYWdlc0xvYWRlZCA9IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fZm91bmRhdGlvbl91dGlsX2ltYWdlTG9hZGVyX19bXFxcImFcXFwiIC8qIG9uSW1hZ2VzTG9hZGVkICovXTtcXG5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX2ZvdW5kYXRpb25fY29yZV9fW1xcXCJhXFxcIiAvKiBGb3VuZGF0aW9uICovXS5LZXlib2FyZCA9IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fZm91bmRhdGlvbl91dGlsX2tleWJvYXJkX19bXFxcImFcXFwiIC8qIEtleWJvYXJkICovXTtcXG5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX2ZvdW5kYXRpb25fY29yZV9fW1xcXCJhXFxcIiAvKiBGb3VuZGF0aW9uICovXS5NZWRpYVF1ZXJ5ID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19mb3VuZGF0aW9uX3V0aWxfbWVkaWFRdWVyeV9fW1xcXCJhXFxcIiAvKiBNZWRpYVF1ZXJ5ICovXTtcXG5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX2ZvdW5kYXRpb25fY29yZV9fW1xcXCJhXFxcIiAvKiBGb3VuZGF0aW9uICovXS5Nb3Rpb24gPSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX2ZvdW5kYXRpb25fdXRpbF9tb3Rpb25fX1tcXFwiYVxcXCIgLyogTW90aW9uICovXTtcXG5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX2ZvdW5kYXRpb25fY29yZV9fW1xcXCJhXFxcIiAvKiBGb3VuZGF0aW9uICovXS5Nb3ZlID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19mb3VuZGF0aW9uX3V0aWxfbW90aW9uX19bXFxcImJcXFwiIC8qIE1vdmUgKi9dO1xcbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fZm91bmRhdGlvbl9jb3JlX19bXFxcImFcXFwiIC8qIEZvdW5kYXRpb24gKi9dLk5lc3QgPSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX2ZvdW5kYXRpb25fdXRpbF9uZXN0X19bXFxcImFcXFwiIC8qIE5lc3QgKi9dO1xcbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fZm91bmRhdGlvbl9jb3JlX19bXFxcImFcXFwiIC8qIEZvdW5kYXRpb24gKi9dLlRpbWVyID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X19mb3VuZGF0aW9uX3V0aWxfdGltZXJfX1tcXFwiYVxcXCIgLyogVGltZXIgKi9dO1xcblxcbi8vIFRvdWNoIGFuZCBUcmlnZ2VycyBwcmV2aW91c2x5IHdlcmUgYWxtb3N0IHB1cmVseSBzZWRlIGVmZmVjdCBkcml2ZW4sXFxuLy8gc28gbm8gLy8gbmVlZCB0byBhZGQgaXQgdG8gRm91bmRhdGlvbiwganVzdCBpbml0IHRoZW0uXFxuXFxuXFxuX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMF9fZm91bmRhdGlvbl91dGlsX3RvdWNoX19bXFxcImFcXFwiIC8qIFRvdWNoICovXS5pbml0KF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0LmEpO1xcblxcblxcbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfX2ZvdW5kYXRpb25fdXRpbF90cmlnZ2Vyc19fW1xcXCJhXFxcIiAvKiBUcmlnZ2VycyAqL10uaW5pdChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdC5hLCBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX2ZvdW5kYXRpb25fY29yZV9fW1xcXCJhXFxcIiAvKiBGb3VuZGF0aW9uICovXSk7XFxuXFxuXFxuX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19mb3VuZGF0aW9uX2NvcmVfX1tcXFwiYVxcXCIgLyogRm91bmRhdGlvbiAqL10ucGx1Z2luKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTJfX2ZvdW5kYXRpb25fYWJpZGVfX1tcXFwiYVxcXCIgLyogQWJpZGUgKi9dLCAnQWJpZGUnKTtcXG5cXG5cXG5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX2ZvdW5kYXRpb25fY29yZV9fW1xcXCJhXFxcIiAvKiBGb3VuZGF0aW9uICovXS5wbHVnaW4oX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xM19fZm91bmRhdGlvbl9hY2NvcmRpb25fX1tcXFwiYVxcXCIgLyogQWNjb3JkaW9uICovXSwgJ0FjY29yZGlvbicpO1xcblxcblxcbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fZm91bmRhdGlvbl9jb3JlX19bXFxcImFcXFwiIC8qIEZvdW5kYXRpb24gKi9dLnBsdWdpbihfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE0X19mb3VuZGF0aW9uX2FjY29yZGlvbk1lbnVfX1tcXFwiYVxcXCIgLyogQWNjb3JkaW9uTWVudSAqL10sICdBY2NvcmRpb25NZW51Jyk7XFxuXFxuXFxuX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19mb3VuZGF0aW9uX2NvcmVfX1tcXFwiYVxcXCIgLyogRm91bmRhdGlvbiAqL10ucGx1Z2luKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTVfX2ZvdW5kYXRpb25fZHJpbGxkb3duX19bXFxcImFcXFwiIC8qIERyaWxsZG93biAqL10sICdEcmlsbGRvd24nKTtcXG5cXG5cXG5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX2ZvdW5kYXRpb25fY29yZV9fW1xcXCJhXFxcIiAvKiBGb3VuZGF0aW9uICovXS5wbHVnaW4oX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNl9fZm91bmRhdGlvbl9kcm9wZG93bl9fW1xcXCJhXFxcIiAvKiBEcm9wZG93biAqL10sICdEcm9wZG93bicpO1xcblxcblxcbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fZm91bmRhdGlvbl9jb3JlX19bXFxcImFcXFwiIC8qIEZvdW5kYXRpb24gKi9dLnBsdWdpbihfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE3X19mb3VuZGF0aW9uX2Ryb3Bkb3duTWVudV9fW1xcXCJhXFxcIiAvKiBEcm9wZG93bk1lbnUgKi9dLCAnRHJvcGRvd25NZW51Jyk7XFxuXFxuXFxuX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19mb3VuZGF0aW9uX2NvcmVfX1tcXFwiYVxcXCIgLyogRm91bmRhdGlvbiAqL10ucGx1Z2luKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMThfX2ZvdW5kYXRpb25fZXF1YWxpemVyX19bXFxcImFcXFwiIC8qIEVxdWFsaXplciAqL10sICdFcXVhbGl6ZXInKTtcXG5cXG5cXG5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX2ZvdW5kYXRpb25fY29yZV9fW1xcXCJhXFxcIiAvKiBGb3VuZGF0aW9uICovXS5wbHVnaW4oX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xOV9fZm91bmRhdGlvbl9pbnRlcmNoYW5nZV9fW1xcXCJhXFxcIiAvKiBJbnRlcmNoYW5nZSAqL10sICdJbnRlcmNoYW5nZScpO1xcblxcblxcbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fZm91bmRhdGlvbl9jb3JlX19bXFxcImFcXFwiIC8qIEZvdW5kYXRpb24gKi9dLnBsdWdpbihfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzIwX19mb3VuZGF0aW9uX21hZ2VsbGFuX19bXFxcImFcXFwiIC8qIE1hZ2VsbGFuICovXSwgJ01hZ2VsbGFuJyk7XFxuXFxuXFxuX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19mb3VuZGF0aW9uX2NvcmVfX1tcXFwiYVxcXCIgLyogRm91bmRhdGlvbiAqL10ucGx1Z2luKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMjFfX2ZvdW5kYXRpb25fb2ZmY2FudmFzX19bXFxcImFcXFwiIC8qIE9mZkNhbnZhcyAqL10sICdPZmZDYW52YXMnKTtcXG5cXG5cXG5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX2ZvdW5kYXRpb25fY29yZV9fW1xcXCJhXFxcIiAvKiBGb3VuZGF0aW9uICovXS5wbHVnaW4oX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yMl9fZm91bmRhdGlvbl9vcmJpdF9fW1xcXCJhXFxcIiAvKiBPcmJpdCAqL10sICdPcmJpdCcpO1xcblxcblxcbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fZm91bmRhdGlvbl9jb3JlX19bXFxcImFcXFwiIC8qIEZvdW5kYXRpb24gKi9dLnBsdWdpbihfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzIzX19mb3VuZGF0aW9uX3Jlc3BvbnNpdmVNZW51X19bXFxcImFcXFwiIC8qIFJlc3BvbnNpdmVNZW51ICovXSwgJ1Jlc3BvbnNpdmVNZW51Jyk7XFxuXFxuXFxuX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19mb3VuZGF0aW9uX2NvcmVfX1tcXFwiYVxcXCIgLyogRm91bmRhdGlvbiAqL10ucGx1Z2luKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMjRfX2ZvdW5kYXRpb25fcmVzcG9uc2l2ZVRvZ2dsZV9fW1xcXCJhXFxcIiAvKiBSZXNwb25zaXZlVG9nZ2xlICovXSwgJ1Jlc3BvbnNpdmVUb2dnbGUnKTtcXG5cXG5cXG5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX2ZvdW5kYXRpb25fY29yZV9fW1xcXCJhXFxcIiAvKiBGb3VuZGF0aW9uICovXS5wbHVnaW4oX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yNV9fZm91bmRhdGlvbl9yZXZlYWxfX1tcXFwiYVxcXCIgLyogUmV2ZWFsICovXSwgJ1JldmVhbCcpO1xcblxcblxcbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fZm91bmRhdGlvbl9jb3JlX19bXFxcImFcXFwiIC8qIEZvdW5kYXRpb24gKi9dLnBsdWdpbihfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzI2X19mb3VuZGF0aW9uX3NsaWRlcl9fW1xcXCJhXFxcIiAvKiBTbGlkZXIgKi9dLCAnU2xpZGVyJyk7XFxuXFxuXFxuX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19mb3VuZGF0aW9uX2NvcmVfX1tcXFwiYVxcXCIgLyogRm91bmRhdGlvbiAqL10ucGx1Z2luKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMjdfX2ZvdW5kYXRpb25fc21vb3RoU2Nyb2xsX19bXFxcImFcXFwiIC8qIFNtb290aFNjcm9sbCAqL10sICdTbW9vdGhTY3JvbGwnKTtcXG5cXG5cXG5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX2ZvdW5kYXRpb25fY29yZV9fW1xcXCJhXFxcIiAvKiBGb3VuZGF0aW9uICovXS5wbHVnaW4oX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yOF9fZm91bmRhdGlvbl9zdGlja3lfX1tcXFwiYVxcXCIgLyogU3RpY2t5ICovXSwgJ1N0aWNreScpO1xcblxcblxcbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fZm91bmRhdGlvbl9jb3JlX19bXFxcImFcXFwiIC8qIEZvdW5kYXRpb24gKi9dLnBsdWdpbihfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzI5X19mb3VuZGF0aW9uX3RhYnNfX1tcXFwiYVxcXCIgLyogVGFicyAqL10sICdUYWJzJyk7XFxuXFxuXFxuX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19mb3VuZGF0aW9uX2NvcmVfX1tcXFwiYVxcXCIgLyogRm91bmRhdGlvbiAqL10ucGx1Z2luKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMzBfX2ZvdW5kYXRpb25fdG9nZ2xlcl9fW1xcXCJhXFxcIiAvKiBUb2dnbGVyICovXSwgJ1RvZ2dsZXInKTtcXG5cXG5cXG5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX2ZvdW5kYXRpb25fY29yZV9fW1xcXCJhXFxcIiAvKiBGb3VuZGF0aW9uICovXS5wbHVnaW4oX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zMV9fZm91bmRhdGlvbl90b29sdGlwX19bXFxcImFcXFwiIC8qIFRvb2x0aXAgKi9dLCAnVG9vbHRpcCcpO1xcblxcblxcbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fZm91bmRhdGlvbl9jb3JlX19bXFxcImFcXFwiIC8qIEZvdW5kYXRpb24gKi9dLnBsdWdpbihfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzMyX19mb3VuZGF0aW9uX3Jlc3BvbnNpdmVBY2NvcmRpb25UYWJzX19bXFxcImFcXFwiIC8qIFJlc3BvbnNpdmVBY2NvcmRpb25UYWJzICovXSwgJ1Jlc3BvbnNpdmVBY2NvcmRpb25UYWJzJyk7XFxuXFxuLyoqKi8gfSksXFxuLyogMjAgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImFcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIEFiaWRlOyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLm4oX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19mb3VuZGF0aW9uX3BsdWdpbl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcXG5cXG5cXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFxcXCJ2YWx1ZVxcXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcXG5cXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpOyB9IH1cXG5cXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXFxcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFxcXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXFxcIm9iamVjdFxcXCIgfHwgdHlwZW9mIGNhbGwgPT09IFxcXCJmdW5jdGlvblxcXCIpID8gY2FsbCA6IHNlbGY7IH1cXG5cXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcXFwiZnVuY3Rpb25cXFwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcXFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxcblxcblxcblxcblxcbi8qKlxcbiAqIEFiaWRlIG1vZHVsZS5cXG4gKiBAbW9kdWxlIGZvdW5kYXRpb24uYWJpZGVcXG4gKi9cXG5cXG52YXIgQWJpZGUgPSBmdW5jdGlvbiAoX1BsdWdpbikge1xcbiAgX2luaGVyaXRzKEFiaWRlLCBfUGx1Z2luKTtcXG5cXG4gIGZ1bmN0aW9uIEFiaWRlKCkge1xcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQWJpZGUpO1xcblxcbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEFiaWRlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQWJpZGUpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcXG4gIH1cXG5cXG4gIF9jcmVhdGVDbGFzcyhBYmlkZSwgW3tcXG4gICAga2V5OiAnX3NldHVwJyxcXG5cXG4gICAgLyoqXFxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgQWJpZGUuXFxuICAgICAqIEBjbGFzc1xcbiAgICAgKiBAbmFtZSBBYmlkZVxcbiAgICAgKiBAZmlyZXMgQWJpZGUjaW5pdFxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gYWRkIHRoZSB0cmlnZ2VyIHRvLlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlcyB0byB0aGUgZGVmYXVsdCBwbHVnaW4gc2V0dGluZ3MuXFxuICAgICAqL1xcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwKGVsZW1lbnQpIHtcXG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XFxuXFxuICAgICAgdGhpcy4kZWxlbWVudCA9IGVsZW1lbnQ7XFxuICAgICAgdGhpcy5vcHRpb25zID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQuYS5leHRlbmQoe30sIEFiaWRlLmRlZmF1bHRzLCB0aGlzLiRlbGVtZW50LmRhdGEoKSwgb3B0aW9ucyk7XFxuXFxuICAgICAgdGhpcy5jbGFzc05hbWUgPSAnQWJpZGUnOyAvLyBpZTkgYmFjayBjb21wYXRcXG4gICAgICB0aGlzLl9pbml0KCk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIEluaXRpYWxpemVzIHRoZSBBYmlkZSBwbHVnaW4gYW5kIGNhbGxzIGZ1bmN0aW9ucyB0byBnZXQgQWJpZGUgZnVuY3Rpb25pbmcgb24gbG9hZC5cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogJ19pbml0JyxcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0KCkge1xcbiAgICAgIHRoaXMuJGlucHV0cyA9IHRoaXMuJGVsZW1lbnQuZmluZCgnaW5wdXQsIHRleHRhcmVhLCBzZWxlY3QnKTtcXG5cXG4gICAgICB0aGlzLl9ldmVudHMoKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogSW5pdGlhbGl6ZXMgZXZlbnRzIGZvciBBYmlkZS5cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogJ19ldmVudHMnLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2V2ZW50cygpIHtcXG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcXG5cXG4gICAgICB0aGlzLiRlbGVtZW50Lm9mZignLmFiaWRlJykub24oJ3Jlc2V0LnpmLmFiaWRlJywgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgX3RoaXMzLnJlc2V0Rm9ybSgpO1xcbiAgICAgIH0pLm9uKCdzdWJtaXQuemYuYWJpZGUnLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICByZXR1cm4gX3RoaXMzLnZhbGlkYXRlRm9ybSgpO1xcbiAgICAgIH0pO1xcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudmFsaWRhdGVPbiA9PT0gJ2ZpZWxkQ2hhbmdlJykge1xcbiAgICAgICAgdGhpcy4kaW5wdXRzLm9mZignY2hhbmdlLnpmLmFiaWRlJykub24oJ2NoYW5nZS56Zi5hYmlkZScsIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICAgIF90aGlzMy52YWxpZGF0ZUlucHV0KF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0KCkoZS50YXJnZXQpKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmxpdmVWYWxpZGF0ZSkge1xcbiAgICAgICAgdGhpcy4kaW5wdXRzLm9mZignaW5wdXQuemYuYWJpZGUnKS5vbignaW5wdXQuemYuYWJpZGUnLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgICBfdGhpczMudmFsaWRhdGVJbnB1dChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKGUudGFyZ2V0KSk7XFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy52YWxpZGF0ZU9uQmx1cikge1xcbiAgICAgICAgdGhpcy4kaW5wdXRzLm9mZignYmx1ci56Zi5hYmlkZScpLm9uKCdibHVyLnpmLmFiaWRlJywgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgICAgX3RoaXMzLnZhbGlkYXRlSW5wdXQoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKShlLnRhcmdldCkpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDYWxscyBuZWNlc3NhcnkgZnVuY3Rpb25zIHRvIHVwZGF0ZSBBYmlkZSB1cG9uIERPTSBjaGFuZ2VcXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogJ19yZWZsb3cnLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlZmxvdygpIHtcXG4gICAgICB0aGlzLl9pbml0KCk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIENoZWNrcyB3aGV0aGVyIG9yIG5vdCBhIGZvcm0gZWxlbWVudCBoYXMgdGhlIHJlcXVpcmVkIGF0dHJpYnV0ZSBhbmQgaWYgaXQncyBjaGVja2VkIG9yIG5vdFxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gY2hlY2sgZm9yIHJlcXVpcmVkIGF0dHJpYnV0ZVxcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gQm9vbGVhbiB2YWx1ZSBkZXBlbmRzIG9uIHdoZXRoZXIgb3Igbm90IGF0dHJpYnV0ZSBpcyBjaGVja2VkIG9yIGVtcHR5XFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6ICdyZXF1aXJlZENoZWNrJyxcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlcXVpcmVkQ2hlY2soJGVsKSB7XFxuICAgICAgaWYgKCEkZWwuYXR0cigncmVxdWlyZWQnKSkgcmV0dXJuIHRydWU7XFxuXFxuICAgICAgdmFyIGlzR29vZCA9IHRydWU7XFxuXFxuICAgICAgc3dpdGNoICgkZWxbMF0udHlwZSkge1xcbiAgICAgICAgY2FzZSAnY2hlY2tib3gnOlxcbiAgICAgICAgICBpc0dvb2QgPSAkZWxbMF0uY2hlY2tlZDtcXG4gICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICBjYXNlICdzZWxlY3QnOlxcbiAgICAgICAgY2FzZSAnc2VsZWN0LW9uZSc6XFxuICAgICAgICBjYXNlICdzZWxlY3QtbXVsdGlwbGUnOlxcbiAgICAgICAgICB2YXIgb3B0ID0gJGVsLmZpbmQoJ29wdGlvbjpzZWxlY3RlZCcpO1xcbiAgICAgICAgICBpZiAoIW9wdC5sZW5ndGggfHwgIW9wdC52YWwoKSkgaXNHb29kID0gZmFsc2U7XFxuICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgZGVmYXVsdDpcXG4gICAgICAgICAgaWYgKCEkZWwudmFsKCkgfHwgISRlbC52YWwoKS5sZW5ndGgpIGlzR29vZCA9IGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gaXNHb29kO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBHZXQ6XFxuICAgICAqIC0gQmFzZWQgb24gJGVsLCB0aGUgZmlyc3QgZWxlbWVudChzKSBjb3JyZXNwb25kaW5nIHRvIGBmb3JtRXJyb3JTZWxlY3RvcmAgaW4gdGhpcyBvcmRlcjpcXG4gICAgICogICAxLiBUaGUgZWxlbWVudCdzIGRpcmVjdCBzaWJsaW5nKCdzKS5cXG4gICAgICogICAyLiBUaGUgZWxlbWVudCdzIHBhcmVudCdzIGNoaWxkcmVuLlxcbiAgICAgKiAtIEVsZW1lbnQocykgd2l0aCB0aGUgYXR0cmlidXRlIGBbZGF0YS1mb3JtLWVycm9yLWZvcl1gIHNldCB3aXRoIHRoZSBlbGVtZW50J3MgaWQuXFxuICAgICAqXFxuICAgICAqIFRoaXMgYWxsb3dzIGZvciBtdWx0aXBsZSBmb3JtIGVycm9ycyBwZXIgaW5wdXQsIHRob3VnaCBpZiBub25lIGFyZSBmb3VuZCwgbm8gZm9ybSBlcnJvcnMgd2lsbCBiZSBzaG93bi5cXG4gICAgICpcXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICRlbCAtIGpRdWVyeSBvYmplY3QgdG8gdXNlIGFzIHJlZmVyZW5jZSB0byBmaW5kIHRoZSBmb3JtIGVycm9yIHNlbGVjdG9yLlxcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBqUXVlcnkgb2JqZWN0IHdpdGggdGhlIHNlbGVjdG9yLlxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAnZmluZEZvcm1FcnJvcicsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kRm9ybUVycm9yKCRlbCkge1xcbiAgICAgIHZhciBpZCA9ICRlbFswXS5pZDtcXG4gICAgICB2YXIgJGVycm9yID0gJGVsLnNpYmxpbmdzKHRoaXMub3B0aW9ucy5mb3JtRXJyb3JTZWxlY3Rvcik7XFxuXFxuICAgICAgaWYgKCEkZXJyb3IubGVuZ3RoKSB7XFxuICAgICAgICAkZXJyb3IgPSAkZWwucGFyZW50KCkuZmluZCh0aGlzLm9wdGlvbnMuZm9ybUVycm9yU2VsZWN0b3IpO1xcbiAgICAgIH1cXG5cXG4gICAgICAkZXJyb3IgPSAkZXJyb3IuYWRkKHRoaXMuJGVsZW1lbnQuZmluZCgnW2RhdGEtZm9ybS1lcnJvci1mb3I9XFxcIicgKyBpZCArICdcXFwiXScpKTtcXG5cXG4gICAgICByZXR1cm4gJGVycm9yO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBHZXQgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhpcyBvcmRlcjpcXG4gICAgICogMi4gVGhlIDxsYWJlbD4gd2l0aCB0aGUgYXR0cmlidXRlIGBbZm9yPVxcXCJzb21lSW5wdXRJZFxcXCJdYFxcbiAgICAgKiAzLiBUaGUgYC5jbG9zZXN0KClgIDxsYWJlbD5cXG4gICAgICpcXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICRlbCAtIGpRdWVyeSBvYmplY3QgdG8gY2hlY2sgZm9yIHJlcXVpcmVkIGF0dHJpYnV0ZVxcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gQm9vbGVhbiB2YWx1ZSBkZXBlbmRzIG9uIHdoZXRoZXIgb3Igbm90IGF0dHJpYnV0ZSBpcyBjaGVja2VkIG9yIGVtcHR5XFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6ICdmaW5kTGFiZWwnLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmluZExhYmVsKCRlbCkge1xcbiAgICAgIHZhciBpZCA9ICRlbFswXS5pZDtcXG4gICAgICB2YXIgJGxhYmVsID0gdGhpcy4kZWxlbWVudC5maW5kKCdsYWJlbFtmb3I9XFxcIicgKyBpZCArICdcXFwiXScpO1xcblxcbiAgICAgIGlmICghJGxhYmVsLmxlbmd0aCkge1xcbiAgICAgICAgcmV0dXJuICRlbC5jbG9zZXN0KCdsYWJlbCcpO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gJGxhYmVsO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBHZXQgdGhlIHNldCBvZiBsYWJlbHMgYXNzb2NpYXRlZCB3aXRoIGEgc2V0IG9mIHJhZGlvIGVscyBpbiB0aGlzIG9yZGVyXFxuICAgICAqIDIuIFRoZSA8bGFiZWw+IHdpdGggdGhlIGF0dHJpYnV0ZSBgW2Zvcj1cXFwic29tZUlucHV0SWRcXFwiXWBcXG4gICAgICogMy4gVGhlIGAuY2xvc2VzdCgpYCA8bGFiZWw+XFxuICAgICAqXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAkZWwgLSBqUXVlcnkgb2JqZWN0IHRvIGNoZWNrIGZvciByZXF1aXJlZCBhdHRyaWJ1dGVcXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IEJvb2xlYW4gdmFsdWUgZGVwZW5kcyBvbiB3aGV0aGVyIG9yIG5vdCBhdHRyaWJ1dGUgaXMgY2hlY2tlZCBvciBlbXB0eVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAnZmluZFJhZGlvTGFiZWxzJyxcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRSYWRpb0xhYmVscygkZWxzKSB7XFxuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XFxuXFxuICAgICAgdmFyIGxhYmVscyA9ICRlbHMubWFwKGZ1bmN0aW9uIChpLCBlbCkge1xcbiAgICAgICAgdmFyIGlkID0gZWwuaWQ7XFxuICAgICAgICB2YXIgJGxhYmVsID0gX3RoaXM0LiRlbGVtZW50LmZpbmQoJ2xhYmVsW2Zvcj1cXFwiJyArIGlkICsgJ1xcXCJdJyk7XFxuXFxuICAgICAgICBpZiAoISRsYWJlbC5sZW5ndGgpIHtcXG4gICAgICAgICAgJGxhYmVsID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKShlbCkuY2xvc2VzdCgnbGFiZWwnKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiAkbGFiZWxbMF07XFxuICAgICAgfSk7XFxuXFxuICAgICAgcmV0dXJuIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0KCkobGFiZWxzKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQWRkcyB0aGUgQ1NTIGVycm9yIGNsYXNzIGFzIHNwZWNpZmllZCBieSB0aGUgQWJpZGUgc2V0dGluZ3MgdG8gdGhlIGxhYmVsLCBpbnB1dCwgYW5kIHRoZSBmb3JtXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAkZWwgLSBqUXVlcnkgb2JqZWN0IHRvIGFkZCB0aGUgY2xhc3MgdG9cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogJ2FkZEVycm9yQ2xhc3NlcycsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRFcnJvckNsYXNzZXMoJGVsKSB7XFxuICAgICAgdmFyICRsYWJlbCA9IHRoaXMuZmluZExhYmVsKCRlbCk7XFxuICAgICAgdmFyICRmb3JtRXJyb3IgPSB0aGlzLmZpbmRGb3JtRXJyb3IoJGVsKTtcXG5cXG4gICAgICBpZiAoJGxhYmVsLmxlbmd0aCkge1xcbiAgICAgICAgJGxhYmVsLmFkZENsYXNzKHRoaXMub3B0aW9ucy5sYWJlbEVycm9yQ2xhc3MpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoJGZvcm1FcnJvci5sZW5ndGgpIHtcXG4gICAgICAgICRmb3JtRXJyb3IuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmZvcm1FcnJvckNsYXNzKTtcXG4gICAgICB9XFxuXFxuICAgICAgJGVsLmFkZENsYXNzKHRoaXMub3B0aW9ucy5pbnB1dEVycm9yQ2xhc3MpLmF0dHIoJ2RhdGEtaW52YWxpZCcsICcnKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogUmVtb3ZlIENTUyBlcnJvciBjbGFzc2VzIGV0YyBmcm9tIGFuIGVudGlyZSByYWRpbyBidXR0b24gZ3JvdXBcXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGdyb3VwTmFtZSAtIEEgc3RyaW5nIHRoYXQgc3BlY2lmaWVzIHRoZSBuYW1lIG9mIGEgcmFkaW8gYnV0dG9uIGdyb3VwXFxuICAgICAqXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6ICdyZW1vdmVSYWRpb0Vycm9yQ2xhc3NlcycsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVSYWRpb0Vycm9yQ2xhc3Nlcyhncm91cE5hbWUpIHtcXG4gICAgICB2YXIgJGVscyA9IHRoaXMuJGVsZW1lbnQuZmluZCgnOnJhZGlvW25hbWU9XFxcIicgKyBncm91cE5hbWUgKyAnXFxcIl0nKTtcXG4gICAgICB2YXIgJGxhYmVscyA9IHRoaXMuZmluZFJhZGlvTGFiZWxzKCRlbHMpO1xcbiAgICAgIHZhciAkZm9ybUVycm9ycyA9IHRoaXMuZmluZEZvcm1FcnJvcigkZWxzKTtcXG5cXG4gICAgICBpZiAoJGxhYmVscy5sZW5ndGgpIHtcXG4gICAgICAgICRsYWJlbHMucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmxhYmVsRXJyb3JDbGFzcyk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICgkZm9ybUVycm9ycy5sZW5ndGgpIHtcXG4gICAgICAgICRmb3JtRXJyb3JzLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5mb3JtRXJyb3JDbGFzcyk7XFxuICAgICAgfVxcblxcbiAgICAgICRlbHMucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmlucHV0RXJyb3JDbGFzcykucmVtb3ZlQXR0cignZGF0YS1pbnZhbGlkJyk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIFJlbW92ZXMgQ1NTIGVycm9yIGNsYXNzIGFzIHNwZWNpZmllZCBieSB0aGUgQWJpZGUgc2V0dGluZ3MgZnJvbSB0aGUgbGFiZWwsIGlucHV0LCBhbmQgdGhlIGZvcm1cXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICRlbCAtIGpRdWVyeSBvYmplY3QgdG8gcmVtb3ZlIHRoZSBjbGFzcyBmcm9tXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6ICdyZW1vdmVFcnJvckNsYXNzZXMnLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlRXJyb3JDbGFzc2VzKCRlbCkge1xcbiAgICAgIC8vIHJhZGlvcyBuZWVkIHRvIGNsZWFyIGFsbCBvZiB0aGUgZWxzXFxuICAgICAgaWYgKCRlbFswXS50eXBlID09ICdyYWRpbycpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLnJlbW92ZVJhZGlvRXJyb3JDbGFzc2VzKCRlbC5hdHRyKCduYW1lJykpO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgJGxhYmVsID0gdGhpcy5maW5kTGFiZWwoJGVsKTtcXG4gICAgICB2YXIgJGZvcm1FcnJvciA9IHRoaXMuZmluZEZvcm1FcnJvcigkZWwpO1xcblxcbiAgICAgIGlmICgkbGFiZWwubGVuZ3RoKSB7XFxuICAgICAgICAkbGFiZWwucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmxhYmVsRXJyb3JDbGFzcyk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICgkZm9ybUVycm9yLmxlbmd0aCkge1xcbiAgICAgICAgJGZvcm1FcnJvci5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuZm9ybUVycm9yQ2xhc3MpO1xcbiAgICAgIH1cXG5cXG4gICAgICAkZWwucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmlucHV0RXJyb3JDbGFzcykucmVtb3ZlQXR0cignZGF0YS1pbnZhbGlkJyk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIEdvZXMgdGhyb3VnaCBhIGZvcm0gdG8gZmluZCBpbnB1dHMgYW5kIHByb2NlZWRzIHRvIHZhbGlkYXRlIHRoZW0gaW4gd2F5cyBzcGVjaWZpYyB0byB0aGVpciB0eXBlLlxcbiAgICAgKiBJZ25vcmVzIGlucHV0cyB3aXRoIGRhdGEtYWJpZGUtaWdub3JlLCB0eXBlPVxcXCJoaWRkZW5cXFwiIG9yIGRpc2FibGVkIGF0dHJpYnV0ZXMgc2V0XFxuICAgICAqIEBmaXJlcyBBYmlkZSNpbnZhbGlkXFxuICAgICAqIEBmaXJlcyBBYmlkZSN2YWxpZFxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gdmFsaWRhdGUsIHNob3VsZCBiZSBhbiBIVE1MIGlucHV0XFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBnb29kVG9HbyAtIElmIHRoZSBpbnB1dCBpcyB2YWxpZCBvciBub3QuXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6ICd2YWxpZGF0ZUlucHV0JyxcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbGlkYXRlSW5wdXQoJGVsKSB7XFxuICAgICAgdmFyIGNsZWFyUmVxdWlyZSA9IHRoaXMucmVxdWlyZWRDaGVjaygkZWwpLFxcbiAgICAgICAgICB2YWxpZGF0ZWQgPSBmYWxzZSxcXG4gICAgICAgICAgY3VzdG9tVmFsaWRhdG9yID0gdHJ1ZSxcXG4gICAgICAgICAgdmFsaWRhdG9yID0gJGVsLmF0dHIoJ2RhdGEtdmFsaWRhdG9yJyksXFxuICAgICAgICAgIGVxdWFsVG8gPSB0cnVlO1xcblxcbiAgICAgIC8vIGRvbid0IHZhbGlkYXRlIGlnbm9yZWQgaW5wdXRzIG9yIGhpZGRlbiBpbnB1dHMgb3IgZGlzYWJsZWQgaW5wdXRzXFxuICAgICAgaWYgKCRlbC5pcygnW2RhdGEtYWJpZGUtaWdub3JlXScpIHx8ICRlbC5pcygnW3R5cGU9XFxcImhpZGRlblxcXCJdJykgfHwgJGVsLmlzKCdbZGlzYWJsZWRdJykpIHtcXG4gICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgIH1cXG5cXG4gICAgICBzd2l0Y2ggKCRlbFswXS50eXBlKSB7XFxuICAgICAgICBjYXNlICdyYWRpbyc6XFxuICAgICAgICAgIHZhbGlkYXRlZCA9IHRoaXMudmFsaWRhdGVSYWRpbygkZWwuYXR0cignbmFtZScpKTtcXG4gICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICBjYXNlICdjaGVja2JveCc6XFxuICAgICAgICAgIHZhbGlkYXRlZCA9IGNsZWFyUmVxdWlyZTtcXG4gICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICBjYXNlICdzZWxlY3QnOlxcbiAgICAgICAgY2FzZSAnc2VsZWN0LW9uZSc6XFxuICAgICAgICBjYXNlICdzZWxlY3QtbXVsdGlwbGUnOlxcbiAgICAgICAgICB2YWxpZGF0ZWQgPSBjbGVhclJlcXVpcmU7XFxuICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgZGVmYXVsdDpcXG4gICAgICAgICAgdmFsaWRhdGVkID0gdGhpcy52YWxpZGF0ZVRleHQoJGVsKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHZhbGlkYXRvcikge1xcbiAgICAgICAgY3VzdG9tVmFsaWRhdG9yID0gdGhpcy5tYXRjaFZhbGlkYXRpb24oJGVsLCB2YWxpZGF0b3IsICRlbC5hdHRyKCdyZXF1aXJlZCcpKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCRlbC5hdHRyKCdkYXRhLWVxdWFsdG8nKSkge1xcbiAgICAgICAgZXF1YWxUbyA9IHRoaXMub3B0aW9ucy52YWxpZGF0b3JzLmVxdWFsVG8oJGVsKTtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIGdvb2RUb0dvID0gW2NsZWFyUmVxdWlyZSwgdmFsaWRhdGVkLCBjdXN0b21WYWxpZGF0b3IsIGVxdWFsVG9dLmluZGV4T2YoZmFsc2UpID09PSAtMTtcXG4gICAgICB2YXIgbWVzc2FnZSA9IChnb29kVG9HbyA/ICd2YWxpZCcgOiAnaW52YWxpZCcpICsgJy56Zi5hYmlkZSc7XFxuXFxuICAgICAgaWYgKGdvb2RUb0dvKSB7XFxuICAgICAgICAvLyBSZS12YWxpZGF0ZSBpbnB1dHMgdGhhdCBkZXBlbmQgb24gdGhpcyBvbmUgd2l0aCBlcXVhbHRvXFxuICAgICAgICB2YXIgZGVwZW5kZW50RWxlbWVudHMgPSB0aGlzLiRlbGVtZW50LmZpbmQoJ1tkYXRhLWVxdWFsdG89XFxcIicgKyAkZWwuYXR0cignaWQnKSArICdcXFwiXScpO1xcbiAgICAgICAgaWYgKGRlcGVuZGVudEVsZW1lbnRzLmxlbmd0aCkge1xcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xcbiAgICAgICAgICBkZXBlbmRlbnRFbGVtZW50cy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICBpZiAoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSh0aGlzKS52YWwoKSkge1xcbiAgICAgICAgICAgICAgX3RoaXMudmFsaWRhdGVJbnB1dChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKHRoaXMpKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzW2dvb2RUb0dvID8gJ3JlbW92ZUVycm9yQ2xhc3NlcycgOiAnYWRkRXJyb3JDbGFzc2VzJ10oJGVsKTtcXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBGaXJlcyB3aGVuIHRoZSBpbnB1dCBpcyBkb25lIGNoZWNraW5nIGZvciB2YWxpZGF0aW9uLiBFdmVudCB0cmlnZ2VyIGlzIGVpdGhlciBgdmFsaWQuemYuYWJpZGVgIG9yIGBpbnZhbGlkLnpmLmFiaWRlYFxcbiAgICAgICAqIFRyaWdnZXIgaW5jbHVkZXMgdGhlIERPTSBlbGVtZW50IG9mIHRoZSBpbnB1dC5cXG4gICAgICAgKiBAZXZlbnQgQWJpZGUjdmFsaWRcXG4gICAgICAgKiBAZXZlbnQgQWJpZGUjaW52YWxpZFxcbiAgICAgICAqL1xcbiAgICAgICRlbC50cmlnZ2VyKG1lc3NhZ2UsIFskZWxdKTtcXG5cXG4gICAgICByZXR1cm4gZ29vZFRvR287XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIEdvZXMgdGhyb3VnaCBhIGZvcm0gYW5kIGlmIHRoZXJlIGFyZSBhbnkgaW52YWxpZCBpbnB1dHMsIGl0IHdpbGwgZGlzcGxheSB0aGUgZm9ybSBlcnJvciBlbGVtZW50XFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBub0Vycm9yIC0gdHJ1ZSBpZiBubyBlcnJvcnMgd2VyZSBkZXRlY3RlZC4uLlxcbiAgICAgKiBAZmlyZXMgQWJpZGUjZm9ybXZhbGlkXFxuICAgICAqIEBmaXJlcyBBYmlkZSNmb3JtaW52YWxpZFxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAndmFsaWRhdGVGb3JtJyxcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbGlkYXRlRm9ybSgpIHtcXG4gICAgICB2YXIgYWNjID0gW107XFxuICAgICAgdmFyIF90aGlzID0gdGhpcztcXG5cXG4gICAgICB0aGlzLiRpbnB1dHMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICBhY2MucHVzaChfdGhpcy52YWxpZGF0ZUlucHV0KF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0KCkodGhpcykpKTtcXG4gICAgICB9KTtcXG5cXG4gICAgICB2YXIgbm9FcnJvciA9IGFjYy5pbmRleE9mKGZhbHNlKSA9PT0gLTE7XFxuXFxuICAgICAgdGhpcy4kZWxlbWVudC5maW5kKCdbZGF0YS1hYmlkZS1lcnJvcl0nKS5jc3MoJ2Rpc3BsYXknLCBub0Vycm9yID8gJ25vbmUnIDogJ2Jsb2NrJyk7XFxuXFxuICAgICAgLyoqXFxuICAgICAgICogRmlyZXMgd2hlbiB0aGUgZm9ybSBpcyBmaW5pc2hlZCB2YWxpZGF0aW5nLiBFdmVudCB0cmlnZ2VyIGlzIGVpdGhlciBgZm9ybXZhbGlkLnpmLmFiaWRlYCBvciBgZm9ybWludmFsaWQuemYuYWJpZGVgLlxcbiAgICAgICAqIFRyaWdnZXIgaW5jbHVkZXMgdGhlIGVsZW1lbnQgb2YgdGhlIGZvcm0uXFxuICAgICAgICogQGV2ZW50IEFiaWRlI2Zvcm12YWxpZFxcbiAgICAgICAqIEBldmVudCBBYmlkZSNmb3JtaW52YWxpZFxcbiAgICAgICAqL1xcbiAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcigobm9FcnJvciA/ICdmb3JtdmFsaWQnIDogJ2Zvcm1pbnZhbGlkJykgKyAnLnpmLmFiaWRlJywgW3RoaXMuJGVsZW1lbnRdKTtcXG5cXG4gICAgICByZXR1cm4gbm9FcnJvcjtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIG9yIGEgbm90IGEgdGV4dCBpbnB1dCBpcyB2YWxpZCBiYXNlZCBvbiB0aGUgcGF0dGVybiBzcGVjaWZpZWQgaW4gdGhlIGF0dHJpYnV0ZS4gSWYgbm8gbWF0Y2hpbmcgcGF0dGVybiBpcyBmb3VuZCwgcmV0dXJucyB0cnVlLlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gJGVsIC0galF1ZXJ5IG9iamVjdCB0byB2YWxpZGF0ZSwgc2hvdWxkIGJlIGEgdGV4dCBpbnB1dCBIVE1MIGVsZW1lbnRcXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhdHRlcm4gLSBzdHJpbmcgdmFsdWUgb2Ygb25lIG9mIHRoZSBSZWdFeCBwYXR0ZXJucyBpbiBBYmlkZS5vcHRpb25zLnBhdHRlcm5zXFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBCb29sZWFuIHZhbHVlIGRlcGVuZHMgb24gd2hldGhlciBvciBub3QgdGhlIGlucHV0IHZhbHVlIG1hdGNoZXMgdGhlIHBhdHRlcm4gc3BlY2lmaWVkXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6ICd2YWxpZGF0ZVRleHQnLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsaWRhdGVUZXh0KCRlbCwgcGF0dGVybikge1xcbiAgICAgIC8vIEEgcGF0dGVybiBjYW4gYmUgcGFzc2VkIHRvIHRoaXMgZnVuY3Rpb24sIG9yIGl0IHdpbGwgYmUgaW5mZXJlZCBmcm9tIHRoZSBpbnB1dCdzIFxcXCJwYXR0ZXJuXFxcIiBhdHRyaWJ1dGUsIG9yIGl0J3MgXFxcInR5cGVcXFwiIGF0dHJpYnV0ZVxcbiAgICAgIHBhdHRlcm4gPSBwYXR0ZXJuIHx8ICRlbC5hdHRyKCdwYXR0ZXJuJykgfHwgJGVsLmF0dHIoJ3R5cGUnKTtcXG4gICAgICB2YXIgaW5wdXRUZXh0ID0gJGVsLnZhbCgpO1xcbiAgICAgIHZhciB2YWxpZCA9IGZhbHNlO1xcblxcbiAgICAgIGlmIChpbnB1dFRleHQubGVuZ3RoKSB7XFxuICAgICAgICAvLyBJZiB0aGUgcGF0dGVybiBhdHRyaWJ1dGUgb24gdGhlIGVsZW1lbnQgaXMgaW4gQWJpZGUncyBsaXN0IG9mIHBhdHRlcm5zLCB0aGVuIHRlc3QgdGhhdCByZWdleHBcXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGF0dGVybnMuaGFzT3duUHJvcGVydHkocGF0dGVybikpIHtcXG4gICAgICAgICAgdmFsaWQgPSB0aGlzLm9wdGlvbnMucGF0dGVybnNbcGF0dGVybl0udGVzdChpbnB1dFRleHQpO1xcbiAgICAgICAgfVxcbiAgICAgICAgLy8gSWYgdGhlIHBhdHRlcm4gbmFtZSBpc24ndCBhbHNvIHRoZSB0eXBlIGF0dHJpYnV0ZSBvZiB0aGUgZmllbGQsIHRoZW4gdGVzdCBpdCBhcyBhIHJlZ2V4cFxcbiAgICAgICAgZWxzZSBpZiAocGF0dGVybiAhPT0gJGVsLmF0dHIoJ3R5cGUnKSkge1xcbiAgICAgICAgICAgIHZhbGlkID0gbmV3IFJlZ0V4cChwYXR0ZXJuKS50ZXN0KGlucHV0VGV4dCk7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgdmFsaWQgPSB0cnVlO1xcbiAgICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIC8vIEFuIGVtcHR5IGZpZWxkIGlzIHZhbGlkIGlmIGl0J3Mgbm90IHJlcXVpcmVkXFxuICAgICAgZWxzZSBpZiAoISRlbC5wcm9wKCdyZXF1aXJlZCcpKSB7XFxuICAgICAgICAgIHZhbGlkID0gdHJ1ZTtcXG4gICAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gdmFsaWQ7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIERldGVybWluZXMgd2hldGhlciBvciBhIG5vdCBhIHJhZGlvIGlucHV0IGlzIHZhbGlkIGJhc2VkIG9uIHdoZXRoZXIgb3Igbm90IGl0IGlzIHJlcXVpcmVkIGFuZCBzZWxlY3RlZC4gQWx0aG91Z2ggdGhlIGZ1bmN0aW9uIHRhcmdldHMgYSBzaW5nbGUgYDxpbnB1dD5gLCBpdCB2YWxpZGF0ZXMgYnkgY2hlY2tpbmcgdGhlIGByZXF1aXJlZGAgYW5kIGBjaGVja2VkYCBwcm9wZXJ0aWVzIG9mIGFsbCByYWRpbyBidXR0b25zIGluIGl0cyBncm91cC5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGdyb3VwTmFtZSAtIEEgc3RyaW5nIHRoYXQgc3BlY2lmaWVzIHRoZSBuYW1lIG9mIGEgcmFkaW8gYnV0dG9uIGdyb3VwXFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBCb29sZWFuIHZhbHVlIGRlcGVuZHMgb24gd2hldGhlciBvciBub3QgYXQgbGVhc3Qgb25lIHJhZGlvIGlucHV0IGhhcyBiZWVuIHNlbGVjdGVkIChpZiBpdCdzIHJlcXVpcmVkKVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAndmFsaWRhdGVSYWRpbycsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWxpZGF0ZVJhZGlvKGdyb3VwTmFtZSkge1xcbiAgICAgIC8vIElmIGF0IGxlYXN0IG9uZSByYWRpbyBpbiB0aGUgZ3JvdXAgaGFzIHRoZSBgcmVxdWlyZWRgIGF0dHJpYnV0ZSwgdGhlIGdyb3VwIGlzIGNvbnNpZGVyZWQgcmVxdWlyZWRcXG4gICAgICAvLyBQZXIgVzNDIHNwZWMsIGFsbCByYWRpbyBidXR0b25zIGluIGEgZ3JvdXAgc2hvdWxkIGhhdmUgYHJlcXVpcmVkYCwgYnV0IHdlJ3JlIGJlaW5nIG5pY2VcXG4gICAgICB2YXIgJGdyb3VwID0gdGhpcy4kZWxlbWVudC5maW5kKCc6cmFkaW9bbmFtZT1cXFwiJyArIGdyb3VwTmFtZSArICdcXFwiXScpO1xcbiAgICAgIHZhciB2YWxpZCA9IGZhbHNlLFxcbiAgICAgICAgICByZXF1aXJlZCA9IGZhbHNlO1xcblxcbiAgICAgIC8vIEZvciB0aGUgZ3JvdXAgdG8gYmUgcmVxdWlyZWQsIGF0IGxlYXN0IG9uZSByYWRpbyBuZWVkcyB0byBiZSByZXF1aXJlZFxcbiAgICAgICRncm91cC5lYWNoKGZ1bmN0aW9uIChpLCBlKSB7XFxuICAgICAgICBpZiAoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKShlKS5hdHRyKCdyZXF1aXJlZCcpKSB7XFxuICAgICAgICAgIHJlcXVpcmVkID0gdHJ1ZTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgICBpZiAoIXJlcXVpcmVkKSB2YWxpZCA9IHRydWU7XFxuXFxuICAgICAgaWYgKCF2YWxpZCkge1xcbiAgICAgICAgLy8gRm9yIHRoZSBncm91cCB0byBiZSB2YWxpZCwgYXQgbGVhc3Qgb25lIHJhZGlvIG5lZWRzIHRvIGJlIGNoZWNrZWRcXG4gICAgICAgICRncm91cC5lYWNoKGZ1bmN0aW9uIChpLCBlKSB7XFxuICAgICAgICAgIGlmIChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKGUpLnByb3AoJ2NoZWNrZWQnKSkge1xcbiAgICAgICAgICAgIHZhbGlkID0gdHJ1ZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgICAgfTtcXG5cXG4gICAgICByZXR1cm4gdmFsaWQ7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIERldGVybWluZXMgaWYgYSBzZWxlY3RlZCBpbnB1dCBwYXNzZXMgYSBjdXN0b20gdmFsaWRhdGlvbiBmdW5jdGlvbi4gTXVsdGlwbGUgdmFsaWRhdGlvbnMgY2FuIGJlIHVzZWQsIGlmIHBhc3NlZCB0byB0aGUgZWxlbWVudCB3aXRoIGBkYXRhLXZhbGlkYXRvcj1cXFwiZm9vIGJhciBiYXpcXFwiYCBpbiBhIHNwYWNlIHNlcGFyYXRlZCBsaXN0ZWQuXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAkZWwgLSBqUXVlcnkgaW5wdXQgZWxlbWVudC5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbGlkYXRvcnMgLSBhIHN0cmluZyBvZiBmdW5jdGlvbiBuYW1lcyBtYXRjaGluZyBmdW5jdGlvbnMgaW4gdGhlIEFiaWRlLm9wdGlvbnMudmFsaWRhdG9ycyBvYmplY3QuXFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVxdWlyZWQgLSBzZWxmIGV4cGxhbmF0b3J5P1xcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gLSB0cnVlIGlmIHZhbGlkYXRpb25zIHBhc3NlZC5cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogJ21hdGNoVmFsaWRhdGlvbicsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXRjaFZhbGlkYXRpb24oJGVsLCB2YWxpZGF0b3JzLCByZXF1aXJlZCkge1xcbiAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xcblxcbiAgICAgIHJlcXVpcmVkID0gcmVxdWlyZWQgPyB0cnVlIDogZmFsc2U7XFxuXFxuICAgICAgdmFyIGNsZWFyID0gdmFsaWRhdG9ycy5zcGxpdCgnICcpLm1hcChmdW5jdGlvbiAodikge1xcbiAgICAgICAgcmV0dXJuIF90aGlzNS5vcHRpb25zLnZhbGlkYXRvcnNbdl0oJGVsLCByZXF1aXJlZCwgJGVsLnBhcmVudCgpKTtcXG4gICAgICB9KTtcXG4gICAgICByZXR1cm4gY2xlYXIuaW5kZXhPZihmYWxzZSkgPT09IC0xO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBSZXNldHMgZm9ybSBpbnB1dHMgYW5kIHN0eWxlc1xcbiAgICAgKiBAZmlyZXMgQWJpZGUjZm9ybXJlc2V0XFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6ICdyZXNldEZvcm0nLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXRGb3JtKCkge1xcbiAgICAgIHZhciAkZm9ybSA9IHRoaXMuJGVsZW1lbnQsXFxuICAgICAgICAgIG9wdHMgPSB0aGlzLm9wdGlvbnM7XFxuXFxuICAgICAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSgnLicgKyBvcHRzLmxhYmVsRXJyb3JDbGFzcywgJGZvcm0pLm5vdCgnc21hbGwnKS5yZW1vdmVDbGFzcyhvcHRzLmxhYmVsRXJyb3JDbGFzcyk7XFxuICAgICAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSgnLicgKyBvcHRzLmlucHV0RXJyb3JDbGFzcywgJGZvcm0pLm5vdCgnc21hbGwnKS5yZW1vdmVDbGFzcyhvcHRzLmlucHV0RXJyb3JDbGFzcyk7XFxuICAgICAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKShvcHRzLmZvcm1FcnJvclNlbGVjdG9yICsgJy4nICsgb3B0cy5mb3JtRXJyb3JDbGFzcykucmVtb3ZlQ2xhc3Mob3B0cy5mb3JtRXJyb3JDbGFzcyk7XFxuICAgICAgJGZvcm0uZmluZCgnW2RhdGEtYWJpZGUtZXJyb3JdJykuY3NzKCdkaXNwbGF5JywgJ25vbmUnKTtcXG4gICAgICBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKCc6aW5wdXQnLCAkZm9ybSkubm90KCc6YnV0dG9uLCA6c3VibWl0LCA6cmVzZXQsIDpoaWRkZW4sIDpyYWRpbywgOmNoZWNrYm94LCBbZGF0YS1hYmlkZS1pZ25vcmVdJykudmFsKCcnKS5yZW1vdmVBdHRyKCdkYXRhLWludmFsaWQnKTtcXG4gICAgICBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKCc6aW5wdXQ6cmFkaW8nLCAkZm9ybSkubm90KCdbZGF0YS1hYmlkZS1pZ25vcmVdJykucHJvcCgnY2hlY2tlZCcsIGZhbHNlKS5yZW1vdmVBdHRyKCdkYXRhLWludmFsaWQnKTtcXG4gICAgICBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKCc6aW5wdXQ6Y2hlY2tib3gnLCAkZm9ybSkubm90KCdbZGF0YS1hYmlkZS1pZ25vcmVdJykucHJvcCgnY2hlY2tlZCcsIGZhbHNlKS5yZW1vdmVBdHRyKCdkYXRhLWludmFsaWQnKTtcXG4gICAgICAvKipcXG4gICAgICAgKiBGaXJlcyB3aGVuIHRoZSBmb3JtIGhhcyBiZWVuIHJlc2V0LlxcbiAgICAgICAqIEBldmVudCBBYmlkZSNmb3JtcmVzZXRcXG4gICAgICAgKi9cXG4gICAgICAkZm9ybS50cmlnZ2VyKCdmb3JtcmVzZXQuemYuYWJpZGUnLCBbJGZvcm1dKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogRGVzdHJveXMgYW4gaW5zdGFuY2Ugb2YgQWJpZGUuXFxuICAgICAqIFJlbW92ZXMgZXJyb3Igc3R5bGVzIGFuZCBjbGFzc2VzIGZyb20gZWxlbWVudHMsIHdpdGhvdXQgcmVzZXR0aW5nIHRoZWlyIHZhbHVlcy5cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogJ19kZXN0cm95JyxcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZXN0cm95KCkge1xcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuICAgICAgdGhpcy4kZWxlbWVudC5vZmYoJy5hYmlkZScpLmZpbmQoJ1tkYXRhLWFiaWRlLWVycm9yXScpLmNzcygnZGlzcGxheScsICdub25lJyk7XFxuXFxuICAgICAgdGhpcy4kaW5wdXRzLm9mZignLmFiaWRlJykuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICBfdGhpcy5yZW1vdmVFcnJvckNsYXNzZXMoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSh0aGlzKSk7XFxuICAgICAgfSk7XFxuICAgIH1cXG4gIH1dKTtcXG5cXG4gIHJldHVybiBBYmlkZTtcXG59KF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fZm91bmRhdGlvbl9wbHVnaW5fX1tcXFwiYVxcXCIgLyogUGx1Z2luICovXSk7XFxuXFxuLyoqXFxuICogRGVmYXVsdCBzZXR0aW5ncyBmb3IgcGx1Z2luXFxuICovXFxuXFxuXFxuQWJpZGUuZGVmYXVsdHMgPSB7XFxuICAvKipcXG4gICAqIFRoZSBkZWZhdWx0IGV2ZW50IHRvIHZhbGlkYXRlIGlucHV0cy4gQ2hlY2tib3hlcyBhbmQgcmFkaW9zIHZhbGlkYXRlIGltbWVkaWF0ZWx5LlxcbiAgICogUmVtb3ZlIG9yIGNoYW5nZSB0aGlzIHZhbHVlIGZvciBtYW51YWwgdmFsaWRhdGlvbi5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHs/c3RyaW5nfVxcbiAgICogQGRlZmF1bHQgJ2ZpZWxkQ2hhbmdlJ1xcbiAgICovXFxuICB2YWxpZGF0ZU9uOiAnZmllbGRDaGFuZ2UnLFxcblxcbiAgLyoqXFxuICAgKiBDbGFzcyB0byBiZSBhcHBsaWVkIHRvIGlucHV0IGxhYmVscyBvbiBmYWlsZWQgdmFsaWRhdGlvbi5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtzdHJpbmd9XFxuICAgKiBAZGVmYXVsdCAnaXMtaW52YWxpZC1sYWJlbCdcXG4gICAqL1xcbiAgbGFiZWxFcnJvckNsYXNzOiAnaXMtaW52YWxpZC1sYWJlbCcsXFxuXFxuICAvKipcXG4gICAqIENsYXNzIHRvIGJlIGFwcGxpZWQgdG8gaW5wdXRzIG9uIGZhaWxlZCB2YWxpZGF0aW9uLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge3N0cmluZ31cXG4gICAqIEBkZWZhdWx0ICdpcy1pbnZhbGlkLWlucHV0J1xcbiAgICovXFxuICBpbnB1dEVycm9yQ2xhc3M6ICdpcy1pbnZhbGlkLWlucHV0JyxcXG5cXG4gIC8qKlxcbiAgICogQ2xhc3Mgc2VsZWN0b3IgdG8gdXNlIHRvIHRhcmdldCBGb3JtIEVycm9ycyBmb3Igc2hvdy9oaWRlLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge3N0cmluZ31cXG4gICAqIEBkZWZhdWx0ICcuZm9ybS1lcnJvcidcXG4gICAqL1xcbiAgZm9ybUVycm9yU2VsZWN0b3I6ICcuZm9ybS1lcnJvcicsXFxuXFxuICAvKipcXG4gICAqIENsYXNzIGFkZGVkIHRvIEZvcm0gRXJyb3JzIG9uIGZhaWxlZCB2YWxpZGF0aW9uLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge3N0cmluZ31cXG4gICAqIEBkZWZhdWx0ICdpcy12aXNpYmxlJ1xcbiAgICovXFxuICBmb3JtRXJyb3JDbGFzczogJ2lzLXZpc2libGUnLFxcblxcbiAgLyoqXFxuICAgKiBTZXQgdG8gdHJ1ZSB0byB2YWxpZGF0ZSB0ZXh0IGlucHV0cyBvbiBhbnkgdmFsdWUgY2hhbmdlLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge2Jvb2xlYW59XFxuICAgKiBAZGVmYXVsdCBmYWxzZVxcbiAgICovXFxuICBsaXZlVmFsaWRhdGU6IGZhbHNlLFxcblxcbiAgLyoqXFxuICAgKiBTZXQgdG8gdHJ1ZSB0byB2YWxpZGF0ZSBpbnB1dHMgb24gYmx1ci5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtib29sZWFufVxcbiAgICogQGRlZmF1bHQgZmFsc2VcXG4gICAqL1xcbiAgdmFsaWRhdGVPbkJsdXI6IGZhbHNlLFxcblxcbiAgcGF0dGVybnM6IHtcXG4gICAgYWxwaGE6IC9eW2EtekEtWl0rJC8sXFxuICAgIGFscGhhX251bWVyaWM6IC9eW2EtekEtWjAtOV0rJC8sXFxuICAgIGludGVnZXI6IC9eWy0rXT9cXFxcZCskLyxcXG4gICAgbnVtYmVyOiAvXlstK10/XFxcXGQqKD86W1xcXFwuXFxcXCxdXFxcXGQrKT8kLyxcXG5cXG4gICAgLy8gYW1leCwgdmlzYSwgZGluZXJzXFxuICAgIGNhcmQ6IC9eKD86NFswLTldezEyfSg/OlswLTldezN9KT98NVsxLTVdWzAtOV17MTR9fCg/OjIyMlsxLTldfDJbMy02XVswLTldezJ9fDI3WzAtMV1bMC05XXwyNzIwKVswLTldezEyfXw2KD86MDExfDVbMC05XVswLTldKVswLTldezEyfXwzWzQ3XVswLTldezEzfXwzKD86MFswLTVdfFs2OF1bMC05XSlbMC05XXsxMX18KD86MjEzMXwxODAwfDM1XFxcXGR7M30pXFxcXGR7MTF9KSQvLFxcbiAgICBjdnY6IC9eKFswLTldKXszLDR9JC8sXFxuXFxuICAgIC8vIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3N0YXRlcy1vZi10aGUtdHlwZS1hdHRyaWJ1dGUuaHRtbCN2YWxpZC1lLW1haWwtYWRkcmVzc1xcbiAgICBlbWFpbDogL15bYS16QS1aMC05LiEjJCUmJyorXFxcXC89P15fYHt8fX4tXStAW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KD86XFxcXC5bYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8pKyQvLFxcblxcbiAgICB1cmw6IC9eKGh0dHBzP3xmdHB8ZmlsZXxzc2gpOlxcXFwvXFxcXC8oKCgoW2EtekEtWl18XFxcXGR8LXxcXFxcLnxffH58W1xcXFx1MDBBMC1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZFRl0pfCglW1xcXFxkYS1mXXsyfSl8WyFcXFxcJCYnXFxcXChcXFxcKVxcXFwqXFxcXCssOz1dfDopKkApPygoKFxcXFxkfFsxLTldXFxcXGR8MVxcXFxkXFxcXGR8MlswLTRdXFxcXGR8MjVbMC01XSlcXFxcLihcXFxcZHxbMS05XVxcXFxkfDFcXFxcZFxcXFxkfDJbMC00XVxcXFxkfDI1WzAtNV0pXFxcXC4oXFxcXGR8WzEtOV1cXFxcZHwxXFxcXGRcXFxcZHwyWzAtNF1cXFxcZHwyNVswLTVdKVxcXFwuKFxcXFxkfFsxLTldXFxcXGR8MVxcXFxkXFxcXGR8MlswLTRdXFxcXGR8MjVbMC01XSkpfCgoKFthLXpBLVpdfFxcXFxkfFtcXFxcdTAwQTAtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRUZdKXwoKFthLXpBLVpdfFxcXFxkfFtcXFxcdTAwQTAtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRUZdKShbYS16QS1aXXxcXFxcZHwtfFxcXFwufF98fnxbXFxcXHUwMEEwLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkVGXSkqKFthLXpBLVpdfFxcXFxkfFtcXFxcdTAwQTAtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRUZdKSkpXFxcXC4pKygoW2EtekEtWl18W1xcXFx1MDBBMC1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZFRl0pfCgoW2EtekEtWl18W1xcXFx1MDBBMC1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZFRl0pKFthLXpBLVpdfFxcXFxkfC18XFxcXC58X3x+fFtcXFxcdTAwQTAtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRUZdKSooW2EtekEtWl18W1xcXFx1MDBBMC1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZFRl0pKSlcXFxcLj8pKDpcXFxcZCopPykoXFxcXC8oKChbYS16QS1aXXxcXFxcZHwtfFxcXFwufF98fnxbXFxcXHUwMEEwLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkVGXSl8KCVbXFxcXGRhLWZdezJ9KXxbIVxcXFwkJidcXFxcKFxcXFwpXFxcXCpcXFxcKyw7PV18OnxAKSsoXFxcXC8oKFthLXpBLVpdfFxcXFxkfC18XFxcXC58X3x+fFtcXFxcdTAwQTAtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRUZdKXwoJVtcXFxcZGEtZl17Mn0pfFshXFxcXCQmJ1xcXFwoXFxcXClcXFxcKlxcXFwrLDs9XXw6fEApKikqKT8pPyhcXFxcPygoKFthLXpBLVpdfFxcXFxkfC18XFxcXC58X3x+fFtcXFxcdTAwQTAtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRUZdKXwoJVtcXFxcZGEtZl17Mn0pfFshXFxcXCQmJ1xcXFwoXFxcXClcXFxcKlxcXFwrLDs9XXw6fEApfFtcXFxcdUUwMDAtXFxcXHVGOEZGXXxcXFxcL3xcXFxcPykqKT8oXFxcXCMoKChbYS16QS1aXXxcXFxcZHwtfFxcXFwufF98fnxbXFxcXHUwMEEwLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkVGXSl8KCVbXFxcXGRhLWZdezJ9KXxbIVxcXFwkJidcXFxcKFxcXFwpXFxcXCpcXFxcKyw7PV18OnxAKXxcXFxcL3xcXFxcPykqKT8kLyxcXG4gICAgLy8gYWJjLmRlXFxuICAgIGRvbWFpbjogL14oW2EtekEtWjAtOV0oW2EtekEtWjAtOVxcXFwtXXswLDYxfVthLXpBLVowLTldKT9cXFxcLikrW2EtekEtWl17Miw4fSQvLFxcblxcbiAgICBkYXRldGltZTogL14oWzAtMl1bMC05XXszfSlcXFxcLShbMC0xXVswLTldKVxcXFwtKFswLTNdWzAtOV0pVChbMC01XVswLTldKVxcXFw6KFswLTVdWzAtOV0pXFxcXDooWzAtNV1bMC05XSkoWnwoW1xcXFwtXFxcXCtdKFswLTFdWzAtOV0pXFxcXDowMCkpJC8sXFxuICAgIC8vIFlZWVktTU0tRERcXG4gICAgZGF0ZTogLyg/OjE5fDIwKVswLTldezJ9LSg/Oig/OjBbMS05XXwxWzAtMl0pLSg/OjBbMS05XXwxWzAtOV18MlswLTldKXwoPzooPyEwMikoPzowWzEtOV18MVswLTJdKS0oPzozMCkpfCg/Oig/OjBbMTM1NzhdfDFbMDJdKS0zMSkpJC8sXFxuICAgIC8vIEhIOk1NOlNTXFxuICAgIHRpbWU6IC9eKDBbMC05XXwxWzAtOV18MlswLTNdKSg6WzAtNV1bMC05XSl7Mn0kLyxcXG4gICAgZGF0ZUlTTzogL15cXFxcZHs0fVtcXFxcL1xcXFwtXVxcXFxkezEsMn1bXFxcXC9cXFxcLV1cXFxcZHsxLDJ9JC8sXFxuICAgIC8vIE1NL0REL1lZWVlcXG4gICAgbW9udGhfZGF5X3llYXI6IC9eKDBbMS05XXwxWzAxMl0pWy0gXFxcXC8uXSgwWzEtOV18WzEyXVswLTldfDNbMDFdKVstIFxcXFwvLl1cXFxcZHs0fSQvLFxcbiAgICAvLyBERC9NTS9ZWVlZXFxuICAgIGRheV9tb250aF95ZWFyOiAvXigwWzEtOV18WzEyXVswLTldfDNbMDFdKVstIFxcXFwvLl0oMFsxLTldfDFbMDEyXSlbLSBcXFxcLy5dXFxcXGR7NH0kLyxcXG5cXG4gICAgLy8gI0ZGRiBvciAjRkZGRkZGXFxuICAgIGNvbG9yOiAvXiM/KFthLWZBLUYwLTldezZ9fFthLWZBLUYwLTldezN9KSQvLFxcblxcbiAgICAvLyBEb21haW4gfHwgVVJMXFxuICAgIHdlYnNpdGU6IHtcXG4gICAgICB0ZXN0OiBmdW5jdGlvbiAodGV4dCkge1xcbiAgICAgICAgcmV0dXJuIEFiaWRlLmRlZmF1bHRzLnBhdHRlcm5zWydkb21haW4nXS50ZXN0KHRleHQpIHx8IEFiaWRlLmRlZmF1bHRzLnBhdHRlcm5zWyd1cmwnXS50ZXN0KHRleHQpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfSxcXG5cXG4gIC8qKlxcbiAgICogT3B0aW9uYWwgdmFsaWRhdGlvbiBmdW5jdGlvbnMgdG8gYmUgdXNlZC4gYGVxdWFsVG9gIGJlaW5nIHRoZSBvbmx5IGRlZmF1bHQgaW5jbHVkZWQgZnVuY3Rpb24uXFxuICAgKiBGdW5jdGlvbnMgc2hvdWxkIHJldHVybiBvbmx5IGEgYm9vbGVhbiBpZiB0aGUgaW5wdXQgaXMgdmFsaWQgb3Igbm90LiBGdW5jdGlvbnMgYXJlIGdpdmVuIHRoZSBmb2xsb3dpbmcgYXJndW1lbnRzOlxcbiAgICogZWwgOiBUaGUgalF1ZXJ5IGVsZW1lbnQgdG8gdmFsaWRhdGUuXFxuICAgKiByZXF1aXJlZCA6IEJvb2xlYW4gdmFsdWUgb2YgdGhlIHJlcXVpcmVkIGF0dHJpYnV0ZSBiZSBwcmVzZW50IG9yIG5vdC5cXG4gICAqIHBhcmVudCA6IFRoZSBkaXJlY3QgcGFyZW50IG9mIHRoZSBpbnB1dC5cXG4gICAqIEBvcHRpb25cXG4gICAqL1xcbiAgdmFsaWRhdG9yczoge1xcbiAgICBlcXVhbFRvOiBmdW5jdGlvbiAoZWwsIHJlcXVpcmVkLCBwYXJlbnQpIHtcXG4gICAgICByZXR1cm4gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSgnIycgKyBlbC5hdHRyKCdkYXRhLWVxdWFsdG8nKSkudmFsKCkgPT09IGVsLnZhbCgpO1xcbiAgICB9XFxuICB9XFxufTtcXG5cXG5cXG5cXG4vKioqLyB9KSxcXG4vKiAyMSAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXFwidXNlIHN0cmljdFxcXCI7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiYVxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gRm91bmRhdGlvbjsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0ID0gX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfXyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fZm91bmRhdGlvbl91dGlsX2NvcmVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fZm91bmRhdGlvbl91dGlsX21lZGlhUXVlcnlfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XFxuXFxuXFxuXFxuXFxuXFxuXFxudmFyIEZPVU5EQVRJT05fVkVSU0lPTiA9ICc2LjQuMSc7XFxuXFxuLy8gR2xvYmFsIEZvdW5kYXRpb24gb2JqZWN0XFxuLy8gVGhpcyBpcyBhdHRhY2hlZCB0byB0aGUgd2luZG93LCBvciB1c2VkIGFzIGEgbW9kdWxlIGZvciBBTUQvQnJvd3NlcmlmeVxcbnZhciBGb3VuZGF0aW9uID0ge1xcbiAgdmVyc2lvbjogRk9VTkRBVElPTl9WRVJTSU9OLFxcblxcbiAgLyoqXFxuICAgKiBTdG9yZXMgaW5pdGlhbGl6ZWQgcGx1Z2lucy5cXG4gICAqL1xcbiAgX3BsdWdpbnM6IHt9LFxcblxcbiAgLyoqXFxuICAgKiBTdG9yZXMgZ2VuZXJhdGVkIHVuaXF1ZSBpZHMgZm9yIHBsdWdpbiBpbnN0YW5jZXNcXG4gICAqL1xcbiAgX3V1aWRzOiBbXSxcXG5cXG4gIC8qKlxcbiAgICogRGVmaW5lcyBhIEZvdW5kYXRpb24gcGx1Z2luLCBhZGRpbmcgaXQgdG8gdGhlIGBGb3VuZGF0aW9uYCBuYW1lc3BhY2UgYW5kIHRoZSBsaXN0IG9mIHBsdWdpbnMgdG8gaW5pdGlhbGl6ZSB3aGVuIHJlZmxvd2luZy5cXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwbHVnaW4gLSBUaGUgY29uc3RydWN0b3Igb2YgdGhlIHBsdWdpbi5cXG4gICAqL1xcbiAgcGx1Z2luOiBmdW5jdGlvbiAocGx1Z2luLCBuYW1lKSB7XFxuICAgIC8vIE9iamVjdCBrZXkgdG8gdXNlIHdoZW4gYWRkaW5nIHRvIGdsb2JhbCBGb3VuZGF0aW9uIG9iamVjdFxcbiAgICAvLyBFeGFtcGxlczogRm91bmRhdGlvbi5SZXZlYWwsIEZvdW5kYXRpb24uT2ZmQ2FudmFzXFxuICAgIHZhciBjbGFzc05hbWUgPSBuYW1lIHx8IGZ1bmN0aW9uTmFtZShwbHVnaW4pO1xcbiAgICAvLyBPYmplY3Qga2V5IHRvIHVzZSB3aGVuIHN0b3JpbmcgdGhlIHBsdWdpbiwgYWxzbyB1c2VkIHRvIGNyZWF0ZSB0aGUgaWRlbnRpZnlpbmcgZGF0YSBhdHRyaWJ1dGUgZm9yIHRoZSBwbHVnaW5cXG4gICAgLy8gRXhhbXBsZXM6IGRhdGEtcmV2ZWFsLCBkYXRhLW9mZi1jYW52YXNcXG4gICAgdmFyIGF0dHJOYW1lID0gaHlwaGVuYXRlKGNsYXNzTmFtZSk7XFxuXFxuICAgIC8vIEFkZCB0byB0aGUgRm91bmRhdGlvbiBvYmplY3QgYW5kIHRoZSBwbHVnaW5zIGxpc3QgKGZvciByZWZsb3dpbmcpXFxuICAgIHRoaXMuX3BsdWdpbnNbYXR0ck5hbWVdID0gdGhpc1tjbGFzc05hbWVdID0gcGx1Z2luO1xcbiAgfSxcXG4gIC8qKlxcbiAgICogQGZ1bmN0aW9uXFxuICAgKiBQb3B1bGF0ZXMgdGhlIF91dWlkcyBhcnJheSB3aXRoIHBvaW50ZXJzIHRvIGVhY2ggaW5kaXZpZHVhbCBwbHVnaW4gaW5zdGFuY2UuXFxuICAgKiBBZGRzIHRoZSBgemZQbHVnaW5gIGRhdGEtYXR0cmlidXRlIHRvIHByb2dyYW1tYXRpY2FsbHkgY3JlYXRlZCBwbHVnaW5zIHRvIGFsbG93IHVzZSBvZiAkKHNlbGVjdG9yKS5mb3VuZGF0aW9uKG1ldGhvZCkgY2FsbHMuXFxuICAgKiBBbHNvIGZpcmVzIHRoZSBpbml0aWFsaXphdGlvbiBldmVudCBmb3IgZWFjaCBwbHVnaW4sIGNvbnNvbGlkYXRpbmcgcmVwZXRpdGl2ZSBjb2RlLlxcbiAgICogQHBhcmFtIHtPYmplY3R9IHBsdWdpbiAtIGFuIGluc3RhbmNlIG9mIGEgcGx1Z2luLCB1c3VhbGx5IGB0aGlzYCBpbiBjb250ZXh0LlxcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgcGx1Z2luLCBwYXNzZWQgYXMgYSBjYW1lbENhc2VkIHN0cmluZy5cXG4gICAqIEBmaXJlcyBQbHVnaW4jaW5pdFxcbiAgICovXFxuICByZWdpc3RlclBsdWdpbjogZnVuY3Rpb24gKHBsdWdpbiwgbmFtZSkge1xcbiAgICB2YXIgcGx1Z2luTmFtZSA9IG5hbWUgPyBoeXBoZW5hdGUobmFtZSkgOiBmdW5jdGlvbk5hbWUocGx1Z2luLmNvbnN0cnVjdG9yKS50b0xvd2VyQ2FzZSgpO1xcbiAgICBwbHVnaW4udXVpZCA9IF9fd2VicGFja19yZXF1aXJlX18uaShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX2ZvdW5kYXRpb25fdXRpbF9jb3JlX19bXFxcImJcXFwiIC8qIEdldFlvRGlnaXRzICovXSkoNiwgcGx1Z2luTmFtZSk7XFxuXFxuICAgIGlmICghcGx1Z2luLiRlbGVtZW50LmF0dHIoJ2RhdGEtJyArIHBsdWdpbk5hbWUpKSB7XFxuICAgICAgcGx1Z2luLiRlbGVtZW50LmF0dHIoJ2RhdGEtJyArIHBsdWdpbk5hbWUsIHBsdWdpbi51dWlkKTtcXG4gICAgfVxcbiAgICBpZiAoIXBsdWdpbi4kZWxlbWVudC5kYXRhKCd6ZlBsdWdpbicpKSB7XFxuICAgICAgcGx1Z2luLiRlbGVtZW50LmRhdGEoJ3pmUGx1Z2luJywgcGx1Z2luKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogRmlyZXMgd2hlbiB0aGUgcGx1Z2luIGhhcyBpbml0aWFsaXplZC5cXG4gICAgICogQGV2ZW50IFBsdWdpbiNpbml0XFxuICAgICAqL1xcbiAgICBwbHVnaW4uJGVsZW1lbnQudHJpZ2dlcignaW5pdC56Zi4nICsgcGx1Z2luTmFtZSk7XFxuXFxuICAgIHRoaXMuX3V1aWRzLnB1c2gocGx1Z2luLnV1aWQpO1xcblxcbiAgICByZXR1cm47XFxuICB9LFxcbiAgLyoqXFxuICAgKiBAZnVuY3Rpb25cXG4gICAqIFJlbW92ZXMgdGhlIHBsdWdpbnMgdXVpZCBmcm9tIHRoZSBfdXVpZHMgYXJyYXkuXFxuICAgKiBSZW1vdmVzIHRoZSB6ZlBsdWdpbiBkYXRhIGF0dHJpYnV0ZSwgYXMgd2VsbCBhcyB0aGUgZGF0YS1wbHVnaW4tbmFtZSBhdHRyaWJ1dGUuXFxuICAgKiBBbHNvIGZpcmVzIHRoZSBkZXN0cm95ZWQgZXZlbnQgZm9yIHRoZSBwbHVnaW4sIGNvbnNvbGlkYXRpbmcgcmVwZXRpdGl2ZSBjb2RlLlxcbiAgICogQHBhcmFtIHtPYmplY3R9IHBsdWdpbiAtIGFuIGluc3RhbmNlIG9mIGEgcGx1Z2luLCB1c3VhbGx5IGB0aGlzYCBpbiBjb250ZXh0LlxcbiAgICogQGZpcmVzIFBsdWdpbiNkZXN0cm95ZWRcXG4gICAqL1xcbiAgdW5yZWdpc3RlclBsdWdpbjogZnVuY3Rpb24gKHBsdWdpbikge1xcbiAgICB2YXIgcGx1Z2luTmFtZSA9IGh5cGhlbmF0ZShmdW5jdGlvbk5hbWUocGx1Z2luLiRlbGVtZW50LmRhdGEoJ3pmUGx1Z2luJykuY29uc3RydWN0b3IpKTtcXG5cXG4gICAgdGhpcy5fdXVpZHMuc3BsaWNlKHRoaXMuX3V1aWRzLmluZGV4T2YocGx1Z2luLnV1aWQpLCAxKTtcXG4gICAgcGx1Z2luLiRlbGVtZW50LnJlbW92ZUF0dHIoJ2RhdGEtJyArIHBsdWdpbk5hbWUpLnJlbW92ZURhdGEoJ3pmUGx1Z2luJylcXG4gICAgLyoqXFxuICAgICAqIEZpcmVzIHdoZW4gdGhlIHBsdWdpbiBoYXMgYmVlbiBkZXN0cm95ZWQuXFxuICAgICAqIEBldmVudCBQbHVnaW4jZGVzdHJveWVkXFxuICAgICAqL1xcbiAgICAudHJpZ2dlcignZGVzdHJveWVkLnpmLicgKyBwbHVnaW5OYW1lKTtcXG4gICAgZm9yICh2YXIgcHJvcCBpbiBwbHVnaW4pIHtcXG4gICAgICBwbHVnaW5bcHJvcF0gPSBudWxsOyAvL2NsZWFuIHVwIHNjcmlwdCB0byBwcmVwIGZvciBnYXJiYWdlIGNvbGxlY3Rpb24uXFxuICAgIH1cXG4gICAgcmV0dXJuO1xcbiAgfSxcXG5cXG4gIC8qKlxcbiAgICogQGZ1bmN0aW9uXFxuICAgKiBDYXVzZXMgb25lIG9yIG1vcmUgYWN0aXZlIHBsdWdpbnMgdG8gcmUtaW5pdGlhbGl6ZSwgcmVzZXR0aW5nIGV2ZW50IGxpc3RlbmVycywgcmVjYWxjdWxhdGluZyBwb3NpdGlvbnMsIGV0Yy5cXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwbHVnaW5zIC0gb3B0aW9uYWwgc3RyaW5nIG9mIGFuIGluZGl2aWR1YWwgcGx1Z2luIGtleSwgYXR0YWluZWQgYnkgY2FsbGluZyBgJChlbGVtZW50KS5kYXRhKCdwbHVnaW5OYW1lJylgLCBvciBzdHJpbmcgb2YgYSBwbHVnaW4gY2xhc3MgaS5lLiBgJ2Ryb3Bkb3duJ2BcXG4gICAqIEBkZWZhdWx0IElmIG5vIGFyZ3VtZW50IGlzIHBhc3NlZCwgcmVmbG93IGFsbCBjdXJyZW50bHkgYWN0aXZlIHBsdWdpbnMuXFxuICAgKi9cXG4gIHJlSW5pdDogZnVuY3Rpb24gKHBsdWdpbnMpIHtcXG4gICAgdmFyIGlzSlEgPSBwbHVnaW5zIGluc3RhbmNlb2YgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQuYTtcXG4gICAgdHJ5IHtcXG4gICAgICBpZiAoaXNKUSkge1xcbiAgICAgICAgcGx1Z2lucy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSh0aGlzKS5kYXRhKCd6ZlBsdWdpbicpLl9pbml0KCk7XFxuICAgICAgICB9KTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgcGx1Z2lucyxcXG4gICAgICAgICAgICBfdGhpcyA9IHRoaXMsXFxuICAgICAgICAgICAgZm5zID0ge1xcbiAgICAgICAgICAnb2JqZWN0JzogZnVuY3Rpb24gKHBsZ3MpIHtcXG4gICAgICAgICAgICBwbGdzLmZvckVhY2goZnVuY3Rpb24gKHApIHtcXG4gICAgICAgICAgICAgIHAgPSBoeXBoZW5hdGUocCk7XFxuICAgICAgICAgICAgICBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKCdbZGF0YS0nICsgcCArICddJykuZm91bmRhdGlvbignX2luaXQnKTtcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgfSxcXG4gICAgICAgICAgJ3N0cmluZyc6IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICBwbHVnaW5zID0gaHlwaGVuYXRlKHBsdWdpbnMpO1xcbiAgICAgICAgICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0KCkoJ1tkYXRhLScgKyBwbHVnaW5zICsgJ10nKS5mb3VuZGF0aW9uKCdfaW5pdCcpO1xcbiAgICAgICAgICB9LFxcbiAgICAgICAgICAndW5kZWZpbmVkJzogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIHRoaXNbJ29iamVjdCddKE9iamVjdC5rZXlzKF90aGlzLl9wbHVnaW5zKSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH07XFxuICAgICAgICBmbnNbdHlwZV0ocGx1Z2lucyk7XFxuICAgICAgfVxcbiAgICB9IGNhdGNoIChlcnIpIHtcXG4gICAgICBjb25zb2xlLmVycm9yKGVycik7XFxuICAgIH0gZmluYWxseSB7XFxuICAgICAgcmV0dXJuIHBsdWdpbnM7XFxuICAgIH1cXG4gIH0sXFxuXFxuICAvKipcXG4gICAqIEluaXRpYWxpemUgcGx1Z2lucyBvbiBhbnkgZWxlbWVudHMgd2l0aGluIGBlbGVtYCAoYW5kIGBlbGVtYCBpdHNlbGYpIHRoYXQgYXJlbid0IGFscmVhZHkgaW5pdGlhbGl6ZWQuXFxuICAgKiBAcGFyYW0ge09iamVjdH0gZWxlbSAtIGpRdWVyeSBvYmplY3QgY29udGFpbmluZyB0aGUgZWxlbWVudCB0byBjaGVjayBpbnNpZGUuIEFsc28gY2hlY2tzIHRoZSBlbGVtZW50IGl0c2VsZiwgdW5sZXNzIGl0J3MgdGhlIGBkb2N1bWVudGAgb2JqZWN0LlxcbiAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IHBsdWdpbnMgLSBBIGxpc3Qgb2YgcGx1Z2lucyB0byBpbml0aWFsaXplLiBMZWF2ZSB0aGlzIG91dCB0byBpbml0aWFsaXplIGV2ZXJ5dGhpbmcuXFxuICAgKi9cXG4gIHJlZmxvdzogZnVuY3Rpb24gKGVsZW0sIHBsdWdpbnMpIHtcXG5cXG4gICAgLy8gSWYgcGx1Z2lucyBpcyB1bmRlZmluZWQsIGp1c3QgZ3JhYiBldmVyeXRoaW5nXFxuICAgIGlmICh0eXBlb2YgcGx1Z2lucyA9PT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICBwbHVnaW5zID0gT2JqZWN0LmtleXModGhpcy5fcGx1Z2lucyk7XFxuICAgIH1cXG4gICAgLy8gSWYgcGx1Z2lucyBpcyBhIHN0cmluZywgY29udmVydCBpdCB0byBhbiBhcnJheSB3aXRoIG9uZSBpdGVtXFxuICAgIGVsc2UgaWYgKHR5cGVvZiBwbHVnaW5zID09PSAnc3RyaW5nJykge1xcbiAgICAgICAgcGx1Z2lucyA9IFtwbHVnaW5zXTtcXG4gICAgICB9XFxuXFxuICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuXFxuICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCBlYWNoIHBsdWdpblxcbiAgICBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdC5hLmVhY2gocGx1Z2lucywgZnVuY3Rpb24gKGksIG5hbWUpIHtcXG4gICAgICAvLyBHZXQgdGhlIGN1cnJlbnQgcGx1Z2luXFxuICAgICAgdmFyIHBsdWdpbiA9IF90aGlzLl9wbHVnaW5zW25hbWVdO1xcblxcbiAgICAgIC8vIExvY2FsaXplIHRoZSBzZWFyY2ggdG8gYWxsIGVsZW1lbnRzIGluc2lkZSBlbGVtLCBhcyB3ZWxsIGFzIGVsZW0gaXRzZWxmLCB1bmxlc3MgZWxlbSA9PT0gZG9jdW1lbnRcXG4gICAgICB2YXIgJGVsZW0gPSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKGVsZW0pLmZpbmQoJ1tkYXRhLScgKyBuYW1lICsgJ10nKS5hZGRCYWNrKCdbZGF0YS0nICsgbmFtZSArICddJyk7XFxuXFxuICAgICAgLy8gRm9yIGVhY2ggcGx1Z2luIGZvdW5kLCBpbml0aWFsaXplIGl0XFxuICAgICAgJGVsZW0uZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgJGVsID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSh0aGlzKSxcXG4gICAgICAgICAgICBvcHRzID0ge307XFxuICAgICAgICAvLyBEb24ndCBkb3VibGUtZGlwIG9uIHBsdWdpbnNcXG4gICAgICAgIGlmICgkZWwuZGF0YSgnemZQbHVnaW4nKSkge1xcbiAgICAgICAgICBjb25zb2xlLndhcm4oXFxcIlRyaWVkIHRvIGluaXRpYWxpemUgXFxcIiArIG5hbWUgKyBcXFwiIG9uIGFuIGVsZW1lbnQgdGhhdCBhbHJlYWR5IGhhcyBhIEZvdW5kYXRpb24gcGx1Z2luLlxcXCIpO1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoJGVsLmF0dHIoJ2RhdGEtb3B0aW9ucycpKSB7XFxuICAgICAgICAgIHZhciB0aGluZyA9ICRlbC5hdHRyKCdkYXRhLW9wdGlvbnMnKS5zcGxpdCgnOycpLmZvckVhY2goZnVuY3Rpb24gKGUsIGkpIHtcXG4gICAgICAgICAgICB2YXIgb3B0ID0gZS5zcGxpdCgnOicpLm1hcChmdW5jdGlvbiAoZWwpIHtcXG4gICAgICAgICAgICAgIHJldHVybiBlbC50cmltKCk7XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgaWYgKG9wdFswXSkgb3B0c1tvcHRbMF1dID0gcGFyc2VWYWx1ZShvcHRbMV0pO1xcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgICRlbC5kYXRhKCd6ZlBsdWdpbicsIG5ldyBwbHVnaW4oX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSh0aGlzKSwgb3B0cykpO1xcbiAgICAgICAgfSBjYXRjaCAoZXIpIHtcXG4gICAgICAgICAgY29uc29sZS5lcnJvcihlcik7XFxuICAgICAgICB9IGZpbmFsbHkge1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgIH0pO1xcbiAgfSxcXG4gIGdldEZuTmFtZTogZnVuY3Rpb25OYW1lLFxcblxcbiAgYWRkVG9KcXVlcnk6IGZ1bmN0aW9uICgkKSB7XFxuICAgIC8vIFRPRE86IGNvbnNpZGVyIG5vdCBtYWtpbmcgdGhpcyBhIGpRdWVyeSBmdW5jdGlvblxcbiAgICAvLyBUT0RPOiBuZWVkIHdheSB0byByZWZsb3cgdnMuIHJlLWluaXRpYWxpemVcXG4gICAgLyoqXFxuICAgICAqIFRoZSBGb3VuZGF0aW9uIGpRdWVyeSBtZXRob2QuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBtZXRob2QgLSBBbiBhY3Rpb24gdG8gcGVyZm9ybSBvbiB0aGUgY3VycmVudCBqUXVlcnkgb2JqZWN0LlxcbiAgICAgKi9cXG4gICAgdmFyIGZvdW5kYXRpb24gPSBmdW5jdGlvbiAobWV0aG9kKSB7XFxuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgbWV0aG9kLFxcbiAgICAgICAgICAkbm9KUyA9ICQoJy5uby1qcycpO1xcblxcbiAgICAgIGlmICgkbm9KUy5sZW5ndGgpIHtcXG4gICAgICAgICRub0pTLnJlbW92ZUNsYXNzKCduby1qcycpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICAgIC8vbmVlZHMgdG8gaW5pdGlhbGl6ZSB0aGUgRm91bmRhdGlvbiBvYmplY3QsIG9yIGFuIGluZGl2aWR1YWwgcGx1Z2luLlxcbiAgICAgICAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19mb3VuZGF0aW9uX3V0aWxfbWVkaWFRdWVyeV9fW1xcXCJhXFxcIiAvKiBNZWRpYVF1ZXJ5ICovXS5faW5pdCgpO1xcbiAgICAgICAgRm91bmRhdGlvbi5yZWZsb3codGhpcyk7XFxuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xcbiAgICAgICAgLy9hbiBpbmRpdmlkdWFsIG1ldGhvZCB0byBpbnZva2Ugb24gYSBwbHVnaW4gb3IgZ3JvdXAgb2YgcGx1Z2luc1xcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpOyAvL2NvbGxlY3QgYWxsIHRoZSBhcmd1bWVudHMsIGlmIG5lY2Vzc2FyeVxcbiAgICAgICAgdmFyIHBsdWdDbGFzcyA9IHRoaXMuZGF0YSgnemZQbHVnaW4nKTsgLy9kZXRlcm1pbmUgdGhlIGNsYXNzIG9mIHBsdWdpblxcblxcbiAgICAgICAgaWYgKHBsdWdDbGFzcyAhPT0gdW5kZWZpbmVkICYmIHBsdWdDbGFzc1ttZXRob2RdICE9PSB1bmRlZmluZWQpIHtcXG4gICAgICAgICAgLy9tYWtlIHN1cmUgYm90aCB0aGUgY2xhc3MgYW5kIG1ldGhvZCBleGlzdFxcbiAgICAgICAgICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHtcXG4gICAgICAgICAgICAvL2lmIHRoZXJlJ3Mgb25seSBvbmUsIGNhbGwgaXQgZGlyZWN0bHkuXFxuICAgICAgICAgICAgcGx1Z0NsYXNzW21ldGhvZF0uYXBwbHkocGx1Z0NsYXNzLCBhcmdzKTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24gKGksIGVsKSB7XFxuICAgICAgICAgICAgICAvL290aGVyd2lzZSBsb29wIHRocm91Z2ggdGhlIGpRdWVyeSBjb2xsZWN0aW9uIGFuZCBpbnZva2UgdGhlIG1ldGhvZCBvbiBlYWNoXFxuICAgICAgICAgICAgICBwbHVnQ2xhc3NbbWV0aG9kXS5hcHBseSgkKGVsKS5kYXRhKCd6ZlBsdWdpbicpLCBhcmdzKTtcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgLy9lcnJvciBmb3Igbm8gY2xhc3Mgb3Igbm8gbWV0aG9kXFxuICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcXFwiV2UncmUgc29ycnksICdcXFwiICsgbWV0aG9kICsgXFxcIicgaXMgbm90IGFuIGF2YWlsYWJsZSBtZXRob2QgZm9yIFxcXCIgKyAocGx1Z0NsYXNzID8gZnVuY3Rpb25OYW1lKHBsdWdDbGFzcykgOiAndGhpcyBlbGVtZW50JykgKyAnLicpO1xcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICAvL2Vycm9yIGZvciBpbnZhbGlkIGFyZ3VtZW50IHR5cGVcXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1dlXFxcXCdyZSBzb3JyeSwgJyArIHR5cGUgKyAnIGlzIG5vdCBhIHZhbGlkIHBhcmFtZXRlci4gWW91IG11c3QgdXNlIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgbWV0aG9kIHlvdSB3aXNoIHRvIGludm9rZS4nKTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIHRoaXM7XFxuICAgIH07XFxuICAgICQuZm4uZm91bmRhdGlvbiA9IGZvdW5kYXRpb247XFxuICAgIHJldHVybiAkO1xcbiAgfVxcbn07XFxuXFxuRm91bmRhdGlvbi51dGlsID0ge1xcbiAgLyoqXFxuICAgKiBGdW5jdGlvbiBmb3IgYXBwbHlpbmcgYSBkZWJvdW5jZSBlZmZlY3QgdG8gYSBmdW5jdGlvbiBjYWxsLlxcbiAgICogQGZ1bmN0aW9uXFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIC0gRnVuY3Rpb24gdG8gYmUgY2FsbGVkIGF0IGVuZCBvZiB0aW1lb3V0LlxcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbGF5IC0gVGltZSBpbiBtcyB0byBkZWxheSB0aGUgY2FsbCBvZiBgZnVuY2AuXFxuICAgKiBAcmV0dXJucyBmdW5jdGlvblxcbiAgICovXFxuICB0aHJvdHRsZTogZnVuY3Rpb24gKGZ1bmMsIGRlbGF5KSB7XFxuICAgIHZhciB0aW1lciA9IG51bGw7XFxuXFxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XFxuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLFxcbiAgICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xcblxcbiAgICAgIGlmICh0aW1lciA9PT0gbnVsbCkge1xcbiAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcXG4gICAgICAgICAgdGltZXIgPSBudWxsO1xcbiAgICAgICAgfSwgZGVsYXkpO1xcbiAgICAgIH1cXG4gICAgfTtcXG4gIH1cXG59O1xcblxcbndpbmRvdy5Gb3VuZGF0aW9uID0gRm91bmRhdGlvbjtcXG5cXG4vLyBQb2x5ZmlsbCBmb3IgcmVxdWVzdEFuaW1hdGlvbkZyYW1lXFxuKGZ1bmN0aW9uICgpIHtcXG4gIGlmICghRGF0ZS5ub3cgfHwgIXdpbmRvdy5EYXRlLm5vdykgd2luZG93LkRhdGUubm93ID0gRGF0ZS5ub3cgPSBmdW5jdGlvbiAoKSB7XFxuICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcXG4gIH07XFxuXFxuICB2YXIgdmVuZG9ycyA9IFsnd2Via2l0JywgJ21veiddO1xcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2ZW5kb3JzLmxlbmd0aCAmJiAhd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZTsgKytpKSB7XFxuICAgIHZhciB2cCA9IHZlbmRvcnNbaV07XFxuICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSB3aW5kb3dbdnAgKyAnUmVxdWVzdEFuaW1hdGlvbkZyYW1lJ107XFxuICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSA9IHdpbmRvd1t2cCArICdDYW5jZWxBbmltYXRpb25GcmFtZSddIHx8IHdpbmRvd1t2cCArICdDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnXTtcXG4gIH1cXG4gIGlmICgvaVAoYWR8aG9uZXxvZCkuKk9TIDYvLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpIHx8ICF3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8ICF3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUpIHtcXG4gICAgdmFyIGxhc3RUaW1lID0gMDtcXG4gICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xcbiAgICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xcbiAgICAgIHZhciBuZXh0VGltZSA9IE1hdGgubWF4KGxhc3RUaW1lICsgMTYsIG5vdyk7XFxuICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgY2FsbGJhY2sobGFzdFRpbWUgPSBuZXh0VGltZSk7XFxuICAgICAgfSwgbmV4dFRpbWUgLSBub3cpO1xcbiAgICB9O1xcbiAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSBjbGVhclRpbWVvdXQ7XFxuICB9XFxuICAvKipcXG4gICAqIFBvbHlmaWxsIGZvciBwZXJmb3JtYW5jZS5ub3csIHJlcXVpcmVkIGJ5IHJBRlxcbiAgICovXFxuICBpZiAoIXdpbmRvdy5wZXJmb3JtYW5jZSB8fCAhd2luZG93LnBlcmZvcm1hbmNlLm5vdykge1xcbiAgICB3aW5kb3cucGVyZm9ybWFuY2UgPSB7XFxuICAgICAgc3RhcnQ6IERhdGUubm93KCksXFxuICAgICAgbm93OiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICByZXR1cm4gRGF0ZS5ub3coKSAtIHRoaXMuc3RhcnQ7XFxuICAgICAgfVxcbiAgICB9O1xcbiAgfVxcbn0pKCk7XFxuaWYgKCFGdW5jdGlvbi5wcm90b3R5cGUuYmluZCkge1xcbiAgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAob1RoaXMpIHtcXG4gICAgaWYgKHR5cGVvZiB0aGlzICE9PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgLy8gY2xvc2VzdCB0aGluZyBwb3NzaWJsZSB0byB0aGUgRUNNQVNjcmlwdCA1XFxuICAgICAgLy8gaW50ZXJuYWwgSXNDYWxsYWJsZSBmdW5jdGlvblxcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Z1bmN0aW9uLnByb3RvdHlwZS5iaW5kIC0gd2hhdCBpcyB0cnlpbmcgdG8gYmUgYm91bmQgaXMgbm90IGNhbGxhYmxlJyk7XFxuICAgIH1cXG5cXG4gICAgdmFyIGFBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSxcXG4gICAgICAgIGZUb0JpbmQgPSB0aGlzLFxcbiAgICAgICAgZk5PUCA9IGZ1bmN0aW9uICgpIHt9LFxcbiAgICAgICAgZkJvdW5kID0gZnVuY3Rpb24gKCkge1xcbiAgICAgIHJldHVybiBmVG9CaW5kLmFwcGx5KHRoaXMgaW5zdGFuY2VvZiBmTk9QID8gdGhpcyA6IG9UaGlzLCBhQXJncy5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xcbiAgICB9O1xcblxcbiAgICBpZiAodGhpcy5wcm90b3R5cGUpIHtcXG4gICAgICAvLyBuYXRpdmUgZnVuY3Rpb25zIGRvbid0IGhhdmUgYSBwcm90b3R5cGVcXG4gICAgICBmTk9QLnByb3RvdHlwZSA9IHRoaXMucHJvdG90eXBlO1xcbiAgICB9XFxuICAgIGZCb3VuZC5wcm90b3R5cGUgPSBuZXcgZk5PUCgpO1xcblxcbiAgICByZXR1cm4gZkJvdW5kO1xcbiAgfTtcXG59XFxuLy8gUG9seWZpbGwgdG8gZ2V0IHRoZSBuYW1lIG9mIGEgZnVuY3Rpb24gaW4gSUU5XFxuZnVuY3Rpb24gZnVuY3Rpb25OYW1lKGZuKSB7XFxuICBpZiAoRnVuY3Rpb24ucHJvdG90eXBlLm5hbWUgPT09IHVuZGVmaW5lZCkge1xcbiAgICB2YXIgZnVuY05hbWVSZWdleCA9IC9mdW5jdGlvblxcXFxzKFteKF17MSx9KVxcXFwoLztcXG4gICAgdmFyIHJlc3VsdHMgPSBmdW5jTmFtZVJlZ2V4LmV4ZWMoZm4udG9TdHJpbmcoKSk7XFxuICAgIHJldHVybiByZXN1bHRzICYmIHJlc3VsdHMubGVuZ3RoID4gMSA/IHJlc3VsdHNbMV0udHJpbSgpIDogXFxcIlxcXCI7XFxuICB9IGVsc2UgaWYgKGZuLnByb3RvdHlwZSA9PT0gdW5kZWZpbmVkKSB7XFxuICAgIHJldHVybiBmbi5jb25zdHJ1Y3Rvci5uYW1lO1xcbiAgfSBlbHNlIHtcXG4gICAgcmV0dXJuIGZuLnByb3RvdHlwZS5jb25zdHJ1Y3Rvci5uYW1lO1xcbiAgfVxcbn1cXG5mdW5jdGlvbiBwYXJzZVZhbHVlKHN0cikge1xcbiAgaWYgKCd0cnVlJyA9PT0gc3RyKSByZXR1cm4gdHJ1ZTtlbHNlIGlmICgnZmFsc2UnID09PSBzdHIpIHJldHVybiBmYWxzZTtlbHNlIGlmICghaXNOYU4oc3RyICogMSkpIHJldHVybiBwYXJzZUZsb2F0KHN0cik7XFxuICByZXR1cm4gc3RyO1xcbn1cXG4vLyBDb252ZXJ0IFBhc2NhbENhc2UgdG8ga2ViYWItY2FzZVxcbi8vIFRoYW5rIHlvdTogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvODk1NTU4MFxcbmZ1bmN0aW9uIGh5cGhlbmF0ZShzdHIpIHtcXG4gIHJldHVybiBzdHIucmVwbGFjZSgvKFthLXpdKShbQS1aXSkvZywgJyQxLSQyJykudG9Mb3dlckNhc2UoKTtcXG59XFxuXFxuXFxuXFxuLyoqKi8gfSksXFxuLyogMjIgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImFcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIERyb3Bkb3duOyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLm4oX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19mb3VuZGF0aW9uX3V0aWxfa2V5Ym9hcmRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fZm91bmRhdGlvbl91dGlsX2NvcmVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fZm91bmRhdGlvbl9wb3NpdGlvbmFibGVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX2ZvdW5kYXRpb25fdXRpbF90cmlnZ2Vyc19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcXG5cXG5cXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFxcXCJ2YWx1ZVxcXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcXG5cXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7IH0gfSBlbHNlIGlmIChcXFwidmFsdWVcXFwiIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9O1xcblxcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7IH0gfVxcblxcbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcXFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXFxcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcXFwib2JqZWN0XFxcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXFxcImZ1bmN0aW9uXFxcIikgPyBjYWxsIDogc2VsZjsgfVxcblxcbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFxcXCJmdW5jdGlvblxcXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFxcXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuLyoqXFxuICogRHJvcGRvd24gbW9kdWxlLlxcbiAqIEBtb2R1bGUgZm91bmRhdGlvbi5kcm9wZG93blxcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwua2V5Ym9hcmRcXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLmJveFxcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwudHJpZ2dlcnNcXG4gKi9cXG5cXG52YXIgRHJvcGRvd24gPSBmdW5jdGlvbiAoX1Bvc2l0aW9uYWJsZSkge1xcbiAgX2luaGVyaXRzKERyb3Bkb3duLCBfUG9zaXRpb25hYmxlKTtcXG5cXG4gIGZ1bmN0aW9uIERyb3Bkb3duKCkge1xcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRHJvcGRvd24pO1xcblxcbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKERyb3Bkb3duLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRHJvcGRvd24pKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcXG4gIH1cXG5cXG4gIF9jcmVhdGVDbGFzcyhEcm9wZG93biwgW3tcXG4gICAga2V5OiAnX3NldHVwJyxcXG5cXG4gICAgLyoqXFxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgYSBkcm9wZG93bi5cXG4gICAgICogQGNsYXNzXFxuICAgICAqIEBuYW1lIERyb3Bkb3duXFxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBtYWtlIGludG8gYSBkcm9wZG93bi5cXG4gICAgICogICAgICAgIE9iamVjdCBzaG91bGQgYmUgb2YgdGhlIGRyb3Bkb3duIHBhbmVsLCByYXRoZXIgdGhhbiBpdHMgYW5jaG9yLlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlcyB0byB0aGUgZGVmYXVsdCBwbHVnaW4gc2V0dGluZ3MuXFxuICAgICAqL1xcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwKGVsZW1lbnQsIG9wdGlvbnMpIHtcXG4gICAgICB0aGlzLiRlbGVtZW50ID0gZWxlbWVudDtcXG4gICAgICB0aGlzLm9wdGlvbnMgPSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdC5hLmV4dGVuZCh7fSwgRHJvcGRvd24uZGVmYXVsdHMsIHRoaXMuJGVsZW1lbnQuZGF0YSgpLCBvcHRpb25zKTtcXG4gICAgICB0aGlzLmNsYXNzTmFtZSA9ICdEcm9wZG93bic7IC8vIGllOSBiYWNrIGNvbXBhdFxcblxcbiAgICAgIC8vIFRyaWdnZXJzIGluaXQgaXMgaWRlbXBvdGVudCwganVzdCBuZWVkIHRvIG1ha2Ugc3VyZSBpdCBpcyBpbml0aWFsaXplZFxcbiAgICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fZm91bmRhdGlvbl91dGlsX3RyaWdnZXJzX19bXFxcImFcXFwiIC8qIFRyaWdnZXJzICovXS5pbml0KF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0LmEpO1xcblxcbiAgICAgIHRoaXMuX2luaXQoKTtcXG5cXG4gICAgICBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX2ZvdW5kYXRpb25fdXRpbF9rZXlib2FyZF9fW1xcXCJhXFxcIiAvKiBLZXlib2FyZCAqL10ucmVnaXN0ZXIoJ0Ryb3Bkb3duJywge1xcbiAgICAgICAgJ0VOVEVSJzogJ29wZW4nLFxcbiAgICAgICAgJ1NQQUNFJzogJ29wZW4nLFxcbiAgICAgICAgJ0VTQ0FQRSc6ICdjbG9zZSdcXG4gICAgICB9KTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIHBsdWdpbiBieSBzZXR0aW5nL2NoZWNraW5nIG9wdGlvbnMgYW5kIGF0dHJpYnV0ZXMsIGFkZGluZyBoZWxwZXIgdmFyaWFibGVzLCBhbmQgc2F2aW5nIHRoZSBhbmNob3IuXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAnX2luaXQnLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXQoKSB7XFxuICAgICAgdmFyICRpZCA9IHRoaXMuJGVsZW1lbnQuYXR0cignaWQnKTtcXG5cXG4gICAgICB0aGlzLiRhbmNob3IgPSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKCdbZGF0YS10b2dnbGU9XFxcIicgKyAkaWQgKyAnXFxcIl0nKS5sZW5ndGggPyBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKCdbZGF0YS10b2dnbGU9XFxcIicgKyAkaWQgKyAnXFxcIl0nKSA6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0KCkoJ1tkYXRhLW9wZW49XFxcIicgKyAkaWQgKyAnXFxcIl0nKTtcXG4gICAgICB0aGlzLiRhbmNob3IuYXR0cih7XFxuICAgICAgICAnYXJpYS1jb250cm9scyc6ICRpZCxcXG4gICAgICAgICdkYXRhLWlzLWZvY3VzJzogZmFsc2UsXFxuICAgICAgICAnZGF0YS15ZXRpLWJveCc6ICRpZCxcXG4gICAgICAgICdhcmlhLWhhc3BvcHVwJzogdHJ1ZSxcXG4gICAgICAgICdhcmlhLWV4cGFuZGVkJzogZmFsc2VcXG5cXG4gICAgICB9KTtcXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnBhcmVudENsYXNzKSB7XFxuICAgICAgICB0aGlzLiRwYXJlbnQgPSB0aGlzLiRlbGVtZW50LnBhcmVudHMoJy4nICsgdGhpcy5vcHRpb25zLnBhcmVudENsYXNzKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdGhpcy4kcGFyZW50ID0gbnVsbDtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy4kZWxlbWVudC5hdHRyKHtcXG4gICAgICAgICdhcmlhLWhpZGRlbic6ICd0cnVlJyxcXG4gICAgICAgICdkYXRhLXlldGktYm94JzogJGlkLFxcbiAgICAgICAgJ2RhdGEtcmVzaXplJzogJGlkLFxcbiAgICAgICAgJ2FyaWEtbGFiZWxsZWRieSc6IHRoaXMuJGFuY2hvclswXS5pZCB8fCBfX3dlYnBhY2tfcmVxdWlyZV9fLmkoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19mb3VuZGF0aW9uX3V0aWxfY29yZV9fW1xcXCJiXFxcIiAvKiBHZXRZb0RpZ2l0cyAqL10pKDYsICdkZC1hbmNob3InKVxcbiAgICAgIH0pO1xcbiAgICAgIF9nZXQoRHJvcGRvd24ucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRHJvcGRvd24ucHJvdG90eXBlKSwgJ19pbml0JywgdGhpcykuY2FsbCh0aGlzKTtcXG4gICAgICB0aGlzLl9ldmVudHMoKTtcXG4gICAgfVxcbiAgfSwge1xcbiAgICBrZXk6ICdfZ2V0RGVmYXVsdFBvc2l0aW9uJyxcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXREZWZhdWx0UG9zaXRpb24oKSB7XFxuICAgICAgLy8gaGFuZGxlIGxlZ2FjeSBjbGFzc25hbWVzXFxuICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy4kZWxlbWVudFswXS5jbGFzc05hbWUubWF0Y2goLyh0b3B8bGVmdHxyaWdodHxib3R0b20pL2cpO1xcbiAgICAgIGlmIChwb3NpdGlvbikge1xcbiAgICAgICAgcmV0dXJuIHBvc2l0aW9uWzBdO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICByZXR1cm4gJ2JvdHRvbSc7XFxuICAgICAgfVxcbiAgICB9XFxuICB9LCB7XFxuICAgIGtleTogJ19nZXREZWZhdWx0QWxpZ25tZW50JyxcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXREZWZhdWx0QWxpZ25tZW50KCkge1xcbiAgICAgIC8vIGhhbmRsZSBsZWdhY3kgZmxvYXQgYXBwcm9hY2hcXG4gICAgICB2YXIgaG9yaXpvbnRhbFBvc2l0aW9uID0gL2Zsb2F0LShcXFxcUyspLy5leGVjKHRoaXMuJGFuY2hvclswXS5jbGFzc05hbWUpO1xcbiAgICAgIGlmIChob3Jpem9udGFsUG9zaXRpb24pIHtcXG4gICAgICAgIHJldHVybiBob3Jpem9udGFsUG9zaXRpb25bMV07XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBfZ2V0KERyb3Bkb3duLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKERyb3Bkb3duLnByb3RvdHlwZSksICdfZ2V0RGVmYXVsdEFsaWdubWVudCcsIHRoaXMpLmNhbGwodGhpcyk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIFNldHMgdGhlIHBvc2l0aW9uIGFuZCBvcmllbnRhdGlvbiBvZiB0aGUgZHJvcGRvd24gcGFuZSwgY2hlY2tzIGZvciBjb2xsaXNpb25zIGlmIGFsbG93LW92ZXJsYXAgaXMgbm90IHRydWUuXFxuICAgICAqIFJlY3Vyc2l2ZWx5IGNhbGxzIGl0c2VsZiBpZiBhIGNvbGxpc2lvbiBpcyBkZXRlY3RlZCwgd2l0aCBhIG5ldyBwb3NpdGlvbiBjbGFzcy5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6ICdfc2V0UG9zaXRpb24nLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldFBvc2l0aW9uKCkge1xcbiAgICAgIF9nZXQoRHJvcGRvd24ucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRHJvcGRvd24ucHJvdG90eXBlKSwgJ19zZXRQb3NpdGlvbicsIHRoaXMpLmNhbGwodGhpcywgdGhpcy4kYW5jaG9yLCB0aGlzLiRlbGVtZW50LCB0aGlzLiRwYXJlbnQpO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBBZGRzIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgZWxlbWVudCB1dGlsaXppbmcgdGhlIHRyaWdnZXJzIHV0aWxpdHkgbGlicmFyeS5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6ICdfZXZlbnRzJyxcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9ldmVudHMoKSB7XFxuICAgICAgdmFyIF90aGlzID0gdGhpcztcXG4gICAgICB0aGlzLiRlbGVtZW50Lm9uKHtcXG4gICAgICAgICdvcGVuLnpmLnRyaWdnZXInOiB0aGlzLm9wZW4uYmluZCh0aGlzKSxcXG4gICAgICAgICdjbG9zZS56Zi50cmlnZ2VyJzogdGhpcy5jbG9zZS5iaW5kKHRoaXMpLFxcbiAgICAgICAgJ3RvZ2dsZS56Zi50cmlnZ2VyJzogdGhpcy50b2dnbGUuYmluZCh0aGlzKSxcXG4gICAgICAgICdyZXNpemVtZS56Zi50cmlnZ2VyJzogdGhpcy5fc2V0UG9zaXRpb24uYmluZCh0aGlzKVxcbiAgICAgIH0pO1xcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaG92ZXIpIHtcXG4gICAgICAgIHRoaXMuJGFuY2hvci5vZmYoJ21vdXNlZW50ZXIuemYuZHJvcGRvd24gbW91c2VsZWF2ZS56Zi5kcm9wZG93bicpLm9uKCdtb3VzZWVudGVyLnpmLmRyb3Bkb3duJywgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICB2YXIgYm9keURhdGEgPSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKCdib2R5JykuZGF0YSgpO1xcbiAgICAgICAgICBpZiAodHlwZW9mIGJvZHlEYXRhLndoYXRpbnB1dCA9PT0gJ3VuZGVmaW5lZCcgfHwgYm9keURhdGEud2hhdGlucHV0ID09PSAnbW91c2UnKSB7XFxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLnRpbWVvdXQpO1xcbiAgICAgICAgICAgIF90aGlzLnRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgIF90aGlzLm9wZW4oKTtcXG4gICAgICAgICAgICAgIF90aGlzLiRhbmNob3IuZGF0YSgnaG92ZXInLCB0cnVlKTtcXG4gICAgICAgICAgICB9LCBfdGhpcy5vcHRpb25zLmhvdmVyRGVsYXkpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9KS5vbignbW91c2VsZWF2ZS56Zi5kcm9wZG93bicsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLnRpbWVvdXQpO1xcbiAgICAgICAgICBfdGhpcy50aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgX3RoaXMuY2xvc2UoKTtcXG4gICAgICAgICAgICBfdGhpcy4kYW5jaG9yLmRhdGEoJ2hvdmVyJywgZmFsc2UpO1xcbiAgICAgICAgICB9LCBfdGhpcy5vcHRpb25zLmhvdmVyRGVsYXkpO1xcbiAgICAgICAgfSk7XFxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmhvdmVyUGFuZSkge1xcbiAgICAgICAgICB0aGlzLiRlbGVtZW50Lm9mZignbW91c2VlbnRlci56Zi5kcm9wZG93biBtb3VzZWxlYXZlLnpmLmRyb3Bkb3duJykub24oJ21vdXNlZW50ZXIuemYuZHJvcGRvd24nLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLnRpbWVvdXQpO1xcbiAgICAgICAgICB9KS5vbignbW91c2VsZWF2ZS56Zi5kcm9wZG93bicsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoX3RoaXMudGltZW91dCk7XFxuICAgICAgICAgICAgX3RoaXMudGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgX3RoaXMuY2xvc2UoKTtcXG4gICAgICAgICAgICAgIF90aGlzLiRhbmNob3IuZGF0YSgnaG92ZXInLCBmYWxzZSk7XFxuICAgICAgICAgICAgfSwgX3RoaXMub3B0aW9ucy5ob3ZlckRlbGF5KTtcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIHRoaXMuJGFuY2hvci5hZGQodGhpcy4kZWxlbWVudCkub24oJ2tleWRvd24uemYuZHJvcGRvd24nLCBmdW5jdGlvbiAoZSkge1xcblxcbiAgICAgICAgdmFyICR0YXJnZXQgPSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKHRoaXMpLFxcbiAgICAgICAgICAgIHZpc2libGVGb2N1c2FibGVFbGVtZW50cyA9IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fZm91bmRhdGlvbl91dGlsX2tleWJvYXJkX19bXFxcImFcXFwiIC8qIEtleWJvYXJkICovXS5maW5kRm9jdXNhYmxlKF90aGlzLiRlbGVtZW50KTtcXG5cXG4gICAgICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fZm91bmRhdGlvbl91dGlsX2tleWJvYXJkX19bXFxcImFcXFwiIC8qIEtleWJvYXJkICovXS5oYW5kbGVLZXkoZSwgJ0Ryb3Bkb3duJywge1xcbiAgICAgICAgICBvcGVuOiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgaWYgKCR0YXJnZXQuaXMoX3RoaXMuJGFuY2hvcikpIHtcXG4gICAgICAgICAgICAgIF90aGlzLm9wZW4oKTtcXG4gICAgICAgICAgICAgIF90aGlzLiRlbGVtZW50LmF0dHIoJ3RhYmluZGV4JywgLTEpLmZvY3VzKCk7XFxuICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9LFxcbiAgICAgICAgICBjbG9zZTogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIF90aGlzLmNsb3NlKCk7XFxuICAgICAgICAgICAgX3RoaXMuJGFuY2hvci5mb2N1cygpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgICB9KTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQWRkcyBhbiBldmVudCBoYW5kbGVyIHRvIHRoZSBib2R5IHRvIGNsb3NlIGFueSBkcm9wZG93bnMgb24gYSBjbGljay5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6ICdfYWRkQm9keUhhbmRsZXInLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2FkZEJvZHlIYW5kbGVyKCkge1xcbiAgICAgIHZhciAkYm9keSA9IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0KCkoZG9jdW1lbnQuYm9keSkubm90KHRoaXMuJGVsZW1lbnQpLFxcbiAgICAgICAgICBfdGhpcyA9IHRoaXM7XFxuICAgICAgJGJvZHkub2ZmKCdjbGljay56Zi5kcm9wZG93bicpLm9uKCdjbGljay56Zi5kcm9wZG93bicsIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICBpZiAoX3RoaXMuJGFuY2hvci5pcyhlLnRhcmdldCkgfHwgX3RoaXMuJGFuY2hvci5maW5kKGUudGFyZ2V0KS5sZW5ndGgpIHtcXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKF90aGlzLiRlbGVtZW50LmZpbmQoZS50YXJnZXQpLmxlbmd0aCkge1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuICAgICAgICBfdGhpcy5jbG9zZSgpO1xcbiAgICAgICAgJGJvZHkub2ZmKCdjbGljay56Zi5kcm9wZG93bicpO1xcbiAgICAgIH0pO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBPcGVucyB0aGUgZHJvcGRvd24gcGFuZSwgYW5kIGZpcmVzIGEgYnViYmxpbmcgZXZlbnQgdG8gY2xvc2Ugb3RoZXIgZHJvcGRvd25zLlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQGZpcmVzIERyb3Bkb3duI2Nsb3NlbWVcXG4gICAgICogQGZpcmVzIERyb3Bkb3duI3Nob3dcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogJ29wZW4nLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3BlbigpIHtcXG4gICAgICAvLyB2YXIgX3RoaXMgPSB0aGlzO1xcbiAgICAgIC8qKlxcbiAgICAgICAqIEZpcmVzIHRvIGNsb3NlIG90aGVyIG9wZW4gZHJvcGRvd25zLCB0eXBpY2FsbHkgd2hlbiBkcm9wZG93biBpcyBvcGVuaW5nXFxuICAgICAgICogQGV2ZW50IERyb3Bkb3duI2Nsb3NlbWVcXG4gICAgICAgKi9cXG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ2Nsb3NlbWUuemYuZHJvcGRvd24nLCB0aGlzLiRlbGVtZW50LmF0dHIoJ2lkJykpO1xcbiAgICAgIHRoaXMuJGFuY2hvci5hZGRDbGFzcygnaG92ZXInKS5hdHRyKHsgJ2FyaWEtZXhwYW5kZWQnOiB0cnVlIH0pO1xcbiAgICAgIC8vIHRoaXMuJGVsZW1lbnQvKi5zaG93KCkqLztcXG5cXG4gICAgICB0aGlzLiRlbGVtZW50LmFkZENsYXNzKCdpcy1vcGVuaW5nJyk7XFxuICAgICAgdGhpcy5fc2V0UG9zaXRpb24oKTtcXG4gICAgICB0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKCdpcy1vcGVuaW5nJykuYWRkQ2xhc3MoJ2lzLW9wZW4nKS5hdHRyKHsgJ2FyaWEtaGlkZGVuJzogZmFsc2UgfSk7XFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvRm9jdXMpIHtcXG4gICAgICAgIHZhciAkZm9jdXNhYmxlID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19mb3VuZGF0aW9uX3V0aWxfa2V5Ym9hcmRfX1tcXFwiYVxcXCIgLyogS2V5Ym9hcmQgKi9dLmZpbmRGb2N1c2FibGUodGhpcy4kZWxlbWVudCk7XFxuICAgICAgICBpZiAoJGZvY3VzYWJsZS5sZW5ndGgpIHtcXG4gICAgICAgICAgJGZvY3VzYWJsZS5lcSgwKS5mb2N1cygpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmNsb3NlT25DbGljaykge1xcbiAgICAgICAgdGhpcy5fYWRkQm9keUhhbmRsZXIoKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy50cmFwRm9jdXMpIHtcXG4gICAgICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fZm91bmRhdGlvbl91dGlsX2tleWJvYXJkX19bXFxcImFcXFwiIC8qIEtleWJvYXJkICovXS50cmFwRm9jdXModGhpcy4kZWxlbWVudCk7XFxuICAgICAgfVxcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIEZpcmVzIG9uY2UgdGhlIGRyb3Bkb3duIGlzIHZpc2libGUuXFxuICAgICAgICogQGV2ZW50IERyb3Bkb3duI3Nob3dcXG4gICAgICAgKi9cXG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ3Nob3cuemYuZHJvcGRvd24nLCBbdGhpcy4kZWxlbWVudF0pO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDbG9zZXMgdGhlIG9wZW4gZHJvcGRvd24gcGFuZS5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBmaXJlcyBEcm9wZG93biNoaWRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6ICdjbG9zZScsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZSgpIHtcXG4gICAgICBpZiAoIXRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2lzLW9wZW4nKSkge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG4gICAgICB0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKCdpcy1vcGVuJykuYXR0cih7ICdhcmlhLWhpZGRlbic6IHRydWUgfSk7XFxuXFxuICAgICAgdGhpcy4kYW5jaG9yLnJlbW92ZUNsYXNzKCdob3ZlcicpLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCBmYWxzZSk7XFxuXFxuICAgICAgLyoqXFxuICAgICAgICogRmlyZXMgb25jZSB0aGUgZHJvcGRvd24gaXMgbm8gbG9uZ2VyIHZpc2libGUuXFxuICAgICAgICogQGV2ZW50IERyb3Bkb3duI2hpZGVcXG4gICAgICAgKi9cXG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ2hpZGUuemYuZHJvcGRvd24nLCBbdGhpcy4kZWxlbWVudF0pO1xcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudHJhcEZvY3VzKSB7XFxuICAgICAgICBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX2ZvdW5kYXRpb25fdXRpbF9rZXlib2FyZF9fW1xcXCJhXFxcIiAvKiBLZXlib2FyZCAqL10ucmVsZWFzZUZvY3VzKHRoaXMuJGVsZW1lbnQpO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogVG9nZ2xlcyB0aGUgZHJvcGRvd24gcGFuZSdzIHZpc2liaWxpdHkuXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAndG9nZ2xlJyxcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvZ2dsZSgpIHtcXG4gICAgICBpZiAodGhpcy4kZWxlbWVudC5oYXNDbGFzcygnaXMtb3BlbicpKSB7XFxuICAgICAgICBpZiAodGhpcy4kYW5jaG9yLmRhdGEoJ2hvdmVyJykpIHJldHVybjtcXG4gICAgICAgIHRoaXMuY2xvc2UoKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdGhpcy5vcGVuKCk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBEZXN0cm95cyB0aGUgZHJvcGRvd24uXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAnX2Rlc3Ryb3knLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Rlc3Ryb3koKSB7XFxuICAgICAgdGhpcy4kZWxlbWVudC5vZmYoJy56Zi50cmlnZ2VyJykuaGlkZSgpO1xcbiAgICAgIHRoaXMuJGFuY2hvci5vZmYoJy56Zi5kcm9wZG93bicpO1xcbiAgICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0KCkoZG9jdW1lbnQuYm9keSkub2ZmKCdjbGljay56Zi5kcm9wZG93bicpO1xcbiAgICB9XFxuICB9XSk7XFxuXFxuICByZXR1cm4gRHJvcGRvd247XFxufShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX2ZvdW5kYXRpb25fcG9zaXRpb25hYmxlX19bXFxcImFcXFwiIC8qIFBvc2l0aW9uYWJsZSAqL10pO1xcblxcbkRyb3Bkb3duLmRlZmF1bHRzID0ge1xcbiAgLyoqXFxuICAgKiBDbGFzcyB0aGF0IGRlc2lnbmF0ZXMgYm91bmRpbmcgY29udGFpbmVyIG9mIERyb3Bkb3duIChkZWZhdWx0OiB3aW5kb3cpXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7P3N0cmluZ31cXG4gICAqIEBkZWZhdWx0IG51bGxcXG4gICAqL1xcbiAgcGFyZW50Q2xhc3M6IG51bGwsXFxuICAvKipcXG4gICAqIEFtb3VudCBvZiB0aW1lIHRvIGRlbGF5IG9wZW5pbmcgYSBzdWJtZW51IG9uIGhvdmVyIGV2ZW50LlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge251bWJlcn1cXG4gICAqIEBkZWZhdWx0IDI1MFxcbiAgICovXFxuICBob3ZlckRlbGF5OiAyNTAsXFxuICAvKipcXG4gICAqIEFsbG93IHN1Ym1lbnVzIHRvIG9wZW4gb24gaG92ZXIgZXZlbnRzXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IGZhbHNlXFxuICAgKi9cXG4gIGhvdmVyOiBmYWxzZSxcXG4gIC8qKlxcbiAgICogRG9uJ3QgY2xvc2UgZHJvcGRvd24gd2hlbiBob3ZlcmluZyBvdmVyIGRyb3Bkb3duIHBhbmVcXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtib29sZWFufVxcbiAgICogQGRlZmF1bHQgZmFsc2VcXG4gICAqL1xcbiAgaG92ZXJQYW5lOiBmYWxzZSxcXG4gIC8qKlxcbiAgICogTnVtYmVyIG9mIHBpeGVscyBiZXR3ZWVuIHRoZSBkcm9wZG93biBwYW5lIGFuZCB0aGUgdHJpZ2dlcmluZyBlbGVtZW50IG9uIG9wZW4uXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7bnVtYmVyfVxcbiAgICogQGRlZmF1bHQgMFxcbiAgICovXFxuICB2T2Zmc2V0OiAwLFxcbiAgLyoqXFxuICAgKiBOdW1iZXIgb2YgcGl4ZWxzIGJldHdlZW4gdGhlIGRyb3Bkb3duIHBhbmUgYW5kIHRoZSB0cmlnZ2VyaW5nIGVsZW1lbnQgb24gb3Blbi5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtudW1iZXJ9XFxuICAgKiBAZGVmYXVsdCAwXFxuICAgKi9cXG4gIGhPZmZzZXQ6IDAsXFxuICAvKipcXG4gICAqIERFUFJFQ0FURUQ6IENsYXNzIGFwcGxpZWQgdG8gYWRqdXN0IG9wZW4gcG9zaXRpb24uXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7c3RyaW5nfVxcbiAgICogQGRlZmF1bHQgJydcXG4gICAqL1xcbiAgcG9zaXRpb25DbGFzczogJycsXFxuXFxuICAvKipcXG4gICAqIFBvc2l0aW9uIG9mIGRyb3Bkb3duLiBDYW4gYmUgbGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBvciBhdXRvLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge3N0cmluZ31cXG4gICAqIEBkZWZhdWx0ICdhdXRvJ1xcbiAgICovXFxuICBwb3NpdGlvbjogJ2F1dG8nLFxcbiAgLyoqXFxuICAgKiBBbGlnbm1lbnQgb2YgZHJvcGRvd24gcmVsYXRpdmUgdG8gYW5jaG9yLiBDYW4gYmUgbGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBjZW50ZXIsIG9yIGF1dG8uXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7c3RyaW5nfVxcbiAgICogQGRlZmF1bHQgJ2F1dG8nXFxuICAgKi9cXG4gIGFsaWdubWVudDogJ2F1dG8nLFxcbiAgLyoqXFxuICAgKiBBbGxvdyBvdmVybGFwIG9mIGNvbnRhaW5lci93aW5kb3cuIElmIGZhbHNlLCBkcm9wZG93biB3aWxsIGZpcnN0IHRyeSB0byBwb3NpdGlvbiBhcyBkZWZpbmVkIGJ5IGRhdGEtcG9zaXRpb24gYW5kIGRhdGEtYWxpZ25tZW50LCBidXQgcmVwb3NpdGlvbiBpZiBpdCB3b3VsZCBjYXVzZSBhbiBvdmVyZmxvdy5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtib29sZWFufVxcbiAgICogQGRlZmF1bHQgZmFsc2VcXG4gICAqL1xcbiAgYWxsb3dPdmVybGFwOiBmYWxzZSxcXG4gIC8qKlxcbiAgICogQWxsb3cgb3ZlcmxhcCBvZiBvbmx5IHRoZSBib3R0b20gb2YgdGhlIGNvbnRhaW5lci4gVGhpcyBpcyB0aGUgbW9zdCBjb21tb25cXG4gICAqIGJlaGF2aW9yIGZvciBkcm9wZG93bnMsIGFsbG93aW5nIHRoZSBkcm9wZG93biB0byBleHRlbmQgdGhlIGJvdHRvbSBvZiB0aGVcXG4gICAqIHNjcmVlbiBidXQgbm90IG90aGVyd2lzZSBpbmZsdWVuY2Ugb3IgYnJlYWsgb3V0IG9mIHRoZSBjb250YWluZXIuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IHRydWVcXG4gICAqL1xcbiAgYWxsb3dCb3R0b21PdmVybGFwOiB0cnVlLFxcbiAgLyoqXFxuICAgKiBBbGxvdyB0aGUgcGx1Z2luIHRvIHRyYXAgZm9jdXMgdG8gdGhlIGRyb3Bkb3duIHBhbmUgaWYgb3BlbmVkIHdpdGgga2V5Ym9hcmQgY29tbWFuZHMuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IGZhbHNlXFxuICAgKi9cXG4gIHRyYXBGb2N1czogZmFsc2UsXFxuICAvKipcXG4gICAqIEFsbG93IHRoZSBwbHVnaW4gdG8gc2V0IGZvY3VzIHRvIHRoZSBmaXJzdCBmb2N1c2FibGUgZWxlbWVudCB3aXRoaW4gdGhlIHBhbmUsIHJlZ2FyZGxlc3Mgb2YgbWV0aG9kIG9mIG9wZW5pbmcuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IGZhbHNlXFxuICAgKi9cXG4gIGF1dG9Gb2N1czogZmFsc2UsXFxuICAvKipcXG4gICAqIEFsbG93cyBhIGNsaWNrIG9uIHRoZSBib2R5IHRvIGNsb3NlIHRoZSBkcm9wZG93bi5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtib29sZWFufVxcbiAgICogQGRlZmF1bHQgZmFsc2VcXG4gICAqL1xcbiAgY2xvc2VPbkNsaWNrOiBmYWxzZVxcbn07XFxuXFxuXFxuXFxuLyoqKi8gfSksXFxuLyogMjMgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImFcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIEVxdWFsaXplcjsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0ID0gX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfXyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fZm91bmRhdGlvbl91dGlsX21lZGlhUXVlcnlfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fZm91bmRhdGlvbl91dGlsX2ltYWdlTG9hZGVyX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX2ZvdW5kYXRpb25fdXRpbF9jb3JlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX2ZvdW5kYXRpb25fcGx1Z2luX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xcblxcblxcbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXFxcInZhbHVlXFxcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xcblxcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7IH0gfVxcblxcbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcXFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXFxcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcXFwib2JqZWN0XFxcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXFxcImZ1bmN0aW9uXFxcIikgPyBjYWxsIDogc2VsZjsgfVxcblxcbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFxcXCJmdW5jdGlvblxcXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFxcXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuLyoqXFxuICogRXF1YWxpemVyIG1vZHVsZS5cXG4gKiBAbW9kdWxlIGZvdW5kYXRpb24uZXF1YWxpemVyXFxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5tZWRpYVF1ZXJ5XFxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5pbWFnZUxvYWRlciBpZiBlcXVhbGl6ZXIgY29udGFpbnMgaW1hZ2VzXFxuICovXFxuXFxudmFyIEVxdWFsaXplciA9IGZ1bmN0aW9uIChfUGx1Z2luKSB7XFxuICBfaW5oZXJpdHMoRXF1YWxpemVyLCBfUGx1Z2luKTtcXG5cXG4gIGZ1bmN0aW9uIEVxdWFsaXplcigpIHtcXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEVxdWFsaXplcik7XFxuXFxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoRXF1YWxpemVyLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRXF1YWxpemVyKSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XFxuICB9XFxuXFxuICBfY3JlYXRlQ2xhc3MoRXF1YWxpemVyLCBbe1xcbiAgICBrZXk6ICdfc2V0dXAnLFxcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBFcXVhbGl6ZXIuXFxuICAgICAqIEBjbGFzc1xcbiAgICAgKiBAbmFtZSBFcXVhbGl6ZXJcXG4gICAgICogQGZpcmVzIEVxdWFsaXplciNpbml0XFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBhZGQgdGhlIHRyaWdnZXIgdG8uXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGVzIHRvIHRoZSBkZWZhdWx0IHBsdWdpbiBzZXR0aW5ncy5cXG4gICAgICovXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0dXAoZWxlbWVudCwgb3B0aW9ucykge1xcbiAgICAgIHRoaXMuJGVsZW1lbnQgPSBlbGVtZW50O1xcbiAgICAgIHRoaXMub3B0aW9ucyA9IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0LmEuZXh0ZW5kKHt9LCBFcXVhbGl6ZXIuZGVmYXVsdHMsIHRoaXMuJGVsZW1lbnQuZGF0YSgpLCBvcHRpb25zKTtcXG4gICAgICB0aGlzLmNsYXNzTmFtZSA9ICdFcXVhbGl6ZXInOyAvLyBpZTkgYmFjayBjb21wYXRcXG5cXG4gICAgICB0aGlzLl9pbml0KCk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIEluaXRpYWxpemVzIHRoZSBFcXVhbGl6ZXIgcGx1Z2luIGFuZCBjYWxscyBmdW5jdGlvbnMgdG8gZ2V0IGVxdWFsaXplciBmdW5jdGlvbmluZyBvbiBsb2FkLlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAnX2luaXQnLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXQoKSB7XFxuICAgICAgdmFyIGVxSWQgPSB0aGlzLiRlbGVtZW50LmF0dHIoJ2RhdGEtZXF1YWxpemVyJykgfHwgJyc7XFxuICAgICAgdmFyICR3YXRjaGVkID0gdGhpcy4kZWxlbWVudC5maW5kKCdbZGF0YS1lcXVhbGl6ZXItd2F0Y2g9XFxcIicgKyBlcUlkICsgJ1xcXCJdJyk7XFxuXFxuICAgICAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19mb3VuZGF0aW9uX3V0aWxfbWVkaWFRdWVyeV9fW1xcXCJhXFxcIiAvKiBNZWRpYVF1ZXJ5ICovXS5faW5pdCgpO1xcblxcbiAgICAgIHRoaXMuJHdhdGNoZWQgPSAkd2F0Y2hlZC5sZW5ndGggPyAkd2F0Y2hlZCA6IHRoaXMuJGVsZW1lbnQuZmluZCgnW2RhdGEtZXF1YWxpemVyLXdhdGNoXScpO1xcbiAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cignZGF0YS1yZXNpemUnLCBlcUlkIHx8IF9fd2VicGFja19yZXF1aXJlX18uaShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX2ZvdW5kYXRpb25fdXRpbF9jb3JlX19bXFxcImJcXFwiIC8qIEdldFlvRGlnaXRzICovXSkoNiwgJ2VxJykpO1xcbiAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cignZGF0YS1tdXRhdGUnLCBlcUlkIHx8IF9fd2VicGFja19yZXF1aXJlX18uaShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX2ZvdW5kYXRpb25fdXRpbF9jb3JlX19bXFxcImJcXFwiIC8qIEdldFlvRGlnaXRzICovXSkoNiwgJ2VxJykpO1xcblxcbiAgICAgIHRoaXMuaGFzTmVzdGVkID0gdGhpcy4kZWxlbWVudC5maW5kKCdbZGF0YS1lcXVhbGl6ZXJdJykubGVuZ3RoID4gMDtcXG4gICAgICB0aGlzLmlzTmVzdGVkID0gdGhpcy4kZWxlbWVudC5wYXJlbnRzVW50aWwoZG9jdW1lbnQuYm9keSwgJ1tkYXRhLWVxdWFsaXplcl0nKS5sZW5ndGggPiAwO1xcbiAgICAgIHRoaXMuaXNPbiA9IGZhbHNlO1xcbiAgICAgIHRoaXMuX2JpbmRIYW5kbGVyID0ge1xcbiAgICAgICAgb25SZXNpemVNZUJvdW5kOiB0aGlzLl9vblJlc2l6ZU1lLmJpbmQodGhpcyksXFxuICAgICAgICBvblBvc3RFcXVhbGl6ZWRCb3VuZDogdGhpcy5fb25Qb3N0RXF1YWxpemVkLmJpbmQodGhpcylcXG4gICAgICB9O1xcblxcbiAgICAgIHZhciBpbWdzID0gdGhpcy4kZWxlbWVudC5maW5kKCdpbWcnKTtcXG4gICAgICB2YXIgdG9vU21hbGw7XFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lcXVhbGl6ZU9uKSB7XFxuICAgICAgICB0b29TbWFsbCA9IHRoaXMuX2NoZWNrTVEoKTtcXG4gICAgICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0KCkod2luZG93KS5vbignY2hhbmdlZC56Zi5tZWRpYXF1ZXJ5JywgdGhpcy5fY2hlY2tNUS5iaW5kKHRoaXMpKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdGhpcy5fZXZlbnRzKCk7XFxuICAgICAgfVxcbiAgICAgIGlmICh0b29TbWFsbCAhPT0gdW5kZWZpbmVkICYmIHRvb1NtYWxsID09PSBmYWxzZSB8fCB0b29TbWFsbCA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICBpZiAoaW1ncy5sZW5ndGgpIHtcXG4gICAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5pKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fZm91bmRhdGlvbl91dGlsX2ltYWdlTG9hZGVyX19bXFxcImFcXFwiIC8qIG9uSW1hZ2VzTG9hZGVkICovXSkoaW1ncywgdGhpcy5fcmVmbG93LmJpbmQodGhpcykpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgdGhpcy5fcmVmbG93KCk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBSZW1vdmVzIGV2ZW50IGxpc3RlbmVycyBpZiB0aGUgYnJlYWtwb2ludCBpcyB0b28gc21hbGwuXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6ICdfcGF1c2VFdmVudHMnLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3BhdXNlRXZlbnRzKCkge1xcbiAgICAgIHRoaXMuaXNPbiA9IGZhbHNlO1xcbiAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKHtcXG4gICAgICAgICcuemYuZXF1YWxpemVyJzogdGhpcy5fYmluZEhhbmRsZXIub25Qb3N0RXF1YWxpemVkQm91bmQsXFxuICAgICAgICAncmVzaXplbWUuemYudHJpZ2dlcic6IHRoaXMuX2JpbmRIYW5kbGVyLm9uUmVzaXplTWVCb3VuZCxcXG4gICAgICAgICdtdXRhdGVtZS56Zi50cmlnZ2VyJzogdGhpcy5fYmluZEhhbmRsZXIub25SZXNpemVNZUJvdW5kXFxuICAgICAgfSk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIGZ1bmN0aW9uIHRvIGhhbmRsZSAkZWxlbWVudHMgcmVzaXplbWUuemYudHJpZ2dlciwgd2l0aCBib3VuZCB0aGlzIG9uIF9iaW5kSGFuZGxlci5vblJlc2l6ZU1lQm91bmRcXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogJ19vblJlc2l6ZU1lJyxcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vblJlc2l6ZU1lKGUpIHtcXG4gICAgICB0aGlzLl9yZWZsb3coKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogZnVuY3Rpb24gdG8gaGFuZGxlICRlbGVtZW50cyBwb3N0ZXF1YWxpemVkLnpmLmVxdWFsaXplciwgd2l0aCBib3VuZCB0aGlzIG9uIF9iaW5kSGFuZGxlci5vblBvc3RFcXVhbGl6ZWRCb3VuZFxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAnX29uUG9zdEVxdWFsaXplZCcsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25Qb3N0RXF1YWxpemVkKGUpIHtcXG4gICAgICBpZiAoZS50YXJnZXQgIT09IHRoaXMuJGVsZW1lbnRbMF0pIHtcXG4gICAgICAgIHRoaXMuX3JlZmxvdygpO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogSW5pdGlhbGl6ZXMgZXZlbnRzIGZvciBFcXVhbGl6ZXIuXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6ICdfZXZlbnRzJyxcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9ldmVudHMoKSB7XFxuICAgICAgdmFyIF90aGlzID0gdGhpcztcXG4gICAgICB0aGlzLl9wYXVzZUV2ZW50cygpO1xcbiAgICAgIGlmICh0aGlzLmhhc05lc3RlZCkge1xcbiAgICAgICAgdGhpcy4kZWxlbWVudC5vbigncG9zdGVxdWFsaXplZC56Zi5lcXVhbGl6ZXInLCB0aGlzLl9iaW5kSGFuZGxlci5vblBvc3RFcXVhbGl6ZWRCb3VuZCk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHRoaXMuJGVsZW1lbnQub24oJ3Jlc2l6ZW1lLnpmLnRyaWdnZXInLCB0aGlzLl9iaW5kSGFuZGxlci5vblJlc2l6ZU1lQm91bmQpO1xcbiAgICAgICAgdGhpcy4kZWxlbWVudC5vbignbXV0YXRlbWUuemYudHJpZ2dlcicsIHRoaXMuX2JpbmRIYW5kbGVyLm9uUmVzaXplTWVCb3VuZCk7XFxuICAgICAgfVxcbiAgICAgIHRoaXMuaXNPbiA9IHRydWU7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIENoZWNrcyB0aGUgY3VycmVudCBicmVha3BvaW50IHRvIHRoZSBtaW5pbXVtIHJlcXVpcmVkIHNpemUuXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6ICdfY2hlY2tNUScsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2hlY2tNUSgpIHtcXG4gICAgICB2YXIgdG9vU21hbGwgPSAhX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19mb3VuZGF0aW9uX3V0aWxfbWVkaWFRdWVyeV9fW1xcXCJhXFxcIiAvKiBNZWRpYVF1ZXJ5ICovXS5pcyh0aGlzLm9wdGlvbnMuZXF1YWxpemVPbik7XFxuICAgICAgaWYgKHRvb1NtYWxsKSB7XFxuICAgICAgICBpZiAodGhpcy5pc09uKSB7XFxuICAgICAgICAgIHRoaXMuX3BhdXNlRXZlbnRzKCk7XFxuICAgICAgICAgIHRoaXMuJHdhdGNoZWQuY3NzKCdoZWlnaHQnLCAnYXV0bycpO1xcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBpZiAoIXRoaXMuaXNPbikge1xcbiAgICAgICAgICB0aGlzLl9ldmVudHMoKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgcmV0dXJuIHRvb1NtYWxsO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBBIG5vb3AgdmVyc2lvbiBmb3IgdGhlIHBsdWdpblxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAnX2tpbGxzd2l0Y2gnLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2tpbGxzd2l0Y2goKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDYWxscyBuZWNlc3NhcnkgZnVuY3Rpb25zIHRvIHVwZGF0ZSBFcXVhbGl6ZXIgdXBvbiBET00gY2hhbmdlXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6ICdfcmVmbG93JyxcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZWZsb3coKSB7XFxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuZXF1YWxpemVPblN0YWNrKSB7XFxuICAgICAgICBpZiAodGhpcy5faXNTdGFja2VkKCkpIHtcXG4gICAgICAgICAgdGhpcy4kd2F0Y2hlZC5jc3MoJ2hlaWdodCcsICdhdXRvJyk7XFxuICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lcXVhbGl6ZUJ5Um93KSB7XFxuICAgICAgICB0aGlzLmdldEhlaWdodHNCeVJvdyh0aGlzLmFwcGx5SGVpZ2h0QnlSb3cuYmluZCh0aGlzKSk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHRoaXMuZ2V0SGVpZ2h0cyh0aGlzLmFwcGx5SGVpZ2h0LmJpbmQodGhpcykpO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogTWFudWFsbHkgZGV0ZXJtaW5lcyBpZiB0aGUgZmlyc3QgMiBlbGVtZW50cyBhcmUgKk5PVCogc3RhY2tlZC5cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogJ19pc1N0YWNrZWQnLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2lzU3RhY2tlZCgpIHtcXG4gICAgICBpZiAoIXRoaXMuJHdhdGNoZWRbMF0gfHwgIXRoaXMuJHdhdGNoZWRbMV0pIHtcXG4gICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gdGhpcy4kd2F0Y2hlZFswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgIT09IHRoaXMuJHdhdGNoZWRbMV0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBGaW5kcyB0aGUgb3V0ZXIgaGVpZ2h0cyBvZiBjaGlsZHJlbiBjb250YWluZWQgd2l0aGluIGFuIEVxdWFsaXplciBwYXJlbnQgYW5kIHJldHVybnMgdGhlbSBpbiBhbiBhcnJheVxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiAtIEEgbm9uLW9wdGlvbmFsIGNhbGxiYWNrIHRvIHJldHVybiB0aGUgaGVpZ2h0cyBhcnJheSB0by5cXG4gICAgICogQHJldHVybnMge0FycmF5fSBoZWlnaHRzIC0gQW4gYXJyYXkgb2YgaGVpZ2h0cyBvZiBjaGlsZHJlbiB3aXRoaW4gRXF1YWxpemVyIGNvbnRhaW5lclxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAnZ2V0SGVpZ2h0cycsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRIZWlnaHRzKGNiKSB7XFxuICAgICAgdmFyIGhlaWdodHMgPSBbXTtcXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy4kd2F0Y2hlZC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xcbiAgICAgICAgdGhpcy4kd2F0Y2hlZFtpXS5zdHlsZS5oZWlnaHQgPSAnYXV0byc7XFxuICAgICAgICBoZWlnaHRzLnB1c2godGhpcy4kd2F0Y2hlZFtpXS5vZmZzZXRIZWlnaHQpO1xcbiAgICAgIH1cXG4gICAgICBjYihoZWlnaHRzKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogRmluZHMgdGhlIG91dGVyIGhlaWdodHMgb2YgY2hpbGRyZW4gY29udGFpbmVkIHdpdGhpbiBhbiBFcXVhbGl6ZXIgcGFyZW50IGFuZCByZXR1cm5zIHRoZW0gaW4gYW4gYXJyYXlcXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgLSBBIG5vbi1vcHRpb25hbCBjYWxsYmFjayB0byByZXR1cm4gdGhlIGhlaWdodHMgYXJyYXkgdG8uXFxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gZ3JvdXBzIC0gQW4gYXJyYXkgb2YgaGVpZ2h0cyBvZiBjaGlsZHJlbiB3aXRoaW4gRXF1YWxpemVyIGNvbnRhaW5lciBncm91cGVkIGJ5IHJvdyB3aXRoIGVsZW1lbnQsaGVpZ2h0IGFuZCBtYXggYXMgbGFzdCBjaGlsZFxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAnZ2V0SGVpZ2h0c0J5Um93JyxcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEhlaWdodHNCeVJvdyhjYikge1xcbiAgICAgIHZhciBsYXN0RWxUb3BPZmZzZXQgPSB0aGlzLiR3YXRjaGVkLmxlbmd0aCA/IHRoaXMuJHdhdGNoZWQuZmlyc3QoKS5vZmZzZXQoKS50b3AgOiAwLFxcbiAgICAgICAgICBncm91cHMgPSBbXSxcXG4gICAgICAgICAgZ3JvdXAgPSAwO1xcbiAgICAgIC8vZ3JvdXAgYnkgUm93XFxuICAgICAgZ3JvdXBzW2dyb3VwXSA9IFtdO1xcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLiR3YXRjaGVkLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XFxuICAgICAgICB0aGlzLiR3YXRjaGVkW2ldLnN0eWxlLmhlaWdodCA9ICdhdXRvJztcXG4gICAgICAgIC8vbWF5YmUgY291bGQgdXNlIHRoaXMuJHdhdGNoZWRbaV0ub2Zmc2V0VG9wXFxuICAgICAgICB2YXIgZWxPZmZzZXRUb3AgPSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKHRoaXMuJHdhdGNoZWRbaV0pLm9mZnNldCgpLnRvcDtcXG4gICAgICAgIGlmIChlbE9mZnNldFRvcCAhPSBsYXN0RWxUb3BPZmZzZXQpIHtcXG4gICAgICAgICAgZ3JvdXArKztcXG4gICAgICAgICAgZ3JvdXBzW2dyb3VwXSA9IFtdO1xcbiAgICAgICAgICBsYXN0RWxUb3BPZmZzZXQgPSBlbE9mZnNldFRvcDtcXG4gICAgICAgIH1cXG4gICAgICAgIGdyb3Vwc1tncm91cF0ucHVzaChbdGhpcy4kd2F0Y2hlZFtpXSwgdGhpcy4kd2F0Y2hlZFtpXS5vZmZzZXRIZWlnaHRdKTtcXG4gICAgICB9XFxuXFxuICAgICAgZm9yICh2YXIgaiA9IDAsIGxuID0gZ3JvdXBzLmxlbmd0aDsgaiA8IGxuOyBqKyspIHtcXG4gICAgICAgIHZhciBoZWlnaHRzID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKShncm91cHNbal0pLm1hcChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHJldHVybiB0aGlzWzFdO1xcbiAgICAgICAgfSkuZ2V0KCk7XFxuICAgICAgICB2YXIgbWF4ID0gTWF0aC5tYXguYXBwbHkobnVsbCwgaGVpZ2h0cyk7XFxuICAgICAgICBncm91cHNbal0ucHVzaChtYXgpO1xcbiAgICAgIH1cXG4gICAgICBjYihncm91cHMpO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDaGFuZ2VzIHRoZSBDU1MgaGVpZ2h0IHByb3BlcnR5IG9mIGVhY2ggY2hpbGQgaW4gYW4gRXF1YWxpemVyIHBhcmVudCB0byBtYXRjaCB0aGUgdGFsbGVzdFxcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBoZWlnaHRzIC0gQW4gYXJyYXkgb2YgaGVpZ2h0cyBvZiBjaGlsZHJlbiB3aXRoaW4gRXF1YWxpemVyIGNvbnRhaW5lclxcbiAgICAgKiBAZmlyZXMgRXF1YWxpemVyI3ByZWVxdWFsaXplZFxcbiAgICAgKiBAZmlyZXMgRXF1YWxpemVyI3Bvc3RlcXVhbGl6ZWRcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogJ2FwcGx5SGVpZ2h0JyxcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGx5SGVpZ2h0KGhlaWdodHMpIHtcXG4gICAgICB2YXIgbWF4ID0gTWF0aC5tYXguYXBwbHkobnVsbCwgaGVpZ2h0cyk7XFxuICAgICAgLyoqXFxuICAgICAgICogRmlyZXMgYmVmb3JlIHRoZSBoZWlnaHRzIGFyZSBhcHBsaWVkXFxuICAgICAgICogQGV2ZW50IEVxdWFsaXplciNwcmVlcXVhbGl6ZWRcXG4gICAgICAgKi9cXG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ3ByZWVxdWFsaXplZC56Zi5lcXVhbGl6ZXInKTtcXG5cXG4gICAgICB0aGlzLiR3YXRjaGVkLmNzcygnaGVpZ2h0JywgbWF4KTtcXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBGaXJlcyB3aGVuIHRoZSBoZWlnaHRzIGhhdmUgYmVlbiBhcHBsaWVkXFxuICAgICAgICogQGV2ZW50IEVxdWFsaXplciNwb3N0ZXF1YWxpemVkXFxuICAgICAgICovXFxuICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdwb3N0ZXF1YWxpemVkLnpmLmVxdWFsaXplcicpO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDaGFuZ2VzIHRoZSBDU1MgaGVpZ2h0IHByb3BlcnR5IG9mIGVhY2ggY2hpbGQgaW4gYW4gRXF1YWxpemVyIHBhcmVudCB0byBtYXRjaCB0aGUgdGFsbGVzdCBieSByb3dcXG4gICAgICogQHBhcmFtIHthcnJheX0gZ3JvdXBzIC0gQW4gYXJyYXkgb2YgaGVpZ2h0cyBvZiBjaGlsZHJlbiB3aXRoaW4gRXF1YWxpemVyIGNvbnRhaW5lciBncm91cGVkIGJ5IHJvdyB3aXRoIGVsZW1lbnQsaGVpZ2h0IGFuZCBtYXggYXMgbGFzdCBjaGlsZFxcbiAgICAgKiBAZmlyZXMgRXF1YWxpemVyI3ByZWVxdWFsaXplZFxcbiAgICAgKiBAZmlyZXMgRXF1YWxpemVyI3ByZWVxdWFsaXplZHJvd1xcbiAgICAgKiBAZmlyZXMgRXF1YWxpemVyI3Bvc3RlcXVhbGl6ZWRyb3dcXG4gICAgICogQGZpcmVzIEVxdWFsaXplciNwb3N0ZXF1YWxpemVkXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6ICdhcHBseUhlaWdodEJ5Um93JyxcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGx5SGVpZ2h0QnlSb3coZ3JvdXBzKSB7XFxuICAgICAgLyoqXFxuICAgICAgICogRmlyZXMgYmVmb3JlIHRoZSBoZWlnaHRzIGFyZSBhcHBsaWVkXFxuICAgICAgICovXFxuICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdwcmVlcXVhbGl6ZWQuemYuZXF1YWxpemVyJyk7XFxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xcbiAgICAgICAgdmFyIGdyb3Vwc0lMZW5ndGggPSBncm91cHNbaV0ubGVuZ3RoLFxcbiAgICAgICAgICAgIG1heCA9IGdyb3Vwc1tpXVtncm91cHNJTGVuZ3RoIC0gMV07XFxuICAgICAgICBpZiAoZ3JvdXBzSUxlbmd0aCA8PSAyKSB7XFxuICAgICAgICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0KCkoZ3JvdXBzW2ldWzBdWzBdKS5jc3MoeyAnaGVpZ2h0JzogJ2F1dG8nIH0pO1xcbiAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgIH1cXG4gICAgICAgIC8qKlxcbiAgICAgICAgICAqIEZpcmVzIGJlZm9yZSB0aGUgaGVpZ2h0cyBwZXIgcm93IGFyZSBhcHBsaWVkXFxuICAgICAgICAgICogQGV2ZW50IEVxdWFsaXplciNwcmVlcXVhbGl6ZWRyb3dcXG4gICAgICAgICAgKi9cXG4gICAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcigncHJlZXF1YWxpemVkcm93LnpmLmVxdWFsaXplcicpO1xcbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIGxlbkogPSBncm91cHNJTGVuZ3RoIC0gMTsgaiA8IGxlbko7IGorKykge1xcbiAgICAgICAgICBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKGdyb3Vwc1tpXVtqXVswXSkuY3NzKHsgJ2hlaWdodCc6IG1heCB9KTtcXG4gICAgICAgIH1cXG4gICAgICAgIC8qKlxcbiAgICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIGhlaWdodHMgcGVyIHJvdyBoYXZlIGJlZW4gYXBwbGllZFxcbiAgICAgICAgICAqIEBldmVudCBFcXVhbGl6ZXIjcG9zdGVxdWFsaXplZHJvd1xcbiAgICAgICAgICAqL1xcbiAgICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdwb3N0ZXF1YWxpemVkcm93LnpmLmVxdWFsaXplcicpO1xcbiAgICAgIH1cXG4gICAgICAvKipcXG4gICAgICAgKiBGaXJlcyB3aGVuIHRoZSBoZWlnaHRzIGhhdmUgYmVlbiBhcHBsaWVkXFxuICAgICAgICovXFxuICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdwb3N0ZXF1YWxpemVkLnpmLmVxdWFsaXplcicpO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBEZXN0cm95cyBhbiBpbnN0YW5jZSBvZiBFcXVhbGl6ZXIuXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAnX2Rlc3Ryb3knLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Rlc3Ryb3koKSB7XFxuICAgICAgdGhpcy5fcGF1c2VFdmVudHMoKTtcXG4gICAgICB0aGlzLiR3YXRjaGVkLmNzcygnaGVpZ2h0JywgJ2F1dG8nKTtcXG4gICAgfVxcbiAgfV0pO1xcblxcbiAgcmV0dXJuIEVxdWFsaXplcjtcXG59KF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fZm91bmRhdGlvbl9wbHVnaW5fX1tcXFwiYVxcXCIgLyogUGx1Z2luICovXSk7XFxuXFxuLyoqXFxuICogRGVmYXVsdCBzZXR0aW5ncyBmb3IgcGx1Z2luXFxuICovXFxuXFxuXFxuRXF1YWxpemVyLmRlZmF1bHRzID0ge1xcbiAgLyoqXFxuICAgKiBFbmFibGUgaGVpZ2h0IGVxdWFsaXphdGlvbiB3aGVuIHN0YWNrZWQgb24gc21hbGxlciBzY3JlZW5zLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge2Jvb2xlYW59XFxuICAgKiBAZGVmYXVsdCBmYWxzZVxcbiAgICovXFxuICBlcXVhbGl6ZU9uU3RhY2s6IGZhbHNlLFxcbiAgLyoqXFxuICAgKiBFbmFibGUgaGVpZ2h0IGVxdWFsaXphdGlvbiByb3cgYnkgcm93LlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge2Jvb2xlYW59XFxuICAgKiBAZGVmYXVsdCBmYWxzZVxcbiAgICovXFxuICBlcXVhbGl6ZUJ5Um93OiBmYWxzZSxcXG4gIC8qKlxcbiAgICogU3RyaW5nIHJlcHJlc2VudGluZyB0aGUgbWluaW11bSBicmVha3BvaW50IHNpemUgdGhlIHBsdWdpbiBzaG91bGQgZXF1YWxpemUgaGVpZ2h0cyBvbi5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtzdHJpbmd9XFxuICAgKiBAZGVmYXVsdCAnJ1xcbiAgICovXFxuICBlcXVhbGl6ZU9uOiAnJ1xcbn07XFxuXFxuXFxuXFxuLyoqKi8gfSksXFxuLyogMjQgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImFcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIEludGVyY2hhbmdlOyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLm4oX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19mb3VuZGF0aW9uX3V0aWxfbWVkaWFRdWVyeV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19mb3VuZGF0aW9uX3BsdWdpbl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19mb3VuZGF0aW9uX3V0aWxfY29yZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcXG5cXG5cXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFxcXCJ2YWx1ZVxcXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcXG5cXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpOyB9IH1cXG5cXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXFxcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFxcXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXFxcIm9iamVjdFxcXCIgfHwgdHlwZW9mIGNhbGwgPT09IFxcXCJmdW5jdGlvblxcXCIpID8gY2FsbCA6IHNlbGY7IH1cXG5cXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcXFwiZnVuY3Rpb25cXFwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcXFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxcblxcblxcblxcblxcblxcblxcbi8qKlxcbiAqIEludGVyY2hhbmdlIG1vZHVsZS5cXG4gKiBAbW9kdWxlIGZvdW5kYXRpb24uaW50ZXJjaGFuZ2VcXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLm1lZGlhUXVlcnlcXG4gKi9cXG5cXG52YXIgSW50ZXJjaGFuZ2UgPSBmdW5jdGlvbiAoX1BsdWdpbikge1xcbiAgX2luaGVyaXRzKEludGVyY2hhbmdlLCBfUGx1Z2luKTtcXG5cXG4gIGZ1bmN0aW9uIEludGVyY2hhbmdlKCkge1xcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW50ZXJjaGFuZ2UpO1xcblxcbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEludGVyY2hhbmdlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoSW50ZXJjaGFuZ2UpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcXG4gIH1cXG5cXG4gIF9jcmVhdGVDbGFzcyhJbnRlcmNoYW5nZSwgW3tcXG4gICAga2V5OiAnX3NldHVwJyxcXG5cXG4gICAgLyoqXFxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgSW50ZXJjaGFuZ2UuXFxuICAgICAqIEBjbGFzc1xcbiAgICAgKiBAbmFtZSBJbnRlcmNoYW5nZVxcbiAgICAgKiBAZmlyZXMgSW50ZXJjaGFuZ2UjaW5pdFxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gYWRkIHRoZSB0cmlnZ2VyIHRvLlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlcyB0byB0aGUgZGVmYXVsdCBwbHVnaW4gc2V0dGluZ3MuXFxuICAgICAqL1xcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwKGVsZW1lbnQsIG9wdGlvbnMpIHtcXG4gICAgICB0aGlzLiRlbGVtZW50ID0gZWxlbWVudDtcXG4gICAgICB0aGlzLm9wdGlvbnMgPSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdC5hLmV4dGVuZCh7fSwgSW50ZXJjaGFuZ2UuZGVmYXVsdHMsIG9wdGlvbnMpO1xcbiAgICAgIHRoaXMucnVsZXMgPSBbXTtcXG4gICAgICB0aGlzLmN1cnJlbnRQYXRoID0gJyc7XFxuICAgICAgdGhpcy5jbGFzc05hbWUgPSAnSW50ZXJjaGFuZ2UnOyAvLyBpZTkgYmFjayBjb21wYXRcXG5cXG4gICAgICB0aGlzLl9pbml0KCk7XFxuICAgICAgdGhpcy5fZXZlbnRzKCk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIEluaXRpYWxpemVzIHRoZSBJbnRlcmNoYW5nZSBwbHVnaW4gYW5kIGNhbGxzIGZ1bmN0aW9ucyB0byBnZXQgaW50ZXJjaGFuZ2UgZnVuY3Rpb25pbmcgb24gbG9hZC5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6ICdfaW5pdCcsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdCgpIHtcXG4gICAgICBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX2ZvdW5kYXRpb25fdXRpbF9tZWRpYVF1ZXJ5X19bXFxcImFcXFwiIC8qIE1lZGlhUXVlcnkgKi9dLl9pbml0KCk7XFxuXFxuICAgICAgdmFyIGlkID0gdGhpcy4kZWxlbWVudFswXS5pZCB8fCBfX3dlYnBhY2tfcmVxdWlyZV9fLmkoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19mb3VuZGF0aW9uX3V0aWxfY29yZV9fW1xcXCJiXFxcIiAvKiBHZXRZb0RpZ2l0cyAqL10pKDYsICdpbnRlcmNoYW5nZScpO1xcbiAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cih7XFxuICAgICAgICAnZGF0YS1yZXNpemUnOiBpZCxcXG4gICAgICAgICdpZCc6IGlkXFxuICAgICAgfSk7XFxuXFxuICAgICAgdGhpcy5fYWRkQnJlYWtwb2ludHMoKTtcXG4gICAgICB0aGlzLl9nZW5lcmF0ZVJ1bGVzKCk7XFxuICAgICAgdGhpcy5fcmVmbG93KCk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIEluaXRpYWxpemVzIGV2ZW50cyBmb3IgSW50ZXJjaGFuZ2UuXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAnX2V2ZW50cycsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZXZlbnRzKCkge1xcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xcblxcbiAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKCdyZXNpemVtZS56Zi50cmlnZ2VyJykub24oJ3Jlc2l6ZW1lLnpmLnRyaWdnZXInLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICByZXR1cm4gX3RoaXMzLl9yZWZsb3coKTtcXG4gICAgICB9KTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQ2FsbHMgbmVjZXNzYXJ5IGZ1bmN0aW9ucyB0byB1cGRhdGUgSW50ZXJjaGFuZ2UgdXBvbiBET00gY2hhbmdlXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAnX3JlZmxvdycsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVmbG93KCkge1xcbiAgICAgIHZhciBtYXRjaDtcXG5cXG4gICAgICAvLyBJdGVyYXRlIHRocm91Z2ggZWFjaCBydWxlLCBidXQgb25seSBzYXZlIHRoZSBsYXN0IG1hdGNoXFxuICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLnJ1bGVzKSB7XFxuICAgICAgICBpZiAodGhpcy5ydWxlcy5oYXNPd25Qcm9wZXJ0eShpKSkge1xcbiAgICAgICAgICB2YXIgcnVsZSA9IHRoaXMucnVsZXNbaV07XFxuICAgICAgICAgIGlmICh3aW5kb3cubWF0Y2hNZWRpYShydWxlLnF1ZXJ5KS5tYXRjaGVzKSB7XFxuICAgICAgICAgICAgbWF0Y2ggPSBydWxlO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChtYXRjaCkge1xcbiAgICAgICAgdGhpcy5yZXBsYWNlKG1hdGNoLnBhdGgpO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogR2V0cyB0aGUgRm91bmRhdGlvbiBicmVha3BvaW50cyBhbmQgYWRkcyB0aGVtIHRvIHRoZSBJbnRlcmNoYW5nZS5TUEVDSUFMX1FVRVJJRVMgb2JqZWN0LlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogJ19hZGRCcmVha3BvaW50cycsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYWRkQnJlYWtwb2ludHMoKSB7XFxuICAgICAgZm9yICh2YXIgaSBpbiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX2ZvdW5kYXRpb25fdXRpbF9tZWRpYVF1ZXJ5X19bXFxcImFcXFwiIC8qIE1lZGlhUXVlcnkgKi9dLnF1ZXJpZXMpIHtcXG4gICAgICAgIGlmIChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX2ZvdW5kYXRpb25fdXRpbF9tZWRpYVF1ZXJ5X19bXFxcImFcXFwiIC8qIE1lZGlhUXVlcnkgKi9dLnF1ZXJpZXMuaGFzT3duUHJvcGVydHkoaSkpIHtcXG4gICAgICAgICAgdmFyIHF1ZXJ5ID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19mb3VuZGF0aW9uX3V0aWxfbWVkaWFRdWVyeV9fW1xcXCJhXFxcIiAvKiBNZWRpYVF1ZXJ5ICovXS5xdWVyaWVzW2ldO1xcbiAgICAgICAgICBJbnRlcmNoYW5nZS5TUEVDSUFMX1FVRVJJRVNbcXVlcnkubmFtZV0gPSBxdWVyeS52YWx1ZTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIENoZWNrcyB0aGUgSW50ZXJjaGFuZ2UgZWxlbWVudCBmb3IgdGhlIHByb3ZpZGVkIG1lZGlhIHF1ZXJ5ICsgY29udGVudCBwYWlyaW5nc1xcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRoYXQgaXMgYW4gSW50ZXJjaGFuZ2UgaW5zdGFuY2VcXG4gICAgICogQHJldHVybnMge0FycmF5fSBzY2VuYXJpb3MgLSBBcnJheSBvZiBvYmplY3RzIHRoYXQgaGF2ZSAnbXEnIGFuZCAncGF0aCcga2V5cyB3aXRoIGNvcnJlc3BvbmRpbmcga2V5c1xcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAnX2dlbmVyYXRlUnVsZXMnLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dlbmVyYXRlUnVsZXMoZWxlbWVudCkge1xcbiAgICAgIHZhciBydWxlc0xpc3QgPSBbXTtcXG4gICAgICB2YXIgcnVsZXM7XFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5ydWxlcykge1xcbiAgICAgICAgcnVsZXMgPSB0aGlzLm9wdGlvbnMucnVsZXM7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHJ1bGVzID0gdGhpcy4kZWxlbWVudC5kYXRhKCdpbnRlcmNoYW5nZScpO1xcbiAgICAgIH1cXG5cXG4gICAgICBydWxlcyA9IHR5cGVvZiBydWxlcyA9PT0gJ3N0cmluZycgPyBydWxlcy5tYXRjaCgvXFxcXFsuKj9cXFxcXS9nKSA6IHJ1bGVzO1xcblxcbiAgICAgIGZvciAodmFyIGkgaW4gcnVsZXMpIHtcXG4gICAgICAgIGlmIChydWxlcy5oYXNPd25Qcm9wZXJ0eShpKSkge1xcbiAgICAgICAgICB2YXIgcnVsZSA9IHJ1bGVzW2ldLnNsaWNlKDEsIC0xKS5zcGxpdCgnLCAnKTtcXG4gICAgICAgICAgdmFyIHBhdGggPSBydWxlLnNsaWNlKDAsIC0xKS5qb2luKCcnKTtcXG4gICAgICAgICAgdmFyIHF1ZXJ5ID0gcnVsZVtydWxlLmxlbmd0aCAtIDFdO1xcblxcbiAgICAgICAgICBpZiAoSW50ZXJjaGFuZ2UuU1BFQ0lBTF9RVUVSSUVTW3F1ZXJ5XSkge1xcbiAgICAgICAgICAgIHF1ZXJ5ID0gSW50ZXJjaGFuZ2UuU1BFQ0lBTF9RVUVSSUVTW3F1ZXJ5XTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBydWxlc0xpc3QucHVzaCh7XFxuICAgICAgICAgICAgcGF0aDogcGF0aCxcXG4gICAgICAgICAgICBxdWVyeTogcXVlcnlcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMucnVsZXMgPSBydWxlc0xpc3Q7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIFVwZGF0ZSB0aGUgYHNyY2AgcHJvcGVydHkgb2YgYW4gaW1hZ2UsIG9yIGNoYW5nZSB0aGUgSFRNTCBvZiBhIGNvbnRhaW5lciwgdG8gdGhlIHNwZWNpZmllZCBwYXRoLlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhdGggLSBQYXRoIHRvIHRoZSBpbWFnZSBvciBIVE1MIHBhcnRpYWwuXFxuICAgICAqIEBmaXJlcyBJbnRlcmNoYW5nZSNyZXBsYWNlZFxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAncmVwbGFjZScsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXBsYWNlKHBhdGgpIHtcXG4gICAgICBpZiAodGhpcy5jdXJyZW50UGF0aCA9PT0gcGF0aCkgcmV0dXJuO1xcblxcbiAgICAgIHZhciBfdGhpcyA9IHRoaXMsXFxuICAgICAgICAgIHRyaWdnZXIgPSAncmVwbGFjZWQuemYuaW50ZXJjaGFuZ2UnO1xcblxcbiAgICAgIC8vIFJlcGxhY2luZyBpbWFnZXNcXG4gICAgICBpZiAodGhpcy4kZWxlbWVudFswXS5ub2RlTmFtZSA9PT0gJ0lNRycpIHtcXG4gICAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cignc3JjJywgcGF0aCkub24oJ2xvYWQnLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIF90aGlzLmN1cnJlbnRQYXRoID0gcGF0aDtcXG4gICAgICAgIH0pLnRyaWdnZXIodHJpZ2dlcik7XFxuICAgICAgfVxcbiAgICAgIC8vIFJlcGxhY2luZyBiYWNrZ3JvdW5kIGltYWdlc1xcbiAgICAgIGVsc2UgaWYgKHBhdGgubWF0Y2goL1xcXFwuKGdpZnxqcGd8anBlZ3xwbmd8c3ZnfHRpZmYpKFs/I10uKik/L2kpKSB7XFxuICAgICAgICAgIHBhdGggPSBwYXRoLnJlcGxhY2UoL1xcXFwoL2csICclMjgnKS5yZXBsYWNlKC9cXFxcKS9nLCAnJTI5Jyk7XFxuICAgICAgICAgIHRoaXMuJGVsZW1lbnQuY3NzKHsgJ2JhY2tncm91bmQtaW1hZ2UnOiAndXJsKCcgKyBwYXRoICsgJyknIH0pLnRyaWdnZXIodHJpZ2dlcik7XFxuICAgICAgICB9XFxuICAgICAgICAvLyBSZXBsYWNpbmcgSFRNTFxcbiAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQuYS5nZXQocGF0aCwgZnVuY3Rpb24gKHJlc3BvbnNlKSB7XFxuICAgICAgICAgICAgICBfdGhpcy4kZWxlbWVudC5odG1sKHJlc3BvbnNlKS50cmlnZ2VyKHRyaWdnZXIpO1xcbiAgICAgICAgICAgICAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKShyZXNwb25zZSkuZm91bmRhdGlvbigpO1xcbiAgICAgICAgICAgICAgX3RoaXMuY3VycmVudFBhdGggPSBwYXRoO1xcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgLyoqXFxuICAgICAgICogRmlyZXMgd2hlbiBjb250ZW50IGluIGFuIEludGVyY2hhbmdlIGVsZW1lbnQgaXMgZG9uZSBiZWluZyBsb2FkZWQuXFxuICAgICAgICogQGV2ZW50IEludGVyY2hhbmdlI3JlcGxhY2VkXFxuICAgICAgICovXFxuICAgICAgLy8gdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdyZXBsYWNlZC56Zi5pbnRlcmNoYW5nZScpO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBEZXN0cm95cyBhbiBpbnN0YW5jZSBvZiBpbnRlcmNoYW5nZS5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6ICdfZGVzdHJveScsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVzdHJveSgpIHtcXG4gICAgICB0aGlzLiRlbGVtZW50Lm9mZigncmVzaXplbWUuemYudHJpZ2dlcicpO1xcbiAgICB9XFxuICB9XSk7XFxuXFxuICByZXR1cm4gSW50ZXJjaGFuZ2U7XFxufShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX2ZvdW5kYXRpb25fcGx1Z2luX19bXFxcImFcXFwiIC8qIFBsdWdpbiAqL10pO1xcblxcbi8qKlxcbiAqIERlZmF1bHQgc2V0dGluZ3MgZm9yIHBsdWdpblxcbiAqL1xcblxcblxcbkludGVyY2hhbmdlLmRlZmF1bHRzID0ge1xcbiAgLyoqXFxuICAgKiBSdWxlcyB0byBiZSBhcHBsaWVkIHRvIEludGVyY2hhbmdlIGVsZW1lbnRzLiBTZXQgd2l0aCB0aGUgYGRhdGEtaW50ZXJjaGFuZ2VgIGFycmF5IG5vdGF0aW9uLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUgez9hcnJheX1cXG4gICAqIEBkZWZhdWx0IG51bGxcXG4gICAqL1xcbiAgcnVsZXM6IG51bGxcXG59O1xcblxcbkludGVyY2hhbmdlLlNQRUNJQUxfUVVFUklFUyA9IHtcXG4gICdsYW5kc2NhcGUnOiAnc2NyZWVuIGFuZCAob3JpZW50YXRpb246IGxhbmRzY2FwZSknLFxcbiAgJ3BvcnRyYWl0JzogJ3NjcmVlbiBhbmQgKG9yaWVudGF0aW9uOiBwb3J0cmFpdCknLFxcbiAgJ3JldGluYSc6ICdvbmx5IHNjcmVlbiBhbmQgKC13ZWJraXQtbWluLWRldmljZS1waXhlbC1yYXRpbzogMiksIG9ubHkgc2NyZWVuIGFuZCAobWluLS1tb3otZGV2aWNlLXBpeGVsLXJhdGlvOiAyKSwgb25seSBzY3JlZW4gYW5kICgtby1taW4tZGV2aWNlLXBpeGVsLXJhdGlvOiAyLzEpLCBvbmx5IHNjcmVlbiBhbmQgKG1pbi1kZXZpY2UtcGl4ZWwtcmF0aW86IDIpLCBvbmx5IHNjcmVlbiBhbmQgKG1pbi1yZXNvbHV0aW9uOiAxOTJkcGkpLCBvbmx5IHNjcmVlbiBhbmQgKG1pbi1yZXNvbHV0aW9uOiAyZHBweCknXFxufTtcXG5cXG5cXG5cXG4vKioqLyB9KSxcXG4vKiAyNSAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXFwidXNlIHN0cmljdFxcXCI7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiYVxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gTWFnZWxsYW47IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCA9IF9fd2VicGFja19yZXF1aXJlX18ubihfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX2ZvdW5kYXRpb25fdXRpbF9jb3JlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX2ZvdW5kYXRpb25fcGx1Z2luX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX2ZvdW5kYXRpb25fc21vb3RoU2Nyb2xsX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcXG5cXG5cXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFxcXCJ2YWx1ZVxcXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcXG5cXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpOyB9IH1cXG5cXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXFxcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFxcXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXFxcIm9iamVjdFxcXCIgfHwgdHlwZW9mIGNhbGwgPT09IFxcXCJmdW5jdGlvblxcXCIpID8gY2FsbCA6IHNlbGY7IH1cXG5cXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcXFwiZnVuY3Rpb25cXFwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcXFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxcblxcblxcblxcblxcblxcblxcbi8qKlxcbiAqIE1hZ2VsbGFuIG1vZHVsZS5cXG4gKiBAbW9kdWxlIGZvdW5kYXRpb24ubWFnZWxsYW5cXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi5zbW9vdGhTY3JvbGxcXG4gKi9cXG5cXG52YXIgTWFnZWxsYW4gPSBmdW5jdGlvbiAoX1BsdWdpbikge1xcbiAgX2luaGVyaXRzKE1hZ2VsbGFuLCBfUGx1Z2luKTtcXG5cXG4gIGZ1bmN0aW9uIE1hZ2VsbGFuKCkge1xcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTWFnZWxsYW4pO1xcblxcbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKE1hZ2VsbGFuLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTWFnZWxsYW4pKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcXG4gIH1cXG5cXG4gIF9jcmVhdGVDbGFzcyhNYWdlbGxhbiwgW3tcXG4gICAga2V5OiAnX3NldHVwJyxcXG5cXG4gICAgLyoqXFxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgTWFnZWxsYW4uXFxuICAgICAqIEBjbGFzc1xcbiAgICAgKiBAbmFtZSBNYWdlbGxhblxcbiAgICAgKiBAZmlyZXMgTWFnZWxsYW4jaW5pdFxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gYWRkIHRoZSB0cmlnZ2VyIHRvLlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlcyB0byB0aGUgZGVmYXVsdCBwbHVnaW4gc2V0dGluZ3MuXFxuICAgICAqL1xcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwKGVsZW1lbnQsIG9wdGlvbnMpIHtcXG4gICAgICB0aGlzLiRlbGVtZW50ID0gZWxlbWVudDtcXG4gICAgICB0aGlzLm9wdGlvbnMgPSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdC5hLmV4dGVuZCh7fSwgTWFnZWxsYW4uZGVmYXVsdHMsIHRoaXMuJGVsZW1lbnQuZGF0YSgpLCBvcHRpb25zKTtcXG4gICAgICB0aGlzLmNsYXNzTmFtZSA9ICdNYWdlbGxhbic7IC8vIGllOSBiYWNrIGNvbXBhdFxcblxcbiAgICAgIHRoaXMuX2luaXQoKTtcXG4gICAgICB0aGlzLmNhbGNQb2ludHMoKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIE1hZ2VsbGFuIHBsdWdpbiBhbmQgY2FsbHMgZnVuY3Rpb25zIHRvIGdldCBlcXVhbGl6ZXIgZnVuY3Rpb25pbmcgb24gbG9hZC5cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogJ19pbml0JyxcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0KCkge1xcbiAgICAgIHZhciBpZCA9IHRoaXMuJGVsZW1lbnRbMF0uaWQgfHwgX193ZWJwYWNrX3JlcXVpcmVfXy5pKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fZm91bmRhdGlvbl91dGlsX2NvcmVfX1tcXFwiYlxcXCIgLyogR2V0WW9EaWdpdHMgKi9dKSg2LCAnbWFnZWxsYW4nKTtcXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xcbiAgICAgIHRoaXMuJHRhcmdldHMgPSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKCdbZGF0YS1tYWdlbGxhbi10YXJnZXRdJyk7XFxuICAgICAgdGhpcy4kbGlua3MgPSB0aGlzLiRlbGVtZW50LmZpbmQoJ2EnKTtcXG4gICAgICB0aGlzLiRlbGVtZW50LmF0dHIoe1xcbiAgICAgICAgJ2RhdGEtcmVzaXplJzogaWQsXFxuICAgICAgICAnZGF0YS1zY3JvbGwnOiBpZCxcXG4gICAgICAgICdpZCc6IGlkXFxuICAgICAgfSk7XFxuICAgICAgdGhpcy4kYWN0aXZlID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSgpO1xcbiAgICAgIHRoaXMuc2Nyb2xsUG9zID0gcGFyc2VJbnQod2luZG93LnBhZ2VZT2Zmc2V0LCAxMCk7XFxuXFxuICAgICAgdGhpcy5fZXZlbnRzKCk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIENhbGN1bGF0ZXMgYW4gYXJyYXkgb2YgcGl4ZWwgdmFsdWVzIHRoYXQgYXJlIHRoZSBkZW1hcmNhdGlvbiBsaW5lcyBiZXR3ZWVuIGxvY2F0aW9ucyBvbiB0aGUgcGFnZS5cXG4gICAgICogQ2FuIGJlIGludm9rZWQgaWYgbmV3IGVsZW1lbnRzIGFyZSBhZGRlZCBvciB0aGUgc2l6ZSBvZiBhIGxvY2F0aW9uIGNoYW5nZXMuXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAnY2FsY1BvaW50cycsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxjUG9pbnRzKCkge1xcbiAgICAgIHZhciBfdGhpcyA9IHRoaXMsXFxuICAgICAgICAgIGJvZHkgPSBkb2N1bWVudC5ib2R5LFxcbiAgICAgICAgICBodG1sID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xcblxcbiAgICAgIHRoaXMucG9pbnRzID0gW107XFxuICAgICAgdGhpcy53aW5IZWlnaHQgPSBNYXRoLnJvdW5kKE1hdGgubWF4KHdpbmRvdy5pbm5lckhlaWdodCwgaHRtbC5jbGllbnRIZWlnaHQpKTtcXG4gICAgICB0aGlzLmRvY0hlaWdodCA9IE1hdGgucm91bmQoTWF0aC5tYXgoYm9keS5zY3JvbGxIZWlnaHQsIGJvZHkub2Zmc2V0SGVpZ2h0LCBodG1sLmNsaWVudEhlaWdodCwgaHRtbC5zY3JvbGxIZWlnaHQsIGh0bWwub2Zmc2V0SGVpZ2h0KSk7XFxuXFxuICAgICAgdGhpcy4kdGFyZ2V0cy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciAkdGFyID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSh0aGlzKSxcXG4gICAgICAgICAgICBwdCA9IE1hdGgucm91bmQoJHRhci5vZmZzZXQoKS50b3AgLSBfdGhpcy5vcHRpb25zLnRocmVzaG9sZCk7XFxuICAgICAgICAkdGFyLnRhcmdldFBvaW50ID0gcHQ7XFxuICAgICAgICBfdGhpcy5wb2ludHMucHVzaChwdCk7XFxuICAgICAgfSk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIEluaXRpYWxpemVzIGV2ZW50cyBmb3IgTWFnZWxsYW4uXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6ICdfZXZlbnRzJyxcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9ldmVudHMoKSB7XFxuICAgICAgdmFyIF90aGlzID0gdGhpcyxcXG4gICAgICAgICAgJGJvZHkgPSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKCdodG1sLCBib2R5JyksXFxuICAgICAgICAgIG9wdHMgPSB7XFxuICAgICAgICBkdXJhdGlvbjogX3RoaXMub3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbixcXG4gICAgICAgIGVhc2luZzogX3RoaXMub3B0aW9ucy5hbmltYXRpb25FYXNpbmdcXG4gICAgICB9O1xcbiAgICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0KCkod2luZG93KS5vbmUoJ2xvYWQnLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy5kZWVwTGlua2luZykge1xcbiAgICAgICAgICBpZiAobG9jYXRpb24uaGFzaCkge1xcbiAgICAgICAgICAgIF90aGlzLnNjcm9sbFRvTG9jKGxvY2F0aW9uLmhhc2gpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBfdGhpcy5jYWxjUG9pbnRzKCk7XFxuICAgICAgICBfdGhpcy5fdXBkYXRlQWN0aXZlKCk7XFxuICAgICAgfSk7XFxuXFxuICAgICAgdGhpcy4kZWxlbWVudC5vbih7XFxuICAgICAgICAncmVzaXplbWUuemYudHJpZ2dlcic6IHRoaXMucmVmbG93LmJpbmQodGhpcyksXFxuICAgICAgICAnc2Nyb2xsbWUuemYudHJpZ2dlcic6IHRoaXMuX3VwZGF0ZUFjdGl2ZS5iaW5kKHRoaXMpXFxuICAgICAgfSkub24oJ2NsaWNrLnpmLm1hZ2VsbGFuJywgJ2FbaHJlZl49XFxcIiNcXFwiXScsIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICB2YXIgYXJyaXZhbCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdocmVmJyk7XFxuICAgICAgICBfdGhpcy5zY3JvbGxUb0xvYyhhcnJpdmFsKTtcXG4gICAgICB9KTtcXG5cXG4gICAgICB0aGlzLl9kZWVwTGlua1Njcm9sbCA9IGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy5kZWVwTGlua2luZykge1xcbiAgICAgICAgICBfdGhpcy5zY3JvbGxUb0xvYyh3aW5kb3cubG9jYXRpb24uaGFzaCk7XFxuICAgICAgICB9XFxuICAgICAgfTtcXG5cXG4gICAgICBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKHdpbmRvdykub24oJ3BvcHN0YXRlJywgdGhpcy5fZGVlcExpbmtTY3JvbGwpO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBGdW5jdGlvbiB0byBzY3JvbGwgdG8gYSBnaXZlbiBsb2NhdGlvbiBvbiB0aGUgcGFnZS5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGxvYyAtIGEgcHJvcGVybHkgZm9ybWF0dGVkIGpRdWVyeSBpZCBzZWxlY3Rvci4gRXhhbXBsZTogJyNmb28nXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAnc2Nyb2xsVG9Mb2MnLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2Nyb2xsVG9Mb2MobG9jKSB7XFxuICAgICAgdGhpcy5faW5UcmFuc2l0aW9uID0gdHJ1ZTtcXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xcblxcbiAgICAgIHZhciBvcHRpb25zID0ge1xcbiAgICAgICAgYW5pbWF0aW9uRWFzaW5nOiB0aGlzLm9wdGlvbnMuYW5pbWF0aW9uRWFzaW5nLFxcbiAgICAgICAgYW5pbWF0aW9uRHVyYXRpb246IHRoaXMub3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbixcXG4gICAgICAgIHRocmVzaG9sZDogdGhpcy5vcHRpb25zLnRocmVzaG9sZCxcXG4gICAgICAgIG9mZnNldDogdGhpcy5vcHRpb25zLm9mZnNldFxcbiAgICAgIH07XFxuXFxuICAgICAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19mb3VuZGF0aW9uX3Ntb290aFNjcm9sbF9fW1xcXCJhXFxcIiAvKiBTbW9vdGhTY3JvbGwgKi9dLnNjcm9sbFRvTG9jKGxvYywgb3B0aW9ucywgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgX3RoaXMuX2luVHJhbnNpdGlvbiA9IGZhbHNlO1xcbiAgICAgICAgX3RoaXMuX3VwZGF0ZUFjdGl2ZSgpO1xcbiAgICAgIH0pO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDYWxscyBuZWNlc3NhcnkgZnVuY3Rpb25zIHRvIHVwZGF0ZSBNYWdlbGxhbiB1cG9uIERPTSBjaGFuZ2VcXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6ICdyZWZsb3cnLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVmbG93KCkge1xcbiAgICAgIHRoaXMuY2FsY1BvaW50cygpO1xcbiAgICAgIHRoaXMuX3VwZGF0ZUFjdGl2ZSgpO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBVcGRhdGVzIHRoZSB2aXNpYmlsaXR5IG9mIGFuIGFjdGl2ZSBsb2NhdGlvbiBsaW5rLCBhbmQgdXBkYXRlcyB0aGUgdXJsIGhhc2ggZm9yIHRoZSBwYWdlLCBpZiBkZWVwTGlua2luZyBlbmFibGVkLlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQGZpcmVzIE1hZ2VsbGFuI3VwZGF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAnX3VwZGF0ZUFjdGl2ZScsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlQWN0aXZlKCkgLypldnQsIGVsZW0sIHNjcm9sbFBvcyove1xcbiAgICAgIGlmICh0aGlzLl9pblRyYW5zaXRpb24pIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuICAgICAgdmFyIHdpblBvcyA9IC8qc2Nyb2xsUG9zIHx8Ki9wYXJzZUludCh3aW5kb3cucGFnZVlPZmZzZXQsIDEwKSxcXG4gICAgICAgICAgY3VySWR4O1xcblxcbiAgICAgIGlmICh3aW5Qb3MgKyB0aGlzLndpbkhlaWdodCA9PT0gdGhpcy5kb2NIZWlnaHQpIHtcXG4gICAgICAgIGN1cklkeCA9IHRoaXMucG9pbnRzLmxlbmd0aCAtIDE7XFxuICAgICAgfSBlbHNlIGlmICh3aW5Qb3MgPCB0aGlzLnBvaW50c1swXSkge1xcbiAgICAgICAgY3VySWR4ID0gdW5kZWZpbmVkO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB2YXIgaXNEb3duID0gdGhpcy5zY3JvbGxQb3MgPCB3aW5Qb3MsXFxuICAgICAgICAgICAgX3RoaXMgPSB0aGlzLFxcbiAgICAgICAgICAgIGN1clZpc2libGUgPSB0aGlzLnBvaW50cy5maWx0ZXIoZnVuY3Rpb24gKHAsIGkpIHtcXG4gICAgICAgICAgcmV0dXJuIGlzRG93biA/IHAgLSBfdGhpcy5vcHRpb25zLm9mZnNldCA8PSB3aW5Qb3MgOiBwIC0gX3RoaXMub3B0aW9ucy5vZmZzZXQgLSBfdGhpcy5vcHRpb25zLnRocmVzaG9sZCA8PSB3aW5Qb3M7XFxuICAgICAgICB9KTtcXG4gICAgICAgIGN1cklkeCA9IGN1clZpc2libGUubGVuZ3RoID8gY3VyVmlzaWJsZS5sZW5ndGggLSAxIDogMDtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy4kYWN0aXZlLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5hY3RpdmVDbGFzcyk7XFxuICAgICAgdGhpcy4kYWN0aXZlID0gdGhpcy4kbGlua3MuZmlsdGVyKCdbaHJlZj1cXFwiIycgKyB0aGlzLiR0YXJnZXRzLmVxKGN1cklkeCkuZGF0YSgnbWFnZWxsYW4tdGFyZ2V0JykgKyAnXFxcIl0nKS5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuYWN0aXZlQ2xhc3MpO1xcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGVlcExpbmtpbmcpIHtcXG4gICAgICAgIHZhciBoYXNoID0gXFxcIlxcXCI7XFxuICAgICAgICBpZiAoY3VySWR4ICE9IHVuZGVmaW5lZCkge1xcbiAgICAgICAgICBoYXNoID0gdGhpcy4kYWN0aXZlWzBdLmdldEF0dHJpYnV0ZSgnaHJlZicpO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKGhhc2ggIT09IHdpbmRvdy5sb2NhdGlvbi5oYXNoKSB7XFxuICAgICAgICAgIGlmICh3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUpIHtcXG4gICAgICAgICAgICB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUobnVsbCwgbnVsbCwgaGFzaCk7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhhc2ggPSBoYXNoO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuc2Nyb2xsUG9zID0gd2luUG9zO1xcbiAgICAgIC8qKlxcbiAgICAgICAqIEZpcmVzIHdoZW4gbWFnZWxsYW4gaXMgZmluaXNoZWQgdXBkYXRpbmcgdG8gdGhlIG5ldyBhY3RpdmUgZWxlbWVudC5cXG4gICAgICAgKiBAZXZlbnQgTWFnZWxsYW4jdXBkYXRlXFxuICAgICAgICovXFxuICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCd1cGRhdGUuemYubWFnZWxsYW4nLCBbdGhpcy4kYWN0aXZlXSk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIERlc3Ryb3lzIGFuIGluc3RhbmNlIG9mIE1hZ2VsbGFuIGFuZCByZXNldHMgdGhlIHVybCBvZiB0aGUgd2luZG93LlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogJ19kZXN0cm95JyxcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZXN0cm95KCkge1xcbiAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKCcuemYudHJpZ2dlciAuemYubWFnZWxsYW4nKS5maW5kKCcuJyArIHRoaXMub3B0aW9ucy5hY3RpdmVDbGFzcykucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmFjdGl2ZUNsYXNzKTtcXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmRlZXBMaW5raW5nKSB7XFxuICAgICAgICB2YXIgaGFzaCA9IHRoaXMuJGFjdGl2ZVswXS5nZXRBdHRyaWJ1dGUoJ2hyZWYnKTtcXG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5oYXNoLnJlcGxhY2UoaGFzaCwgJycpO1xcbiAgICAgIH1cXG4gICAgICBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKHdpbmRvdykub2ZmKCdwb3BzdGF0ZScsIHRoaXMuX2RlZXBMaW5rU2Nyb2xsKTtcXG4gICAgfVxcbiAgfV0pO1xcblxcbiAgcmV0dXJuIE1hZ2VsbGFuO1xcbn0oX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19mb3VuZGF0aW9uX3BsdWdpbl9fW1xcXCJhXFxcIiAvKiBQbHVnaW4gKi9dKTtcXG5cXG4vKipcXG4gKiBEZWZhdWx0IHNldHRpbmdzIGZvciBwbHVnaW5cXG4gKi9cXG5cXG5cXG5NYWdlbGxhbi5kZWZhdWx0cyA9IHtcXG4gIC8qKlxcbiAgICogQW1vdW50IG9mIHRpbWUsIGluIG1zLCB0aGUgYW5pbWF0ZWQgc2Nyb2xsaW5nIHNob3VsZCB0YWtlIGJldHdlZW4gbG9jYXRpb25zLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge251bWJlcn1cXG4gICAqIEBkZWZhdWx0IDUwMFxcbiAgICovXFxuICBhbmltYXRpb25EdXJhdGlvbjogNTAwLFxcbiAgLyoqXFxuICAgKiBBbmltYXRpb24gc3R5bGUgdG8gdXNlIHdoZW4gc2Nyb2xsaW5nIGJldHdlZW4gbG9jYXRpb25zLiBDYW4gYmUgYCdzd2luZydgIG9yIGAnbGluZWFyJ2AuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7c3RyaW5nfVxcbiAgICogQGRlZmF1bHQgJ2xpbmVhcidcXG4gICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vYXBpLmpxdWVyeS5jb20vYW5pbWF0ZXxKcXVlcnkgYW5pbWF0ZX1cXG4gICAqL1xcbiAgYW5pbWF0aW9uRWFzaW5nOiAnbGluZWFyJyxcXG4gIC8qKlxcbiAgICogTnVtYmVyIG9mIHBpeGVscyB0byB1c2UgYXMgYSBtYXJrZXIgZm9yIGxvY2F0aW9uIGNoYW5nZXMuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7bnVtYmVyfVxcbiAgICogQGRlZmF1bHQgNTBcXG4gICAqL1xcbiAgdGhyZXNob2xkOiA1MCxcXG4gIC8qKlxcbiAgICogQ2xhc3MgYXBwbGllZCB0byB0aGUgYWN0aXZlIGxvY2F0aW9ucyBsaW5rIG9uIHRoZSBtYWdlbGxhbiBjb250YWluZXIuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7c3RyaW5nfVxcbiAgICogQGRlZmF1bHQgJ2lzLWFjdGl2ZSdcXG4gICAqL1xcbiAgYWN0aXZlQ2xhc3M6ICdpcy1hY3RpdmUnLFxcbiAgLyoqXFxuICAgKiBBbGxvd3MgdGhlIHNjcmlwdCB0byBtYW5pcHVsYXRlIHRoZSB1cmwgb2YgdGhlIGN1cnJlbnQgcGFnZSwgYW5kIGlmIHN1cHBvcnRlZCwgYWx0ZXIgdGhlIGhpc3RvcnkuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IGZhbHNlXFxuICAgKi9cXG4gIGRlZXBMaW5raW5nOiBmYWxzZSxcXG4gIC8qKlxcbiAgICogTnVtYmVyIG9mIHBpeGVscyB0byBvZmZzZXQgdGhlIHNjcm9sbCBvZiB0aGUgcGFnZSBvbiBpdGVtIGNsaWNrIGlmIHVzaW5nIGEgc3RpY2t5IG5hdiBiYXIuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7bnVtYmVyfVxcbiAgICogQGRlZmF1bHQgMFxcbiAgICovXFxuICBvZmZzZXQ6IDBcXG59O1xcblxcblxcblxcbi8qKiovIH0pLFxcbi8qIDI2ICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJhXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBPZmZDYW52YXM7IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCA9IF9fd2VicGFja19yZXF1aXJlX18ubihfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX2ZvdW5kYXRpb25fdXRpbF9rZXlib2FyZF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19mb3VuZGF0aW9uX3V0aWxfbWVkaWFRdWVyeV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19mb3VuZGF0aW9uX3V0aWxfY29yZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19mb3VuZGF0aW9uX3BsdWdpbl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19mb3VuZGF0aW9uX3V0aWxfdHJpZ2dlcnNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XFxuXFxuXFxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcXFwidmFsdWVcXFwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XFxuXFxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTsgfSB9XFxuXFxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFxcXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcXFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFxcXCJvYmplY3RcXFwiIHx8IHR5cGVvZiBjYWxsID09PSBcXFwiZnVuY3Rpb25cXFwiKSA/IGNhbGwgOiBzZWxmOyB9XFxuXFxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXFxcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG4vKipcXG4gKiBPZmZDYW52YXMgbW9kdWxlLlxcbiAqIEBtb2R1bGUgZm91bmRhdGlvbi5vZmZjYW52YXNcXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLmtleWJvYXJkXFxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5tZWRpYVF1ZXJ5XFxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC50cmlnZ2Vyc1xcbiAqL1xcblxcbnZhciBPZmZDYW52YXMgPSBmdW5jdGlvbiAoX1BsdWdpbikge1xcbiAgX2luaGVyaXRzKE9mZkNhbnZhcywgX1BsdWdpbik7XFxuXFxuICBmdW5jdGlvbiBPZmZDYW52YXMoKSB7XFxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBPZmZDYW52YXMpO1xcblxcbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKE9mZkNhbnZhcy5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKE9mZkNhbnZhcykpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xcbiAgfVxcblxcbiAgX2NyZWF0ZUNsYXNzKE9mZkNhbnZhcywgW3tcXG4gICAga2V5OiAnX3NldHVwJyxcXG5cXG4gICAgLyoqXFxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgYW4gb2ZmLWNhbnZhcyB3cmFwcGVyLlxcbiAgICAgKiBAY2xhc3NcXG4gICAgICogQG5hbWUgT2ZmQ2FudmFzXFxuICAgICAqIEBmaXJlcyBPZmZDYW52YXMjaW5pdFxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gaW5pdGlhbGl6ZS5cXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZXMgdG8gdGhlIGRlZmF1bHQgcGx1Z2luIHNldHRpbmdzLlxcbiAgICAgKi9cXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cChlbGVtZW50LCBvcHRpb25zKSB7XFxuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XFxuXFxuICAgICAgdGhpcy5jbGFzc05hbWUgPSAnT2ZmQ2FudmFzJzsgLy8gaWU5IGJhY2sgY29tcGF0XFxuICAgICAgdGhpcy4kZWxlbWVudCA9IGVsZW1lbnQ7XFxuICAgICAgdGhpcy5vcHRpb25zID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQuYS5leHRlbmQoe30sIE9mZkNhbnZhcy5kZWZhdWx0cywgdGhpcy4kZWxlbWVudC5kYXRhKCksIG9wdGlvbnMpO1xcbiAgICAgIHRoaXMuY29udGVudENsYXNzZXMgPSB7IGJhc2U6IFtdLCByZXZlYWw6IFtdIH07XFxuICAgICAgdGhpcy4kbGFzdFRyaWdnZXIgPSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKCk7XFxuICAgICAgdGhpcy4kdHJpZ2dlcnMgPSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKCk7XFxuICAgICAgdGhpcy5wb3NpdGlvbiA9ICdsZWZ0JztcXG4gICAgICB0aGlzLiRjb250ZW50ID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSgpO1xcbiAgICAgIHRoaXMubmVzdGVkID0gISF0aGlzLm9wdGlvbnMubmVzdGVkO1xcblxcbiAgICAgIC8vIERlZmluZXMgdGhlIENTUyB0cmFuc2l0aW9uL3Bvc2l0aW9uIGNsYXNzZXMgb2YgdGhlIG9mZi1jYW52YXMgY29udGVudCBjb250YWluZXIuXFxuICAgICAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKShbJ3B1c2gnLCAnb3ZlcmxhcCddKS5lYWNoKGZ1bmN0aW9uIChpbmRleCwgdmFsKSB7XFxuICAgICAgICBfdGhpczMuY29udGVudENsYXNzZXMuYmFzZS5wdXNoKCdoYXMtdHJhbnNpdGlvbi0nICsgdmFsKTtcXG4gICAgICB9KTtcXG4gICAgICBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKFsnbGVmdCcsICdyaWdodCcsICd0b3AnLCAnYm90dG9tJ10pLmVhY2goZnVuY3Rpb24gKGluZGV4LCB2YWwpIHtcXG4gICAgICAgIF90aGlzMy5jb250ZW50Q2xhc3Nlcy5iYXNlLnB1c2goJ2hhcy1wb3NpdGlvbi0nICsgdmFsKTtcXG4gICAgICAgIF90aGlzMy5jb250ZW50Q2xhc3Nlcy5yZXZlYWwucHVzaCgnaGFzLXJldmVhbC0nICsgdmFsKTtcXG4gICAgICB9KTtcXG5cXG4gICAgICAvLyBUcmlnZ2VycyBpbml0IGlzIGlkZW1wb3RlbnQsIGp1c3QgbmVlZCB0byBtYWtlIHN1cmUgaXQgaXMgaW5pdGlhbGl6ZWRcXG4gICAgICBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX2ZvdW5kYXRpb25fdXRpbF90cmlnZ2Vyc19fW1xcXCJhXFxcIiAvKiBUcmlnZ2VycyAqL10uaW5pdChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdC5hKTtcXG4gICAgICBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX2ZvdW5kYXRpb25fdXRpbF9tZWRpYVF1ZXJ5X19bXFxcImFcXFwiIC8qIE1lZGlhUXVlcnkgKi9dLl9pbml0KCk7XFxuXFxuICAgICAgdGhpcy5faW5pdCgpO1xcbiAgICAgIHRoaXMuX2V2ZW50cygpO1xcblxcbiAgICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fZm91bmRhdGlvbl91dGlsX2tleWJvYXJkX19bXFxcImFcXFwiIC8qIEtleWJvYXJkICovXS5yZWdpc3RlcignT2ZmQ2FudmFzJywge1xcbiAgICAgICAgJ0VTQ0FQRSc6ICdjbG9zZSdcXG4gICAgICB9KTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIG9mZi1jYW52YXMgd3JhcHBlciBieSBhZGRpbmcgdGhlIGV4aXQgb3ZlcmxheSAoaWYgbmVlZGVkKS5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6ICdfaW5pdCcsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdCgpIHtcXG4gICAgICB2YXIgaWQgPSB0aGlzLiRlbGVtZW50LmF0dHIoJ2lkJyk7XFxuXFxuICAgICAgdGhpcy4kZWxlbWVudC5hdHRyKCdhcmlhLWhpZGRlbicsICd0cnVlJyk7XFxuXFxuICAgICAgLy8gRmluZCBvZmYtY2FudmFzIGNvbnRlbnQsIGVpdGhlciBieSBJRCAoaWYgc3BlY2lmaWVkKSwgYnkgc2libGluZ3Mgb3IgYnkgY2xvc2VzdCBzZWxlY3RvciAoZmFsbGJhY2spXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5jb250ZW50SWQpIHtcXG4gICAgICAgIHRoaXMuJGNvbnRlbnQgPSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKCcjJyArIHRoaXMub3B0aW9ucy5jb250ZW50SWQpO1xcbiAgICAgIH0gZWxzZSBpZiAodGhpcy4kZWxlbWVudC5zaWJsaW5ncygnW2RhdGEtb2ZmLWNhbnZhcy1jb250ZW50XScpLmxlbmd0aCkge1xcbiAgICAgICAgdGhpcy4kY29udGVudCA9IHRoaXMuJGVsZW1lbnQuc2libGluZ3MoJ1tkYXRhLW9mZi1jYW52YXMtY29udGVudF0nKS5maXJzdCgpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB0aGlzLiRjb250ZW50ID0gdGhpcy4kZWxlbWVudC5jbG9zZXN0KCdbZGF0YS1vZmYtY2FudmFzLWNvbnRlbnRdJykuZmlyc3QoKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuY29udGVudElkKSB7XFxuICAgICAgICAvLyBBc3N1bWUgdGhhdCB0aGUgb2ZmLWNhbnZhcyBlbGVtZW50IGlzIG5lc3RlZCBpZiBpdCBpc24ndCBhIHNpYmxpbmcgb2YgdGhlIGNvbnRlbnRcXG4gICAgICAgIHRoaXMubmVzdGVkID0gdGhpcy4kZWxlbWVudC5zaWJsaW5ncygnW2RhdGEtb2ZmLWNhbnZhcy1jb250ZW50XScpLmxlbmd0aCA9PT0gMDtcXG4gICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5jb250ZW50SWQgJiYgdGhpcy5vcHRpb25zLm5lc3RlZCA9PT0gbnVsbCkge1xcbiAgICAgICAgLy8gV2FybmluZyBpZiB1c2luZyBjb250ZW50IElEIHdpdGhvdXQgc2V0dGluZyB0aGUgbmVzdGVkIG9wdGlvblxcbiAgICAgICAgLy8gT25jZSB0aGUgZWxlbWVudCBpcyBuZXN0ZWQgaXQgaXMgcmVxdWlyZWQgdG8gd29yayBwcm9wZXJseSBpbiB0aGlzIGNhc2VcXG4gICAgICAgIGNvbnNvbGUud2FybignUmVtZW1iZXIgdG8gdXNlIHRoZSBuZXN0ZWQgb3B0aW9uIGlmIHVzaW5nIHRoZSBjb250ZW50IElEIG9wdGlvbiEnKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRoaXMubmVzdGVkID09PSB0cnVlKSB7XFxuICAgICAgICAvLyBGb3JjZSB0cmFuc2l0aW9uIG92ZXJsYXAgaWYgbmVzdGVkXFxuICAgICAgICB0aGlzLm9wdGlvbnMudHJhbnNpdGlvbiA9ICdvdmVybGFwJztcXG4gICAgICAgIC8vIFJlbW92ZSBhcHByb3ByaWF0ZSBjbGFzc2VzIGlmIGFscmVhZHkgYXNzaWduZWQgaW4gbWFya3VwXFxuICAgICAgICB0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKCdpcy10cmFuc2l0aW9uLXB1c2gnKTtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy4kZWxlbWVudC5hZGRDbGFzcygnaXMtdHJhbnNpdGlvbi0nICsgdGhpcy5vcHRpb25zLnRyYW5zaXRpb24gKyAnIGlzLWNsb3NlZCcpO1xcblxcbiAgICAgIC8vIEZpbmQgdHJpZ2dlcnMgdGhhdCBhZmZlY3QgdGhpcyBlbGVtZW50IGFuZCBhZGQgYXJpYS1leHBhbmRlZCB0byB0aGVtXFxuICAgICAgdGhpcy4kdHJpZ2dlcnMgPSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKGRvY3VtZW50KS5maW5kKCdbZGF0YS1vcGVuPVxcXCInICsgaWQgKyAnXFxcIl0sIFtkYXRhLWNsb3NlPVxcXCInICsgaWQgKyAnXFxcIl0sIFtkYXRhLXRvZ2dsZT1cXFwiJyArIGlkICsgJ1xcXCJdJykuYXR0cignYXJpYS1leHBhbmRlZCcsICdmYWxzZScpLmF0dHIoJ2FyaWEtY29udHJvbHMnLCBpZCk7XFxuXFxuICAgICAgLy8gR2V0IHBvc2l0aW9uIGJ5IGNoZWNraW5nIGZvciByZWxhdGVkIENTUyBjbGFzc1xcbiAgICAgIHRoaXMucG9zaXRpb24gPSB0aGlzLiRlbGVtZW50LmlzKCcucG9zaXRpb24tbGVmdCwgLnBvc2l0aW9uLXRvcCwgLnBvc2l0aW9uLXJpZ2h0LCAucG9zaXRpb24tYm90dG9tJykgPyB0aGlzLiRlbGVtZW50LmF0dHIoJ2NsYXNzJykubWF0Y2goL3Bvc2l0aW9uXFxcXC0obGVmdHx0b3B8cmlnaHR8Ym90dG9tKS8pWzFdIDogdGhpcy5wb3NpdGlvbjtcXG5cXG4gICAgICAvLyBBZGQgYW4gb3ZlcmxheSBvdmVyIHRoZSBjb250ZW50IGlmIG5lY2Vzc2FyeVxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuY29udGVudE92ZXJsYXkgPT09IHRydWUpIHtcXG4gICAgICAgIHZhciBvdmVybGF5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XFxuICAgICAgICB2YXIgb3ZlcmxheVBvc2l0aW9uID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSh0aGlzLiRlbGVtZW50KS5jc3MoXFxcInBvc2l0aW9uXFxcIikgPT09ICdmaXhlZCcgPyAnaXMtb3ZlcmxheS1maXhlZCcgOiAnaXMtb3ZlcmxheS1hYnNvbHV0ZSc7XFxuICAgICAgICBvdmVybGF5LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnanMtb2ZmLWNhbnZhcy1vdmVybGF5ICcgKyBvdmVybGF5UG9zaXRpb24pO1xcbiAgICAgICAgdGhpcy4kb3ZlcmxheSA9IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0KCkob3ZlcmxheSk7XFxuICAgICAgICBpZiAob3ZlcmxheVBvc2l0aW9uID09PSAnaXMtb3ZlcmxheS1maXhlZCcpIHtcXG4gICAgICAgICAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSh0aGlzLiRvdmVybGF5KS5pbnNlcnRBZnRlcih0aGlzLiRlbGVtZW50KTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHRoaXMuJGNvbnRlbnQuYXBwZW5kKHRoaXMuJG92ZXJsYXkpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLm9wdGlvbnMuaXNSZXZlYWxlZCA9IHRoaXMub3B0aW9ucy5pc1JldmVhbGVkIHx8IG5ldyBSZWdFeHAodGhpcy5vcHRpb25zLnJldmVhbENsYXNzLCAnZycpLnRlc3QodGhpcy4kZWxlbWVudFswXS5jbGFzc05hbWUpO1xcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaXNSZXZlYWxlZCA9PT0gdHJ1ZSkge1xcbiAgICAgICAgdGhpcy5vcHRpb25zLnJldmVhbE9uID0gdGhpcy5vcHRpb25zLnJldmVhbE9uIHx8IHRoaXMuJGVsZW1lbnRbMF0uY2xhc3NOYW1lLm1hdGNoKC8ocmV2ZWFsLWZvci1tZWRpdW18cmV2ZWFsLWZvci1sYXJnZSkvZylbMF0uc3BsaXQoJy0nKVsyXTtcXG4gICAgICAgIHRoaXMuX3NldE1RQ2hlY2tlcigpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnRyYW5zaXRpb25UaW1lKSB7XFxuICAgICAgICB0aGlzLiRlbGVtZW50LmNzcygndHJhbnNpdGlvbi1kdXJhdGlvbicsIHRoaXMub3B0aW9ucy50cmFuc2l0aW9uVGltZSk7XFxuICAgICAgfVxcblxcbiAgICAgIC8vIEluaXRhbGx5IHJlbW92ZSBhbGwgdHJhbnNpdGlvbi9wb3NpdGlvbiBDU1MgY2xhc3NlcyBmcm9tIG9mZi1jYW52YXMgY29udGVudCBjb250YWluZXIuXFxuICAgICAgdGhpcy5fcmVtb3ZlQ29udGVudENsYXNzZXMoKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQWRkcyBldmVudCBoYW5kbGVycyB0byB0aGUgb2ZmLWNhbnZhcyB3cmFwcGVyIGFuZCB0aGUgZXhpdCBvdmVybGF5LlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogJ19ldmVudHMnLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2V2ZW50cygpIHtcXG4gICAgICB0aGlzLiRlbGVtZW50Lm9mZignLnpmLnRyaWdnZXIgLnpmLm9mZmNhbnZhcycpLm9uKHtcXG4gICAgICAgICdvcGVuLnpmLnRyaWdnZXInOiB0aGlzLm9wZW4uYmluZCh0aGlzKSxcXG4gICAgICAgICdjbG9zZS56Zi50cmlnZ2VyJzogdGhpcy5jbG9zZS5iaW5kKHRoaXMpLFxcbiAgICAgICAgJ3RvZ2dsZS56Zi50cmlnZ2VyJzogdGhpcy50b2dnbGUuYmluZCh0aGlzKSxcXG4gICAgICAgICdrZXlkb3duLnpmLm9mZmNhbnZhcyc6IHRoaXMuX2hhbmRsZUtleWJvYXJkLmJpbmQodGhpcylcXG4gICAgICB9KTtcXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmNsb3NlT25DbGljayA9PT0gdHJ1ZSkge1xcbiAgICAgICAgdmFyICR0YXJnZXQgPSB0aGlzLm9wdGlvbnMuY29udGVudE92ZXJsYXkgPyB0aGlzLiRvdmVybGF5IDogdGhpcy4kY29udGVudDtcXG4gICAgICAgICR0YXJnZXQub24oeyAnY2xpY2suemYub2ZmY2FudmFzJzogdGhpcy5jbG9zZS5iaW5kKHRoaXMpIH0pO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQXBwbGllcyBldmVudCBsaXN0ZW5lciBmb3IgZWxlbWVudHMgdGhhdCB3aWxsIHJldmVhbCBhdCBjZXJ0YWluIGJyZWFrcG9pbnRzLlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAnX3NldE1RQ2hlY2tlcicsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0TVFDaGVja2VyKCkge1xcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuXFxuICAgICAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSh3aW5kb3cpLm9uKCdjaGFuZ2VkLnpmLm1lZGlhcXVlcnknLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICBpZiAoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19mb3VuZGF0aW9uX3V0aWxfbWVkaWFRdWVyeV9fW1xcXCJhXFxcIiAvKiBNZWRpYVF1ZXJ5ICovXS5hdExlYXN0KF90aGlzLm9wdGlvbnMucmV2ZWFsT24pKSB7XFxuICAgICAgICAgIF90aGlzLnJldmVhbCh0cnVlKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIF90aGlzLnJldmVhbChmYWxzZSk7XFxuICAgICAgICB9XFxuICAgICAgfSkub25lKCdsb2FkLnpmLm9mZmNhbnZhcycsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGlmIChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX2ZvdW5kYXRpb25fdXRpbF9tZWRpYVF1ZXJ5X19bXFxcImFcXFwiIC8qIE1lZGlhUXVlcnkgKi9dLmF0TGVhc3QoX3RoaXMub3B0aW9ucy5yZXZlYWxPbikpIHtcXG4gICAgICAgICAgX3RoaXMucmV2ZWFsKHRydWUpO1xcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBSZW1vdmVzIHRoZSBDU1MgdHJhbnNpdGlvbi9wb3NpdGlvbiBjbGFzc2VzIG9mIHRoZSBvZmYtY2FudmFzIGNvbnRlbnQgY29udGFpbmVyLlxcbiAgICAgKiBSZW1vdmluZyB0aGUgY2xhc3NlcyBpcyBpbXBvcnRhbnQgd2hlbiBhbm90aGVyIG9mZi1jYW52YXMgZ2V0cyBvcGVuZWQgdGhhdCB1c2VzIHRoZSBzYW1lIGNvbnRlbnQgY29udGFpbmVyLlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAnX3JlbW92ZUNvbnRlbnRDbGFzc2VzJyxcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW1vdmVDb250ZW50Q2xhc3NlcyhoYXNSZXZlYWwpIHtcXG4gICAgICB0aGlzLiRjb250ZW50LnJlbW92ZUNsYXNzKHRoaXMuY29udGVudENsYXNzZXMuYmFzZS5qb2luKCcgJykpO1xcbiAgICAgIGlmIChoYXNSZXZlYWwgPT09IHRydWUpIHtcXG4gICAgICAgIHRoaXMuJGNvbnRlbnQucmVtb3ZlQ2xhc3ModGhpcy5jb250ZW50Q2xhc3Nlcy5yZXZlYWwuam9pbignICcpKTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIEFkZHMgdGhlIENTUyB0cmFuc2l0aW9uL3Bvc2l0aW9uIGNsYXNzZXMgb2YgdGhlIG9mZi1jYW52YXMgY29udGVudCBjb250YWluZXIsIGJhc2VkIG9uIHRoZSBvcGVuaW5nIG9mZi1jYW52YXMgZWxlbWVudC5cXG4gICAgICogQmVmb3JlaGFuZCBhbnkgdHJhbnNpdGlvbi9wb3NpdGlvbiBjbGFzcyBnZXRzIHJlbW92ZWQuXFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaGFzUmV2ZWFsIC0gdHJ1ZSBpZiByZWxhdGVkIG9mZi1jYW52YXMgZWxlbWVudCBpcyByZXZlYWxlZC5cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogJ19hZGRDb250ZW50Q2xhc3NlcycsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYWRkQ29udGVudENsYXNzZXMoaGFzUmV2ZWFsKSB7XFxuICAgICAgdGhpcy5fcmVtb3ZlQ29udGVudENsYXNzZXMoKTtcXG4gICAgICB0aGlzLiRjb250ZW50LmFkZENsYXNzKCdoYXMtdHJhbnNpdGlvbi0nICsgdGhpcy5vcHRpb25zLnRyYW5zaXRpb24gKyAnIGhhcy1wb3NpdGlvbi0nICsgdGhpcy5wb3NpdGlvbik7XFxuICAgICAgaWYgKGhhc1JldmVhbCA9PT0gdHJ1ZSkge1xcbiAgICAgICAgdGhpcy4kY29udGVudC5hZGRDbGFzcygnaGFzLXJldmVhbC0nICsgdGhpcy5wb3NpdGlvbik7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBIYW5kbGVzIHRoZSByZXZlYWxpbmcvaGlkaW5nIHRoZSBvZmYtY2FudmFzIGF0IGJyZWFrcG9pbnRzLCBub3QgdGhlIHNhbWUgYXMgb3Blbi5cXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBpc1JldmVhbGVkIC0gdHJ1ZSBpZiBlbGVtZW50IHNob3VsZCBiZSByZXZlYWxlZC5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6ICdyZXZlYWwnLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmV2ZWFsKGlzUmV2ZWFsZWQpIHtcXG4gICAgICBpZiAoaXNSZXZlYWxlZCkge1xcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xcbiAgICAgICAgdGhpcy5pc1JldmVhbGVkID0gdHJ1ZTtcXG4gICAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cignYXJpYS1oaWRkZW4nLCAnZmFsc2UnKTtcXG4gICAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKCdvcGVuLnpmLnRyaWdnZXIgdG9nZ2xlLnpmLnRyaWdnZXInKTtcXG4gICAgICAgIHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3MoJ2lzLWNsb3NlZCcpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB0aGlzLmlzUmV2ZWFsZWQgPSBmYWxzZTtcXG4gICAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cignYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xcbiAgICAgICAgdGhpcy4kZWxlbWVudC5vZmYoJ29wZW4uemYudHJpZ2dlciB0b2dnbGUuemYudHJpZ2dlcicpLm9uKHtcXG4gICAgICAgICAgJ29wZW4uemYudHJpZ2dlcic6IHRoaXMub3Blbi5iaW5kKHRoaXMpLFxcbiAgICAgICAgICAndG9nZ2xlLnpmLnRyaWdnZXInOiB0aGlzLnRvZ2dsZS5iaW5kKHRoaXMpXFxuICAgICAgICB9KTtcXG4gICAgICAgIHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3MoJ2lzLWNsb3NlZCcpO1xcbiAgICAgIH1cXG4gICAgICB0aGlzLl9hZGRDb250ZW50Q2xhc3Nlcyhpc1JldmVhbGVkKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogU3RvcHMgc2Nyb2xsaW5nIG9mIHRoZSBib2R5IHdoZW4gb2ZmY2FudmFzIGlzIG9wZW4gb24gbW9iaWxlIFNhZmFyaSBhbmQgb3RoZXIgdHJvdWJsZXNvbWUgYnJvd3NlcnMuXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6ICdfc3RvcFNjcm9sbGluZycsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc3RvcFNjcm9sbGluZyhldmVudCkge1xcbiAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcblxcbiAgICAvLyBUYWtlbiBhbmQgYWRhcHRlZCBmcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTY4ODk0NDcvcHJldmVudC1mdWxsLXBhZ2Utc2Nyb2xsaW5nLWlvc1xcbiAgICAvLyBPbmx5IHJlYWxseSB3b3JrcyBmb3IgeSwgbm90IHN1cmUgaG93IHRvIGV4dGVuZCB0byB4IG9yIGlmIHdlIG5lZWQgdG8uXFxuXFxuICB9LCB7XFxuICAgIGtleTogJ19yZWNvcmRTY3JvbGxhYmxlJyxcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZWNvcmRTY3JvbGxhYmxlKGV2ZW50KSB7XFxuICAgICAgdmFyIGVsZW0gPSB0aGlzOyAvLyBjYWxsZWQgZnJvbSBldmVudCBoYW5kbGVyIGNvbnRleHQgd2l0aCB0aGlzIGFzIGVsZW1cXG5cXG4gICAgICAvLyBJZiB0aGUgZWxlbWVudCBpcyBzY3JvbGxhYmxlIChjb250ZW50IG92ZXJmbG93cyksIHRoZW4uLi5cXG4gICAgICBpZiAoZWxlbS5zY3JvbGxIZWlnaHQgIT09IGVsZW0uY2xpZW50SGVpZ2h0KSB7XFxuICAgICAgICAvLyBJZiB3ZSdyZSBhdCB0aGUgdG9wLCBzY3JvbGwgZG93biBvbmUgcGl4ZWwgdG8gYWxsb3cgc2Nyb2xsaW5nIHVwXFxuICAgICAgICBpZiAoZWxlbS5zY3JvbGxUb3AgPT09IDApIHtcXG4gICAgICAgICAgZWxlbS5zY3JvbGxUb3AgPSAxO1xcbiAgICAgICAgfVxcbiAgICAgICAgLy8gSWYgd2UncmUgYXQgdGhlIGJvdHRvbSwgc2Nyb2xsIHVwIG9uZSBwaXhlbCB0byBhbGxvdyBzY3JvbGxpbmcgZG93blxcbiAgICAgICAgaWYgKGVsZW0uc2Nyb2xsVG9wID09PSBlbGVtLnNjcm9sbEhlaWdodCAtIGVsZW0uY2xpZW50SGVpZ2h0KSB7XFxuICAgICAgICAgIGVsZW0uc2Nyb2xsVG9wID0gZWxlbS5zY3JvbGxIZWlnaHQgLSBlbGVtLmNsaWVudEhlaWdodCAtIDE7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIGVsZW0uYWxsb3dVcCA9IGVsZW0uc2Nyb2xsVG9wID4gMDtcXG4gICAgICBlbGVtLmFsbG93RG93biA9IGVsZW0uc2Nyb2xsVG9wIDwgZWxlbS5zY3JvbGxIZWlnaHQgLSBlbGVtLmNsaWVudEhlaWdodDtcXG4gICAgICBlbGVtLmxhc3RZID0gZXZlbnQub3JpZ2luYWxFdmVudC5wYWdlWTtcXG4gICAgfVxcbiAgfSwge1xcbiAgICBrZXk6ICdfc3RvcFNjcm9sbFByb3BhZ2F0aW9uJyxcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zdG9wU2Nyb2xsUHJvcGFnYXRpb24oZXZlbnQpIHtcXG4gICAgICB2YXIgZWxlbSA9IHRoaXM7IC8vIGNhbGxlZCBmcm9tIGV2ZW50IGhhbmRsZXIgY29udGV4dCB3aXRoIHRoaXMgYXMgZWxlbVxcbiAgICAgIHZhciB1cCA9IGV2ZW50LnBhZ2VZIDwgZWxlbS5sYXN0WTtcXG4gICAgICB2YXIgZG93biA9ICF1cDtcXG4gICAgICBlbGVtLmxhc3RZID0gZXZlbnQucGFnZVk7XFxuXFxuICAgICAgaWYgKHVwICYmIGVsZW0uYWxsb3dVcCB8fCBkb3duICYmIGVsZW0uYWxsb3dEb3duKSB7XFxuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIE9wZW5zIHRoZSBvZmYtY2FudmFzIG1lbnUuXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSBFdmVudCBvYmplY3QgcGFzc2VkIGZyb20gbGlzdGVuZXIuXFxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSB0cmlnZ2VyIC0gZWxlbWVudCB0aGF0IHRyaWdnZXJlZCB0aGUgb2ZmLWNhbnZhcyB0byBvcGVuLlxcbiAgICAgKiBAZmlyZXMgT2ZmQ2FudmFzI29wZW5lZFxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAnb3BlbicsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvcGVuKGV2ZW50LCB0cmlnZ2VyKSB7XFxuICAgICAgaWYgKHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2lzLW9wZW4nKSB8fCB0aGlzLmlzUmV2ZWFsZWQpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuICAgICAgdmFyIF90aGlzID0gdGhpcztcXG5cXG4gICAgICBpZiAodHJpZ2dlcikge1xcbiAgICAgICAgdGhpcy4kbGFzdFRyaWdnZXIgPSB0cmlnZ2VyO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmZvcmNlVG8gPT09ICd0b3AnKSB7XFxuICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgMCk7XFxuICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuZm9yY2VUbyA9PT0gJ2JvdHRvbScpIHtcXG4gICAgICAgIHdpbmRvdy5zY3JvbGxUbygwLCBkb2N1bWVudC5ib2R5LnNjcm9sbEhlaWdodCk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudHJhbnNpdGlvblRpbWUgJiYgdGhpcy5vcHRpb25zLnRyYW5zaXRpb24gIT09ICdvdmVybGFwJykge1xcbiAgICAgICAgdGhpcy4kZWxlbWVudC5zaWJsaW5ncygnW2RhdGEtb2ZmLWNhbnZhcy1jb250ZW50XScpLmNzcygndHJhbnNpdGlvbi1kdXJhdGlvbicsIHRoaXMub3B0aW9ucy50cmFuc2l0aW9uVGltZSk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHRoaXMuJGVsZW1lbnQuc2libGluZ3MoJ1tkYXRhLW9mZi1jYW52YXMtY29udGVudF0nKS5jc3MoJ3RyYW5zaXRpb24tZHVyYXRpb24nLCAnJyk7XFxuICAgICAgfVxcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIEZpcmVzIHdoZW4gdGhlIG9mZi1jYW52YXMgbWVudSBvcGVucy5cXG4gICAgICAgKiBAZXZlbnQgT2ZmQ2FudmFzI29wZW5lZFxcbiAgICAgICAqL1xcbiAgICAgIHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3MoJ2lzLW9wZW4nKS5yZW1vdmVDbGFzcygnaXMtY2xvc2VkJyk7XFxuXFxuICAgICAgdGhpcy4kdHJpZ2dlcnMuYXR0cignYXJpYS1leHBhbmRlZCcsICd0cnVlJyk7XFxuICAgICAgdGhpcy4kZWxlbWVudC5hdHRyKCdhcmlhLWhpZGRlbicsICdmYWxzZScpLnRyaWdnZXIoJ29wZW5lZC56Zi5vZmZjYW52YXMnKTtcXG5cXG4gICAgICB0aGlzLiRjb250ZW50LmFkZENsYXNzKCdpcy1vcGVuLScgKyB0aGlzLnBvc2l0aW9uKTtcXG5cXG4gICAgICAvLyBJZiBgY29udGVudFNjcm9sbGAgaXMgc2V0IHRvIGZhbHNlLCBhZGQgY2xhc3MgYW5kIGRpc2FibGUgc2Nyb2xsaW5nIG9uIHRvdWNoIGRldmljZXMuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5jb250ZW50U2Nyb2xsID09PSBmYWxzZSkge1xcbiAgICAgICAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSgnYm9keScpLmFkZENsYXNzKCdpcy1vZmYtY2FudmFzLW9wZW4nKS5vbigndG91Y2htb3ZlJywgdGhpcy5fc3RvcFNjcm9sbGluZyk7XFxuICAgICAgICB0aGlzLiRlbGVtZW50Lm9uKCd0b3VjaHN0YXJ0JywgdGhpcy5fcmVjb3JkU2Nyb2xsYWJsZSk7XFxuICAgICAgICB0aGlzLiRlbGVtZW50Lm9uKCd0b3VjaG1vdmUnLCB0aGlzLl9zdG9wU2Nyb2xsUHJvcGFnYXRpb24pO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmNvbnRlbnRPdmVybGF5ID09PSB0cnVlKSB7XFxuICAgICAgICB0aGlzLiRvdmVybGF5LmFkZENsYXNzKCdpcy12aXNpYmxlJyk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrID09PSB0cnVlICYmIHRoaXMub3B0aW9ucy5jb250ZW50T3ZlcmxheSA9PT0gdHJ1ZSkge1xcbiAgICAgICAgdGhpcy4kb3ZlcmxheS5hZGRDbGFzcygnaXMtY2xvc2FibGUnKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvRm9jdXMgPT09IHRydWUpIHtcXG4gICAgICAgIHRoaXMuJGVsZW1lbnQub25lKF9fd2VicGFja19yZXF1aXJlX18uaShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX2ZvdW5kYXRpb25fdXRpbF9jb3JlX19bXFxcImNcXFwiIC8qIHRyYW5zaXRpb25lbmQgKi9dKSh0aGlzLiRlbGVtZW50KSwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICBpZiAoIV90aGlzLiRlbGVtZW50Lmhhc0NsYXNzKCdpcy1vcGVuJykpIHtcXG4gICAgICAgICAgICByZXR1cm47IC8vIGV4aXQgaWYgcHJlbWF0dXJlbHkgY2xvc2VkXFxuICAgICAgICAgIH1cXG4gICAgICAgICAgdmFyIGNhbnZhc0ZvY3VzID0gX3RoaXMuJGVsZW1lbnQuZmluZCgnW2RhdGEtYXV0b2ZvY3VzXScpO1xcbiAgICAgICAgICBpZiAoY2FudmFzRm9jdXMubGVuZ3RoKSB7XFxuICAgICAgICAgICAgY2FudmFzRm9jdXMuZXEoMCkuZm9jdXMoKTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBfdGhpcy4kZWxlbWVudC5maW5kKCdhLCBidXR0b24nKS5lcSgwKS5mb2N1cygpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy50cmFwRm9jdXMgPT09IHRydWUpIHtcXG4gICAgICAgIHRoaXMuJGNvbnRlbnQuYXR0cigndGFiaW5kZXgnLCAnLTEnKTtcXG4gICAgICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fZm91bmRhdGlvbl91dGlsX2tleWJvYXJkX19bXFxcImFcXFwiIC8qIEtleWJvYXJkICovXS50cmFwRm9jdXModGhpcy4kZWxlbWVudCk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX2FkZENvbnRlbnRDbGFzc2VzKCk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIENsb3NlcyB0aGUgb2ZmLWNhbnZhcyBtZW51LlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgLSBvcHRpb25hbCBjYiB0byBmaXJlIGFmdGVyIGNsb3N1cmUuXFxuICAgICAqIEBmaXJlcyBPZmZDYW52YXMjY2xvc2VkXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6ICdjbG9zZScsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZShjYikge1xcbiAgICAgIGlmICghdGhpcy4kZWxlbWVudC5oYXNDbGFzcygnaXMtb3BlbicpIHx8IHRoaXMuaXNSZXZlYWxlZCkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xcblxcbiAgICAgIHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3MoJ2lzLW9wZW4nKTtcXG5cXG4gICAgICB0aGlzLiRlbGVtZW50LmF0dHIoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKVxcbiAgICAgIC8qKlxcbiAgICAgICAqIEZpcmVzIHdoZW4gdGhlIG9mZi1jYW52YXMgbWVudSBvcGVucy5cXG4gICAgICAgKiBAZXZlbnQgT2ZmQ2FudmFzI2Nsb3NlZFxcbiAgICAgICAqL1xcbiAgICAgIC50cmlnZ2VyKCdjbG9zZWQuemYub2ZmY2FudmFzJyk7XFxuXFxuICAgICAgdGhpcy4kY29udGVudC5yZW1vdmVDbGFzcygnaXMtb3Blbi1sZWZ0IGlzLW9wZW4tdG9wIGlzLW9wZW4tcmlnaHQgaXMtb3Blbi1ib3R0b20nKTtcXG5cXG4gICAgICAvLyBJZiBgY29udGVudFNjcm9sbGAgaXMgc2V0IHRvIGZhbHNlLCByZW1vdmUgY2xhc3MgYW5kIHJlLWVuYWJsZSBzY3JvbGxpbmcgb24gdG91Y2ggZGV2aWNlcy5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmNvbnRlbnRTY3JvbGwgPT09IGZhbHNlKSB7XFxuICAgICAgICBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKCdib2R5JykucmVtb3ZlQ2xhc3MoJ2lzLW9mZi1jYW52YXMtb3BlbicpLm9mZigndG91Y2htb3ZlJywgdGhpcy5fc3RvcFNjcm9sbGluZyk7XFxuICAgICAgICB0aGlzLiRlbGVtZW50Lm9mZigndG91Y2hzdGFydCcsIHRoaXMuX3JlY29yZFNjcm9sbGFibGUpO1xcbiAgICAgICAgdGhpcy4kZWxlbWVudC5vZmYoJ3RvdWNobW92ZScsIHRoaXMuX3N0b3BTY3JvbGxQcm9wYWdhdGlvbik7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuY29udGVudE92ZXJsYXkgPT09IHRydWUpIHtcXG4gICAgICAgIHRoaXMuJG92ZXJsYXkucmVtb3ZlQ2xhc3MoJ2lzLXZpc2libGUnKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2sgPT09IHRydWUgJiYgdGhpcy5vcHRpb25zLmNvbnRlbnRPdmVybGF5ID09PSB0cnVlKSB7XFxuICAgICAgICB0aGlzLiRvdmVybGF5LnJlbW92ZUNsYXNzKCdpcy1jbG9zYWJsZScpO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLiR0cmlnZ2Vycy5hdHRyKCdhcmlhLWV4cGFuZGVkJywgJ2ZhbHNlJyk7XFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy50cmFwRm9jdXMgPT09IHRydWUpIHtcXG4gICAgICAgIHRoaXMuJGNvbnRlbnQucmVtb3ZlQXR0cigndGFiaW5kZXgnKTtcXG4gICAgICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fZm91bmRhdGlvbl91dGlsX2tleWJvYXJkX19bXFxcImFcXFwiIC8qIEtleWJvYXJkICovXS5yZWxlYXNlRm9jdXModGhpcy4kZWxlbWVudCk7XFxuICAgICAgfVxcblxcbiAgICAgIC8vIExpc3RlbiB0byB0cmFuc2l0aW9uRW5kIGFuZCBhZGQgY2xhc3Mgd2hlbiBkb25lLlxcbiAgICAgIHRoaXMuJGVsZW1lbnQub25lKF9fd2VicGFja19yZXF1aXJlX18uaShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX2ZvdW5kYXRpb25fdXRpbF9jb3JlX19bXFxcImNcXFwiIC8qIHRyYW5zaXRpb25lbmQgKi9dKSh0aGlzLiRlbGVtZW50KSwgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgIF90aGlzLiRlbGVtZW50LmFkZENsYXNzKCdpcy1jbG9zZWQnKTtcXG4gICAgICAgIF90aGlzLl9yZW1vdmVDb250ZW50Q2xhc3NlcygpO1xcbiAgICAgIH0pO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBUb2dnbGVzIHRoZSBvZmYtY2FudmFzIG1lbnUgb3BlbiBvciBjbG9zZWQuXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSBFdmVudCBvYmplY3QgcGFzc2VkIGZyb20gbGlzdGVuZXIuXFxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSB0cmlnZ2VyIC0gZWxlbWVudCB0aGF0IHRyaWdnZXJlZCB0aGUgb2ZmLWNhbnZhcyB0byBvcGVuLlxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAndG9nZ2xlJyxcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvZ2dsZShldmVudCwgdHJpZ2dlcikge1xcbiAgICAgIGlmICh0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKCdpcy1vcGVuJykpIHtcXG4gICAgICAgIHRoaXMuY2xvc2UoZXZlbnQsIHRyaWdnZXIpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB0aGlzLm9wZW4oZXZlbnQsIHRyaWdnZXIpO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogSGFuZGxlcyBrZXlib2FyZCBpbnB1dCB3aGVuIGRldGVjdGVkLiBXaGVuIHRoZSBlc2NhcGUga2V5IGlzIHByZXNzZWQsIHRoZSBvZmYtY2FudmFzIG1lbnUgY2xvc2VzLCBhbmQgZm9jdXMgaXMgcmVzdG9yZWQgdG8gdGhlIGVsZW1lbnQgdGhhdCBvcGVuZWQgdGhlIG1lbnUuXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAnX2hhbmRsZUtleWJvYXJkJyxcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVLZXlib2FyZChlKSB7XFxuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XFxuXFxuICAgICAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19mb3VuZGF0aW9uX3V0aWxfa2V5Ym9hcmRfX1tcXFwiYVxcXCIgLyogS2V5Ym9hcmQgKi9dLmhhbmRsZUtleShlLCAnT2ZmQ2FudmFzJywge1xcbiAgICAgICAgY2xvc2U6IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgX3RoaXM0LmNsb3NlKCk7XFxuICAgICAgICAgIF90aGlzNC4kbGFzdFRyaWdnZXIuZm9jdXMoKTtcXG4gICAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgICB9LFxcbiAgICAgICAgaGFuZGxlZDogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIERlc3Ryb3lzIHRoZSBvZmZjYW52YXMgcGx1Z2luLlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogJ19kZXN0cm95JyxcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZXN0cm95KCkge1xcbiAgICAgIHRoaXMuY2xvc2UoKTtcXG4gICAgICB0aGlzLiRlbGVtZW50Lm9mZignLnpmLnRyaWdnZXIgLnpmLm9mZmNhbnZhcycpO1xcbiAgICAgIHRoaXMuJG92ZXJsYXkub2ZmKCcuemYub2ZmY2FudmFzJyk7XFxuICAgIH1cXG4gIH1dKTtcXG5cXG4gIHJldHVybiBPZmZDYW52YXM7XFxufShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX2ZvdW5kYXRpb25fcGx1Z2luX19bXFxcImFcXFwiIC8qIFBsdWdpbiAqL10pO1xcblxcbk9mZkNhbnZhcy5kZWZhdWx0cyA9IHtcXG4gIC8qKlxcbiAgICogQWxsb3cgdGhlIHVzZXIgdG8gY2xpY2sgb3V0c2lkZSBvZiB0aGUgbWVudSB0byBjbG9zZSBpdC5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtib29sZWFufVxcbiAgICogQGRlZmF1bHQgdHJ1ZVxcbiAgICovXFxuICBjbG9zZU9uQ2xpY2s6IHRydWUsXFxuXFxuICAvKipcXG4gICAqIEFkZHMgYW4gb3ZlcmxheSBvbiB0b3Agb2YgYFtkYXRhLW9mZi1jYW52YXMtY29udGVudF1gLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge2Jvb2xlYW59XFxuICAgKiBAZGVmYXVsdCB0cnVlXFxuICAgKi9cXG4gIGNvbnRlbnRPdmVybGF5OiB0cnVlLFxcblxcbiAgLyoqXFxuICAgKiBUYXJnZXQgYW4gb2ZmLWNhbnZhcyBjb250ZW50IGNvbnRhaW5lciBieSBJRCB0aGF0IG1heSBiZSBwbGFjZWQgYW55d2hlcmUuIElmIG51bGwgdGhlIGNsb3Nlc3QgY29udGVudCBjb250YWluZXIgd2lsbCBiZSB0YWtlbi5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHs/c3RyaW5nfVxcbiAgICogQGRlZmF1bHQgbnVsbFxcbiAgICovXFxuICBjb250ZW50SWQ6IG51bGwsXFxuXFxuICAvKipcXG4gICAqIERlZmluZSB0aGUgb2ZmLWNhbnZhcyBlbGVtZW50IGlzIG5lc3RlZCBpbiBhbiBvZmYtY2FudmFzIGNvbnRlbnQuIFRoaXMgaXMgcmVxdWlyZWQgd2hlbiB1c2luZyB0aGUgY29udGVudElkIG9wdGlvbiBmb3IgYSBuZXN0ZWQgZWxlbWVudC5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtib29sZWFufVxcbiAgICogQGRlZmF1bHQgbnVsbFxcbiAgICovXFxuICBuZXN0ZWQ6IG51bGwsXFxuXFxuICAvKipcXG4gICAqIEVuYWJsZS9kaXNhYmxlIHNjcm9sbGluZyBvZiB0aGUgbWFpbiBjb250ZW50IHdoZW4gYW4gb2ZmIGNhbnZhcyBwYW5lbCBpcyBvcGVuLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge2Jvb2xlYW59XFxuICAgKiBAZGVmYXVsdCB0cnVlXFxuICAgKi9cXG4gIGNvbnRlbnRTY3JvbGw6IHRydWUsXFxuXFxuICAvKipcXG4gICAqIEFtb3VudCBvZiB0aW1lIGluIG1zIHRoZSBvcGVuIGFuZCBjbG9zZSB0cmFuc2l0aW9uIHJlcXVpcmVzLiBJZiBub25lIHNlbGVjdGVkLCBwdWxscyBmcm9tIGJvZHkgc3R5bGUuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7bnVtYmVyfVxcbiAgICogQGRlZmF1bHQgbnVsbFxcbiAgICovXFxuICB0cmFuc2l0aW9uVGltZTogbnVsbCxcXG5cXG4gIC8qKlxcbiAgICogVHlwZSBvZiB0cmFuc2l0aW9uIGZvciB0aGUgb2ZmY2FudmFzIG1lbnUuIE9wdGlvbnMgYXJlICdwdXNoJywgJ2RldGFjaGVkJyBvciAnc2xpZGUnLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge3N0cmluZ31cXG4gICAqIEBkZWZhdWx0IHB1c2hcXG4gICAqL1xcbiAgdHJhbnNpdGlvbjogJ3B1c2gnLFxcblxcbiAgLyoqXFxuICAgKiBGb3JjZSB0aGUgcGFnZSB0byBzY3JvbGwgdG8gdG9wIG9yIGJvdHRvbSBvbiBvcGVuLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUgez9zdHJpbmd9XFxuICAgKiBAZGVmYXVsdCBudWxsXFxuICAgKi9cXG4gIGZvcmNlVG86IG51bGwsXFxuXFxuICAvKipcXG4gICAqIEFsbG93IHRoZSBvZmZjYW52YXMgdG8gcmVtYWluIG9wZW4gZm9yIGNlcnRhaW4gYnJlYWtwb2ludHMuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IGZhbHNlXFxuICAgKi9cXG4gIGlzUmV2ZWFsZWQ6IGZhbHNlLFxcblxcbiAgLyoqXFxuICAgKiBCcmVha3BvaW50IGF0IHdoaWNoIHRvIHJldmVhbC4gSlMgd2lsbCB1c2UgYSBSZWdFeHAgdG8gdGFyZ2V0IHN0YW5kYXJkIGNsYXNzZXMsIGlmIGNoYW5naW5nIGNsYXNzbmFtZXMsIHBhc3MgeW91ciBjbGFzcyB3aXRoIHRoZSBgcmV2ZWFsQ2xhc3NgIG9wdGlvbi5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHs/c3RyaW5nfVxcbiAgICogQGRlZmF1bHQgbnVsbFxcbiAgICovXFxuICByZXZlYWxPbjogbnVsbCxcXG5cXG4gIC8qKlxcbiAgICogRm9yY2UgZm9jdXMgdG8gdGhlIG9mZmNhbnZhcyBvbiBvcGVuLiBJZiB0cnVlLCB3aWxsIGZvY3VzIHRoZSBvcGVuaW5nIHRyaWdnZXIgb24gY2xvc2UuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IHRydWVcXG4gICAqL1xcbiAgYXV0b0ZvY3VzOiB0cnVlLFxcblxcbiAgLyoqXFxuICAgKiBDbGFzcyB1c2VkIHRvIGZvcmNlIGFuIG9mZmNhbnZhcyB0byByZW1haW4gb3Blbi4gRm91bmRhdGlvbiBkZWZhdWx0cyBmb3IgdGhpcyBhcmUgYHJldmVhbC1mb3ItbGFyZ2VgICYgYHJldmVhbC1mb3ItbWVkaXVtYC5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtzdHJpbmd9XFxuICAgKiBAZGVmYXVsdCByZXZlYWwtZm9yLVxcbiAgICogQHRvZG8gaW1wcm92ZSB0aGUgcmVnZXggdGVzdGluZyBmb3IgdGhpcy5cXG4gICAqL1xcbiAgcmV2ZWFsQ2xhc3M6ICdyZXZlYWwtZm9yLScsXFxuXFxuICAvKipcXG4gICAqIFRyaWdnZXJzIG9wdGlvbmFsIGZvY3VzIHRyYXBwaW5nIHdoZW4gb3BlbmluZyBhbiBvZmZjYW52YXMuIFNldHMgdGFiaW5kZXggb2YgW2RhdGEtb2ZmLWNhbnZhcy1jb250ZW50XSB0byAtMSBmb3IgYWNjZXNzaWJpbGl0eSBwdXJwb3Nlcy5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtib29sZWFufVxcbiAgICogQGRlZmF1bHQgZmFsc2VcXG4gICAqL1xcbiAgdHJhcEZvY3VzOiBmYWxzZVxcbn07XFxuXFxuXFxuXFxuLyoqKi8gfSksXFxuLyogMjcgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImFcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIE9yYml0OyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLm4oX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19mb3VuZGF0aW9uX3V0aWxfa2V5Ym9hcmRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fZm91bmRhdGlvbl91dGlsX21vdGlvbl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19mb3VuZGF0aW9uX3V0aWxfdGltZXJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX2ZvdW5kYXRpb25fdXRpbF9pbWFnZUxvYWRlcl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19mb3VuZGF0aW9uX3V0aWxfY29yZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19mb3VuZGF0aW9uX3BsdWdpbl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19mb3VuZGF0aW9uX3V0aWxfdG91Y2hfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xcblxcblxcbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXFxcInZhbHVlXFxcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xcblxcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7IH0gfVxcblxcbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcXFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXFxcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcXFwib2JqZWN0XFxcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXFxcImZ1bmN0aW9uXFxcIikgPyBjYWxsIDogc2VsZjsgfVxcblxcbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFxcXCJmdW5jdGlvblxcXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFxcXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuLyoqXFxuICogT3JiaXQgbW9kdWxlLlxcbiAqIEBtb2R1bGUgZm91bmRhdGlvbi5vcmJpdFxcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwua2V5Ym9hcmRcXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLm1vdGlvblxcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwudGltZXJcXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLmltYWdlTG9hZGVyXFxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC50b3VjaFxcbiAqL1xcblxcbnZhciBPcmJpdCA9IGZ1bmN0aW9uIChfUGx1Z2luKSB7XFxuICBfaW5oZXJpdHMoT3JiaXQsIF9QbHVnaW4pO1xcblxcbiAgZnVuY3Rpb24gT3JiaXQoKSB7XFxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBPcmJpdCk7XFxuXFxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoT3JiaXQuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihPcmJpdCkpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xcbiAgfVxcblxcbiAgX2NyZWF0ZUNsYXNzKE9yYml0LCBbe1xcbiAgICBrZXk6ICdfc2V0dXAnLFxcblxcbiAgICAvKipcXG4gICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIGFuIG9yYml0IGNhcm91c2VsLlxcbiAgICAqIEBjbGFzc1xcbiAgICAqIEBuYW1lIE9yYml0XFxuICAgICogQHBhcmFtIHtqUXVlcnl9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIG1ha2UgaW50byBhbiBPcmJpdCBDYXJvdXNlbC5cXG4gICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlcyB0byB0aGUgZGVmYXVsdCBwbHVnaW4gc2V0dGluZ3MuXFxuICAgICovXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0dXAoZWxlbWVudCwgb3B0aW9ucykge1xcbiAgICAgIHRoaXMuJGVsZW1lbnQgPSBlbGVtZW50O1xcbiAgICAgIHRoaXMub3B0aW9ucyA9IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0LmEuZXh0ZW5kKHt9LCBPcmJpdC5kZWZhdWx0cywgdGhpcy4kZWxlbWVudC5kYXRhKCksIG9wdGlvbnMpO1xcbiAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ09yYml0JzsgLy8gaWU5IGJhY2sgY29tcGF0XFxuXFxuICAgICAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19mb3VuZGF0aW9uX3V0aWxfdG91Y2hfX1tcXFwiYVxcXCIgLyogVG91Y2ggKi9dLmluaXQoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQuYSk7IC8vIFRvdWNoIGluaXQgaXMgaWRlbXBvdGVudCwgd2UganVzdCBuZWVkIHRvIG1ha2Ugc3VyZSBpdCdzIGluaXRpYWxpZWQuXFxuXFxuICAgICAgdGhpcy5faW5pdCgpO1xcblxcbiAgICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fZm91bmRhdGlvbl91dGlsX2tleWJvYXJkX19bXFxcImFcXFwiIC8qIEtleWJvYXJkICovXS5yZWdpc3RlcignT3JiaXQnLCB7XFxuICAgICAgICAnbHRyJzoge1xcbiAgICAgICAgICAnQVJST1dfUklHSFQnOiAnbmV4dCcsXFxuICAgICAgICAgICdBUlJPV19MRUZUJzogJ3ByZXZpb3VzJ1xcbiAgICAgICAgfSxcXG4gICAgICAgICdydGwnOiB7XFxuICAgICAgICAgICdBUlJPV19MRUZUJzogJ25leHQnLFxcbiAgICAgICAgICAnQVJST1dfUklHSFQnOiAncHJldmlvdXMnXFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICogSW5pdGlhbGl6ZXMgdGhlIHBsdWdpbiBieSBjcmVhdGluZyBqUXVlcnkgY29sbGVjdGlvbnMsIHNldHRpbmcgYXR0cmlidXRlcywgYW5kIHN0YXJ0aW5nIHRoZSBhbmltYXRpb24uXFxuICAgICogQGZ1bmN0aW9uXFxuICAgICogQHByaXZhdGVcXG4gICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAnX2luaXQnLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXQoKSB7XFxuICAgICAgLy8gQFRPRE86IGNvbnNpZGVyIGRpc2N1c3Npb24gb24gUFIgIzkyNzggYWJvdXQgRE9NIHBvbGx1dGlvbiBieSBjaGFuZ2VTbGlkZVxcbiAgICAgIHRoaXMuX3Jlc2V0KCk7XFxuXFxuICAgICAgdGhpcy4kd3JhcHBlciA9IHRoaXMuJGVsZW1lbnQuZmluZCgnLicgKyB0aGlzLm9wdGlvbnMuY29udGFpbmVyQ2xhc3MpO1xcbiAgICAgIHRoaXMuJHNsaWRlcyA9IHRoaXMuJGVsZW1lbnQuZmluZCgnLicgKyB0aGlzLm9wdGlvbnMuc2xpZGVDbGFzcyk7XFxuXFxuICAgICAgdmFyICRpbWFnZXMgPSB0aGlzLiRlbGVtZW50LmZpbmQoJ2ltZycpLFxcbiAgICAgICAgICBpbml0QWN0aXZlID0gdGhpcy4kc2xpZGVzLmZpbHRlcignLmlzLWFjdGl2ZScpLFxcbiAgICAgICAgICBpZCA9IHRoaXMuJGVsZW1lbnRbMF0uaWQgfHwgX193ZWJwYWNrX3JlcXVpcmVfXy5pKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fZm91bmRhdGlvbl91dGlsX2NvcmVfX1tcXFwiYlxcXCIgLyogR2V0WW9EaWdpdHMgKi9dKSg2LCAnb3JiaXQnKTtcXG5cXG4gICAgICB0aGlzLiRlbGVtZW50LmF0dHIoe1xcbiAgICAgICAgJ2RhdGEtcmVzaXplJzogaWQsXFxuICAgICAgICAnaWQnOiBpZFxcbiAgICAgIH0pO1xcblxcbiAgICAgIGlmICghaW5pdEFjdGl2ZS5sZW5ndGgpIHtcXG4gICAgICAgIHRoaXMuJHNsaWRlcy5lcSgwKS5hZGRDbGFzcygnaXMtYWN0aXZlJyk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLnVzZU1VSSkge1xcbiAgICAgICAgdGhpcy4kc2xpZGVzLmFkZENsYXNzKCduby1tb3Rpb251aScpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoJGltYWdlcy5sZW5ndGgpIHtcXG4gICAgICAgIF9fd2VicGFja19yZXF1aXJlX18uaShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX2ZvdW5kYXRpb25fdXRpbF9pbWFnZUxvYWRlcl9fW1xcXCJhXFxcIiAvKiBvbkltYWdlc0xvYWRlZCAqL10pKCRpbWFnZXMsIHRoaXMuX3ByZXBhcmVGb3JPcmJpdC5iaW5kKHRoaXMpKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdGhpcy5fcHJlcGFyZUZvck9yYml0KCk7IC8vaGVoZVxcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmJ1bGxldHMpIHtcXG4gICAgICAgIHRoaXMuX2xvYWRCdWxsZXRzKCk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX2V2ZW50cygpO1xcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0b1BsYXkgJiYgdGhpcy4kc2xpZGVzLmxlbmd0aCA+IDEpIHtcXG4gICAgICAgIHRoaXMuZ2VvU3luYygpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmFjY2Vzc2libGUpIHtcXG4gICAgICAgIC8vIGFsbG93IHdyYXBwZXIgdG8gYmUgZm9jdXNhYmxlIHRvIGVuYWJsZSBhcnJvdyBuYXZpZ2F0aW9uXFxuICAgICAgICB0aGlzLiR3cmFwcGVyLmF0dHIoJ3RhYmluZGV4JywgMCk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAqIENyZWF0ZXMgYSBqUXVlcnkgY29sbGVjdGlvbiBvZiBidWxsZXRzLCBpZiB0aGV5IGFyZSBiZWluZyB1c2VkLlxcbiAgICAqIEBmdW5jdGlvblxcbiAgICAqIEBwcml2YXRlXFxuICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogJ19sb2FkQnVsbGV0cycsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbG9hZEJ1bGxldHMoKSB7XFxuICAgICAgdGhpcy4kYnVsbGV0cyA9IHRoaXMuJGVsZW1lbnQuZmluZCgnLicgKyB0aGlzLm9wdGlvbnMuYm94T2ZCdWxsZXRzKS5maW5kKCdidXR0b24nKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgKiBTZXRzIGEgYHRpbWVyYCBvYmplY3Qgb24gdGhlIG9yYml0LCBhbmQgc3RhcnRzIHRoZSBjb3VudGVyIGZvciB0aGUgbmV4dCBzbGlkZS5cXG4gICAgKiBAZnVuY3Rpb25cXG4gICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAnZ2VvU3luYycsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZW9TeW5jKCkge1xcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuICAgICAgdGhpcy50aW1lciA9IG5ldyBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX2ZvdW5kYXRpb25fdXRpbF90aW1lcl9fW1xcXCJhXFxcIiAvKiBUaW1lciAqL10odGhpcy4kZWxlbWVudCwge1xcbiAgICAgICAgZHVyYXRpb246IHRoaXMub3B0aW9ucy50aW1lckRlbGF5LFxcbiAgICAgICAgaW5maW5pdGU6IGZhbHNlXFxuICAgICAgfSwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgX3RoaXMuY2hhbmdlU2xpZGUodHJ1ZSk7XFxuICAgICAgfSk7XFxuICAgICAgdGhpcy50aW1lci5zdGFydCgpO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAqIFNldHMgd3JhcHBlciBhbmQgc2xpZGUgaGVpZ2h0cyBmb3IgdGhlIG9yYml0LlxcbiAgICAqIEBmdW5jdGlvblxcbiAgICAqIEBwcml2YXRlXFxuICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogJ19wcmVwYXJlRm9yT3JiaXQnLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3ByZXBhcmVGb3JPcmJpdCgpIHtcXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xcbiAgICAgIHRoaXMuX3NldFdyYXBwZXJIZWlnaHQoKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgKiBDYWx1bGF0ZXMgdGhlIGhlaWdodCBvZiBlYWNoIHNsaWRlIGluIHRoZSBjb2xsZWN0aW9uLCBhbmQgdXNlcyB0aGUgdGFsbGVzdCBvbmUgZm9yIHRoZSB3cmFwcGVyIGhlaWdodC5cXG4gICAgKiBAZnVuY3Rpb25cXG4gICAgKiBAcHJpdmF0ZVxcbiAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIC0gYSBjYWxsYmFjayBmdW5jdGlvbiB0byBmaXJlIHdoZW4gY29tcGxldGUuXFxuICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogJ19zZXRXcmFwcGVySGVpZ2h0JyxcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRXcmFwcGVySGVpZ2h0KGNiKSB7XFxuICAgICAgLy9yZXdyaXRlIHRoaXMgdG8gYGZvcmAgbG9vcFxcbiAgICAgIHZhciBtYXggPSAwLFxcbiAgICAgICAgICB0ZW1wLFxcbiAgICAgICAgICBjb3VudGVyID0gMCxcXG4gICAgICAgICAgX3RoaXMgPSB0aGlzO1xcblxcbiAgICAgIHRoaXMuJHNsaWRlcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHRlbXAgPSB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcXG4gICAgICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0KCkodGhpcykuYXR0cignZGF0YS1zbGlkZScsIGNvdW50ZXIpO1xcblxcbiAgICAgICAgaWYgKF90aGlzLiRzbGlkZXMuZmlsdGVyKCcuaXMtYWN0aXZlJylbMF0gIT09IF90aGlzLiRzbGlkZXMuZXEoY291bnRlcilbMF0pIHtcXG4gICAgICAgICAgLy9pZiBub3QgdGhlIGFjdGl2ZSBzbGlkZSwgc2V0IGNzcyBwb3NpdGlvbiBhbmQgZGlzcGxheSBwcm9wZXJ0eVxcbiAgICAgICAgICBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKHRoaXMpLmNzcyh7ICdwb3NpdGlvbic6ICdyZWxhdGl2ZScsICdkaXNwbGF5JzogJ25vbmUnIH0pO1xcbiAgICAgICAgfVxcbiAgICAgICAgbWF4ID0gdGVtcCA+IG1heCA/IHRlbXAgOiBtYXg7XFxuICAgICAgICBjb3VudGVyKys7XFxuICAgICAgfSk7XFxuXFxuICAgICAgaWYgKGNvdW50ZXIgPT09IHRoaXMuJHNsaWRlcy5sZW5ndGgpIHtcXG4gICAgICAgIHRoaXMuJHdyYXBwZXIuY3NzKHsgJ2hlaWdodCc6IG1heCB9KTsgLy9vbmx5IGNoYW5nZSB0aGUgd3JhcHBlciBoZWlnaHQgcHJvcGVydHkgb25jZS5cXG4gICAgICAgIGlmIChjYikge1xcbiAgICAgICAgICBjYihtYXgpO1xcbiAgICAgICAgfSAvL2ZpcmUgY2FsbGJhY2sgd2l0aCBtYXggaGVpZ2h0IGRpbWVuc2lvbi5cXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICogU2V0cyB0aGUgbWF4LWhlaWdodCBvZiBlYWNoIHNsaWRlLlxcbiAgICAqIEBmdW5jdGlvblxcbiAgICAqIEBwcml2YXRlXFxuICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogJ19zZXRTbGlkZUhlaWdodCcsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0U2xpZGVIZWlnaHQoaGVpZ2h0KSB7XFxuICAgICAgdGhpcy4kc2xpZGVzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSh0aGlzKS5jc3MoJ21heC1oZWlnaHQnLCBoZWlnaHQpO1xcbiAgICAgIH0pO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAqIEFkZHMgZXZlbnQgbGlzdGVuZXJzIHRvIGJhc2ljYWxseSBldmVyeXRoaW5nIHdpdGhpbiB0aGUgZWxlbWVudC5cXG4gICAgKiBAZnVuY3Rpb25cXG4gICAgKiBAcHJpdmF0ZVxcbiAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6ICdfZXZlbnRzJyxcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9ldmVudHMoKSB7XFxuICAgICAgdmFyIF90aGlzID0gdGhpcztcXG5cXG4gICAgICAvLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxcbiAgICAgIC8vKipOb3cgdXNpbmcgY3VzdG9tIGV2ZW50IC0gdGhhbmtzIHRvOioqXFxuICAgICAgLy8qKiAgICAgIFlvaGFpIEFyYXJhdCBvZiBUb3JvbnRvICAgICAgKipcXG4gICAgICAvLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxcbiAgICAgIC8vXFxuICAgICAgdGhpcy4kZWxlbWVudC5vZmYoJy5yZXNpemVtZS56Zi50cmlnZ2VyJykub24oe1xcbiAgICAgICAgJ3Jlc2l6ZW1lLnpmLnRyaWdnZXInOiB0aGlzLl9wcmVwYXJlRm9yT3JiaXQuYmluZCh0aGlzKVxcbiAgICAgIH0pO1xcbiAgICAgIGlmICh0aGlzLiRzbGlkZXMubGVuZ3RoID4gMSkge1xcblxcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zd2lwZSkge1xcbiAgICAgICAgICB0aGlzLiRzbGlkZXMub2ZmKCdzd2lwZWxlZnQuemYub3JiaXQgc3dpcGVyaWdodC56Zi5vcmJpdCcpLm9uKCdzd2lwZWxlZnQuemYub3JiaXQnLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgICAgICBfdGhpcy5jaGFuZ2VTbGlkZSh0cnVlKTtcXG4gICAgICAgICAgfSkub24oJ3N3aXBlcmlnaHQuemYub3JiaXQnLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgICAgICBfdGhpcy5jaGFuZ2VTbGlkZShmYWxzZSk7XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICAgICAgLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcXG5cXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0b1BsYXkpIHtcXG4gICAgICAgICAgdGhpcy4kc2xpZGVzLm9uKCdjbGljay56Zi5vcmJpdCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICBfdGhpcy4kZWxlbWVudC5kYXRhKCdjbGlja2VkT24nLCBfdGhpcy4kZWxlbWVudC5kYXRhKCdjbGlja2VkT24nKSA/IGZhbHNlIDogdHJ1ZSk7XFxuICAgICAgICAgICAgX3RoaXMudGltZXJbX3RoaXMuJGVsZW1lbnQuZGF0YSgnY2xpY2tlZE9uJykgPyAncGF1c2UnIDogJ3N0YXJ0J10oKTtcXG4gICAgICAgICAgfSk7XFxuXFxuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGF1c2VPbkhvdmVyKSB7XFxuICAgICAgICAgICAgdGhpcy4kZWxlbWVudC5vbignbW91c2VlbnRlci56Zi5vcmJpdCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgIF90aGlzLnRpbWVyLnBhdXNlKCk7XFxuICAgICAgICAgICAgfSkub24oJ21vdXNlbGVhdmUuemYub3JiaXQnLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICBpZiAoIV90aGlzLiRlbGVtZW50LmRhdGEoJ2NsaWNrZWRPbicpKSB7XFxuICAgICAgICAgICAgICAgIF90aGlzLnRpbWVyLnN0YXJ0KCk7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubmF2QnV0dG9ucykge1xcbiAgICAgICAgICB2YXIgJGNvbnRyb2xzID0gdGhpcy4kZWxlbWVudC5maW5kKCcuJyArIHRoaXMub3B0aW9ucy5uZXh0Q2xhc3MgKyAnLCAuJyArIHRoaXMub3B0aW9ucy5wcmV2Q2xhc3MpO1xcbiAgICAgICAgICAkY29udHJvbHMuYXR0cigndGFiaW5kZXgnLCAwKVxcbiAgICAgICAgICAvL2Fsc28gbmVlZCB0byBoYW5kbGUgZW50ZXIvcmV0dXJuIGFuZCBzcGFjZWJhciBrZXkgcHJlc3Nlc1xcbiAgICAgICAgICAub24oJ2NsaWNrLnpmLm9yYml0IHRvdWNoZW5kLnpmLm9yYml0JywgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICAgICAgX3RoaXMuY2hhbmdlU2xpZGUoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSh0aGlzKS5oYXNDbGFzcyhfdGhpcy5vcHRpb25zLm5leHRDbGFzcykpO1xcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYnVsbGV0cykge1xcbiAgICAgICAgICB0aGlzLiRidWxsZXRzLm9uKCdjbGljay56Zi5vcmJpdCB0b3VjaGVuZC56Zi5vcmJpdCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICBpZiAoL2lzLWFjdGl2ZS9nLnRlc3QodGhpcy5jbGFzc05hbWUpKSB7XFxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICAgICAgfSAvL2lmIHRoaXMgaXMgYWN0aXZlLCBraWNrIG91dCBvZiBmdW5jdGlvbi5cXG4gICAgICAgICAgICB2YXIgaWR4ID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSh0aGlzKS5kYXRhKCdzbGlkZScpLFxcbiAgICAgICAgICAgICAgICBsdHIgPSBpZHggPiBfdGhpcy4kc2xpZGVzLmZpbHRlcignLmlzLWFjdGl2ZScpLmRhdGEoJ3NsaWRlJyksXFxuICAgICAgICAgICAgICAgICRzbGlkZSA9IF90aGlzLiRzbGlkZXMuZXEoaWR4KTtcXG5cXG4gICAgICAgICAgICBfdGhpcy5jaGFuZ2VTbGlkZShsdHIsICRzbGlkZSwgaWR4KTtcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmFjY2Vzc2libGUpIHtcXG4gICAgICAgICAgdGhpcy4kd3JhcHBlci5hZGQodGhpcy4kYnVsbGV0cykub24oJ2tleWRvd24uemYub3JiaXQnLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgICAgIC8vIGhhbmRsZSBrZXlib2FyZCBldmVudCB3aXRoIGtleWJvYXJkIHV0aWxcXG4gICAgICAgICAgICBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX2ZvdW5kYXRpb25fdXRpbF9rZXlib2FyZF9fW1xcXCJhXFxcIiAvKiBLZXlib2FyZCAqL10uaGFuZGxlS2V5KGUsICdPcmJpdCcsIHtcXG4gICAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICAgX3RoaXMuY2hhbmdlU2xpZGUodHJ1ZSk7XFxuICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgcHJldmlvdXM6IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICAgX3RoaXMuY2hhbmdlU2xpZGUoZmFsc2UpO1xcbiAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgIGhhbmRsZWQ6IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICAgLy8gaWYgYnVsbGV0IGlzIGZvY3VzZWQsIG1ha2Ugc3VyZSBmb2N1cyBtb3Zlc1xcbiAgICAgICAgICAgICAgICBpZiAoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKShlLnRhcmdldCkuaXMoX3RoaXMuJGJ1bGxldHMpKSB7XFxuICAgICAgICAgICAgICAgICAgX3RoaXMuJGJ1bGxldHMuZmlsdGVyKCcuaXMtYWN0aXZlJykuZm9jdXMoKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIFJlc2V0cyBPcmJpdCBzbyBpdCBjYW4gYmUgcmVpbml0aWFsaXplZFxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAnX3Jlc2V0JyxcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXNldCgpIHtcXG4gICAgICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiB0aGVyZSBhcmUgbm8gc2xpZGVzIChmaXJzdCBydW4pXFxuICAgICAgaWYgKHR5cGVvZiB0aGlzLiRzbGlkZXMgPT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRoaXMuJHNsaWRlcy5sZW5ndGggPiAxKSB7XFxuICAgICAgICAvLyBSZW1vdmUgb2xkIGV2ZW50c1xcbiAgICAgICAgdGhpcy4kZWxlbWVudC5vZmYoJy56Zi5vcmJpdCcpLmZpbmQoJyonKS5vZmYoJy56Zi5vcmJpdCcpO1xcblxcbiAgICAgICAgLy8gUmVzdGFydCB0aW1lciBpZiBhdXRvUGxheSBpcyBlbmFibGVkXFxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmF1dG9QbGF5KSB7XFxuICAgICAgICAgIHRoaXMudGltZXIucmVzdGFydCgpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgLy8gUmVzZXQgYWxsIHNsaWRkZXNcXG4gICAgICAgIHRoaXMuJHNsaWRlcy5lYWNoKGZ1bmN0aW9uIChlbCkge1xcbiAgICAgICAgICBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKGVsKS5yZW1vdmVDbGFzcygnaXMtYWN0aXZlIGlzLWFjdGl2ZSBpcy1pbicpLnJlbW92ZUF0dHIoJ2FyaWEtbGl2ZScpLmhpZGUoKTtcXG4gICAgICAgIH0pO1xcblxcbiAgICAgICAgLy8gU2hvdyB0aGUgZmlyc3Qgc2xpZGVcXG4gICAgICAgIHRoaXMuJHNsaWRlcy5maXJzdCgpLmFkZENsYXNzKCdpcy1hY3RpdmUnKS5zaG93KCk7XFxuXFxuICAgICAgICAvLyBUcmlnZ2VycyB3aGVuIHRoZSBzbGlkZSBoYXMgZmluaXNoZWQgYW5pbWF0aW5nXFxuICAgICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ3NsaWRlY2hhbmdlLnpmLm9yYml0JywgW3RoaXMuJHNsaWRlcy5maXJzdCgpXSk7XFxuXFxuICAgICAgICAvLyBTZWxlY3QgZmlyc3QgYnVsbGV0IGlmIGJ1bGxldHMgYXJlIHByZXNlbnRcXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYnVsbGV0cykge1xcbiAgICAgICAgICB0aGlzLl91cGRhdGVCdWxsZXRzKDApO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgKiBDaGFuZ2VzIHRoZSBjdXJyZW50IHNsaWRlIHRvIGEgbmV3IG9uZS5cXG4gICAgKiBAZnVuY3Rpb25cXG4gICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzTFRSIC0gZmxhZyBpZiB0aGUgc2xpZGUgc2hvdWxkIG1vdmUgbGVmdCB0byByaWdodC5cXG4gICAgKiBAcGFyYW0ge2pRdWVyeX0gY2hvc2VuU2xpZGUgLSB0aGUgalF1ZXJ5IGVsZW1lbnQgb2YgdGhlIHNsaWRlIHRvIHNob3cgbmV4dCwgaWYgb25lIGlzIHNlbGVjdGVkLlxcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSBpZHggLSB0aGUgaW5kZXggb2YgdGhlIG5ldyBzbGlkZSBpbiBpdHMgY29sbGVjdGlvbiwgaWYgb25lIGNob3Nlbi5cXG4gICAgKiBAZmlyZXMgT3JiaXQjc2xpZGVjaGFuZ2VcXG4gICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAnY2hhbmdlU2xpZGUnLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2hhbmdlU2xpZGUoaXNMVFIsIGNob3NlblNsaWRlLCBpZHgpIHtcXG4gICAgICBpZiAoIXRoaXMuJHNsaWRlcykge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH0gLy8gRG9uJ3QgZnJlYWsgb3V0IGlmIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgY2xlYW51cFxcbiAgICAgIHZhciAkY3VyU2xpZGUgPSB0aGlzLiRzbGlkZXMuZmlsdGVyKCcuaXMtYWN0aXZlJykuZXEoMCk7XFxuXFxuICAgICAgaWYgKC9tdWkvZy50ZXN0KCRjdXJTbGlkZVswXS5jbGFzc05hbWUpKSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfSAvL2lmIHRoZSBzbGlkZSBpcyBjdXJyZW50bHkgYW5pbWF0aW5nLCBraWNrIG91dCBvZiB0aGUgZnVuY3Rpb25cXG5cXG4gICAgICB2YXIgJGZpcnN0U2xpZGUgPSB0aGlzLiRzbGlkZXMuZmlyc3QoKSxcXG4gICAgICAgICAgJGxhc3RTbGlkZSA9IHRoaXMuJHNsaWRlcy5sYXN0KCksXFxuICAgICAgICAgIGRpckluID0gaXNMVFIgPyAnUmlnaHQnIDogJ0xlZnQnLFxcbiAgICAgICAgICBkaXJPdXQgPSBpc0xUUiA/ICdMZWZ0JyA6ICdSaWdodCcsXFxuICAgICAgICAgIF90aGlzID0gdGhpcyxcXG4gICAgICAgICAgJG5ld1NsaWRlO1xcblxcbiAgICAgIGlmICghY2hvc2VuU2xpZGUpIHtcXG4gICAgICAgIC8vbW9zdCBvZiB0aGUgdGltZSwgdGhpcyB3aWxsIGJlIGF1dG8gcGxheWVkIG9yIGNsaWNrZWQgZnJvbSB0aGUgbmF2QnV0dG9ucy5cXG4gICAgICAgICRuZXdTbGlkZSA9IGlzTFRSID8gLy9pZiB3cmFwcGluZyBlbmFibGVkLCBjaGVjayB0byBzZWUgaWYgdGhlcmUgaXMgYSBgbmV4dGAgb3IgYHByZXZgIHNpYmxpbmcsIGlmIG5vdCwgc2VsZWN0IHRoZSBmaXJzdCBvciBsYXN0IHNsaWRlIHRvIGZpbGwgaW4uIGlmIHdyYXBwaW5nIG5vdCBlbmFibGVkLCBhdHRlbXB0IHRvIHNlbGVjdCBgbmV4dGAgb3IgYHByZXZgLCBpZiB0aGVyZSdzIG5vdGhpbmcgdGhlcmUsIHRoZSBmdW5jdGlvbiB3aWxsIGtpY2sgb3V0IG9uIG5leHQgc3RlcC4gQ1JBWlkgTkVTVEVEIFRFUk5BUklFUyEhISEhXFxuICAgICAgICB0aGlzLm9wdGlvbnMuaW5maW5pdGVXcmFwID8gJGN1clNsaWRlLm5leHQoJy4nICsgdGhpcy5vcHRpb25zLnNsaWRlQ2xhc3MpLmxlbmd0aCA/ICRjdXJTbGlkZS5uZXh0KCcuJyArIHRoaXMub3B0aW9ucy5zbGlkZUNsYXNzKSA6ICRmaXJzdFNsaWRlIDogJGN1clNsaWRlLm5leHQoJy4nICsgdGhpcy5vcHRpb25zLnNsaWRlQ2xhc3MpIDogLy9waWNrIG5leHQgc2xpZGUgaWYgbW92aW5nIGxlZnQgdG8gcmlnaHRcXG4gICAgICAgIHRoaXMub3B0aW9ucy5pbmZpbml0ZVdyYXAgPyAkY3VyU2xpZGUucHJldignLicgKyB0aGlzLm9wdGlvbnMuc2xpZGVDbGFzcykubGVuZ3RoID8gJGN1clNsaWRlLnByZXYoJy4nICsgdGhpcy5vcHRpb25zLnNsaWRlQ2xhc3MpIDogJGxhc3RTbGlkZSA6ICRjdXJTbGlkZS5wcmV2KCcuJyArIHRoaXMub3B0aW9ucy5zbGlkZUNsYXNzKTsgLy9waWNrIHByZXYgc2xpZGUgaWYgbW92aW5nIHJpZ2h0IHRvIGxlZnRcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgJG5ld1NsaWRlID0gY2hvc2VuU2xpZGU7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICgkbmV3U2xpZGUubGVuZ3RoKSB7XFxuICAgICAgICAvKipcXG4gICAgICAgICogVHJpZ2dlcnMgYmVmb3JlIHRoZSBuZXh0IHNsaWRlIHN0YXJ0cyBhbmltYXRpbmcgaW4gYW5kIG9ubHkgaWYgYSBuZXh0IHNsaWRlIGhhcyBiZWVuIGZvdW5kLlxcbiAgICAgICAgKiBAZXZlbnQgT3JiaXQjYmVmb3Jlc2xpZGVjaGFuZ2VcXG4gICAgICAgICovXFxuICAgICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ2JlZm9yZXNsaWRlY2hhbmdlLnpmLm9yYml0JywgWyRjdXJTbGlkZSwgJG5ld1NsaWRlXSk7XFxuXFxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmJ1bGxldHMpIHtcXG4gICAgICAgICAgaWR4ID0gaWR4IHx8IHRoaXMuJHNsaWRlcy5pbmRleCgkbmV3U2xpZGUpOyAvL2dyYWIgaW5kZXggdG8gdXBkYXRlIGJ1bGxldHNcXG4gICAgICAgICAgdGhpcy5fdXBkYXRlQnVsbGV0cyhpZHgpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy51c2VNVUkgJiYgIXRoaXMuJGVsZW1lbnQuaXMoJzpoaWRkZW4nKSkge1xcbiAgICAgICAgICBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX2ZvdW5kYXRpb25fdXRpbF9tb3Rpb25fX1tcXFwiYVxcXCIgLyogTW90aW9uICovXS5hbmltYXRlSW4oJG5ld1NsaWRlLmFkZENsYXNzKCdpcy1hY3RpdmUnKS5jc3MoeyAncG9zaXRpb24nOiAnYWJzb2x1dGUnLCAndG9wJzogMCB9KSwgdGhpcy5vcHRpb25zWydhbmltSW5Gcm9tJyArIGRpckluXSwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICRuZXdTbGlkZS5jc3MoeyAncG9zaXRpb24nOiAncmVsYXRpdmUnLCAnZGlzcGxheSc6ICdibG9jaycgfSkuYXR0cignYXJpYS1saXZlJywgJ3BvbGl0ZScpO1xcbiAgICAgICAgICB9KTtcXG5cXG4gICAgICAgICAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19mb3VuZGF0aW9uX3V0aWxfbW90aW9uX19bXFxcImFcXFwiIC8qIE1vdGlvbiAqL10uYW5pbWF0ZU91dCgkY3VyU2xpZGUucmVtb3ZlQ2xhc3MoJ2lzLWFjdGl2ZScpLCB0aGlzLm9wdGlvbnNbJ2FuaW1PdXRUbycgKyBkaXJPdXRdLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgJGN1clNsaWRlLnJlbW92ZUF0dHIoJ2FyaWEtbGl2ZScpO1xcbiAgICAgICAgICAgIGlmIChfdGhpcy5vcHRpb25zLmF1dG9QbGF5ICYmICFfdGhpcy50aW1lci5pc1BhdXNlZCkge1xcbiAgICAgICAgICAgICAgX3RoaXMudGltZXIucmVzdGFydCgpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAvL2RvIHN0dWZmP1xcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICRjdXJTbGlkZS5yZW1vdmVDbGFzcygnaXMtYWN0aXZlIGlzLWluJykucmVtb3ZlQXR0cignYXJpYS1saXZlJykuaGlkZSgpO1xcbiAgICAgICAgICAkbmV3U2xpZGUuYWRkQ2xhc3MoJ2lzLWFjdGl2ZSBpcy1pbicpLmF0dHIoJ2FyaWEtbGl2ZScsICdwb2xpdGUnKS5zaG93KCk7XFxuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0b1BsYXkgJiYgIXRoaXMudGltZXIuaXNQYXVzZWQpIHtcXG4gICAgICAgICAgICB0aGlzLnRpbWVyLnJlc3RhcnQoKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgLyoqXFxuICAgICAgICAqIFRyaWdnZXJzIHdoZW4gdGhlIHNsaWRlIGhhcyBmaW5pc2hlZCBhbmltYXRpbmcgaW4uXFxuICAgICAgICAqIEBldmVudCBPcmJpdCNzbGlkZWNoYW5nZVxcbiAgICAgICAgKi9cXG4gICAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignc2xpZGVjaGFuZ2UuemYub3JiaXQnLCBbJG5ld1NsaWRlXSk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAqIFVwZGF0ZXMgdGhlIGFjdGl2ZSBzdGF0ZSBvZiB0aGUgYnVsbGV0cywgaWYgZGlzcGxheWVkLlxcbiAgICAqIEBmdW5jdGlvblxcbiAgICAqIEBwcml2YXRlXFxuICAgICogQHBhcmFtIHtOdW1iZXJ9IGlkeCAtIHRoZSBpbmRleCBvZiB0aGUgY3VycmVudCBzbGlkZS5cXG4gICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAnX3VwZGF0ZUJ1bGxldHMnLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZUJ1bGxldHMoaWR4KSB7XFxuICAgICAgdmFyICRvbGRCdWxsZXQgPSB0aGlzLiRlbGVtZW50LmZpbmQoJy4nICsgdGhpcy5vcHRpb25zLmJveE9mQnVsbGV0cykuZmluZCgnLmlzLWFjdGl2ZScpLnJlbW92ZUNsYXNzKCdpcy1hY3RpdmUnKS5ibHVyKCksXFxuICAgICAgICAgIHNwYW4gPSAkb2xkQnVsbGV0LmZpbmQoJ3NwYW46bGFzdCcpLmRldGFjaCgpLFxcbiAgICAgICAgICAkbmV3QnVsbGV0ID0gdGhpcy4kYnVsbGV0cy5lcShpZHgpLmFkZENsYXNzKCdpcy1hY3RpdmUnKS5hcHBlbmQoc3Bhbik7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICogRGVzdHJveXMgdGhlIGNhcm91c2VsIGFuZCBoaWRlcyB0aGUgZWxlbWVudC5cXG4gICAgKiBAZnVuY3Rpb25cXG4gICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAnX2Rlc3Ryb3knLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Rlc3Ryb3koKSB7XFxuICAgICAgdGhpcy4kZWxlbWVudC5vZmYoJy56Zi5vcmJpdCcpLmZpbmQoJyonKS5vZmYoJy56Zi5vcmJpdCcpLmVuZCgpLmhpZGUoKTtcXG4gICAgfVxcbiAgfV0pO1xcblxcbiAgcmV0dXJuIE9yYml0O1xcbn0oX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19mb3VuZGF0aW9uX3BsdWdpbl9fW1xcXCJhXFxcIiAvKiBQbHVnaW4gKi9dKTtcXG5cXG5PcmJpdC5kZWZhdWx0cyA9IHtcXG4gIC8qKlxcbiAgKiBUZWxscyB0aGUgSlMgdG8gbG9vayBmb3IgYW5kIGxvYWRCdWxsZXRzLlxcbiAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICogQGRlZmF1bHQgdHJ1ZVxcbiAgKi9cXG4gIGJ1bGxldHM6IHRydWUsXFxuICAvKipcXG4gICogVGVsbHMgdGhlIEpTIHRvIGFwcGx5IGV2ZW50IGxpc3RlbmVycyB0byBuYXYgYnV0dG9uc1xcbiAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICogQGRlZmF1bHQgdHJ1ZVxcbiAgKi9cXG4gIG5hdkJ1dHRvbnM6IHRydWUsXFxuICAvKipcXG4gICogbW90aW9uLXVpIGFuaW1hdGlvbiBjbGFzcyB0byBhcHBseVxcbiAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7c3RyaW5nfVxcbiAgKiBAZGVmYXVsdCAnc2xpZGUtaW4tcmlnaHQnXFxuICAqL1xcbiAgYW5pbUluRnJvbVJpZ2h0OiAnc2xpZGUtaW4tcmlnaHQnLFxcbiAgLyoqXFxuICAqIG1vdGlvbi11aSBhbmltYXRpb24gY2xhc3MgdG8gYXBwbHlcXG4gICogQG9wdGlvblxcbiAgICogQHR5cGUge3N0cmluZ31cXG4gICogQGRlZmF1bHQgJ3NsaWRlLW91dC1yaWdodCdcXG4gICovXFxuICBhbmltT3V0VG9SaWdodDogJ3NsaWRlLW91dC1yaWdodCcsXFxuICAvKipcXG4gICogbW90aW9uLXVpIGFuaW1hdGlvbiBjbGFzcyB0byBhcHBseVxcbiAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7c3RyaW5nfVxcbiAgKiBAZGVmYXVsdCAnc2xpZGUtaW4tbGVmdCdcXG4gICpcXG4gICovXFxuICBhbmltSW5Gcm9tTGVmdDogJ3NsaWRlLWluLWxlZnQnLFxcbiAgLyoqXFxuICAqIG1vdGlvbi11aSBhbmltYXRpb24gY2xhc3MgdG8gYXBwbHlcXG4gICogQG9wdGlvblxcbiAgICogQHR5cGUge3N0cmluZ31cXG4gICogQGRlZmF1bHQgJ3NsaWRlLW91dC1sZWZ0J1xcbiAgKi9cXG4gIGFuaW1PdXRUb0xlZnQ6ICdzbGlkZS1vdXQtbGVmdCcsXFxuICAvKipcXG4gICogQWxsb3dzIE9yYml0IHRvIGF1dG9tYXRpY2FsbHkgYW5pbWF0ZSBvbiBwYWdlIGxvYWQuXFxuICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtib29sZWFufVxcbiAgKiBAZGVmYXVsdCB0cnVlXFxuICAqL1xcbiAgYXV0b1BsYXk6IHRydWUsXFxuICAvKipcXG4gICogQW1vdW50IG9mIHRpbWUsIGluIG1zLCBiZXR3ZWVuIHNsaWRlIHRyYW5zaXRpb25zXFxuICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtudW1iZXJ9XFxuICAqIEBkZWZhdWx0IDUwMDBcXG4gICovXFxuICB0aW1lckRlbGF5OiA1MDAwLFxcbiAgLyoqXFxuICAqIEFsbG93cyBPcmJpdCB0byBpbmZpbml0ZWx5IGxvb3AgdGhyb3VnaCB0aGUgc2xpZGVzXFxuICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtib29sZWFufVxcbiAgKiBAZGVmYXVsdCB0cnVlXFxuICAqL1xcbiAgaW5maW5pdGVXcmFwOiB0cnVlLFxcbiAgLyoqXFxuICAqIEFsbG93cyB0aGUgT3JiaXQgc2xpZGVzIHRvIGJpbmQgdG8gc3dpcGUgZXZlbnRzIGZvciBtb2JpbGUsIHJlcXVpcmVzIGFuIGFkZGl0aW9uYWwgdXRpbCBsaWJyYXJ5XFxuICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtib29sZWFufVxcbiAgKiBAZGVmYXVsdCB0cnVlXFxuICAqL1xcbiAgc3dpcGU6IHRydWUsXFxuICAvKipcXG4gICogQWxsb3dzIHRoZSB0aW1pbmcgZnVuY3Rpb24gdG8gcGF1c2UgYW5pbWF0aW9uIG9uIGhvdmVyLlxcbiAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICogQGRlZmF1bHQgdHJ1ZVxcbiAgKi9cXG4gIHBhdXNlT25Ib3ZlcjogdHJ1ZSxcXG4gIC8qKlxcbiAgKiBBbGxvd3MgT3JiaXQgdG8gYmluZCBrZXlib2FyZCBldmVudHMgdG8gdGhlIHNsaWRlciwgdG8gYW5pbWF0ZSBmcmFtZXMgd2l0aCBhcnJvdyBrZXlzXFxuICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtib29sZWFufVxcbiAgKiBAZGVmYXVsdCB0cnVlXFxuICAqL1xcbiAgYWNjZXNzaWJsZTogdHJ1ZSxcXG4gIC8qKlxcbiAgKiBDbGFzcyBhcHBsaWVkIHRvIHRoZSBjb250YWluZXIgb2YgT3JiaXRcXG4gICogQG9wdGlvblxcbiAgICogQHR5cGUge3N0cmluZ31cXG4gICogQGRlZmF1bHQgJ29yYml0LWNvbnRhaW5lcidcXG4gICovXFxuICBjb250YWluZXJDbGFzczogJ29yYml0LWNvbnRhaW5lcicsXFxuICAvKipcXG4gICogQ2xhc3MgYXBwbGllZCB0byBpbmRpdmlkdWFsIHNsaWRlcy5cXG4gICogQG9wdGlvblxcbiAgICogQHR5cGUge3N0cmluZ31cXG4gICogQGRlZmF1bHQgJ29yYml0LXNsaWRlJ1xcbiAgKi9cXG4gIHNsaWRlQ2xhc3M6ICdvcmJpdC1zbGlkZScsXFxuICAvKipcXG4gICogQ2xhc3MgYXBwbGllZCB0byB0aGUgYnVsbGV0IGNvbnRhaW5lci4gWW91J3JlIHdlbGNvbWUuXFxuICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtzdHJpbmd9XFxuICAqIEBkZWZhdWx0ICdvcmJpdC1idWxsZXRzJ1xcbiAgKi9cXG4gIGJveE9mQnVsbGV0czogJ29yYml0LWJ1bGxldHMnLFxcbiAgLyoqXFxuICAqIENsYXNzIGFwcGxpZWQgdG8gdGhlIGBuZXh0YCBuYXZpZ2F0aW9uIGJ1dHRvbi5cXG4gICogQG9wdGlvblxcbiAgICogQHR5cGUge3N0cmluZ31cXG4gICogQGRlZmF1bHQgJ29yYml0LW5leHQnXFxuICAqL1xcbiAgbmV4dENsYXNzOiAnb3JiaXQtbmV4dCcsXFxuICAvKipcXG4gICogQ2xhc3MgYXBwbGllZCB0byB0aGUgYHByZXZpb3VzYCBuYXZpZ2F0aW9uIGJ1dHRvbi5cXG4gICogQG9wdGlvblxcbiAgICogQHR5cGUge3N0cmluZ31cXG4gICogQGRlZmF1bHQgJ29yYml0LXByZXZpb3VzJ1xcbiAgKi9cXG4gIHByZXZDbGFzczogJ29yYml0LXByZXZpb3VzJyxcXG4gIC8qKlxcbiAgKiBCb29sZWFuIHRvIGZsYWcgdGhlIGpzIHRvIHVzZSBtb3Rpb24gdWkgY2xhc3NlcyBvciBub3QuIERlZmF1bHQgdG8gdHJ1ZSBmb3IgYmFja3dhcmRzIGNvbXBhdGFiaWxpdHkuXFxuICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtib29sZWFufVxcbiAgKiBAZGVmYXVsdCB0cnVlXFxuICAqL1xcbiAgdXNlTVVJOiB0cnVlXFxufTtcXG5cXG5cXG5cXG4vKioqLyB9KSxcXG4vKiAyOCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXFwidXNlIHN0cmljdFxcXCI7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiYVxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gUmVzcG9uc2l2ZUFjY29yZGlvblRhYnM7IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCA9IF9fd2VicGFja19yZXF1aXJlX18ubihfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX2ZvdW5kYXRpb25fdXRpbF9tZWRpYVF1ZXJ5X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX2ZvdW5kYXRpb25fdXRpbF9jb3JlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX2ZvdW5kYXRpb25fcGx1Z2luX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX2ZvdW5kYXRpb25fYWNjb3JkaW9uX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19mb3VuZGF0aW9uX3RhYnNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xcblxcblxcbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXFxcInZhbHVlXFxcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xcblxcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7IH0gfVxcblxcbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcXFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXFxcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcXFwib2JqZWN0XFxcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXFxcImZ1bmN0aW9uXFxcIikgPyBjYWxsIDogc2VsZjsgfVxcblxcbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFxcXCJmdW5jdGlvblxcXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFxcXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuLy8gVGhlIHBsdWdpbiBtYXRjaGVzIHRoZSBwbHVnaW4gY2xhc3NlcyB3aXRoIHRoZXNlIHBsdWdpbiBpbnN0YW5jZXMuXFxudmFyIE1lbnVQbHVnaW5zID0ge1xcbiAgdGFiczoge1xcbiAgICBjc3NDbGFzczogJ3RhYnMnLFxcbiAgICBwbHVnaW46IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fZm91bmRhdGlvbl90YWJzX19bXFxcImFcXFwiIC8qIFRhYnMgKi9dXFxuICB9LFxcbiAgYWNjb3JkaW9uOiB7XFxuICAgIGNzc0NsYXNzOiAnYWNjb3JkaW9uJyxcXG4gICAgcGx1Z2luOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX2ZvdW5kYXRpb25fYWNjb3JkaW9uX19bXFxcImFcXFwiIC8qIEFjY29yZGlvbiAqL11cXG4gIH1cXG59O1xcblxcbi8qKlxcbiAqIFJlc3BvbnNpdmVBY2NvcmRpb25UYWJzIG1vZHVsZS5cXG4gKiBAbW9kdWxlIGZvdW5kYXRpb24ucmVzcG9uc2l2ZUFjY29yZGlvblRhYnNcXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLm1vdGlvblxcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLmFjY29yZGlvblxcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnRhYnNcXG4gKi9cXG5cXG52YXIgUmVzcG9uc2l2ZUFjY29yZGlvblRhYnMgPSBmdW5jdGlvbiAoX1BsdWdpbikge1xcbiAgX2luaGVyaXRzKFJlc3BvbnNpdmVBY2NvcmRpb25UYWJzLCBfUGx1Z2luKTtcXG5cXG4gIGZ1bmN0aW9uIFJlc3BvbnNpdmVBY2NvcmRpb25UYWJzKCkge1xcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVzcG9uc2l2ZUFjY29yZGlvblRhYnMpO1xcblxcbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFJlc3BvbnNpdmVBY2NvcmRpb25UYWJzLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoUmVzcG9uc2l2ZUFjY29yZGlvblRhYnMpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcXG4gIH1cXG5cXG4gIF9jcmVhdGVDbGFzcyhSZXNwb25zaXZlQWNjb3JkaW9uVGFicywgW3tcXG4gICAga2V5OiAnX3NldHVwJyxcXG5cXG4gICAgLyoqXFxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgYSByZXNwb25zaXZlIGFjY29yZGlvbiB0YWJzLlxcbiAgICAgKiBAY2xhc3NcXG4gICAgICogQG5hbWUgUmVzcG9uc2l2ZUFjY29yZGlvblRhYnNcXG4gICAgICogQGZpcmVzIFJlc3BvbnNpdmVBY2NvcmRpb25UYWJzI2luaXRcXG4gICAgICogQHBhcmFtIHtqUXVlcnl9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIG1ha2UgaW50byBSZXNwb25zaXZlIEFjY29yZGlvbiBUYWJzLlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlcyB0byB0aGUgZGVmYXVsdCBwbHVnaW4gc2V0dGluZ3MuXFxuICAgICAqL1xcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwKGVsZW1lbnQsIG9wdGlvbnMpIHtcXG4gICAgICB0aGlzLiRlbGVtZW50ID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKShlbGVtZW50KTtcXG4gICAgICB0aGlzLm9wdGlvbnMgPSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdC5hLmV4dGVuZCh7fSwgdGhpcy4kZWxlbWVudC5kYXRhKCksIG9wdGlvbnMpO1xcbiAgICAgIHRoaXMucnVsZXMgPSB0aGlzLiRlbGVtZW50LmRhdGEoJ3Jlc3BvbnNpdmUtYWNjb3JkaW9uLXRhYnMnKTtcXG4gICAgICB0aGlzLmN1cnJlbnRNcSA9IG51bGw7XFxuICAgICAgdGhpcy5jdXJyZW50UGx1Z2luID0gbnVsbDtcXG4gICAgICB0aGlzLmNsYXNzTmFtZSA9ICdSZXNwb25zaXZlQWNjb3JkaW9uVGFicyc7IC8vIGllOSBiYWNrIGNvbXBhdFxcbiAgICAgIGlmICghdGhpcy4kZWxlbWVudC5hdHRyKCdpZCcpKSB7XFxuICAgICAgICB0aGlzLiRlbGVtZW50LmF0dHIoJ2lkJywgX193ZWJwYWNrX3JlcXVpcmVfXy5pKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fZm91bmRhdGlvbl91dGlsX2NvcmVfX1tcXFwiYlxcXCIgLyogR2V0WW9EaWdpdHMgKi9dKSg2LCAncmVzcG9uc2l2ZWFjY29yZGlvbnRhYnMnKSk7XFxuICAgICAgfTtcXG5cXG4gICAgICB0aGlzLl9pbml0KCk7XFxuICAgICAgdGhpcy5fZXZlbnRzKCk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIEluaXRpYWxpemVzIHRoZSBNZW51IGJ5IHBhcnNpbmcgdGhlIGNsYXNzZXMgZnJvbSB0aGUgJ2RhdGEtcmVzcG9uc2l2ZS1hY2NvcmRpb24tdGFicycgYXR0cmlidXRlIG9uIHRoZSBlbGVtZW50LlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogJ19pbml0JyxcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0KCkge1xcbiAgICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fZm91bmRhdGlvbl91dGlsX21lZGlhUXVlcnlfX1tcXFwiYVxcXCIgLyogTWVkaWFRdWVyeSAqL10uX2luaXQoKTtcXG5cXG4gICAgICAvLyBUaGUgZmlyc3QgdGltZSBhbiBJbnRlcmNoYW5nZSBwbHVnaW4gaXMgaW5pdGlhbGl6ZWQsIHRoaXMucnVsZXMgaXMgY29udmVydGVkIGZyb20gYSBzdHJpbmcgb2YgXFxcImNsYXNzZXNcXFwiIHRvIGFuIG9iamVjdCBvZiBydWxlc1xcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5ydWxlcyA9PT0gJ3N0cmluZycpIHtcXG4gICAgICAgIHZhciBydWxlc1RyZWUgPSB7fTtcXG5cXG4gICAgICAgIC8vIFBhcnNlIHJ1bGVzIGZyb20gXFxcImNsYXNzZXNcXFwiIHB1bGxlZCBmcm9tIGRhdGEgYXR0cmlidXRlXFxuICAgICAgICB2YXIgcnVsZXMgPSB0aGlzLnJ1bGVzLnNwbGl0KCcgJyk7XFxuXFxuICAgICAgICAvLyBJdGVyYXRlIHRocm91Z2ggZXZlcnkgcnVsZSBmb3VuZFxcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgICB2YXIgcnVsZSA9IHJ1bGVzW2ldLnNwbGl0KCctJyk7XFxuICAgICAgICAgIHZhciBydWxlU2l6ZSA9IHJ1bGUubGVuZ3RoID4gMSA/IHJ1bGVbMF0gOiAnc21hbGwnO1xcbiAgICAgICAgICB2YXIgcnVsZVBsdWdpbiA9IHJ1bGUubGVuZ3RoID4gMSA/IHJ1bGVbMV0gOiBydWxlWzBdO1xcblxcbiAgICAgICAgICBpZiAoTWVudVBsdWdpbnNbcnVsZVBsdWdpbl0gIT09IG51bGwpIHtcXG4gICAgICAgICAgICBydWxlc1RyZWVbcnVsZVNpemVdID0gTWVudVBsdWdpbnNbcnVsZVBsdWdpbl07XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHRoaXMucnVsZXMgPSBydWxlc1RyZWU7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX2dldEFsbE9wdGlvbnMoKTtcXG5cXG4gICAgICBpZiAoIV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0LmEuaXNFbXB0eU9iamVjdCh0aGlzLnJ1bGVzKSkge1xcbiAgICAgICAgdGhpcy5fY2hlY2tNZWRpYVF1ZXJpZXMoKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH0sIHtcXG4gICAga2V5OiAnX2dldEFsbE9wdGlvbnMnLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEFsbE9wdGlvbnMoKSB7XFxuICAgICAgLy9nZXQgYWxsIGRlZmF1bHRzIGFuZCBvcHRpb25zXFxuICAgICAgdmFyIF90aGlzID0gdGhpcztcXG4gICAgICBfdGhpcy5hbGxPcHRpb25zID0ge307XFxuICAgICAgZm9yICh2YXIga2V5IGluIE1lbnVQbHVnaW5zKSB7XFxuICAgICAgICBpZiAoTWVudVBsdWdpbnMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xcbiAgICAgICAgICB2YXIgb2JqID0gTWVudVBsdWdpbnNba2V5XTtcXG4gICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICB2YXIgZHVtbXlQbHVnaW4gPSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKCc8dWw+PC91bD4nKTtcXG4gICAgICAgICAgICB2YXIgdG1wUGx1Z2luID0gbmV3IG9iai5wbHVnaW4oZHVtbXlQbHVnaW4sIF90aGlzLm9wdGlvbnMpO1xcbiAgICAgICAgICAgIGZvciAodmFyIGtleUtleSBpbiB0bXBQbHVnaW4ub3B0aW9ucykge1xcbiAgICAgICAgICAgICAgaWYgKHRtcFBsdWdpbi5vcHRpb25zLmhhc093blByb3BlcnR5KGtleUtleSkgJiYga2V5S2V5ICE9PSAnemZQbHVnaW4nKSB7XFxuICAgICAgICAgICAgICAgIHZhciBvYmpPYmogPSB0bXBQbHVnaW4ub3B0aW9uc1trZXlLZXldO1xcbiAgICAgICAgICAgICAgICBfdGhpcy5hbGxPcHRpb25zW2tleUtleV0gPSBvYmpPYmo7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHRtcFBsdWdpbi5kZXN0cm95KCk7XFxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBJbml0aWFsaXplcyBldmVudHMgZm9yIHRoZSBNZW51LlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogJ19ldmVudHMnLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2V2ZW50cygpIHtcXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xcblxcbiAgICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0KCkod2luZG93KS5vbignY2hhbmdlZC56Zi5tZWRpYXF1ZXJ5JywgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgX3RoaXMuX2NoZWNrTWVkaWFRdWVyaWVzKCk7XFxuICAgICAgfSk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIENoZWNrcyB0aGUgY3VycmVudCBzY3JlZW4gd2lkdGggYWdhaW5zdCBhdmFpbGFibGUgbWVkaWEgcXVlcmllcy4gSWYgdGhlIG1lZGlhIHF1ZXJ5IGhhcyBjaGFuZ2VkLCBhbmQgdGhlIHBsdWdpbiBuZWVkZWQgaGFzIGNoYW5nZWQsIHRoZSBwbHVnaW5zIHdpbGwgc3dhcCBvdXQuXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAnX2NoZWNrTWVkaWFRdWVyaWVzJyxcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jaGVja01lZGlhUXVlcmllcygpIHtcXG4gICAgICB2YXIgbWF0Y2hlZE1xLFxcbiAgICAgICAgICBfdGhpcyA9IHRoaXM7XFxuICAgICAgLy8gSXRlcmF0ZSB0aHJvdWdoIGVhY2ggcnVsZSBhbmQgZmluZCB0aGUgbGFzdCBtYXRjaGluZyBydWxlXFxuICAgICAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQuYS5lYWNoKHRoaXMucnVsZXMsIGZ1bmN0aW9uIChrZXkpIHtcXG4gICAgICAgIGlmIChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX2ZvdW5kYXRpb25fdXRpbF9tZWRpYVF1ZXJ5X19bXFxcImFcXFwiIC8qIE1lZGlhUXVlcnkgKi9dLmF0TGVhc3Qoa2V5KSkge1xcbiAgICAgICAgICBtYXRjaGVkTXEgPSBrZXk7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuXFxuICAgICAgLy8gTm8gbWF0Y2g/IE5vIGRpY2VcXG4gICAgICBpZiAoIW1hdGNoZWRNcSkgcmV0dXJuO1xcblxcbiAgICAgIC8vIFBsdWdpbiBhbHJlYWR5IGluaXRpYWxpemVkPyBXZSBnb29kXFxuICAgICAgaWYgKHRoaXMuY3VycmVudFBsdWdpbiBpbnN0YW5jZW9mIHRoaXMucnVsZXNbbWF0Y2hlZE1xXS5wbHVnaW4pIHJldHVybjtcXG5cXG4gICAgICAvLyBSZW1vdmUgZXhpc3RpbmcgcGx1Z2luLXNwZWNpZmljIENTUyBjbGFzc2VzXFxuICAgICAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQuYS5lYWNoKE1lbnVQbHVnaW5zLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xcbiAgICAgICAgX3RoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3ModmFsdWUuY3NzQ2xhc3MpO1xcbiAgICAgIH0pO1xcblxcbiAgICAgIC8vIEFkZCB0aGUgQ1NTIGNsYXNzIGZvciB0aGUgbmV3IHBsdWdpblxcbiAgICAgIHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3ModGhpcy5ydWxlc1ttYXRjaGVkTXFdLmNzc0NsYXNzKTtcXG5cXG4gICAgICAvLyBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhlIG5ldyBwbHVnaW5cXG4gICAgICBpZiAodGhpcy5jdXJyZW50UGx1Z2luKSB7XFxuICAgICAgICAvL2Rvbid0IGtub3cgd2h5IGJ1dCBvbiBuZXN0ZWQgZWxlbWVudHMgZGF0YSB6ZlBsdWdpbiBnZXQncyBsb3N0XFxuICAgICAgICBpZiAoIXRoaXMuY3VycmVudFBsdWdpbi4kZWxlbWVudC5kYXRhKCd6ZlBsdWdpbicpICYmIHRoaXMuc3RvcmV6ZkRhdGEpIHRoaXMuY3VycmVudFBsdWdpbi4kZWxlbWVudC5kYXRhKCd6ZlBsdWdpbicsIHRoaXMuc3RvcmV6ZkRhdGEpO1xcbiAgICAgICAgdGhpcy5jdXJyZW50UGx1Z2luLmRlc3Ryb3koKTtcXG4gICAgICB9XFxuICAgICAgdGhpcy5faGFuZGxlTWFya3VwKHRoaXMucnVsZXNbbWF0Y2hlZE1xXS5jc3NDbGFzcyk7XFxuICAgICAgdGhpcy5jdXJyZW50UGx1Z2luID0gbmV3IHRoaXMucnVsZXNbbWF0Y2hlZE1xXS5wbHVnaW4odGhpcy4kZWxlbWVudCwge30pO1xcbiAgICAgIHRoaXMuc3RvcmV6ZkRhdGEgPSB0aGlzLmN1cnJlbnRQbHVnaW4uJGVsZW1lbnQuZGF0YSgnemZQbHVnaW4nKTtcXG4gICAgfVxcbiAgfSwge1xcbiAgICBrZXk6ICdfaGFuZGxlTWFya3VwJyxcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVNYXJrdXAodG9TZXQpIHtcXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzLFxcbiAgICAgICAgICBmcm9tU3RyaW5nID0gJ2FjY29yZGlvbic7XFxuICAgICAgdmFyICRwYW5lbHMgPSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKCdbZGF0YS10YWJzLWNvbnRlbnQ9JyArIHRoaXMuJGVsZW1lbnQuYXR0cignaWQnKSArICddJyk7XFxuICAgICAgaWYgKCRwYW5lbHMubGVuZ3RoKSBmcm9tU3RyaW5nID0gJ3RhYnMnO1xcbiAgICAgIGlmIChmcm9tU3RyaW5nID09PSB0b1NldCkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH07XFxuXFxuICAgICAgdmFyIHRhYnNUaXRsZSA9IF90aGlzLmFsbE9wdGlvbnMubGlua0NsYXNzID8gX3RoaXMuYWxsT3B0aW9ucy5saW5rQ2xhc3MgOiAndGFicy10aXRsZSc7XFxuICAgICAgdmFyIHRhYnNQYW5lbCA9IF90aGlzLmFsbE9wdGlvbnMucGFuZWxDbGFzcyA/IF90aGlzLmFsbE9wdGlvbnMucGFuZWxDbGFzcyA6ICd0YWJzLXBhbmVsJztcXG5cXG4gICAgICB0aGlzLiRlbGVtZW50LnJlbW92ZUF0dHIoJ3JvbGUnKTtcXG4gICAgICB2YXIgJGxpSGVhZHMgPSB0aGlzLiRlbGVtZW50LmNoaWxkcmVuKCcuJyArIHRhYnNUaXRsZSArICcsW2RhdGEtYWNjb3JkaW9uLWl0ZW1dJykucmVtb3ZlQ2xhc3ModGFic1RpdGxlKS5yZW1vdmVDbGFzcygnYWNjb3JkaW9uLWl0ZW0nKS5yZW1vdmVBdHRyKCdkYXRhLWFjY29yZGlvbi1pdGVtJyk7XFxuICAgICAgdmFyICRsaUhlYWRzQSA9ICRsaUhlYWRzLmNoaWxkcmVuKCdhJykucmVtb3ZlQ2xhc3MoJ2FjY29yZGlvbi10aXRsZScpO1xcblxcbiAgICAgIGlmIChmcm9tU3RyaW5nID09PSAndGFicycpIHtcXG4gICAgICAgICRwYW5lbHMgPSAkcGFuZWxzLmNoaWxkcmVuKCcuJyArIHRhYnNQYW5lbCkucmVtb3ZlQ2xhc3ModGFic1BhbmVsKS5yZW1vdmVBdHRyKCdyb2xlJykucmVtb3ZlQXR0cignYXJpYS1oaWRkZW4nKS5yZW1vdmVBdHRyKCdhcmlhLWxhYmVsbGVkYnknKTtcXG4gICAgICAgICRwYW5lbHMuY2hpbGRyZW4oJ2EnKS5yZW1vdmVBdHRyKCdyb2xlJykucmVtb3ZlQXR0cignYXJpYS1jb250cm9scycpLnJlbW92ZUF0dHIoJ2FyaWEtc2VsZWN0ZWQnKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgJHBhbmVscyA9ICRsaUhlYWRzLmNoaWxkcmVuKCdbZGF0YS10YWItY29udGVudF0nKS5yZW1vdmVDbGFzcygnYWNjb3JkaW9uLWNvbnRlbnQnKTtcXG4gICAgICB9O1xcblxcbiAgICAgICRwYW5lbHMuY3NzKHsgZGlzcGxheTogJycsIHZpc2liaWxpdHk6ICcnIH0pO1xcbiAgICAgICRsaUhlYWRzLmNzcyh7IGRpc3BsYXk6ICcnLCB2aXNpYmlsaXR5OiAnJyB9KTtcXG4gICAgICBpZiAodG9TZXQgPT09ICdhY2NvcmRpb24nKSB7XFxuICAgICAgICAkcGFuZWxzLmVhY2goZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcXG4gICAgICAgICAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSh2YWx1ZSkuYXBwZW5kVG8oJGxpSGVhZHMuZ2V0KGtleSkpLmFkZENsYXNzKCdhY2NvcmRpb24tY29udGVudCcpLmF0dHIoJ2RhdGEtdGFiLWNvbnRlbnQnLCAnJykucmVtb3ZlQ2xhc3MoJ2lzLWFjdGl2ZScpLmNzcyh7IGhlaWdodDogJycgfSk7XFxuICAgICAgICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0KCkoJ1tkYXRhLXRhYnMtY29udGVudD0nICsgX3RoaXMuJGVsZW1lbnQuYXR0cignaWQnKSArICddJykuYWZ0ZXIoJzxkaXYgaWQ9XFxcInRhYnMtcGxhY2Vob2xkZXItJyArIF90aGlzLiRlbGVtZW50LmF0dHIoJ2lkJykgKyAnXFxcIj48L2Rpdj4nKS5kZXRhY2goKTtcXG4gICAgICAgICAgJGxpSGVhZHMuYWRkQ2xhc3MoJ2FjY29yZGlvbi1pdGVtJykuYXR0cignZGF0YS1hY2NvcmRpb24taXRlbScsICcnKTtcXG4gICAgICAgICAgJGxpSGVhZHNBLmFkZENsYXNzKCdhY2NvcmRpb24tdGl0bGUnKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH0gZWxzZSBpZiAodG9TZXQgPT09ICd0YWJzJykge1xcbiAgICAgICAgdmFyICR0YWJzQ29udGVudCA9IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0KCkoJ1tkYXRhLXRhYnMtY29udGVudD0nICsgX3RoaXMuJGVsZW1lbnQuYXR0cignaWQnKSArICddJyk7XFxuICAgICAgICB2YXIgJHBsYWNlaG9sZGVyID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSgnI3RhYnMtcGxhY2Vob2xkZXItJyArIF90aGlzLiRlbGVtZW50LmF0dHIoJ2lkJykpO1xcbiAgICAgICAgaWYgKCRwbGFjZWhvbGRlci5sZW5ndGgpIHtcXG4gICAgICAgICAgJHRhYnNDb250ZW50ID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSgnPGRpdiBjbGFzcz1cXFwidGFicy1jb250ZW50XFxcIj48L2Rpdj4nKS5pbnNlcnRBZnRlcigkcGxhY2Vob2xkZXIpLmF0dHIoJ2RhdGEtdGFicy1jb250ZW50JywgX3RoaXMuJGVsZW1lbnQuYXR0cignaWQnKSk7XFxuICAgICAgICAgICRwbGFjZWhvbGRlci5yZW1vdmUoKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICR0YWJzQ29udGVudCA9IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0KCkoJzxkaXYgY2xhc3M9XFxcInRhYnMtY29udGVudFxcXCI+PC9kaXY+JykuaW5zZXJ0QWZ0ZXIoX3RoaXMuJGVsZW1lbnQpLmF0dHIoJ2RhdGEtdGFicy1jb250ZW50JywgX3RoaXMuJGVsZW1lbnQuYXR0cignaWQnKSk7XFxuICAgICAgICB9O1xcbiAgICAgICAgJHBhbmVscy5lYWNoKGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XFxuICAgICAgICAgIHZhciB0ZW1wVmFsdWUgPSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKHZhbHVlKS5hcHBlbmRUbygkdGFic0NvbnRlbnQpLmFkZENsYXNzKHRhYnNQYW5lbCk7XFxuICAgICAgICAgIHZhciBoYXNoID0gJGxpSGVhZHNBLmdldChrZXkpLmhhc2guc2xpY2UoMSk7XFxuICAgICAgICAgIHZhciBpZCA9IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0KCkodmFsdWUpLmF0dHIoJ2lkJykgfHwgX193ZWJwYWNrX3JlcXVpcmVfXy5pKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fZm91bmRhdGlvbl91dGlsX2NvcmVfX1tcXFwiYlxcXCIgLyogR2V0WW9EaWdpdHMgKi9dKSg2LCAnYWNjb3JkaW9uJyk7XFxuICAgICAgICAgIGlmIChoYXNoICE9PSBpZCkge1xcbiAgICAgICAgICAgIGlmIChoYXNoICE9PSAnJykge1xcbiAgICAgICAgICAgICAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSh2YWx1ZSkuYXR0cignaWQnLCBoYXNoKTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgaGFzaCA9IGlkO1xcbiAgICAgICAgICAgICAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSh2YWx1ZSkuYXR0cignaWQnLCBoYXNoKTtcXG4gICAgICAgICAgICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0KCkoJGxpSGVhZHNBLmdldChrZXkpKS5hdHRyKCdocmVmJywgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSgkbGlIZWFkc0EuZ2V0KGtleSkpLmF0dHIoJ2hyZWYnKS5yZXBsYWNlKCcjJywgJycpICsgJyMnICsgaGFzaCk7XFxuICAgICAgICAgICAgfTtcXG4gICAgICAgICAgfTtcXG4gICAgICAgICAgdmFyIGlzQWN0aXZlID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSgkbGlIZWFkcy5nZXQoa2V5KSkuaGFzQ2xhc3MoJ2lzLWFjdGl2ZScpO1xcbiAgICAgICAgICBpZiAoaXNBY3RpdmUpIHtcXG4gICAgICAgICAgICB0ZW1wVmFsdWUuYWRkQ2xhc3MoJ2lzLWFjdGl2ZScpO1xcbiAgICAgICAgICB9O1xcbiAgICAgICAgfSk7XFxuICAgICAgICAkbGlIZWFkcy5hZGRDbGFzcyh0YWJzVGl0bGUpO1xcbiAgICAgIH07XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIERlc3Ryb3lzIHRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBwbHVnaW4gb24gdGhpcyBlbGVtZW50LCBhcyB3ZWxsIGFzIHRoZSB3aW5kb3cgcmVzaXplIGhhbmRsZXIgdGhhdCBzd2l0Y2hlcyB0aGUgcGx1Z2lucyBvdXQuXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAnX2Rlc3Ryb3knLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Rlc3Ryb3koKSB7XFxuICAgICAgaWYgKHRoaXMuY3VycmVudFBsdWdpbikgdGhpcy5jdXJyZW50UGx1Z2luLmRlc3Ryb3koKTtcXG4gICAgICBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKHdpbmRvdykub2ZmKCcuemYuUmVzcG9uc2l2ZUFjY29yZGlvblRhYnMnKTtcXG4gICAgfVxcbiAgfV0pO1xcblxcbiAgcmV0dXJuIFJlc3BvbnNpdmVBY2NvcmRpb25UYWJzO1xcbn0oX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19mb3VuZGF0aW9uX3BsdWdpbl9fW1xcXCJhXFxcIiAvKiBQbHVnaW4gKi9dKTtcXG5cXG5SZXNwb25zaXZlQWNjb3JkaW9uVGFicy5kZWZhdWx0cyA9IHt9O1xcblxcblxcblxcbi8qKiovIH0pLFxcbi8qIDI5ICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJhXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBSZXNwb25zaXZlTWVudTsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0ID0gX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfXyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fZm91bmRhdGlvbl91dGlsX21lZGlhUXVlcnlfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fZm91bmRhdGlvbl91dGlsX2NvcmVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fZm91bmRhdGlvbl9wbHVnaW5fXyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fZm91bmRhdGlvbl9kcm9wZG93bk1lbnVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX2ZvdW5kYXRpb25fZHJpbGxkb3duX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19mb3VuZGF0aW9uX2FjY29yZGlvbk1lbnVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xcblxcblxcbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXFxcInZhbHVlXFxcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xcblxcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7IH0gfVxcblxcbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcXFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXFxcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcXFwib2JqZWN0XFxcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXFxcImZ1bmN0aW9uXFxcIikgPyBjYWxsIDogc2VsZjsgfVxcblxcbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFxcXCJmdW5jdGlvblxcXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFxcXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxudmFyIE1lbnVQbHVnaW5zID0ge1xcbiAgZHJvcGRvd246IHtcXG4gICAgY3NzQ2xhc3M6ICdkcm9wZG93bicsXFxuICAgIHBsdWdpbjogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19mb3VuZGF0aW9uX2Ryb3Bkb3duTWVudV9fW1xcXCJhXFxcIiAvKiBEcm9wZG93bk1lbnUgKi9dXFxuICB9LFxcbiAgZHJpbGxkb3duOiB7XFxuICAgIGNzc0NsYXNzOiAnZHJpbGxkb3duJyxcXG4gICAgcGx1Z2luOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX2ZvdW5kYXRpb25fZHJpbGxkb3duX19bXFxcImFcXFwiIC8qIERyaWxsZG93biAqL11cXG4gIH0sXFxuICBhY2NvcmRpb246IHtcXG4gICAgY3NzQ2xhc3M6ICdhY2NvcmRpb24tbWVudScsXFxuICAgIHBsdWdpbjogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19mb3VuZGF0aW9uX2FjY29yZGlvbk1lbnVfX1tcXFwiYVxcXCIgLyogQWNjb3JkaW9uTWVudSAqL11cXG4gIH1cXG59O1xcblxcbi8vIGltcG9ydCBcXFwiZm91bmRhdGlvbi51dGlsLnRyaWdnZXJzLmpzXFxcIjtcXG5cXG5cXG4vKipcXG4gKiBSZXNwb25zaXZlTWVudSBtb2R1bGUuXFxuICogQG1vZHVsZSBmb3VuZGF0aW9uLnJlc3BvbnNpdmVNZW51XFxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC50cmlnZ2Vyc1xcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwubWVkaWFRdWVyeVxcbiAqL1xcblxcbnZhciBSZXNwb25zaXZlTWVudSA9IGZ1bmN0aW9uIChfUGx1Z2luKSB7XFxuICBfaW5oZXJpdHMoUmVzcG9uc2l2ZU1lbnUsIF9QbHVnaW4pO1xcblxcbiAgZnVuY3Rpb24gUmVzcG9uc2l2ZU1lbnUoKSB7XFxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZXNwb25zaXZlTWVudSk7XFxuXFxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoUmVzcG9uc2l2ZU1lbnUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihSZXNwb25zaXZlTWVudSkpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xcbiAgfVxcblxcbiAgX2NyZWF0ZUNsYXNzKFJlc3BvbnNpdmVNZW51LCBbe1xcbiAgICBrZXk6ICdfc2V0dXAnLFxcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBhIHJlc3BvbnNpdmUgbWVudS5cXG4gICAgICogQGNsYXNzXFxuICAgICAqIEBuYW1lIFJlc3BvbnNpdmVNZW51XFxuICAgICAqIEBmaXJlcyBSZXNwb25zaXZlTWVudSNpbml0XFxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBtYWtlIGludG8gYSBkcm9wZG93biBtZW51LlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlcyB0byB0aGUgZGVmYXVsdCBwbHVnaW4gc2V0dGluZ3MuXFxuICAgICAqL1xcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwKGVsZW1lbnQsIG9wdGlvbnMpIHtcXG4gICAgICB0aGlzLiRlbGVtZW50ID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKShlbGVtZW50KTtcXG4gICAgICB0aGlzLnJ1bGVzID0gdGhpcy4kZWxlbWVudC5kYXRhKCdyZXNwb25zaXZlLW1lbnUnKTtcXG4gICAgICB0aGlzLmN1cnJlbnRNcSA9IG51bGw7XFxuICAgICAgdGhpcy5jdXJyZW50UGx1Z2luID0gbnVsbDtcXG4gICAgICB0aGlzLmNsYXNzTmFtZSA9ICdSZXNwb25zaXZlTWVudSc7IC8vIGllOSBiYWNrIGNvbXBhdFxcblxcbiAgICAgIHRoaXMuX2luaXQoKTtcXG4gICAgICB0aGlzLl9ldmVudHMoKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIE1lbnUgYnkgcGFyc2luZyB0aGUgY2xhc3NlcyBmcm9tIHRoZSAnZGF0YS1SZXNwb25zaXZlTWVudScgYXR0cmlidXRlIG9uIHRoZSBlbGVtZW50LlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogJ19pbml0JyxcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0KCkge1xcblxcbiAgICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fZm91bmRhdGlvbl91dGlsX21lZGlhUXVlcnlfX1tcXFwiYVxcXCIgLyogTWVkaWFRdWVyeSAqL10uX2luaXQoKTtcXG4gICAgICAvLyBUaGUgZmlyc3QgdGltZSBhbiBJbnRlcmNoYW5nZSBwbHVnaW4gaXMgaW5pdGlhbGl6ZWQsIHRoaXMucnVsZXMgaXMgY29udmVydGVkIGZyb20gYSBzdHJpbmcgb2YgXFxcImNsYXNzZXNcXFwiIHRvIGFuIG9iamVjdCBvZiBydWxlc1xcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5ydWxlcyA9PT0gJ3N0cmluZycpIHtcXG4gICAgICAgIHZhciBydWxlc1RyZWUgPSB7fTtcXG5cXG4gICAgICAgIC8vIFBhcnNlIHJ1bGVzIGZyb20gXFxcImNsYXNzZXNcXFwiIHB1bGxlZCBmcm9tIGRhdGEgYXR0cmlidXRlXFxuICAgICAgICB2YXIgcnVsZXMgPSB0aGlzLnJ1bGVzLnNwbGl0KCcgJyk7XFxuXFxuICAgICAgICAvLyBJdGVyYXRlIHRocm91Z2ggZXZlcnkgcnVsZSBmb3VuZFxcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgICB2YXIgcnVsZSA9IHJ1bGVzW2ldLnNwbGl0KCctJyk7XFxuICAgICAgICAgIHZhciBydWxlU2l6ZSA9IHJ1bGUubGVuZ3RoID4gMSA/IHJ1bGVbMF0gOiAnc21hbGwnO1xcbiAgICAgICAgICB2YXIgcnVsZVBsdWdpbiA9IHJ1bGUubGVuZ3RoID4gMSA/IHJ1bGVbMV0gOiBydWxlWzBdO1xcblxcbiAgICAgICAgICBpZiAoTWVudVBsdWdpbnNbcnVsZVBsdWdpbl0gIT09IG51bGwpIHtcXG4gICAgICAgICAgICBydWxlc1RyZWVbcnVsZVNpemVdID0gTWVudVBsdWdpbnNbcnVsZVBsdWdpbl07XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHRoaXMucnVsZXMgPSBydWxlc1RyZWU7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQuYS5pc0VtcHR5T2JqZWN0KHRoaXMucnVsZXMpKSB7XFxuICAgICAgICB0aGlzLl9jaGVja01lZGlhUXVlcmllcygpO1xcbiAgICAgIH1cXG4gICAgICAvLyBBZGQgZGF0YS1tdXRhdGUgc2luY2UgY2hpbGRyZW4gbWF5IG5lZWQgaXQuXFxuICAgICAgdGhpcy4kZWxlbWVudC5hdHRyKCdkYXRhLW11dGF0ZScsIHRoaXMuJGVsZW1lbnQuYXR0cignZGF0YS1tdXRhdGUnKSB8fCBfX3dlYnBhY2tfcmVxdWlyZV9fLmkoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19mb3VuZGF0aW9uX3V0aWxfY29yZV9fW1xcXCJiXFxcIiAvKiBHZXRZb0RpZ2l0cyAqL10pKDYsICdyZXNwb25zaXZlLW1lbnUnKSk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIEluaXRpYWxpemVzIGV2ZW50cyBmb3IgdGhlIE1lbnUuXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAnX2V2ZW50cycsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZXZlbnRzKCkge1xcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuXFxuICAgICAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSh3aW5kb3cpLm9uKCdjaGFuZ2VkLnpmLm1lZGlhcXVlcnknLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICBfdGhpcy5fY2hlY2tNZWRpYVF1ZXJpZXMoKTtcXG4gICAgICB9KTtcXG4gICAgICAvLyAkKHdpbmRvdykub24oJ3Jlc2l6ZS56Zi5SZXNwb25zaXZlTWVudScsIGZ1bmN0aW9uKCkge1xcbiAgICAgIC8vICAgX3RoaXMuX2NoZWNrTWVkaWFRdWVyaWVzKCk7XFxuICAgICAgLy8gfSk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIENoZWNrcyB0aGUgY3VycmVudCBzY3JlZW4gd2lkdGggYWdhaW5zdCBhdmFpbGFibGUgbWVkaWEgcXVlcmllcy4gSWYgdGhlIG1lZGlhIHF1ZXJ5IGhhcyBjaGFuZ2VkLCBhbmQgdGhlIHBsdWdpbiBuZWVkZWQgaGFzIGNoYW5nZWQsIHRoZSBwbHVnaW5zIHdpbGwgc3dhcCBvdXQuXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAnX2NoZWNrTWVkaWFRdWVyaWVzJyxcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jaGVja01lZGlhUXVlcmllcygpIHtcXG4gICAgICB2YXIgbWF0Y2hlZE1xLFxcbiAgICAgICAgICBfdGhpcyA9IHRoaXM7XFxuICAgICAgLy8gSXRlcmF0ZSB0aHJvdWdoIGVhY2ggcnVsZSBhbmQgZmluZCB0aGUgbGFzdCBtYXRjaGluZyBydWxlXFxuICAgICAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQuYS5lYWNoKHRoaXMucnVsZXMsIGZ1bmN0aW9uIChrZXkpIHtcXG4gICAgICAgIGlmIChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX2ZvdW5kYXRpb25fdXRpbF9tZWRpYVF1ZXJ5X19bXFxcImFcXFwiIC8qIE1lZGlhUXVlcnkgKi9dLmF0TGVhc3Qoa2V5KSkge1xcbiAgICAgICAgICBtYXRjaGVkTXEgPSBrZXk7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuXFxuICAgICAgLy8gTm8gbWF0Y2g/IE5vIGRpY2VcXG4gICAgICBpZiAoIW1hdGNoZWRNcSkgcmV0dXJuO1xcblxcbiAgICAgIC8vIFBsdWdpbiBhbHJlYWR5IGluaXRpYWxpemVkPyBXZSBnb29kXFxuICAgICAgaWYgKHRoaXMuY3VycmVudFBsdWdpbiBpbnN0YW5jZW9mIHRoaXMucnVsZXNbbWF0Y2hlZE1xXS5wbHVnaW4pIHJldHVybjtcXG5cXG4gICAgICAvLyBSZW1vdmUgZXhpc3RpbmcgcGx1Z2luLXNwZWNpZmljIENTUyBjbGFzc2VzXFxuICAgICAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQuYS5lYWNoKE1lbnVQbHVnaW5zLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xcbiAgICAgICAgX3RoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3ModmFsdWUuY3NzQ2xhc3MpO1xcbiAgICAgIH0pO1xcblxcbiAgICAgIC8vIEFkZCB0aGUgQ1NTIGNsYXNzIGZvciB0aGUgbmV3IHBsdWdpblxcbiAgICAgIHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3ModGhpcy5ydWxlc1ttYXRjaGVkTXFdLmNzc0NsYXNzKTtcXG5cXG4gICAgICAvLyBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhlIG5ldyBwbHVnaW5cXG4gICAgICBpZiAodGhpcy5jdXJyZW50UGx1Z2luKSB0aGlzLmN1cnJlbnRQbHVnaW4uZGVzdHJveSgpO1xcbiAgICAgIHRoaXMuY3VycmVudFBsdWdpbiA9IG5ldyB0aGlzLnJ1bGVzW21hdGNoZWRNcV0ucGx1Z2luKHRoaXMuJGVsZW1lbnQsIHt9KTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogRGVzdHJveXMgdGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IHBsdWdpbiBvbiB0aGlzIGVsZW1lbnQsIGFzIHdlbGwgYXMgdGhlIHdpbmRvdyByZXNpemUgaGFuZGxlciB0aGF0IHN3aXRjaGVzIHRoZSBwbHVnaW5zIG91dC5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6ICdfZGVzdHJveScsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVzdHJveSgpIHtcXG4gICAgICB0aGlzLmN1cnJlbnRQbHVnaW4uZGVzdHJveSgpO1xcbiAgICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0KCkod2luZG93KS5vZmYoJy56Zi5SZXNwb25zaXZlTWVudScpO1xcbiAgICB9XFxuICB9XSk7XFxuXFxuICByZXR1cm4gUmVzcG9uc2l2ZU1lbnU7XFxufShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX2ZvdW5kYXRpb25fcGx1Z2luX19bXFxcImFcXFwiIC8qIFBsdWdpbiAqL10pO1xcblxcblJlc3BvbnNpdmVNZW51LmRlZmF1bHRzID0ge307XFxuXFxuXFxuXFxuLyoqKi8gfSksXFxuLyogMzAgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImFcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFJlc3BvbnNpdmVUb2dnbGU7IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCA9IF9fd2VicGFja19yZXF1aXJlX18ubihfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX2ZvdW5kYXRpb25fdXRpbF9tZWRpYVF1ZXJ5X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX2ZvdW5kYXRpb25fdXRpbF9tb3Rpb25fXyA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fZm91bmRhdGlvbl9wbHVnaW5fXyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XFxuXFxuXFxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcXFwidmFsdWVcXFwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XFxuXFxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTsgfSB9XFxuXFxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFxcXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcXFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFxcXCJvYmplY3RcXFwiIHx8IHR5cGVvZiBjYWxsID09PSBcXFwiZnVuY3Rpb25cXFwiKSA/IGNhbGwgOiBzZWxmOyB9XFxuXFxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXFxcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG4vKipcXG4gKiBSZXNwb25zaXZlVG9nZ2xlIG1vZHVsZS5cXG4gKiBAbW9kdWxlIGZvdW5kYXRpb24ucmVzcG9uc2l2ZVRvZ2dsZVxcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwubWVkaWFRdWVyeVxcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwubW90aW9uXFxuICovXFxuXFxudmFyIFJlc3BvbnNpdmVUb2dnbGUgPSBmdW5jdGlvbiAoX1BsdWdpbikge1xcbiAgX2luaGVyaXRzKFJlc3BvbnNpdmVUb2dnbGUsIF9QbHVnaW4pO1xcblxcbiAgZnVuY3Rpb24gUmVzcG9uc2l2ZVRvZ2dsZSgpIHtcXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJlc3BvbnNpdmVUb2dnbGUpO1xcblxcbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFJlc3BvbnNpdmVUb2dnbGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihSZXNwb25zaXZlVG9nZ2xlKSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XFxuICB9XFxuXFxuICBfY3JlYXRlQ2xhc3MoUmVzcG9uc2l2ZVRvZ2dsZSwgW3tcXG4gICAga2V5OiAnX3NldHVwJyxcXG5cXG4gICAgLyoqXFxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgVGFiIEJhci5cXG4gICAgICogQGNsYXNzXFxuICAgICAqIEBuYW1lIFJlc3BvbnNpdmVUb2dnbGVcXG4gICAgICogQGZpcmVzIFJlc3BvbnNpdmVUb2dnbGUjaW5pdFxcbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gYXR0YWNoIHRhYiBiYXIgZnVuY3Rpb25hbGl0eSB0by5cXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZXMgdG8gdGhlIGRlZmF1bHQgcGx1Z2luIHNldHRpbmdzLlxcbiAgICAgKi9cXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cChlbGVtZW50LCBvcHRpb25zKSB7XFxuICAgICAgdGhpcy4kZWxlbWVudCA9IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0KCkoZWxlbWVudCk7XFxuICAgICAgdGhpcy5vcHRpb25zID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQuYS5leHRlbmQoe30sIFJlc3BvbnNpdmVUb2dnbGUuZGVmYXVsdHMsIHRoaXMuJGVsZW1lbnQuZGF0YSgpLCBvcHRpb25zKTtcXG4gICAgICB0aGlzLmNsYXNzTmFtZSA9ICdSZXNwb25zaXZlVG9nZ2xlJzsgLy8gaWU5IGJhY2sgY29tcGF0XFxuXFxuICAgICAgdGhpcy5faW5pdCgpO1xcbiAgICAgIHRoaXMuX2V2ZW50cygpO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgdGFiIGJhciBieSBmaW5kaW5nIHRoZSB0YXJnZXQgZWxlbWVudCwgdG9nZ2xpbmcgZWxlbWVudCwgYW5kIHJ1bm5pbmcgdXBkYXRlKCkuXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAnX2luaXQnLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXQoKSB7XFxuICAgICAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19mb3VuZGF0aW9uX3V0aWxfbWVkaWFRdWVyeV9fW1xcXCJhXFxcIiAvKiBNZWRpYVF1ZXJ5ICovXS5faW5pdCgpO1xcbiAgICAgIHZhciB0YXJnZXRJRCA9IHRoaXMuJGVsZW1lbnQuZGF0YSgncmVzcG9uc2l2ZS10b2dnbGUnKTtcXG4gICAgICBpZiAoIXRhcmdldElEKSB7XFxuICAgICAgICBjb25zb2xlLmVycm9yKCdZb3VyIHRhYiBiYXIgbmVlZHMgYW4gSUQgb2YgYSBNZW51IGFzIHRoZSB2YWx1ZSBvZiBkYXRhLXRhYi1iYXIuJyk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuJHRhcmdldE1lbnUgPSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKCcjJyArIHRhcmdldElEKTtcXG4gICAgICB0aGlzLiR0b2dnbGVyID0gdGhpcy4kZWxlbWVudC5maW5kKCdbZGF0YS10b2dnbGVdJykuZmlsdGVyKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciB0YXJnZXQgPSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKHRoaXMpLmRhdGEoJ3RvZ2dsZScpO1xcbiAgICAgICAgcmV0dXJuIHRhcmdldCA9PT0gdGFyZ2V0SUQgfHwgdGFyZ2V0ID09PSBcXFwiXFxcIjtcXG4gICAgICB9KTtcXG4gICAgICB0aGlzLm9wdGlvbnMgPSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdC5hLmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zLCB0aGlzLiR0YXJnZXRNZW51LmRhdGEoKSk7XFxuXFxuICAgICAgLy8gSWYgdGhleSB3ZXJlIHNldCwgcGFyc2UgdGhlIGFuaW1hdGlvbiBjbGFzc2VzXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5hbmltYXRlKSB7XFxuICAgICAgICB2YXIgaW5wdXQgPSB0aGlzLm9wdGlvbnMuYW5pbWF0ZS5zcGxpdCgnICcpO1xcblxcbiAgICAgICAgdGhpcy5hbmltYXRpb25JbiA9IGlucHV0WzBdO1xcbiAgICAgICAgdGhpcy5hbmltYXRpb25PdXQgPSBpbnB1dFsxXSB8fCBudWxsO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl91cGRhdGUoKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQWRkcyBuZWNlc3NhcnkgZXZlbnQgaGFuZGxlcnMgZm9yIHRoZSB0YWIgYmFyIHRvIHdvcmsuXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAnX2V2ZW50cycsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZXZlbnRzKCkge1xcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuXFxuICAgICAgdGhpcy5fdXBkYXRlTXFIYW5kbGVyID0gdGhpcy5fdXBkYXRlLmJpbmQodGhpcyk7XFxuXFxuICAgICAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSh3aW5kb3cpLm9uKCdjaGFuZ2VkLnpmLm1lZGlhcXVlcnknLCB0aGlzLl91cGRhdGVNcUhhbmRsZXIpO1xcblxcbiAgICAgIHRoaXMuJHRvZ2dsZXIub24oJ2NsaWNrLnpmLnJlc3BvbnNpdmVUb2dnbGUnLCB0aGlzLnRvZ2dsZU1lbnUuYmluZCh0aGlzKSk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIENoZWNrcyB0aGUgY3VycmVudCBtZWRpYSBxdWVyeSB0byBkZXRlcm1pbmUgaWYgdGhlIHRhYiBiYXIgc2hvdWxkIGJlIHZpc2libGUgb3IgaGlkZGVuLlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogJ191cGRhdGUnLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZSgpIHtcXG4gICAgICAvLyBNb2JpbGVcXG4gICAgICBpZiAoIV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fZm91bmRhdGlvbl91dGlsX21lZGlhUXVlcnlfX1tcXFwiYVxcXCIgLyogTWVkaWFRdWVyeSAqL10uYXRMZWFzdCh0aGlzLm9wdGlvbnMuaGlkZUZvcikpIHtcXG4gICAgICAgIHRoaXMuJGVsZW1lbnQuc2hvdygpO1xcbiAgICAgICAgdGhpcy4kdGFyZ2V0TWVudS5oaWRlKCk7XFxuICAgICAgfVxcblxcbiAgICAgIC8vIERlc2t0b3BcXG4gICAgICBlbHNlIHtcXG4gICAgICAgICAgdGhpcy4kZWxlbWVudC5oaWRlKCk7XFxuICAgICAgICAgIHRoaXMuJHRhcmdldE1lbnUuc2hvdygpO1xcbiAgICAgICAgfVxcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBUb2dnbGVzIHRoZSBlbGVtZW50IGF0dGFjaGVkIHRvIHRoZSB0YWIgYmFyLiBUaGUgdG9nZ2xlIG9ubHkgaGFwcGVucyBpZiB0aGUgc2NyZWVuIGlzIHNtYWxsIGVub3VnaCB0byBhbGxvdyBpdC5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBmaXJlcyBSZXNwb25zaXZlVG9nZ2xlI3RvZ2dsZWRcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogJ3RvZ2dsZU1lbnUnLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9nZ2xlTWVudSgpIHtcXG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcXG5cXG4gICAgICBpZiAoIV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fZm91bmRhdGlvbl91dGlsX21lZGlhUXVlcnlfX1tcXFwiYVxcXCIgLyogTWVkaWFRdWVyeSAqL10uYXRMZWFzdCh0aGlzLm9wdGlvbnMuaGlkZUZvcikpIHtcXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgZWxlbWVudCBhdHRhY2hlZCB0byB0aGUgdGFiIGJhciB0b2dnbGVzLlxcbiAgICAgICAgICogQGV2ZW50IFJlc3BvbnNpdmVUb2dnbGUjdG9nZ2xlZFxcbiAgICAgICAgICovXFxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmFuaW1hdGUpIHtcXG4gICAgICAgICAgaWYgKHRoaXMuJHRhcmdldE1lbnUuaXMoJzpoaWRkZW4nKSkge1xcbiAgICAgICAgICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fZm91bmRhdGlvbl91dGlsX21vdGlvbl9fW1xcXCJhXFxcIiAvKiBNb3Rpb24gKi9dLmFuaW1hdGVJbih0aGlzLiR0YXJnZXRNZW51LCB0aGlzLmFuaW1hdGlvbkluLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICBfdGhpczMuJGVsZW1lbnQudHJpZ2dlcigndG9nZ2xlZC56Zi5yZXNwb25zaXZlVG9nZ2xlJyk7XFxuICAgICAgICAgICAgICBfdGhpczMuJHRhcmdldE1lbnUuZmluZCgnW2RhdGEtbXV0YXRlXScpLnRyaWdnZXJIYW5kbGVyKCdtdXRhdGVtZS56Zi50cmlnZ2VyJyk7XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19mb3VuZGF0aW9uX3V0aWxfbW90aW9uX19bXFxcImFcXFwiIC8qIE1vdGlvbiAqL10uYW5pbWF0ZU91dCh0aGlzLiR0YXJnZXRNZW51LCB0aGlzLmFuaW1hdGlvbk91dCwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgX3RoaXMzLiRlbGVtZW50LnRyaWdnZXIoJ3RvZ2dsZWQuemYucmVzcG9uc2l2ZVRvZ2dsZScpO1xcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICB0aGlzLiR0YXJnZXRNZW51LnRvZ2dsZSgwKTtcXG4gICAgICAgICAgdGhpcy4kdGFyZ2V0TWVudS5maW5kKCdbZGF0YS1tdXRhdGVdJykudHJpZ2dlcignbXV0YXRlbWUuemYudHJpZ2dlcicpO1xcbiAgICAgICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ3RvZ2dsZWQuemYucmVzcG9uc2l2ZVRvZ2dsZScpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcbiAgfSwge1xcbiAgICBrZXk6ICdfZGVzdHJveScsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVzdHJveSgpIHtcXG4gICAgICB0aGlzLiRlbGVtZW50Lm9mZignLnpmLnJlc3BvbnNpdmVUb2dnbGUnKTtcXG4gICAgICB0aGlzLiR0b2dnbGVyLm9mZignLnpmLnJlc3BvbnNpdmVUb2dnbGUnKTtcXG5cXG4gICAgICBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKHdpbmRvdykub2ZmKCdjaGFuZ2VkLnpmLm1lZGlhcXVlcnknLCB0aGlzLl91cGRhdGVNcUhhbmRsZXIpO1xcbiAgICB9XFxuICB9XSk7XFxuXFxuICByZXR1cm4gUmVzcG9uc2l2ZVRvZ2dsZTtcXG59KF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fZm91bmRhdGlvbl9wbHVnaW5fX1tcXFwiYVxcXCIgLyogUGx1Z2luICovXSk7XFxuXFxuUmVzcG9uc2l2ZVRvZ2dsZS5kZWZhdWx0cyA9IHtcXG4gIC8qKlxcbiAgICogVGhlIGJyZWFrcG9pbnQgYWZ0ZXIgd2hpY2ggdGhlIG1lbnUgaXMgYWx3YXlzIHNob3duLCBhbmQgdGhlIHRhYiBiYXIgaXMgaGlkZGVuLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge3N0cmluZ31cXG4gICAqIEBkZWZhdWx0ICdtZWRpdW0nXFxuICAgKi9cXG4gIGhpZGVGb3I6ICdtZWRpdW0nLFxcblxcbiAgLyoqXFxuICAgKiBUbyBkZWNpZGUgaWYgdGhlIHRvZ2dsZSBzaG91bGQgYmUgYW5pbWF0ZWQgb3Igbm90LlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge2Jvb2xlYW59XFxuICAgKiBAZGVmYXVsdCBmYWxzZVxcbiAgICovXFxuICBhbmltYXRlOiBmYWxzZVxcbn07XFxuXFxuXFxuXFxuLyoqKi8gfSksXFxuLyogMzEgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImFcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFJldmVhbDsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0ID0gX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfXyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fZm91bmRhdGlvbl91dGlsX2tleWJvYXJkX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX2ZvdW5kYXRpb25fdXRpbF9tZWRpYVF1ZXJ5X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX2ZvdW5kYXRpb25fdXRpbF9tb3Rpb25fXyA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fZm91bmRhdGlvbl9wbHVnaW5fXyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fZm91bmRhdGlvbl91dGlsX3RyaWdnZXJzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xcblxcblxcbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXFxcInZhbHVlXFxcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xcblxcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7IH0gfVxcblxcbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcXFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXFxcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcXFwib2JqZWN0XFxcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXFxcImZ1bmN0aW9uXFxcIikgPyBjYWxsIDogc2VsZjsgfVxcblxcbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFxcXCJmdW5jdGlvblxcXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFxcXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuLyoqXFxuICogUmV2ZWFsIG1vZHVsZS5cXG4gKiBAbW9kdWxlIGZvdW5kYXRpb24ucmV2ZWFsXFxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5rZXlib2FyZFxcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwudHJpZ2dlcnNcXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLm1lZGlhUXVlcnlcXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLm1vdGlvbiBpZiB1c2luZyBhbmltYXRpb25zXFxuICovXFxuXFxudmFyIFJldmVhbCA9IGZ1bmN0aW9uIChfUGx1Z2luKSB7XFxuICBfaW5oZXJpdHMoUmV2ZWFsLCBfUGx1Z2luKTtcXG5cXG4gIGZ1bmN0aW9uIFJldmVhbCgpIHtcXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJldmVhbCk7XFxuXFxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoUmV2ZWFsLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoUmV2ZWFsKSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XFxuICB9XFxuXFxuICBfY3JlYXRlQ2xhc3MoUmV2ZWFsLCBbe1xcbiAgICBrZXk6ICdfc2V0dXAnLFxcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBSZXZlYWwuXFxuICAgICAqIEBjbGFzc1xcbiAgICAgKiBAbmFtZSBSZXZlYWxcXG4gICAgICogQHBhcmFtIHtqUXVlcnl9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIHVzZSBmb3IgdGhlIG1vZGFsLlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIG9wdGlvbmFsIHBhcmFtZXRlcnMuXFxuICAgICAqL1xcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwKGVsZW1lbnQsIG9wdGlvbnMpIHtcXG4gICAgICB0aGlzLiRlbGVtZW50ID0gZWxlbWVudDtcXG4gICAgICB0aGlzLm9wdGlvbnMgPSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdC5hLmV4dGVuZCh7fSwgUmV2ZWFsLmRlZmF1bHRzLCB0aGlzLiRlbGVtZW50LmRhdGEoKSwgb3B0aW9ucyk7XFxuICAgICAgdGhpcy5jbGFzc05hbWUgPSAnUmV2ZWFsJzsgLy8gaWU5IGJhY2sgY29tcGF0XFxuICAgICAgdGhpcy5faW5pdCgpO1xcblxcbiAgICAgIC8vIFRyaWdnZXJzIGluaXQgaXMgaWRlbXBvdGVudCwganVzdCBuZWVkIHRvIG1ha2Ugc3VyZSBpdCBpcyBpbml0aWFsaXplZFxcbiAgICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fZm91bmRhdGlvbl91dGlsX3RyaWdnZXJzX19bXFxcImFcXFwiIC8qIFRyaWdnZXJzICovXS5pbml0KF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0LmEpO1xcblxcbiAgICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fZm91bmRhdGlvbl91dGlsX2tleWJvYXJkX19bXFxcImFcXFwiIC8qIEtleWJvYXJkICovXS5yZWdpc3RlcignUmV2ZWFsJywge1xcbiAgICAgICAgJ0VTQ0FQRSc6ICdjbG9zZSdcXG4gICAgICB9KTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIG1vZGFsIGJ5IGFkZGluZyB0aGUgb3ZlcmxheSBhbmQgY2xvc2UgYnV0dG9ucywgKGlmIHNlbGVjdGVkKS5cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogJ19pbml0JyxcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0KCkge1xcbiAgICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fZm91bmRhdGlvbl91dGlsX21lZGlhUXVlcnlfX1tcXFwiYVxcXCIgLyogTWVkaWFRdWVyeSAqL10uX2luaXQoKTtcXG4gICAgICB0aGlzLmlkID0gdGhpcy4kZWxlbWVudC5hdHRyKCdpZCcpO1xcbiAgICAgIHRoaXMuaXNBY3RpdmUgPSBmYWxzZTtcXG4gICAgICB0aGlzLmNhY2hlZCA9IHsgbXE6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fZm91bmRhdGlvbl91dGlsX21lZGlhUXVlcnlfX1tcXFwiYVxcXCIgLyogTWVkaWFRdWVyeSAqL10uY3VycmVudCB9O1xcbiAgICAgIHRoaXMuaXNNb2JpbGUgPSBtb2JpbGVTbmlmZigpO1xcblxcbiAgICAgIHRoaXMuJGFuY2hvciA9IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0KCkoJ1tkYXRhLW9wZW49XFxcIicgKyB0aGlzLmlkICsgJ1xcXCJdJykubGVuZ3RoID8gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSgnW2RhdGEtb3Blbj1cXFwiJyArIHRoaXMuaWQgKyAnXFxcIl0nKSA6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0KCkoJ1tkYXRhLXRvZ2dsZT1cXFwiJyArIHRoaXMuaWQgKyAnXFxcIl0nKTtcXG4gICAgICB0aGlzLiRhbmNob3IuYXR0cih7XFxuICAgICAgICAnYXJpYS1jb250cm9scyc6IHRoaXMuaWQsXFxuICAgICAgICAnYXJpYS1oYXNwb3B1cCc6IHRydWUsXFxuICAgICAgICAndGFiaW5kZXgnOiAwXFxuICAgICAgfSk7XFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5mdWxsU2NyZWVuIHx8IHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2Z1bGwnKSkge1xcbiAgICAgICAgdGhpcy5vcHRpb25zLmZ1bGxTY3JlZW4gPSB0cnVlO1xcbiAgICAgICAgdGhpcy5vcHRpb25zLm92ZXJsYXkgPSBmYWxzZTtcXG4gICAgICB9XFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5vdmVybGF5ICYmICF0aGlzLiRvdmVybGF5KSB7XFxuICAgICAgICB0aGlzLiRvdmVybGF5ID0gdGhpcy5fbWFrZU92ZXJsYXkodGhpcy5pZCk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cih7XFxuICAgICAgICAncm9sZSc6ICdkaWFsb2cnLFxcbiAgICAgICAgJ2FyaWEtaGlkZGVuJzogdHJ1ZSxcXG4gICAgICAgICdkYXRhLXlldGktYm94JzogdGhpcy5pZCxcXG4gICAgICAgICdkYXRhLXJlc2l6ZSc6IHRoaXMuaWRcXG4gICAgICB9KTtcXG5cXG4gICAgICBpZiAodGhpcy4kb3ZlcmxheSkge1xcbiAgICAgICAgdGhpcy4kZWxlbWVudC5kZXRhY2goKS5hcHBlbmRUbyh0aGlzLiRvdmVybGF5KTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdGhpcy4kZWxlbWVudC5kZXRhY2goKS5hcHBlbmRUbyhfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKHRoaXMub3B0aW9ucy5hcHBlbmRUbykpO1xcbiAgICAgICAgdGhpcy4kZWxlbWVudC5hZGRDbGFzcygnd2l0aG91dC1vdmVybGF5Jyk7XFxuICAgICAgfVxcbiAgICAgIHRoaXMuX2V2ZW50cygpO1xcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGVlcExpbmsgJiYgd2luZG93LmxvY2F0aW9uLmhhc2ggPT09ICcjJyArIHRoaXMuaWQpIHtcXG4gICAgICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0KCkod2luZG93KS5vbmUoJ2xvYWQuemYucmV2ZWFsJywgdGhpcy5vcGVuLmJpbmQodGhpcykpO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhbiBvdmVybGF5IGRpdiB0byBkaXNwbGF5IGJlaGluZCB0aGUgbW9kYWwuXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6ICdfbWFrZU92ZXJsYXknLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX21ha2VPdmVybGF5KCkge1xcbiAgICAgIHZhciBhZGRpdGlvbmFsT3ZlcmxheUNsYXNzZXMgPSAnJztcXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmFkZGl0aW9uYWxPdmVybGF5Q2xhc3Nlcykge1xcbiAgICAgICAgYWRkaXRpb25hbE92ZXJsYXlDbGFzc2VzID0gJyAnICsgdGhpcy5vcHRpb25zLmFkZGl0aW9uYWxPdmVybGF5Q2xhc3NlcztcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0KCkoJzxkaXY+PC9kaXY+JykuYWRkQ2xhc3MoJ3JldmVhbC1vdmVybGF5JyArIGFkZGl0aW9uYWxPdmVybGF5Q2xhc3NlcykuYXBwZW5kVG8odGhpcy5vcHRpb25zLmFwcGVuZFRvKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogVXBkYXRlcyBwb3NpdGlvbiBvZiBtb2RhbFxcbiAgICAgKiBUT0RPOiAgRmlndXJlIG91dCBpZiB3ZSBhY3R1YWxseSBuZWVkIHRvIGNhY2hlIHRoZXNlIHZhbHVlcyBvciBpZiBpdCBkb2Vzbid0IG1hdHRlclxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAnX3VwZGF0ZVBvc2l0aW9uJyxcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVQb3NpdGlvbigpIHtcXG4gICAgICB2YXIgd2lkdGggPSB0aGlzLiRlbGVtZW50Lm91dGVyV2lkdGgoKTtcXG4gICAgICB2YXIgb3V0ZXJXaWR0aCA9IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0KCkod2luZG93KS53aWR0aCgpO1xcbiAgICAgIHZhciBoZWlnaHQgPSB0aGlzLiRlbGVtZW50Lm91dGVySGVpZ2h0KCk7XFxuICAgICAgdmFyIG91dGVySGVpZ2h0ID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSh3aW5kb3cpLmhlaWdodCgpO1xcbiAgICAgIHZhciBsZWZ0LCB0b3A7XFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5oT2Zmc2V0ID09PSAnYXV0bycpIHtcXG4gICAgICAgIGxlZnQgPSBwYXJzZUludCgob3V0ZXJXaWR0aCAtIHdpZHRoKSAvIDIsIDEwKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgbGVmdCA9IHBhcnNlSW50KHRoaXMub3B0aW9ucy5oT2Zmc2V0LCAxMCk7XFxuICAgICAgfVxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudk9mZnNldCA9PT0gJ2F1dG8nKSB7XFxuICAgICAgICBpZiAoaGVpZ2h0ID4gb3V0ZXJIZWlnaHQpIHtcXG4gICAgICAgICAgdG9wID0gcGFyc2VJbnQoTWF0aC5taW4oMTAwLCBvdXRlckhlaWdodCAvIDEwKSwgMTApO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgdG9wID0gcGFyc2VJbnQoKG91dGVySGVpZ2h0IC0gaGVpZ2h0KSAvIDQsIDEwKTtcXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdG9wID0gcGFyc2VJbnQodGhpcy5vcHRpb25zLnZPZmZzZXQsIDEwKTtcXG4gICAgICB9XFxuICAgICAgdGhpcy4kZWxlbWVudC5jc3MoeyB0b3A6IHRvcCArICdweCcgfSk7XFxuICAgICAgLy8gb25seSB3b3JyeSBhYm91dCBsZWZ0IGlmIHdlIGRvbid0IGhhdmUgYW4gb3ZlcmxheSBvciB3ZSBoYXZlYSAgaG9yaXpvbnRhbCBvZmZzZXQsXFxuICAgICAgLy8gb3RoZXJ3aXNlIHdlJ3JlIHBlcmZlY3RseSBpbiB0aGUgbWlkZGxlXFxuICAgICAgaWYgKCF0aGlzLiRvdmVybGF5IHx8IHRoaXMub3B0aW9ucy5oT2Zmc2V0ICE9PSAnYXV0bycpIHtcXG4gICAgICAgIHRoaXMuJGVsZW1lbnQuY3NzKHsgbGVmdDogbGVmdCArICdweCcgfSk7XFxuICAgICAgICB0aGlzLiRlbGVtZW50LmNzcyh7IG1hcmdpbjogJzBweCcgfSk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBBZGRzIGV2ZW50IGhhbmRsZXJzIGZvciB0aGUgbW9kYWwuXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6ICdfZXZlbnRzJyxcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9ldmVudHMoKSB7XFxuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XFxuXFxuICAgICAgdmFyIF90aGlzID0gdGhpcztcXG5cXG4gICAgICB0aGlzLiRlbGVtZW50Lm9uKHtcXG4gICAgICAgICdvcGVuLnpmLnRyaWdnZXInOiB0aGlzLm9wZW4uYmluZCh0aGlzKSxcXG4gICAgICAgICdjbG9zZS56Zi50cmlnZ2VyJzogZnVuY3Rpb24gKGV2ZW50LCAkZWxlbWVudCkge1xcbiAgICAgICAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSBfdGhpcy4kZWxlbWVudFswXSB8fCBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKGV2ZW50LnRhcmdldCkucGFyZW50cygnW2RhdGEtY2xvc2FibGVdJylbMF0gPT09ICRlbGVtZW50KSB7XFxuICAgICAgICAgICAgLy8gb25seSBjbG9zZSByZXZlYWwgd2hlbiBpdCdzIGV4cGxpY2l0bHkgY2FsbGVkXFxuICAgICAgICAgICAgcmV0dXJuIF90aGlzMy5jbG9zZS5hcHBseShfdGhpczMpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgICAgJ3RvZ2dsZS56Zi50cmlnZ2VyJzogdGhpcy50b2dnbGUuYmluZCh0aGlzKSxcXG4gICAgICAgICdyZXNpemVtZS56Zi50cmlnZ2VyJzogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICBfdGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmNsb3NlT25DbGljayAmJiB0aGlzLm9wdGlvbnMub3ZlcmxheSkge1xcbiAgICAgICAgdGhpcy4kb3ZlcmxheS5vZmYoJy56Zi5yZXZlYWwnKS5vbignY2xpY2suemYucmV2ZWFsJywgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgICAgaWYgKGUudGFyZ2V0ID09PSBfdGhpcy4kZWxlbWVudFswXSB8fCBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdC5hLmNvbnRhaW5zKF90aGlzLiRlbGVtZW50WzBdLCBlLnRhcmdldCkgfHwgIV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0LmEuY29udGFpbnMoZG9jdW1lbnQsIGUudGFyZ2V0KSkge1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBfdGhpcy5jbG9zZSgpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfVxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGVlcExpbmspIHtcXG4gICAgICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0KCkod2luZG93KS5vbigncG9wc3RhdGUuemYucmV2ZWFsOicgKyB0aGlzLmlkLCB0aGlzLl9oYW5kbGVTdGF0ZS5iaW5kKHRoaXMpKTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIEhhbmRsZXMgbW9kYWwgbWV0aG9kcyBvbiBiYWNrL2ZvcndhcmQgYnV0dG9uIGNsaWNrcyBvciBhbnkgb3RoZXIgZXZlbnQgdGhhdCB0cmlnZ2VycyBwb3BzdGF0ZS5cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogJ19oYW5kbGVTdGF0ZScsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlU3RhdGUoZSkge1xcbiAgICAgIGlmICh3aW5kb3cubG9jYXRpb24uaGFzaCA9PT0gJyMnICsgdGhpcy5pZCAmJiAhdGhpcy5pc0FjdGl2ZSkge1xcbiAgICAgICAgdGhpcy5vcGVuKCk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHRoaXMuY2xvc2UoKTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIE9wZW5zIHRoZSBtb2RhbCBjb250cm9sbGVkIGJ5IGB0aGlzLiRhbmNob3JgLCBhbmQgY2xvc2VzIGFsbCBvdGhlcnMgYnkgZGVmYXVsdC5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBmaXJlcyBSZXZlYWwjY2xvc2VtZVxcbiAgICAgKiBAZmlyZXMgUmV2ZWFsI29wZW5cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogJ29wZW4nLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3BlbigpIHtcXG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcXG5cXG4gICAgICAvLyBlaXRoZXIgdXBkYXRlIG9yIHJlcGxhY2UgYnJvd3NlciBoaXN0b3J5XFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5kZWVwTGluaykge1xcbiAgICAgICAgdmFyIGhhc2ggPSAnIycgKyB0aGlzLmlkO1xcblxcbiAgICAgICAgaWYgKHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZSkge1xcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnVwZGF0ZUhpc3RvcnkpIHtcXG4gICAgICAgICAgICB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUoe30sICcnLCBoYXNoKTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoe30sICcnLCBoYXNoKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhhc2ggPSBoYXNoO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLmlzQWN0aXZlID0gdHJ1ZTtcXG5cXG4gICAgICAvLyBNYWtlIGVsZW1lbnRzIGludmlzaWJsZSwgYnV0IHJlbW92ZSBkaXNwbGF5OiBub25lIHNvIHdlIGNhbiBnZXQgc2l6ZSBhbmQgcG9zaXRpb25pbmdcXG4gICAgICB0aGlzLiRlbGVtZW50LmNzcyh7ICd2aXNpYmlsaXR5JzogJ2hpZGRlbicgfSkuc2hvdygpLnNjcm9sbFRvcCgwKTtcXG4gICAgICBpZiAodGhpcy5vcHRpb25zLm92ZXJsYXkpIHtcXG4gICAgICAgIHRoaXMuJG92ZXJsYXkuY3NzKHsgJ3Zpc2liaWxpdHknOiAnaGlkZGVuJyB9KS5zaG93KCk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XFxuXFxuICAgICAgdGhpcy4kZWxlbWVudC5oaWRlKCkuY3NzKHsgJ3Zpc2liaWxpdHknOiAnJyB9KTtcXG5cXG4gICAgICBpZiAodGhpcy4kb3ZlcmxheSkge1xcbiAgICAgICAgdGhpcy4kb3ZlcmxheS5jc3MoeyAndmlzaWJpbGl0eSc6ICcnIH0pLmhpZGUoKTtcXG4gICAgICAgIGlmICh0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKCdmYXN0JykpIHtcXG4gICAgICAgICAgdGhpcy4kb3ZlcmxheS5hZGRDbGFzcygnZmFzdCcpO1xcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKCdzbG93JykpIHtcXG4gICAgICAgICAgdGhpcy4kb3ZlcmxheS5hZGRDbGFzcygnc2xvdycpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5tdWx0aXBsZU9wZW5lZCkge1xcbiAgICAgICAgLyoqXFxuICAgICAgICAgKiBGaXJlcyBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIG1vZGFsIG9wZW5zLlxcbiAgICAgICAgICogQ2xvc2VzIGFueSBvdGhlciBtb2RhbHMgdGhhdCBhcmUgY3VycmVudGx5IG9wZW5cXG4gICAgICAgICAqIEBldmVudCBSZXZlYWwjY2xvc2VtZVxcbiAgICAgICAgICovXFxuICAgICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ2Nsb3NlbWUuemYucmV2ZWFsJywgdGhpcy5pZCk7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuXFxuICAgICAgZnVuY3Rpb24gYWRkUmV2ZWFsT3BlbkNsYXNzZXMoKSB7XFxuICAgICAgICBpZiAoX3RoaXMuaXNNb2JpbGUpIHtcXG4gICAgICAgICAgaWYgKCFfdGhpcy5vcmlnaW5hbFNjcm9sbFBvcykge1xcbiAgICAgICAgICAgIF90aGlzLm9yaWdpbmFsU2Nyb2xsUG9zID0gd2luZG93LnBhZ2VZT2Zmc2V0O1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0KCkoJ2h0bWwsIGJvZHknKS5hZGRDbGFzcygnaXMtcmV2ZWFsLW9wZW4nKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0KCkoJ2JvZHknKS5hZGRDbGFzcygnaXMtcmV2ZWFsLW9wZW4nKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgLy8gTW90aW9uIFVJIG1ldGhvZCBvZiByZXZlYWxcXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmFuaW1hdGlvbkluKSB7XFxuICAgICAgICB2YXIgYWZ0ZXJBbmltYXRpb24gPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIF90aGlzLiRlbGVtZW50LmF0dHIoe1xcbiAgICAgICAgICAgICdhcmlhLWhpZGRlbic6IGZhbHNlLFxcbiAgICAgICAgICAgICd0YWJpbmRleCc6IC0xXFxuICAgICAgICAgIH0pLmZvY3VzKCk7XFxuICAgICAgICAgIGFkZFJldmVhbE9wZW5DbGFzc2VzKCk7XFxuICAgICAgICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fZm91bmRhdGlvbl91dGlsX2tleWJvYXJkX19bXFxcImFcXFwiIC8qIEtleWJvYXJkICovXS50cmFwRm9jdXMoX3RoaXMuJGVsZW1lbnQpO1xcbiAgICAgICAgfTtcXG5cXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMub3ZlcmxheSkge1xcbiAgICAgICAgICBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX2ZvdW5kYXRpb25fdXRpbF9tb3Rpb25fX1tcXFwiYVxcXCIgLyogTW90aW9uICovXS5hbmltYXRlSW4odGhpcy4kb3ZlcmxheSwgJ2ZhZGUtaW4nKTtcXG4gICAgICAgIH1cXG4gICAgICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fZm91bmRhdGlvbl91dGlsX21vdGlvbl9fW1xcXCJhXFxcIiAvKiBNb3Rpb24gKi9dLmFuaW1hdGVJbih0aGlzLiRlbGVtZW50LCB0aGlzLm9wdGlvbnMuYW5pbWF0aW9uSW4sIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgaWYgKF90aGlzNC4kZWxlbWVudCkge1xcbiAgICAgICAgICAgIC8vIHByb3RlY3QgYWdhaW5zdCBvYmplY3QgaGF2aW5nIGJlZW4gcmVtb3ZlZFxcbiAgICAgICAgICAgIF90aGlzNC5mb2N1c2FibGVFbGVtZW50cyA9IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fZm91bmRhdGlvbl91dGlsX2tleWJvYXJkX19bXFxcImFcXFwiIC8qIEtleWJvYXJkICovXS5maW5kRm9jdXNhYmxlKF90aGlzNC4kZWxlbWVudCk7XFxuICAgICAgICAgICAgYWZ0ZXJBbmltYXRpb24oKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgICAgfVxcbiAgICAgIC8vIGpRdWVyeSBtZXRob2Qgb2YgcmV2ZWFsXFxuICAgICAgZWxzZSB7XFxuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMub3ZlcmxheSkge1xcbiAgICAgICAgICAgIHRoaXMuJG92ZXJsYXkuc2hvdygwKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICB0aGlzLiRlbGVtZW50LnNob3codGhpcy5vcHRpb25zLnNob3dEZWxheSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgLy8gaGFuZGxlIGFjY2Vzc2liaWxpdHlcXG4gICAgICB0aGlzLiRlbGVtZW50LmF0dHIoe1xcbiAgICAgICAgJ2FyaWEtaGlkZGVuJzogZmFsc2UsXFxuICAgICAgICAndGFiaW5kZXgnOiAtMVxcbiAgICAgIH0pLmZvY3VzKCk7XFxuICAgICAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19mb3VuZGF0aW9uX3V0aWxfa2V5Ym9hcmRfX1tcXFwiYVxcXCIgLyogS2V5Ym9hcmQgKi9dLnRyYXBGb2N1cyh0aGlzLiRlbGVtZW50KTtcXG5cXG4gICAgICBhZGRSZXZlYWxPcGVuQ2xhc3NlcygpO1xcblxcbiAgICAgIHRoaXMuX2V4dHJhSGFuZGxlcnMoKTtcXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBGaXJlcyB3aGVuIHRoZSBtb2RhbCBoYXMgc3VjY2Vzc2Z1bGx5IG9wZW5lZC5cXG4gICAgICAgKiBAZXZlbnQgUmV2ZWFsI29wZW5cXG4gICAgICAgKi9cXG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ29wZW4uemYucmV2ZWFsJyk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIEFkZHMgZXh0cmEgZXZlbnQgaGFuZGxlcnMgZm9yIHRoZSBib2R5IGFuZCB3aW5kb3cgaWYgbmVjZXNzYXJ5LlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAnX2V4dHJhSGFuZGxlcnMnLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2V4dHJhSGFuZGxlcnMoKSB7XFxuICAgICAgdmFyIF90aGlzID0gdGhpcztcXG4gICAgICBpZiAoIXRoaXMuJGVsZW1lbnQpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9IC8vIElmIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgY2xlYW51cCwgZG9uJ3QgZnJlYWsgb3V0XFxuICAgICAgdGhpcy5mb2N1c2FibGVFbGVtZW50cyA9IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fZm91bmRhdGlvbl91dGlsX2tleWJvYXJkX19bXFxcImFcXFwiIC8qIEtleWJvYXJkICovXS5maW5kRm9jdXNhYmxlKHRoaXMuJGVsZW1lbnQpO1xcblxcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLm92ZXJsYXkgJiYgdGhpcy5vcHRpb25zLmNsb3NlT25DbGljayAmJiAhdGhpcy5vcHRpb25zLmZ1bGxTY3JlZW4pIHtcXG4gICAgICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0KCkoJ2JvZHknKS5vbignY2xpY2suemYucmV2ZWFsJywgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgICAgaWYgKGUudGFyZ2V0ID09PSBfdGhpcy4kZWxlbWVudFswXSB8fCBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdC5hLmNvbnRhaW5zKF90aGlzLiRlbGVtZW50WzBdLCBlLnRhcmdldCkgfHwgIV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0LmEuY29udGFpbnMoZG9jdW1lbnQsIGUudGFyZ2V0KSkge1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBfdGhpcy5jbG9zZSgpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuY2xvc2VPbkVzYykge1xcbiAgICAgICAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSh3aW5kb3cpLm9uKCdrZXlkb3duLnpmLnJldmVhbCcsIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fZm91bmRhdGlvbl91dGlsX2tleWJvYXJkX19bXFxcImFcXFwiIC8qIEtleWJvYXJkICovXS5oYW5kbGVLZXkoZSwgJ1JldmVhbCcsIHtcXG4gICAgICAgICAgICBjbG9zZTogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMuY2xvc2VPbkVzYykge1xcbiAgICAgICAgICAgICAgICBfdGhpcy5jbG9zZSgpO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIENsb3NlcyB0aGUgbW9kYWwuXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAZmlyZXMgUmV2ZWFsI2Nsb3NlZFxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAnY2xvc2UnLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvc2UoKSB7XFxuICAgICAgaWYgKCF0aGlzLmlzQWN0aXZlIHx8ICF0aGlzLiRlbGVtZW50LmlzKCc6dmlzaWJsZScpKSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfVxcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuXFxuICAgICAgLy8gTW90aW9uIFVJIG1ldGhvZCBvZiBoaWRpbmdcXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmFuaW1hdGlvbk91dCkge1xcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5vdmVybGF5KSB7XFxuICAgICAgICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fZm91bmRhdGlvbl91dGlsX21vdGlvbl9fW1xcXCJhXFxcIiAvKiBNb3Rpb24gKi9dLmFuaW1hdGVPdXQodGhpcy4kb3ZlcmxheSwgJ2ZhZGUtb3V0Jyk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX2ZvdW5kYXRpb25fdXRpbF9tb3Rpb25fX1tcXFwiYVxcXCIgLyogTW90aW9uICovXS5hbmltYXRlT3V0KHRoaXMuJGVsZW1lbnQsIHRoaXMub3B0aW9ucy5hbmltYXRpb25PdXQsIGZpbmlzaFVwKTtcXG4gICAgICB9XFxuICAgICAgLy8galF1ZXJ5IG1ldGhvZCBvZiBoaWRpbmdcXG4gICAgICBlbHNlIHtcXG4gICAgICAgICAgdGhpcy4kZWxlbWVudC5oaWRlKHRoaXMub3B0aW9ucy5oaWRlRGVsYXkpO1xcblxcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLm92ZXJsYXkpIHtcXG4gICAgICAgICAgICB0aGlzLiRvdmVybGF5LmhpZGUoMCwgZmluaXNoVXApO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGZpbmlzaFVwKCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAvLyBDb25kaXRpb25hbHMgdG8gcmVtb3ZlIGV4dHJhIGV2ZW50IGxpc3RlbmVycyBhZGRlZCBvbiBvcGVuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5jbG9zZU9uRXNjKSB7XFxuICAgICAgICBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKHdpbmRvdykub2ZmKCdrZXlkb3duLnpmLnJldmVhbCcpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5vdmVybGF5ICYmIHRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2spIHtcXG4gICAgICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0KCkoJ2JvZHknKS5vZmYoJ2NsaWNrLnpmLnJldmVhbCcpO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLiRlbGVtZW50Lm9mZigna2V5ZG93bi56Zi5yZXZlYWwnKTtcXG5cXG4gICAgICBmdW5jdGlvbiBmaW5pc2hVcCgpIHtcXG4gICAgICAgIGlmIChfdGhpcy5pc01vYmlsZSkge1xcbiAgICAgICAgICBpZiAoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSgnLnJldmVhbDp2aXNpYmxlJykubGVuZ3RoID09PSAwKSB7XFxuICAgICAgICAgICAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSgnaHRtbCwgYm9keScpLnJlbW92ZUNsYXNzKCdpcy1yZXZlYWwtb3BlbicpO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGlmIChfdGhpcy5vcmlnaW5hbFNjcm9sbFBvcykge1xcbiAgICAgICAgICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0KCkoJ2JvZHknKS5zY3JvbGxUb3AoX3RoaXMub3JpZ2luYWxTY3JvbGxQb3MpO1xcbiAgICAgICAgICAgIF90aGlzLm9yaWdpbmFsU2Nyb2xsUG9zID0gbnVsbDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgaWYgKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0KCkoJy5yZXZlYWw6dmlzaWJsZScpLmxlbmd0aCA9PT0gMCkge1xcbiAgICAgICAgICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0KCkoJ2JvZHknKS5yZW1vdmVDbGFzcygnaXMtcmV2ZWFsLW9wZW4nKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19mb3VuZGF0aW9uX3V0aWxfa2V5Ym9hcmRfX1tcXFwiYVxcXCIgLyogS2V5Ym9hcmQgKi9dLnJlbGVhc2VGb2N1cyhfdGhpcy4kZWxlbWVudCk7XFxuXFxuICAgICAgICBfdGhpcy4kZWxlbWVudC5hdHRyKCdhcmlhLWhpZGRlbicsIHRydWUpO1xcblxcbiAgICAgICAgLyoqXFxuICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIG1vZGFsIGlzIGRvbmUgY2xvc2luZy5cXG4gICAgICAgICogQGV2ZW50IFJldmVhbCNjbG9zZWRcXG4gICAgICAgICovXFxuICAgICAgICBfdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdjbG9zZWQuemYucmV2ZWFsJyk7XFxuICAgICAgfVxcblxcbiAgICAgIC8qKlxcbiAgICAgICogUmVzZXRzIHRoZSBtb2RhbCBjb250ZW50XFxuICAgICAgKiBUaGlzIHByZXZlbnRzIGEgcnVubmluZyB2aWRlbyB0byBrZWVwIGdvaW5nIGluIHRoZSBiYWNrZ3JvdW5kXFxuICAgICAgKi9cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnJlc2V0T25DbG9zZSkge1xcbiAgICAgICAgdGhpcy4kZWxlbWVudC5odG1sKHRoaXMuJGVsZW1lbnQuaHRtbCgpKTtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xcbiAgICAgIGlmIChfdGhpcy5vcHRpb25zLmRlZXBMaW5rKSB7XFxuICAgICAgICBpZiAod2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKSB7XFxuICAgICAgICAgIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSgnJywgZG9jdW1lbnQudGl0bGUsIHdpbmRvdy5sb2NhdGlvbi5ocmVmLnJlcGxhY2UoJyMnICsgdGhpcy5pZCwgJycpKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5oYXNoID0gJyc7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuJGFuY2hvci5mb2N1cygpO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBUb2dnbGVzIHRoZSBvcGVuL2Nsb3NlZCBzdGF0ZSBvZiBhIG1vZGFsLlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogJ3RvZ2dsZScsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b2dnbGUoKSB7XFxuICAgICAgaWYgKHRoaXMuaXNBY3RpdmUpIHtcXG4gICAgICAgIHRoaXMuY2xvc2UoKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdGhpcy5vcGVuKCk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9LCB7XFxuICAgIGtleTogJ19kZXN0cm95JyxcXG5cXG5cXG4gICAgLyoqXFxuICAgICAqIERlc3Ryb3lzIGFuIGluc3RhbmNlIG9mIGEgbW9kYWwuXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKi9cXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZXN0cm95KCkge1xcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMub3ZlcmxheSkge1xcbiAgICAgICAgdGhpcy4kZWxlbWVudC5hcHBlbmRUbyhfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKHRoaXMub3B0aW9ucy5hcHBlbmRUbykpOyAvLyBtb3ZlICRlbGVtZW50IG91dHNpZGUgb2YgJG92ZXJsYXkgdG8gcHJldmVudCBlcnJvciB1bnJlZ2lzdGVyUGx1Z2luKClcXG4gICAgICAgIHRoaXMuJG92ZXJsYXkuaGlkZSgpLm9mZigpLnJlbW92ZSgpO1xcbiAgICAgIH1cXG4gICAgICB0aGlzLiRlbGVtZW50LmhpZGUoKS5vZmYoKTtcXG4gICAgICB0aGlzLiRhbmNob3Iub2ZmKCcuemYnKTtcXG4gICAgICBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKHdpbmRvdykub2ZmKCcuemYucmV2ZWFsOicgKyB0aGlzLmlkKTtcXG4gICAgfVxcbiAgfV0pO1xcblxcbiAgcmV0dXJuIFJldmVhbDtcXG59KF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fZm91bmRhdGlvbl9wbHVnaW5fX1tcXFwiYVxcXCIgLyogUGx1Z2luICovXSk7XFxuXFxuUmV2ZWFsLmRlZmF1bHRzID0ge1xcbiAgLyoqXFxuICAgKiBNb3Rpb24tVUkgY2xhc3MgdG8gdXNlIGZvciBhbmltYXRlZCBlbGVtZW50cy4gSWYgbm9uZSB1c2VkLCBkZWZhdWx0cyB0byBzaW1wbGUgc2hvdy9oaWRlLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge3N0cmluZ31cXG4gICAqIEBkZWZhdWx0ICcnXFxuICAgKi9cXG4gIGFuaW1hdGlvbkluOiAnJyxcXG4gIC8qKlxcbiAgICogTW90aW9uLVVJIGNsYXNzIHRvIHVzZSBmb3IgYW5pbWF0ZWQgZWxlbWVudHMuIElmIG5vbmUgdXNlZCwgZGVmYXVsdHMgdG8gc2ltcGxlIHNob3cvaGlkZS5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtzdHJpbmd9XFxuICAgKiBAZGVmYXVsdCAnJ1xcbiAgICovXFxuICBhbmltYXRpb25PdXQ6ICcnLFxcbiAgLyoqXFxuICAgKiBUaW1lLCBpbiBtcywgdG8gZGVsYXkgdGhlIG9wZW5pbmcgb2YgYSBtb2RhbCBhZnRlciBhIGNsaWNrIGlmIG5vIGFuaW1hdGlvbiB1c2VkLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge251bWJlcn1cXG4gICAqIEBkZWZhdWx0IDBcXG4gICAqL1xcbiAgc2hvd0RlbGF5OiAwLFxcbiAgLyoqXFxuICAgKiBUaW1lLCBpbiBtcywgdG8gZGVsYXkgdGhlIGNsb3Npbmcgb2YgYSBtb2RhbCBhZnRlciBhIGNsaWNrIGlmIG5vIGFuaW1hdGlvbiB1c2VkLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge251bWJlcn1cXG4gICAqIEBkZWZhdWx0IDBcXG4gICAqL1xcbiAgaGlkZURlbGF5OiAwLFxcbiAgLyoqXFxuICAgKiBBbGxvd3MgYSBjbGljayBvbiB0aGUgYm9keS9vdmVybGF5IHRvIGNsb3NlIHRoZSBtb2RhbC5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtib29sZWFufVxcbiAgICogQGRlZmF1bHQgdHJ1ZVxcbiAgICovXFxuICBjbG9zZU9uQ2xpY2s6IHRydWUsXFxuICAvKipcXG4gICAqIEFsbG93cyB0aGUgbW9kYWwgdG8gY2xvc2UgaWYgdGhlIHVzZXIgcHJlc3NlcyB0aGUgYEVTQ0FQRWAga2V5LlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge2Jvb2xlYW59XFxuICAgKiBAZGVmYXVsdCB0cnVlXFxuICAgKi9cXG4gIGNsb3NlT25Fc2M6IHRydWUsXFxuICAvKipcXG4gICAqIElmIHRydWUsIGFsbG93cyBtdWx0aXBsZSBtb2RhbHMgdG8gYmUgZGlzcGxheWVkIGF0IG9uY2UuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IGZhbHNlXFxuICAgKi9cXG4gIG11bHRpcGxlT3BlbmVkOiBmYWxzZSxcXG4gIC8qKlxcbiAgICogRGlzdGFuY2UsIGluIHBpeGVscywgdGhlIG1vZGFsIHNob3VsZCBwdXNoIGRvd24gZnJvbSB0aGUgdG9wIG9mIHRoZSBzY3JlZW4uXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7bnVtYmVyfHN0cmluZ31cXG4gICAqIEBkZWZhdWx0IGF1dG9cXG4gICAqL1xcbiAgdk9mZnNldDogJ2F1dG8nLFxcbiAgLyoqXFxuICAgKiBEaXN0YW5jZSwgaW4gcGl4ZWxzLCB0aGUgbW9kYWwgc2hvdWxkIHB1c2ggaW4gZnJvbSB0aGUgc2lkZSBvZiB0aGUgc2NyZWVuLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge251bWJlcnxzdHJpbmd9XFxuICAgKiBAZGVmYXVsdCBhdXRvXFxuICAgKi9cXG4gIGhPZmZzZXQ6ICdhdXRvJyxcXG4gIC8qKlxcbiAgICogQWxsb3dzIHRoZSBtb2RhbCB0byBiZSBmdWxsc2NyZWVuLCBjb21wbGV0ZWx5IGJsb2NraW5nIG91dCB0aGUgcmVzdCBvZiB0aGUgdmlldy4gSlMgY2hlY2tzIGZvciB0aGlzIGFzIHdlbGwuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IGZhbHNlXFxuICAgKi9cXG4gIGZ1bGxTY3JlZW46IGZhbHNlLFxcbiAgLyoqXFxuICAgKiBQZXJjZW50YWdlIG9mIHNjcmVlbiBoZWlnaHQgdGhlIG1vZGFsIHNob3VsZCBwdXNoIHVwIGZyb20gdGhlIGJvdHRvbSBvZiB0aGUgdmlldy5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtudW1iZXJ9XFxuICAgKiBAZGVmYXVsdCAxMFxcbiAgICovXFxuICBidG1PZmZzZXRQY3Q6IDEwLFxcbiAgLyoqXFxuICAgKiBBbGxvd3MgdGhlIG1vZGFsIHRvIGdlbmVyYXRlIGFuIG92ZXJsYXkgZGl2LCB3aGljaCB3aWxsIGNvdmVyIHRoZSB2aWV3IHdoZW4gbW9kYWwgb3BlbnMuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IHRydWVcXG4gICAqL1xcbiAgb3ZlcmxheTogdHJ1ZSxcXG4gIC8qKlxcbiAgICogQWxsb3dzIHRoZSBtb2RhbCB0byByZW1vdmUgYW5kIHJlaW5qZWN0IG1hcmt1cCBvbiBjbG9zZS4gU2hvdWxkIGJlIHRydWUgaWYgdXNpbmcgdmlkZW8gZWxlbWVudHMgdy9vIHVzaW5nIHByb3ZpZGVyJ3MgYXBpLCBvdGhlcndpc2UsIHZpZGVvcyB3aWxsIGNvbnRpbnVlIHRvIHBsYXkgaW4gdGhlIGJhY2tncm91bmQuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IGZhbHNlXFxuICAgKi9cXG4gIHJlc2V0T25DbG9zZTogZmFsc2UsXFxuICAvKipcXG4gICAqIEFsbG93cyB0aGUgbW9kYWwgdG8gYWx0ZXIgdGhlIHVybCBvbiBvcGVuL2Nsb3NlLCBhbmQgYWxsb3dzIHRoZSB1c2Ugb2YgdGhlIGBiYWNrYCBidXR0b24gdG8gY2xvc2UgbW9kYWxzLiBBTFNPLCBhbGxvd3MgYSBtb2RhbCB0byBhdXRvLW1hbmlhY2FsbHkgb3BlbiBvbiBwYWdlIGxvYWQgSUYgdGhlIGhhc2ggPT09IHRoZSBtb2RhbCdzIHVzZXItc2V0IGlkLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge2Jvb2xlYW59XFxuICAgKiBAZGVmYXVsdCBmYWxzZVxcbiAgICovXFxuICBkZWVwTGluazogZmFsc2UsXFxuICAvKipcXG4gICAqIFVwZGF0ZSB0aGUgYnJvd3NlciBoaXN0b3J5IHdpdGggdGhlIG9wZW4gbW9kYWxcXG4gICAqIEBvcHRpb25cXG4gICAqIEBkZWZhdWx0IGZhbHNlXFxuICAgKi9cXG4gIHVwZGF0ZUhpc3Rvcnk6IGZhbHNlLFxcbiAgLyoqXFxuICAqIEFsbG93cyB0aGUgbW9kYWwgdG8gYXBwZW5kIHRvIGN1c3RvbSBkaXYuXFxuICAqIEBvcHRpb25cXG4gICogQHR5cGUge3N0cmluZ31cXG4gICogQGRlZmF1bHQgXFxcImJvZHlcXFwiXFxuICAqL1xcbiAgYXBwZW5kVG86IFxcXCJib2R5XFxcIixcXG4gIC8qKlxcbiAgICogQWxsb3dzIGFkZGluZyBhZGRpdGlvbmFsIGNsYXNzIG5hbWVzIHRvIHRoZSByZXZlYWwgb3ZlcmxheS5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtzdHJpbmd9XFxuICAgKiBAZGVmYXVsdCAnJ1xcbiAgICovXFxuICBhZGRpdGlvbmFsT3ZlcmxheUNsYXNzZXM6ICcnXFxufTtcXG5cXG5mdW5jdGlvbiBpUGhvbmVTbmlmZigpIHtcXG4gIHJldHVybiAoL2lQKGFkfGhvbmV8b2QpLipPUy8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudClcXG4gICk7XFxufVxcblxcbmZ1bmN0aW9uIGFuZHJvaWRTbmlmZigpIHtcXG4gIHJldHVybiAoL0FuZHJvaWQvLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpXFxuICApO1xcbn1cXG5cXG5mdW5jdGlvbiBtb2JpbGVTbmlmZigpIHtcXG4gIHJldHVybiBpUGhvbmVTbmlmZigpIHx8IGFuZHJvaWRTbmlmZigpO1xcbn1cXG5cXG5cXG5cXG4vKioqLyB9KSxcXG4vKiAzMiAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXFwidXNlIHN0cmljdFxcXCI7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiYVxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gU2xpZGVyOyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLm4oX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19mb3VuZGF0aW9uX3V0aWxfa2V5Ym9hcmRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fZm91bmRhdGlvbl91dGlsX21vdGlvbl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19mb3VuZGF0aW9uX3V0aWxfY29yZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19mb3VuZGF0aW9uX3BsdWdpbl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19mb3VuZGF0aW9uX3V0aWxfdG91Y2hfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX2ZvdW5kYXRpb25fdXRpbF90cmlnZ2Vyc19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcXG5cXG5cXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFxcXCJ2YWx1ZVxcXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcXG5cXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpOyB9IH1cXG5cXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXFxcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFxcXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXFxcIm9iamVjdFxcXCIgfHwgdHlwZW9mIGNhbGwgPT09IFxcXCJmdW5jdGlvblxcXCIpID8gY2FsbCA6IHNlbGY7IH1cXG5cXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcXFwiZnVuY3Rpb25cXFwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcXFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcbi8qKlxcbiAqIFNsaWRlciBtb2R1bGUuXFxuICogQG1vZHVsZSBmb3VuZGF0aW9uLnNsaWRlclxcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwubW90aW9uXFxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC50cmlnZ2Vyc1xcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwua2V5Ym9hcmRcXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLnRvdWNoXFxuICovXFxuXFxudmFyIFNsaWRlciA9IGZ1bmN0aW9uIChfUGx1Z2luKSB7XFxuICBfaW5oZXJpdHMoU2xpZGVyLCBfUGx1Z2luKTtcXG5cXG4gIGZ1bmN0aW9uIFNsaWRlcigpIHtcXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNsaWRlcik7XFxuXFxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoU2xpZGVyLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoU2xpZGVyKSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XFxuICB9XFxuXFxuICBfY3JlYXRlQ2xhc3MoU2xpZGVyLCBbe1xcbiAgICBrZXk6ICdfc2V0dXAnLFxcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBhIHNsaWRlciBjb250cm9sLlxcbiAgICAgKiBAY2xhc3NcXG4gICAgICogQG5hbWUgU2xpZGVyXFxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBtYWtlIGludG8gYSBzbGlkZXIgY29udHJvbC5cXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZXMgdG8gdGhlIGRlZmF1bHQgcGx1Z2luIHNldHRpbmdzLlxcbiAgICAgKi9cXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cChlbGVtZW50LCBvcHRpb25zKSB7XFxuICAgICAgdGhpcy4kZWxlbWVudCA9IGVsZW1lbnQ7XFxuICAgICAgdGhpcy5vcHRpb25zID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQuYS5leHRlbmQoe30sIFNsaWRlci5kZWZhdWx0cywgdGhpcy4kZWxlbWVudC5kYXRhKCksIG9wdGlvbnMpO1xcbiAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ1NsaWRlcic7IC8vIGllOSBiYWNrIGNvbXBhdFxcblxcbiAgICAgIC8vIFRvdWNoIGFuZCBUcmlnZ2VycyBpbml0cyBhcmUgaWRlbXBvdGVudCwgd2UganVzdCBuZWVkIHRvIG1ha2Ugc3VyZSBpdCdzIGluaXRpYWxpZWQuXFxuICAgICAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19mb3VuZGF0aW9uX3V0aWxfdG91Y2hfX1tcXFwiYVxcXCIgLyogVG91Y2ggKi9dLmluaXQoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQuYSk7XFxuICAgICAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19mb3VuZGF0aW9uX3V0aWxfdHJpZ2dlcnNfX1tcXFwiYVxcXCIgLyogVHJpZ2dlcnMgKi9dLmluaXQoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQuYSk7XFxuXFxuICAgICAgdGhpcy5faW5pdCgpO1xcblxcbiAgICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fZm91bmRhdGlvbl91dGlsX2tleWJvYXJkX19bXFxcImFcXFwiIC8qIEtleWJvYXJkICovXS5yZWdpc3RlcignU2xpZGVyJywge1xcbiAgICAgICAgJ2x0cic6IHtcXG4gICAgICAgICAgJ0FSUk9XX1JJR0hUJzogJ2luY3JlYXNlJyxcXG4gICAgICAgICAgJ0FSUk9XX1VQJzogJ2luY3JlYXNlJyxcXG4gICAgICAgICAgJ0FSUk9XX0RPV04nOiAnZGVjcmVhc2UnLFxcbiAgICAgICAgICAnQVJST1dfTEVGVCc6ICdkZWNyZWFzZScsXFxuICAgICAgICAgICdTSElGVF9BUlJPV19SSUdIVCc6ICdpbmNyZWFzZV9mYXN0JyxcXG4gICAgICAgICAgJ1NISUZUX0FSUk9XX1VQJzogJ2luY3JlYXNlX2Zhc3QnLFxcbiAgICAgICAgICAnU0hJRlRfQVJST1dfRE9XTic6ICdkZWNyZWFzZV9mYXN0JyxcXG4gICAgICAgICAgJ1NISUZUX0FSUk9XX0xFRlQnOiAnZGVjcmVhc2VfZmFzdCcsXFxuICAgICAgICAgICdIT01FJzogJ21pbicsXFxuICAgICAgICAgICdFTkQnOiAnbWF4J1xcbiAgICAgICAgfSxcXG4gICAgICAgICdydGwnOiB7XFxuICAgICAgICAgICdBUlJPV19MRUZUJzogJ2luY3JlYXNlJyxcXG4gICAgICAgICAgJ0FSUk9XX1JJR0hUJzogJ2RlY3JlYXNlJyxcXG4gICAgICAgICAgJ1NISUZUX0FSUk9XX0xFRlQnOiAnaW5jcmVhc2VfZmFzdCcsXFxuICAgICAgICAgICdTSElGVF9BUlJPV19SSUdIVCc6ICdkZWNyZWFzZV9mYXN0J1xcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBJbml0aWxpemVzIHRoZSBwbHVnaW4gYnkgcmVhZGluZy9zZXR0aW5nIGF0dHJpYnV0ZXMsIGNyZWF0aW5nIGNvbGxlY3Rpb25zIGFuZCBzZXR0aW5nIHRoZSBpbml0aWFsIHBvc2l0aW9uIG9mIHRoZSBoYW5kbGUocykuXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAnX2luaXQnLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXQoKSB7XFxuICAgICAgdGhpcy5pbnB1dHMgPSB0aGlzLiRlbGVtZW50LmZpbmQoJ2lucHV0Jyk7XFxuICAgICAgdGhpcy5oYW5kbGVzID0gdGhpcy4kZWxlbWVudC5maW5kKCdbZGF0YS1zbGlkZXItaGFuZGxlXScpO1xcblxcbiAgICAgIHRoaXMuJGhhbmRsZSA9IHRoaXMuaGFuZGxlcy5lcSgwKTtcXG4gICAgICB0aGlzLiRpbnB1dCA9IHRoaXMuaW5wdXRzLmxlbmd0aCA/IHRoaXMuaW5wdXRzLmVxKDApIDogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSgnIycgKyB0aGlzLiRoYW5kbGUuYXR0cignYXJpYS1jb250cm9scycpKTtcXG4gICAgICB0aGlzLiRmaWxsID0gdGhpcy4kZWxlbWVudC5maW5kKCdbZGF0YS1zbGlkZXItZmlsbF0nKS5jc3ModGhpcy5vcHRpb25zLnZlcnRpY2FsID8gJ2hlaWdodCcgOiAnd2lkdGgnLCAwKTtcXG5cXG4gICAgICB2YXIgaXNEYmwgPSBmYWxzZSxcXG4gICAgICAgICAgX3RoaXMgPSB0aGlzO1xcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGlzYWJsZWQgfHwgdGhpcy4kZWxlbWVudC5oYXNDbGFzcyh0aGlzLm9wdGlvbnMuZGlzYWJsZWRDbGFzcykpIHtcXG4gICAgICAgIHRoaXMub3B0aW9ucy5kaXNhYmxlZCA9IHRydWU7XFxuICAgICAgICB0aGlzLiRlbGVtZW50LmFkZENsYXNzKHRoaXMub3B0aW9ucy5kaXNhYmxlZENsYXNzKTtcXG4gICAgICB9XFxuICAgICAgaWYgKCF0aGlzLmlucHV0cy5sZW5ndGgpIHtcXG4gICAgICAgIHRoaXMuaW5wdXRzID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSgpLmFkZCh0aGlzLiRpbnB1dCk7XFxuICAgICAgICB0aGlzLm9wdGlvbnMuYmluZGluZyA9IHRydWU7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX3NldEluaXRBdHRyKDApO1xcblxcbiAgICAgIGlmICh0aGlzLmhhbmRsZXNbMV0pIHtcXG4gICAgICAgIHRoaXMub3B0aW9ucy5kb3VibGVTaWRlZCA9IHRydWU7XFxuICAgICAgICB0aGlzLiRoYW5kbGUyID0gdGhpcy5oYW5kbGVzLmVxKDEpO1xcbiAgICAgICAgdGhpcy4kaW5wdXQyID0gdGhpcy5pbnB1dHMubGVuZ3RoID4gMSA/IHRoaXMuaW5wdXRzLmVxKDEpIDogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSgnIycgKyB0aGlzLiRoYW5kbGUyLmF0dHIoJ2FyaWEtY29udHJvbHMnKSk7XFxuXFxuICAgICAgICBpZiAoIXRoaXMuaW5wdXRzWzFdKSB7XFxuICAgICAgICAgIHRoaXMuaW5wdXRzID0gdGhpcy5pbnB1dHMuYWRkKHRoaXMuJGlucHV0Mik7XFxuICAgICAgICB9XFxuICAgICAgICBpc0RibCA9IHRydWU7XFxuXFxuICAgICAgICAvLyB0aGlzLiRoYW5kbGUudHJpZ2dlckhhbmRsZXIoJ2NsaWNrLnpmLnNsaWRlcicpO1xcbiAgICAgICAgdGhpcy5fc2V0SW5pdEF0dHIoMSk7XFxuICAgICAgfVxcblxcbiAgICAgIC8vIFNldCBoYW5kbGUgcG9zaXRpb25zXFxuICAgICAgdGhpcy5zZXRIYW5kbGVzKCk7XFxuXFxuICAgICAgdGhpcy5fZXZlbnRzKCk7XFxuICAgIH1cXG4gIH0sIHtcXG4gICAga2V5OiAnc2V0SGFuZGxlcycsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRIYW5kbGVzKCkge1xcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xcblxcbiAgICAgIGlmICh0aGlzLmhhbmRsZXNbMV0pIHtcXG4gICAgICAgIHRoaXMuX3NldEhhbmRsZVBvcyh0aGlzLiRoYW5kbGUsIHRoaXMuaW5wdXRzLmVxKDApLnZhbCgpLCB0cnVlLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIF90aGlzMy5fc2V0SGFuZGxlUG9zKF90aGlzMy4kaGFuZGxlMiwgX3RoaXMzLmlucHV0cy5lcSgxKS52YWwoKSwgdHJ1ZSk7XFxuICAgICAgICB9KTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdGhpcy5fc2V0SGFuZGxlUG9zKHRoaXMuJGhhbmRsZSwgdGhpcy5pbnB1dHMuZXEoMCkudmFsKCksIHRydWUpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfSwge1xcbiAgICBrZXk6ICdfcmVmbG93JyxcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZWZsb3coKSB7XFxuICAgICAgdGhpcy5zZXRIYW5kbGVzKCk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICogQGZ1bmN0aW9uXFxuICAgICogQHByaXZhdGVcXG4gICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBmbG9hdGluZyBwb2ludCAodGhlIHZhbHVlKSB0byBiZSB0cmFuc2Zvcm1lZCB1c2luZyB0byBhIHJlbGF0aXZlIHBvc2l0aW9uIG9uIHRoZSBzbGlkZXIgKHRoZSBpbnZlcnNlIG9mIF92YWx1ZSlcXG4gICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAnX3BjdE9mQmFyJyxcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wY3RPZkJhcih2YWx1ZSkge1xcbiAgICAgIHZhciBwY3RPZkJhciA9IHBlcmNlbnQodmFsdWUgLSB0aGlzLm9wdGlvbnMuc3RhcnQsIHRoaXMub3B0aW9ucy5lbmQgLSB0aGlzLm9wdGlvbnMuc3RhcnQpO1xcblxcbiAgICAgIHN3aXRjaCAodGhpcy5vcHRpb25zLnBvc2l0aW9uVmFsdWVGdW5jdGlvbikge1xcbiAgICAgICAgY2FzZSBcXFwicG93XFxcIjpcXG4gICAgICAgICAgcGN0T2ZCYXIgPSB0aGlzLl9sb2dUcmFuc2Zvcm0ocGN0T2ZCYXIpO1xcbiAgICAgICAgICBicmVhaztcXG4gICAgICAgIGNhc2UgXFxcImxvZ1xcXCI6XFxuICAgICAgICAgIHBjdE9mQmFyID0gdGhpcy5fcG93VHJhbnNmb3JtKHBjdE9mQmFyKTtcXG4gICAgICAgICAgYnJlYWs7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBwY3RPZkJhci50b0ZpeGVkKDIpO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAqIEBmdW5jdGlvblxcbiAgICAqIEBwcml2YXRlXFxuICAgICogQHBhcmFtIHtOdW1iZXJ9IHBjdE9mQmFyIC0gZmxvYXRpbmcgcG9pbnQsIHRoZSByZWxhdGl2ZSBwb3NpdGlvbiBvZiB0aGUgc2xpZGVyICh0eXBpY2FsbHkgYmV0d2VlbiAwLTEpIHRvIGJlIHRyYW5zZm9ybWVkIHRvIGEgdmFsdWVcXG4gICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAnX3ZhbHVlJyxcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF92YWx1ZShwY3RPZkJhcikge1xcbiAgICAgIHN3aXRjaCAodGhpcy5vcHRpb25zLnBvc2l0aW9uVmFsdWVGdW5jdGlvbikge1xcbiAgICAgICAgY2FzZSBcXFwicG93XFxcIjpcXG4gICAgICAgICAgcGN0T2ZCYXIgPSB0aGlzLl9wb3dUcmFuc2Zvcm0ocGN0T2ZCYXIpO1xcbiAgICAgICAgICBicmVhaztcXG4gICAgICAgIGNhc2UgXFxcImxvZ1xcXCI6XFxuICAgICAgICAgIHBjdE9mQmFyID0gdGhpcy5fbG9nVHJhbnNmb3JtKHBjdE9mQmFyKTtcXG4gICAgICAgICAgYnJlYWs7XFxuICAgICAgfVxcbiAgICAgIHZhciB2YWx1ZSA9ICh0aGlzLm9wdGlvbnMuZW5kIC0gdGhpcy5vcHRpb25zLnN0YXJ0KSAqIHBjdE9mQmFyICsgdGhpcy5vcHRpb25zLnN0YXJ0O1xcblxcbiAgICAgIHJldHVybiB2YWx1ZTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgKiBAZnVuY3Rpb25cXG4gICAgKiBAcHJpdmF0ZVxcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIGZsb2F0aW5nIHBvaW50ICh0eXBpY2FsbHkgYmV0d2VlbiAwLTEpIHRvIGJlIHRyYW5zZm9ybWVkIHVzaW5nIHRoZSBsb2cgZnVuY3Rpb25cXG4gICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAnX2xvZ1RyYW5zZm9ybScsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbG9nVHJhbnNmb3JtKHZhbHVlKSB7XFxuICAgICAgcmV0dXJuIGJhc2VMb2codGhpcy5vcHRpb25zLm5vbkxpbmVhckJhc2UsIHZhbHVlICogKHRoaXMub3B0aW9ucy5ub25MaW5lYXJCYXNlIC0gMSkgKyAxKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgKiBAZnVuY3Rpb25cXG4gICAgKiBAcHJpdmF0ZVxcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIGZsb2F0aW5nIHBvaW50ICh0eXBpY2FsbHkgYmV0d2VlbiAwLTEpIHRvIGJlIHRyYW5zZm9ybWVkIHVzaW5nIHRoZSBwb3dlciBmdW5jdGlvblxcbiAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6ICdfcG93VHJhbnNmb3JtJyxcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wb3dUcmFuc2Zvcm0odmFsdWUpIHtcXG4gICAgICByZXR1cm4gKE1hdGgucG93KHRoaXMub3B0aW9ucy5ub25MaW5lYXJCYXNlLCB2YWx1ZSkgLSAxKSAvICh0aGlzLm9wdGlvbnMubm9uTGluZWFyQmFzZSAtIDEpO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBTZXRzIHRoZSBwb3NpdGlvbiBvZiB0aGUgc2VsZWN0ZWQgaGFuZGxlIGFuZCBmaWxsIGJhci5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSAkaG5kbCAtIHRoZSBzZWxlY3RlZCBoYW5kbGUgdG8gbW92ZS5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxvY2F0aW9uIC0gZmxvYXRpbmcgcG9pbnQgYmV0d2VlbiB0aGUgc3RhcnQgYW5kIGVuZCB2YWx1ZXMgb2YgdGhlIHNsaWRlciBiYXIuXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIC0gY2FsbGJhY2sgZnVuY3Rpb24gdG8gZmlyZSBvbiBjb21wbGV0aW9uLlxcbiAgICAgKiBAZmlyZXMgU2xpZGVyI21vdmVkXFxuICAgICAqIEBmaXJlcyBTbGlkZXIjY2hhbmdlZFxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAnX3NldEhhbmRsZVBvcycsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0SGFuZGxlUG9zKCRobmRsLCBsb2NhdGlvbiwgbm9JbnZlcnQsIGNiKSB7XFxuICAgICAgLy8gZG9uJ3QgbW92ZSBpZiB0aGUgc2xpZGVyIGhhcyBiZWVuIGRpc2FibGVkIHNpbmNlIGl0cyBpbml0aWFsaXphdGlvblxcbiAgICAgIGlmICh0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKHRoaXMub3B0aW9ucy5kaXNhYmxlZENsYXNzKSkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG4gICAgICAvL21pZ2h0IG5lZWQgdG8gYWx0ZXIgdGhhdCBzbGlnaHRseSBmb3IgYmFycyB0aGF0IHdpbGwgaGF2ZSBvZGQgbnVtYmVyIHNlbGVjdGlvbnMuXFxuICAgICAgbG9jYXRpb24gPSBwYXJzZUZsb2F0KGxvY2F0aW9uKTsgLy9vbiBpbnB1dCBjaGFuZ2UgZXZlbnRzLCBjb252ZXJ0IHN0cmluZyB0byBudW1iZXIuLi5ncnVtYmxlLlxcblxcbiAgICAgIC8vIHByZXZlbnQgc2xpZGVyIGZyb20gcnVubmluZyBvdXQgb2YgYm91bmRzLCBpZiB2YWx1ZSBleGNlZWRzIHRoZSBsaW1pdHMgc2V0IHRocm91Z2ggb3B0aW9ucywgb3ZlcnJpZGUgdGhlIHZhbHVlIHRvIG1pbi9tYXhcXG4gICAgICBpZiAobG9jYXRpb24gPCB0aGlzLm9wdGlvbnMuc3RhcnQpIHtcXG4gICAgICAgIGxvY2F0aW9uID0gdGhpcy5vcHRpb25zLnN0YXJ0O1xcbiAgICAgIH0gZWxzZSBpZiAobG9jYXRpb24gPiB0aGlzLm9wdGlvbnMuZW5kKSB7XFxuICAgICAgICBsb2NhdGlvbiA9IHRoaXMub3B0aW9ucy5lbmQ7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBpc0RibCA9IHRoaXMub3B0aW9ucy5kb3VibGVTaWRlZDtcXG5cXG4gICAgICBpZiAoaXNEYmwpIHtcXG4gICAgICAgIC8vdGhpcyBibG9jayBpcyB0byBwcmV2ZW50IDIgaGFuZGxlcyBmcm9tIGNyb3NzaW5nIGVhY2hvdGhlci4gQ291bGQvc2hvdWxkIGJlIGltcHJvdmVkLlxcbiAgICAgICAgaWYgKHRoaXMuaGFuZGxlcy5pbmRleCgkaG5kbCkgPT09IDApIHtcXG4gICAgICAgICAgdmFyIGgyVmFsID0gcGFyc2VGbG9hdCh0aGlzLiRoYW5kbGUyLmF0dHIoJ2FyaWEtdmFsdWVub3cnKSk7XFxuICAgICAgICAgIGxvY2F0aW9uID0gbG9jYXRpb24gPj0gaDJWYWwgPyBoMlZhbCAtIHRoaXMub3B0aW9ucy5zdGVwIDogbG9jYXRpb247XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICB2YXIgaDFWYWwgPSBwYXJzZUZsb2F0KHRoaXMuJGhhbmRsZS5hdHRyKCdhcmlhLXZhbHVlbm93JykpO1xcbiAgICAgICAgICBsb2NhdGlvbiA9IGxvY2F0aW9uIDw9IGgxVmFsID8gaDFWYWwgKyB0aGlzLm9wdGlvbnMuc3RlcCA6IGxvY2F0aW9uO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICAvL3RoaXMgaXMgZm9yIHNpbmdsZS1oYW5kbGVkIHZlcnRpY2FsIHNsaWRlcnMsIGl0IGFkanVzdHMgdGhlIHZhbHVlIHRvIGFjY291bnQgZm9yIHRoZSBzbGlkZXIgYmVpbmcgXFxcInVwc2lkZS1kb3duXFxcIlxcbiAgICAgIC8vZm9yIGNsaWNrIGFuZCBkcmFnIGV2ZW50cywgaXQncyB3ZWlyZCBkdWUgdG8gdGhlIHNjYWxlKC0xLCAxKSBjc3MgcHJvcGVydHlcXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnZlcnRpY2FsICYmICFub0ludmVydCkge1xcbiAgICAgICAgbG9jYXRpb24gPSB0aGlzLm9wdGlvbnMuZW5kIC0gbG9jYXRpb247XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBfdGhpcyA9IHRoaXMsXFxuICAgICAgICAgIHZlcnQgPSB0aGlzLm9wdGlvbnMudmVydGljYWwsXFxuICAgICAgICAgIGhPclcgPSB2ZXJ0ID8gJ2hlaWdodCcgOiAnd2lkdGgnLFxcbiAgICAgICAgICBsT3JUID0gdmVydCA/ICd0b3AnIDogJ2xlZnQnLFxcbiAgICAgICAgICBoYW5kbGVEaW0gPSAkaG5kbFswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVtoT3JXXSxcXG4gICAgICAgICAgZWxlbURpbSA9IHRoaXMuJGVsZW1lbnRbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClbaE9yV10sXFxuXFxuICAgICAgLy9wZXJjZW50YWdlIG9mIGJhciBtaW4vbWF4IHZhbHVlIGJhc2VkIG9uIGNsaWNrIG9yIGRyYWcgcG9pbnRcXG4gICAgICBwY3RPZkJhciA9IHRoaXMuX3BjdE9mQmFyKGxvY2F0aW9uKSxcXG5cXG4gICAgICAvL251bWJlciBvZiBhY3R1YWwgcGl4ZWxzIHRvIHNoaWZ0IHRoZSBoYW5kbGUsIGJhc2VkIG9uIHRoZSBwZXJjZW50YWdlIG9idGFpbmVkIGFib3ZlXFxuICAgICAgcHhUb01vdmUgPSAoZWxlbURpbSAtIGhhbmRsZURpbSkgKiBwY3RPZkJhcixcXG5cXG4gICAgICAvL3BlcmNlbnRhZ2Ugb2YgYmFyIHRvIHNoaWZ0IHRoZSBoYW5kbGVcXG4gICAgICBtb3ZlbWVudCA9IChwZXJjZW50KHB4VG9Nb3ZlLCBlbGVtRGltKSAqIDEwMCkudG9GaXhlZCh0aGlzLm9wdGlvbnMuZGVjaW1hbCk7XFxuICAgICAgLy9maXhpbmcgdGhlIGRlY2ltYWwgdmFsdWUgZm9yIHRoZSBsb2NhdGlvbiBudW1iZXIsIGlzIHBhc3NlZCB0byBvdGhlciBtZXRob2RzIGFzIGEgZml4ZWQgZmxvYXRpbmctcG9pbnQgdmFsdWVcXG4gICAgICBsb2NhdGlvbiA9IHBhcnNlRmxvYXQobG9jYXRpb24udG9GaXhlZCh0aGlzLm9wdGlvbnMuZGVjaW1hbCkpO1xcbiAgICAgIC8vIGRlY2xhcmUgZW1wdHkgb2JqZWN0IGZvciBjc3MgYWRqdXN0bWVudHMsIG9ubHkgdXNlZCB3aXRoIDIgaGFuZGxlZC1zbGlkZXJzXFxuICAgICAgdmFyIGNzcyA9IHt9O1xcblxcbiAgICAgIHRoaXMuX3NldFZhbHVlcygkaG5kbCwgbG9jYXRpb24pO1xcblxcbiAgICAgIC8vIFRPRE8gdXBkYXRlIHRvIGNhbGN1bGF0ZSBiYXNlZCBvbiB2YWx1ZXMgc2V0IHRvIHJlc3BlY3RpdmUgaW5wdXRzPz9cXG4gICAgICBpZiAoaXNEYmwpIHtcXG4gICAgICAgIHZhciBpc0xlZnRIbmRsID0gdGhpcy5oYW5kbGVzLmluZGV4KCRobmRsKSA9PT0gMCxcXG5cXG4gICAgICAgIC8vZW1wdHkgdmFyaWFibGUsIHdpbGwgYmUgdXNlZCBmb3IgbWluLWhlaWdodC93aWR0aCBmb3IgZmlsbCBiYXJcXG4gICAgICAgIGRpbSxcXG5cXG4gICAgICAgIC8vcGVyY2VudGFnZSB3L2ggb2YgdGhlIGhhbmRsZSBjb21wYXJlZCB0byB0aGUgc2xpZGVyIGJhclxcbiAgICAgICAgaGFuZGxlUGN0ID0gfn4ocGVyY2VudChoYW5kbGVEaW0sIGVsZW1EaW0pICogMTAwKTtcXG4gICAgICAgIC8vaWYgbGVmdCBoYW5kbGUsIHRoZSBtYXRoIGlzIHNsaWdodGx5IGRpZmZlcmVudCB0aGFuIGlmIGl0J3MgdGhlIHJpZ2h0IGhhbmRsZSwgYW5kIHRoZSBsZWZ0L3RvcCBwcm9wZXJ0eSBuZWVkcyB0byBiZSBjaGFuZ2VkIGZvciB0aGUgZmlsbCBiYXJcXG4gICAgICAgIGlmIChpc0xlZnRIbmRsKSB7XFxuICAgICAgICAgIC8vbGVmdCBvciB0b3AgcGVyY2VudGFnZSB2YWx1ZSB0byBhcHBseSB0byB0aGUgZmlsbCBiYXIuXFxuICAgICAgICAgIGNzc1tsT3JUXSA9IG1vdmVtZW50ICsgJyUnO1xcbiAgICAgICAgICAvL2NhbGN1bGF0ZSB0aGUgbmV3IG1pbi1oZWlnaHQvd2lkdGggZm9yIHRoZSBmaWxsIGJhci5cXG4gICAgICAgICAgZGltID0gcGFyc2VGbG9hdCh0aGlzLiRoYW5kbGUyWzBdLnN0eWxlW2xPclRdKSAtIG1vdmVtZW50ICsgaGFuZGxlUGN0O1xcbiAgICAgICAgICAvL3RoaXMgY2FsbGJhY2sgaXMgbmVjZXNzYXJ5IHRvIHByZXZlbnQgZXJyb3JzIGFuZCBhbGxvdyB0aGUgcHJvcGVyIHBsYWNlbWVudCBhbmQgaW5pdGlhbGl6YXRpb24gb2YgYSAyLWhhbmRsZWQgc2xpZGVyXFxuICAgICAgICAgIC8vcGx1cywgaXQgbWVhbnMgd2UgZG9uJ3QgY2FyZSBpZiAnZGltJyBpc05hTiBvbiBpbml0LCBpdCB3b24ndCBiZSBpbiB0aGUgZnV0dXJlLlxcbiAgICAgICAgICBpZiAoY2IgJiYgdHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgICAgICAgY2IoKTtcXG4gICAgICAgICAgfSAvL3RoaXMgaXMgb25seSBuZWVkZWQgZm9yIHRoZSBpbml0aWFsaXphdGlvbiBvZiAyIGhhbmRsZWQgc2xpZGVyc1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgLy9qdXN0IGNhY2hpbmcgdGhlIHZhbHVlIG9mIHRoZSBsZWZ0L2JvdHRvbSBoYW5kbGUncyBsZWZ0L3RvcCBwcm9wZXJ0eVxcbiAgICAgICAgICB2YXIgaGFuZGxlUG9zID0gcGFyc2VGbG9hdCh0aGlzLiRoYW5kbGVbMF0uc3R5bGVbbE9yVF0pO1xcbiAgICAgICAgICAvL2NhbGN1bGF0ZSB0aGUgbmV3IG1pbi1oZWlnaHQvd2lkdGggZm9yIHRoZSBmaWxsIGJhci4gVXNlIGlzTmFOIHRvIHByZXZlbnQgZmFsc2UgcG9zaXRpdmVzIGZvciBudW1iZXJzIDw9IDBcXG4gICAgICAgICAgLy9iYXNlZCBvbiB0aGUgcGVyY2VudGFnZSBvZiBtb3ZlbWVudCBvZiB0aGUgaGFuZGxlIGJlaW5nIG1hbmlwdWxhdGVkLCBsZXNzIHRoZSBvcHBvc2luZyBoYW5kbGUncyBsZWZ0L3RvcCBwb3NpdGlvbiwgcGx1cyB0aGUgcGVyY2VudGFnZSB3L2ggb2YgdGhlIGhhbmRsZSBpdHNlbGZcXG4gICAgICAgICAgZGltID0gbW92ZW1lbnQgLSAoaXNOYU4oaGFuZGxlUG9zKSA/ICh0aGlzLm9wdGlvbnMuaW5pdGlhbFN0YXJ0IC0gdGhpcy5vcHRpb25zLnN0YXJ0KSAvICgodGhpcy5vcHRpb25zLmVuZCAtIHRoaXMub3B0aW9ucy5zdGFydCkgLyAxMDApIDogaGFuZGxlUG9zKSArIGhhbmRsZVBjdDtcXG4gICAgICAgIH1cXG4gICAgICAgIC8vIGFzc2lnbiB0aGUgbWluLWhlaWdodC93aWR0aCB0byBvdXIgY3NzIG9iamVjdFxcbiAgICAgICAgY3NzWydtaW4tJyArIGhPclddID0gZGltICsgJyUnO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLiRlbGVtZW50Lm9uZSgnZmluaXNoZWQuemYuYW5pbWF0ZScsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgaGFuZGxlIGlzIGRvbmUgbW92aW5nLlxcbiAgICAgICAgICogQGV2ZW50IFNsaWRlciNtb3ZlZFxcbiAgICAgICAgICovXFxuICAgICAgICBfdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdtb3ZlZC56Zi5zbGlkZXInLCBbJGhuZGxdKTtcXG4gICAgICB9KTtcXG5cXG4gICAgICAvL2JlY2F1c2Ugd2UgZG9uJ3Qga25vdyBleGFjdGx5IGhvdyB0aGUgaGFuZGxlIHdpbGwgYmUgbW92ZWQsIGNoZWNrIHRoZSBhbW91bnQgb2YgdGltZSBpdCBzaG91bGQgdGFrZSB0byBtb3ZlLlxcbiAgICAgIHZhciBtb3ZlVGltZSA9IHRoaXMuJGVsZW1lbnQuZGF0YSgnZHJhZ2dpbmcnKSA/IDEwMDAgLyA2MCA6IHRoaXMub3B0aW9ucy5tb3ZlVGltZTtcXG5cXG4gICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmkoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19mb3VuZGF0aW9uX3V0aWxfbW90aW9uX19bXFxcImJcXFwiIC8qIE1vdmUgKi9dKShtb3ZlVGltZSwgJGhuZGwsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIC8vIGFkanVzdGluZyB0aGUgbGVmdC90b3AgcHJvcGVydHkgb2YgdGhlIGhhbmRsZSwgYmFzZWQgb24gdGhlIHBlcmNlbnRhZ2UgY2FsY3VsYXRlZCBhYm92ZVxcbiAgICAgICAgLy8gaWYgbW92ZW1lbnQgaXNOYU4sIHRoYXQgaXMgYmVjYXVzZSB0aGUgc2xpZGVyIGlzIGhpZGRlbiBhbmQgd2UgY2Fubm90IGRldGVybWluZSBoYW5kbGUgd2lkdGgsXFxuICAgICAgICAvLyBmYWxsIGJhY2sgdG8gbmV4dCBiZXN0IGd1ZXNzLlxcbiAgICAgICAgaWYgKGlzTmFOKG1vdmVtZW50KSkge1xcbiAgICAgICAgICAkaG5kbC5jc3MobE9yVCwgcGN0T2ZCYXIgKiAxMDAgKyAnJScpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgJGhuZGwuY3NzKGxPclQsIG1vdmVtZW50ICsgJyUnKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICghX3RoaXMub3B0aW9ucy5kb3VibGVTaWRlZCkge1xcbiAgICAgICAgICAvL2lmIHNpbmdsZS1oYW5kbGVkLCBhIHNpbXBsZSBtZXRob2QgdG8gZXhwYW5kIHRoZSBmaWxsIGJhclxcbiAgICAgICAgICBfdGhpcy4kZmlsbC5jc3MoaE9yVywgcGN0T2ZCYXIgKiAxMDAgKyAnJScpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgLy9vdGhlcndpc2UsIHVzZSB0aGUgY3NzIG9iamVjdCB3ZSBjcmVhdGVkIGFib3ZlXFxuICAgICAgICAgIF90aGlzLiRmaWxsLmNzcyhjc3MpO1xcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHZhbHVlIGhhcyBub3QgYmVlbiBjaGFuZ2UgZm9yIGEgZ2l2ZW4gdGltZS5cXG4gICAgICAgKiBAZXZlbnQgU2xpZGVyI2NoYW5nZWRcXG4gICAgICAgKi9cXG4gICAgICBjbGVhclRpbWVvdXQoX3RoaXMudGltZW91dCk7XFxuICAgICAgX3RoaXMudGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgX3RoaXMuJGVsZW1lbnQudHJpZ2dlcignY2hhbmdlZC56Zi5zbGlkZXInLCBbJGhuZGxdKTtcXG4gICAgICB9LCBfdGhpcy5vcHRpb25zLmNoYW5nZWREZWxheSk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIFNldHMgdGhlIGluaXRpYWwgYXR0cmlidXRlIGZvciB0aGUgc2xpZGVyIGVsZW1lbnQuXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaWR4IC0gaW5kZXggb2YgdGhlIGN1cnJlbnQgaGFuZGxlL2lucHV0IHRvIHVzZS5cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogJ19zZXRJbml0QXR0cicsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0SW5pdEF0dHIoaWR4KSB7XFxuICAgICAgdmFyIGluaXRWYWwgPSBpZHggPT09IDAgPyB0aGlzLm9wdGlvbnMuaW5pdGlhbFN0YXJ0IDogdGhpcy5vcHRpb25zLmluaXRpYWxFbmQ7XFxuICAgICAgdmFyIGlkID0gdGhpcy5pbnB1dHMuZXEoaWR4KS5hdHRyKCdpZCcpIHx8IF9fd2VicGFja19yZXF1aXJlX18uaShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX2ZvdW5kYXRpb25fdXRpbF9jb3JlX19bXFxcImJcXFwiIC8qIEdldFlvRGlnaXRzICovXSkoNiwgJ3NsaWRlcicpO1xcbiAgICAgIHRoaXMuaW5wdXRzLmVxKGlkeCkuYXR0cih7XFxuICAgICAgICAnaWQnOiBpZCxcXG4gICAgICAgICdtYXgnOiB0aGlzLm9wdGlvbnMuZW5kLFxcbiAgICAgICAgJ21pbic6IHRoaXMub3B0aW9ucy5zdGFydCxcXG4gICAgICAgICdzdGVwJzogdGhpcy5vcHRpb25zLnN0ZXBcXG4gICAgICB9KTtcXG4gICAgICB0aGlzLmlucHV0cy5lcShpZHgpLnZhbChpbml0VmFsKTtcXG4gICAgICB0aGlzLmhhbmRsZXMuZXEoaWR4KS5hdHRyKHtcXG4gICAgICAgICdyb2xlJzogJ3NsaWRlcicsXFxuICAgICAgICAnYXJpYS1jb250cm9scyc6IGlkLFxcbiAgICAgICAgJ2FyaWEtdmFsdWVtYXgnOiB0aGlzLm9wdGlvbnMuZW5kLFxcbiAgICAgICAgJ2FyaWEtdmFsdWVtaW4nOiB0aGlzLm9wdGlvbnMuc3RhcnQsXFxuICAgICAgICAnYXJpYS12YWx1ZW5vdyc6IGluaXRWYWwsXFxuICAgICAgICAnYXJpYS1vcmllbnRhdGlvbic6IHRoaXMub3B0aW9ucy52ZXJ0aWNhbCA/ICd2ZXJ0aWNhbCcgOiAnaG9yaXpvbnRhbCcsXFxuICAgICAgICAndGFiaW5kZXgnOiAwXFxuICAgICAgfSk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIFNldHMgdGhlIGlucHV0IGFuZCBgYXJpYS12YWx1ZW5vd2AgdmFsdWVzIGZvciB0aGUgc2xpZGVyIGVsZW1lbnQuXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gJGhhbmRsZSAtIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgaGFuZGxlLlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsIC0gZmxvYXRpbmcgcG9pbnQgb2YgdGhlIG5ldyB2YWx1ZS5cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogJ19zZXRWYWx1ZXMnLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldFZhbHVlcygkaGFuZGxlLCB2YWwpIHtcXG4gICAgICB2YXIgaWR4ID0gdGhpcy5vcHRpb25zLmRvdWJsZVNpZGVkID8gdGhpcy5oYW5kbGVzLmluZGV4KCRoYW5kbGUpIDogMDtcXG4gICAgICB0aGlzLmlucHV0cy5lcShpZHgpLnZhbCh2YWwpO1xcbiAgICAgICRoYW5kbGUuYXR0cignYXJpYS12YWx1ZW5vdycsIHZhbCk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIEhhbmRsZXMgZXZlbnRzIG9uIHRoZSBzbGlkZXIgZWxlbWVudC5cXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgbmV3IGxvY2F0aW9uIG9mIHRoZSBjdXJyZW50IGhhbmRsZS5cXG4gICAgICogSWYgdGhlcmUgYXJlIHR3byBoYW5kbGVzIGFuZCB0aGUgYmFyIHdhcyBjbGlja2VkLCBpdCBkZXRlcm1pbmVzIHdoaWNoIGhhbmRsZSB0byBtb3ZlLlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGUgLSB0aGUgYGV2ZW50YCBvYmplY3QgcGFzc2VkIGZyb20gdGhlIGxpc3RlbmVyLlxcbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gJGhhbmRsZSAtIHRoZSBjdXJyZW50IGhhbmRsZSB0byBjYWxjdWxhdGUgZm9yLCBpZiBzZWxlY3RlZC5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbCAtIGZsb2F0aW5nIHBvaW50IG51bWJlciBmb3IgdGhlIG5ldyB2YWx1ZSBvZiB0aGUgc2xpZGVyLlxcbiAgICAgKiBUT0RPIGNsZWFuIHRoaXMgdXAsIHRoZXJlJ3MgYSBsb3Qgb2YgcmVwZWF0ZWQgY29kZSBiZXR3ZWVuIHRoaXMgYW5kIHRoZSBfc2V0SGFuZGxlUG9zIGZuLlxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAnX2hhbmRsZUV2ZW50JyxcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVFdmVudChlLCAkaGFuZGxlLCB2YWwpIHtcXG4gICAgICB2YXIgdmFsdWUsIGhhc1ZhbDtcXG4gICAgICBpZiAoIXZhbCkge1xcbiAgICAgICAgLy9jbGljayBvciBkcmFnIGV2ZW50c1xcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcyxcXG4gICAgICAgICAgICB2ZXJ0aWNhbCA9IHRoaXMub3B0aW9ucy52ZXJ0aWNhbCxcXG4gICAgICAgICAgICBwYXJhbSA9IHZlcnRpY2FsID8gJ2hlaWdodCcgOiAnd2lkdGgnLFxcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IHZlcnRpY2FsID8gJ3RvcCcgOiAnbGVmdCcsXFxuICAgICAgICAgICAgZXZlbnRPZmZzZXQgPSB2ZXJ0aWNhbCA/IGUucGFnZVkgOiBlLnBhZ2VYLFxcbiAgICAgICAgICAgIGhhbGZPZkhhbmRsZSA9IHRoaXMuJGhhbmRsZVswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVtwYXJhbV0gLyAyLFxcbiAgICAgICAgICAgIGJhckRpbSA9IHRoaXMuJGVsZW1lbnRbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClbcGFyYW1dLFxcbiAgICAgICAgICAgIHdpbmRvd1Njcm9sbCA9IHZlcnRpY2FsID8gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSh3aW5kb3cpLnNjcm9sbFRvcCgpIDogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSh3aW5kb3cpLnNjcm9sbExlZnQoKTtcXG5cXG4gICAgICAgIHZhciBlbGVtT2Zmc2V0ID0gdGhpcy4kZWxlbWVudC5vZmZzZXQoKVtkaXJlY3Rpb25dO1xcblxcbiAgICAgICAgLy8gdG91Y2ggZXZlbnRzIGVtdWxhdGVkIGJ5IHRoZSB0b3VjaCB1dGlsIGdpdmUgcG9zaXRpb24gcmVsYXRpdmUgdG8gc2NyZWVuLCBhZGQgd2luZG93LnNjcm9sbCB0byBldmVudCBjb29yZGluYXRlcy4uLlxcbiAgICAgICAgLy8gYmVzdCB3YXkgdG8gZ3Vlc3MgdGhpcyBpcyBzaW11bGF0ZWQgaXMgaWYgY2xpZW50WSA9PSBwYWdlWVxcbiAgICAgICAgaWYgKGUuY2xpZW50WSA9PT0gZS5wYWdlWSkge1xcbiAgICAgICAgICBldmVudE9mZnNldCA9IGV2ZW50T2Zmc2V0ICsgd2luZG93U2Nyb2xsO1xcbiAgICAgICAgfVxcbiAgICAgICAgdmFyIGV2ZW50RnJvbUJhciA9IGV2ZW50T2Zmc2V0IC0gZWxlbU9mZnNldDtcXG4gICAgICAgIHZhciBiYXJYWTtcXG4gICAgICAgIGlmIChldmVudEZyb21CYXIgPCAwKSB7XFxuICAgICAgICAgIGJhclhZID0gMDtcXG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnRGcm9tQmFyID4gYmFyRGltKSB7XFxuICAgICAgICAgIGJhclhZID0gYmFyRGltO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgYmFyWFkgPSBldmVudEZyb21CYXI7XFxuICAgICAgICB9XFxuICAgICAgICB2YXIgb2Zmc2V0UGN0ID0gcGVyY2VudChiYXJYWSwgYmFyRGltKTtcXG5cXG4gICAgICAgIHZhbHVlID0gdGhpcy5fdmFsdWUob2Zmc2V0UGN0KTtcXG5cXG4gICAgICAgIC8vIHR1cm4gZXZlcnl0aGluZyBhcm91bmQgZm9yIFJUTCwgeWF5IG1hdGghXFxuICAgICAgICBpZiAoX193ZWJwYWNrX3JlcXVpcmVfXy5pKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fZm91bmRhdGlvbl91dGlsX2NvcmVfX1tcXFwiYVxcXCIgLyogcnRsICovXSkoKSAmJiAhdGhpcy5vcHRpb25zLnZlcnRpY2FsKSB7XFxuICAgICAgICAgIHZhbHVlID0gdGhpcy5vcHRpb25zLmVuZCAtIHZhbHVlO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdmFsdWUgPSBfdGhpcy5fYWRqdXN0VmFsdWUobnVsbCwgdmFsdWUpO1xcbiAgICAgICAgLy9ib29sZWFuIGZsYWcgZm9yIHRoZSBzZXRIYW5kbGVQb3MgZm4sIHNwZWNpZmljYWxseSBmb3IgdmVydGljYWwgc2xpZGVyc1xcbiAgICAgICAgaGFzVmFsID0gZmFsc2U7XFxuXFxuICAgICAgICBpZiAoISRoYW5kbGUpIHtcXG4gICAgICAgICAgLy9maWd1cmUgb3V0IHdoaWNoIGhhbmRsZSBpdCBpcywgcGFzcyBpdCB0byB0aGUgbmV4dCBmdW5jdGlvbi5cXG4gICAgICAgICAgdmFyIGZpcnN0SG5kbFBvcyA9IGFic1Bvc2l0aW9uKHRoaXMuJGhhbmRsZSwgZGlyZWN0aW9uLCBiYXJYWSwgcGFyYW0pLFxcbiAgICAgICAgICAgICAgc2VjbmRIbmRsUG9zID0gYWJzUG9zaXRpb24odGhpcy4kaGFuZGxlMiwgZGlyZWN0aW9uLCBiYXJYWSwgcGFyYW0pO1xcbiAgICAgICAgICAkaGFuZGxlID0gZmlyc3RIbmRsUG9zIDw9IHNlY25kSG5kbFBvcyA/IHRoaXMuJGhhbmRsZSA6IHRoaXMuJGhhbmRsZTI7XFxuICAgICAgICB9XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIC8vY2hhbmdlIGV2ZW50IG9uIGlucHV0XFxuICAgICAgICB2YWx1ZSA9IHRoaXMuX2FkanVzdFZhbHVlKG51bGwsIHZhbCk7XFxuICAgICAgICBoYXNWYWwgPSB0cnVlO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9zZXRIYW5kbGVQb3MoJGhhbmRsZSwgdmFsdWUsIGhhc1ZhbCk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIEFkanVzdGVzIHZhbHVlIGZvciBoYW5kbGUgaW4gcmVnYXJkIHRvIHN0ZXAgdmFsdWUuIHJldHVybnMgYWRqdXN0ZWQgdmFsdWVcXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSAkaGFuZGxlIC0gdGhlIHNlbGVjdGVkIGhhbmRsZS5cXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gdmFsdWUgdG8gYWRqdXN0LiB1c2VkIGlmICRoYW5kbGUgaXMgZmFsc3lcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogJ19hZGp1c3RWYWx1ZScsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYWRqdXN0VmFsdWUoJGhhbmRsZSwgdmFsdWUpIHtcXG4gICAgICB2YXIgdmFsLFxcbiAgICAgICAgICBzdGVwID0gdGhpcy5vcHRpb25zLnN0ZXAsXFxuICAgICAgICAgIGRpdiA9IHBhcnNlRmxvYXQoc3RlcCAvIDIpLFxcbiAgICAgICAgICBsZWZ0LFxcbiAgICAgICAgICBwcmV2X3ZhbCxcXG4gICAgICAgICAgbmV4dF92YWw7XFxuICAgICAgaWYgKCEhJGhhbmRsZSkge1xcbiAgICAgICAgdmFsID0gcGFyc2VGbG9hdCgkaGFuZGxlLmF0dHIoJ2FyaWEtdmFsdWVub3cnKSk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHZhbCA9IHZhbHVlO1xcbiAgICAgIH1cXG4gICAgICBsZWZ0ID0gdmFsICUgc3RlcDtcXG4gICAgICBwcmV2X3ZhbCA9IHZhbCAtIGxlZnQ7XFxuICAgICAgbmV4dF92YWwgPSBwcmV2X3ZhbCArIHN0ZXA7XFxuICAgICAgaWYgKGxlZnQgPT09IDApIHtcXG4gICAgICAgIHJldHVybiB2YWw7XFxuICAgICAgfVxcbiAgICAgIHZhbCA9IHZhbCA+PSBwcmV2X3ZhbCArIGRpdiA/IG5leHRfdmFsIDogcHJldl92YWw7XFxuICAgICAgcmV0dXJuIHZhbDtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQWRkcyBldmVudCBsaXN0ZW5lcnMgdG8gdGhlIHNsaWRlciBlbGVtZW50cy5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6ICdfZXZlbnRzJyxcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9ldmVudHMoKSB7XFxuICAgICAgdGhpcy5fZXZlbnRzRm9ySGFuZGxlKHRoaXMuJGhhbmRsZSk7XFxuICAgICAgaWYgKHRoaXMuaGFuZGxlc1sxXSkge1xcbiAgICAgICAgdGhpcy5fZXZlbnRzRm9ySGFuZGxlKHRoaXMuJGhhbmRsZTIpO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQWRkcyBldmVudCBsaXN0ZW5lcnMgYSBwYXJ0aWN1bGFyIGhhbmRsZVxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHBhcmFtIHtqUXVlcnl9ICRoYW5kbGUgLSB0aGUgY3VycmVudCBoYW5kbGUgdG8gYXBwbHkgbGlzdGVuZXJzIHRvLlxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAnX2V2ZW50c0ZvckhhbmRsZScsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZXZlbnRzRm9ySGFuZGxlKCRoYW5kbGUpIHtcXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzLFxcbiAgICAgICAgICBjdXJIYW5kbGUsXFxuICAgICAgICAgIHRpbWVyO1xcblxcbiAgICAgIHRoaXMuaW5wdXRzLm9mZignY2hhbmdlLnpmLnNsaWRlcicpLm9uKCdjaGFuZ2UuemYuc2xpZGVyJywgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgIHZhciBpZHggPSBfdGhpcy5pbnB1dHMuaW5kZXgoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSh0aGlzKSk7XFxuICAgICAgICBfdGhpcy5faGFuZGxlRXZlbnQoZSwgX3RoaXMuaGFuZGxlcy5lcShpZHgpLCBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKHRoaXMpLnZhbCgpKTtcXG4gICAgICB9KTtcXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmNsaWNrU2VsZWN0KSB7XFxuICAgICAgICB0aGlzLiRlbGVtZW50Lm9mZignY2xpY2suemYuc2xpZGVyJykub24oJ2NsaWNrLnpmLnNsaWRlcicsIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICAgIGlmIChfdGhpcy4kZWxlbWVudC5kYXRhKCdkcmFnZ2luZycpKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlmICghX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKShlLnRhcmdldCkuaXMoJ1tkYXRhLXNsaWRlci1oYW5kbGVdJykpIHtcXG4gICAgICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy5kb3VibGVTaWRlZCkge1xcbiAgICAgICAgICAgICAgX3RoaXMuX2hhbmRsZUV2ZW50KGUpO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICBfdGhpcy5faGFuZGxlRXZlbnQoZSwgX3RoaXMuJGhhbmRsZSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5kcmFnZ2FibGUpIHtcXG4gICAgICAgIHRoaXMuaGFuZGxlcy5hZGRUb3VjaCgpO1xcblxcbiAgICAgICAgdmFyICRib2R5ID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSgnYm9keScpO1xcbiAgICAgICAgJGhhbmRsZS5vZmYoJ21vdXNlZG93bi56Zi5zbGlkZXInKS5vbignbW91c2Vkb3duLnpmLnNsaWRlcicsIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICAgICRoYW5kbGUuYWRkQ2xhc3MoJ2lzLWRyYWdnaW5nJyk7XFxuICAgICAgICAgIF90aGlzLiRmaWxsLmFkZENsYXNzKCdpcy1kcmFnZ2luZycpOyAvL1xcbiAgICAgICAgICBfdGhpcy4kZWxlbWVudC5kYXRhKCdkcmFnZ2luZycsIHRydWUpO1xcblxcbiAgICAgICAgICBjdXJIYW5kbGUgPSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKGUuY3VycmVudFRhcmdldCk7XFxuXFxuICAgICAgICAgICRib2R5Lm9uKCdtb3VzZW1vdmUuemYuc2xpZGVyJywgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICAgICAgX3RoaXMuX2hhbmRsZUV2ZW50KGUsIGN1ckhhbmRsZSk7XFxuICAgICAgICAgIH0pLm9uKCdtb3VzZXVwLnpmLnNsaWRlcicsIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICAgICAgX3RoaXMuX2hhbmRsZUV2ZW50KGUsIGN1ckhhbmRsZSk7XFxuXFxuICAgICAgICAgICAgJGhhbmRsZS5yZW1vdmVDbGFzcygnaXMtZHJhZ2dpbmcnKTtcXG4gICAgICAgICAgICBfdGhpcy4kZmlsbC5yZW1vdmVDbGFzcygnaXMtZHJhZ2dpbmcnKTtcXG4gICAgICAgICAgICBfdGhpcy4kZWxlbWVudC5kYXRhKCdkcmFnZ2luZycsIGZhbHNlKTtcXG5cXG4gICAgICAgICAgICAkYm9keS5vZmYoJ21vdXNlbW92ZS56Zi5zbGlkZXIgbW91c2V1cC56Zi5zbGlkZXInKTtcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9KVxcbiAgICAgICAgLy8gcHJldmVudCBldmVudHMgdHJpZ2dlcmVkIGJ5IHRvdWNoXFxuICAgICAgICAub24oJ3NlbGVjdHN0YXJ0LnpmLnNsaWRlciB0b3VjaG1vdmUuemYuc2xpZGVyJywgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfVxcblxcbiAgICAgICRoYW5kbGUub2ZmKCdrZXlkb3duLnpmLnNsaWRlcicpLm9uKCdrZXlkb3duLnpmLnNsaWRlcicsIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICB2YXIgXyRoYW5kbGUgPSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKHRoaXMpLFxcbiAgICAgICAgICAgIGlkeCA9IF90aGlzLm9wdGlvbnMuZG91YmxlU2lkZWQgPyBfdGhpcy5oYW5kbGVzLmluZGV4KF8kaGFuZGxlKSA6IDAsXFxuICAgICAgICAgICAgb2xkVmFsdWUgPSBwYXJzZUZsb2F0KF90aGlzLmlucHV0cy5lcShpZHgpLnZhbCgpKSxcXG4gICAgICAgICAgICBuZXdWYWx1ZTtcXG5cXG4gICAgICAgIC8vIGhhbmRsZSBrZXlib2FyZCBldmVudCB3aXRoIGtleWJvYXJkIHV0aWxcXG4gICAgICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fZm91bmRhdGlvbl91dGlsX2tleWJvYXJkX19bXFxcImFcXFwiIC8qIEtleWJvYXJkICovXS5oYW5kbGVLZXkoZSwgJ1NsaWRlcicsIHtcXG4gICAgICAgICAgZGVjcmVhc2U6IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICBuZXdWYWx1ZSA9IG9sZFZhbHVlIC0gX3RoaXMub3B0aW9ucy5zdGVwO1xcbiAgICAgICAgICB9LFxcbiAgICAgICAgICBpbmNyZWFzZTogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gb2xkVmFsdWUgKyBfdGhpcy5vcHRpb25zLnN0ZXA7XFxuICAgICAgICAgIH0sXFxuICAgICAgICAgIGRlY3JlYXNlX2Zhc3Q6IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICBuZXdWYWx1ZSA9IG9sZFZhbHVlIC0gX3RoaXMub3B0aW9ucy5zdGVwICogMTA7XFxuICAgICAgICAgIH0sXFxuICAgICAgICAgIGluY3JlYXNlX2Zhc3Q6IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICBuZXdWYWx1ZSA9IG9sZFZhbHVlICsgX3RoaXMub3B0aW9ucy5zdGVwICogMTA7XFxuICAgICAgICAgIH0sXFxuICAgICAgICAgIG1pbjogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gX3RoaXMub3B0aW9ucy5zdGFydDtcXG4gICAgICAgICAgfSxcXG4gICAgICAgICAgbWF4OiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgbmV3VmFsdWUgPSBfdGhpcy5vcHRpb25zLmVuZDtcXG4gICAgICAgICAgfSxcXG4gICAgICAgICAgaGFuZGxlZDogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIC8vIG9ubHkgc2V0IGhhbmRsZSBwb3Mgd2hlbiBldmVudCB3YXMgaGFuZGxlZCBzcGVjaWFsbHlcXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICAgICAgX3RoaXMuX3NldEhhbmRsZVBvcyhfJGhhbmRsZSwgbmV3VmFsdWUsIHRydWUpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgICAgIC8qaWYgKG5ld1ZhbHVlKSB7IC8vIGlmIHByZXNzZWQga2V5IGhhcyBzcGVjaWFsIGZ1bmN0aW9uLCB1cGRhdGUgdmFsdWVcXG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgICBfdGhpcy5fc2V0SGFuZGxlUG9zKF8kaGFuZGxlLCBuZXdWYWx1ZSk7XFxuICAgICAgICB9Ki9cXG4gICAgICB9KTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogRGVzdHJveXMgdGhlIHNsaWRlciBwbHVnaW4uXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6ICdfZGVzdHJveScsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVzdHJveSgpIHtcXG4gICAgICB0aGlzLmhhbmRsZXMub2ZmKCcuemYuc2xpZGVyJyk7XFxuICAgICAgdGhpcy5pbnB1dHMub2ZmKCcuemYuc2xpZGVyJyk7XFxuICAgICAgdGhpcy4kZWxlbWVudC5vZmYoJy56Zi5zbGlkZXInKTtcXG5cXG4gICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KTtcXG4gICAgfVxcbiAgfV0pO1xcblxcbiAgcmV0dXJuIFNsaWRlcjtcXG59KF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fZm91bmRhdGlvbl9wbHVnaW5fX1tcXFwiYVxcXCIgLyogUGx1Z2luICovXSk7XFxuXFxuU2xpZGVyLmRlZmF1bHRzID0ge1xcbiAgLyoqXFxuICAgKiBNaW5pbXVtIHZhbHVlIGZvciB0aGUgc2xpZGVyIHNjYWxlLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge251bWJlcn1cXG4gICAqIEBkZWZhdWx0IDBcXG4gICAqL1xcbiAgc3RhcnQ6IDAsXFxuICAvKipcXG4gICAqIE1heGltdW0gdmFsdWUgZm9yIHRoZSBzbGlkZXIgc2NhbGUuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7bnVtYmVyfVxcbiAgICogQGRlZmF1bHQgMTAwXFxuICAgKi9cXG4gIGVuZDogMTAwLFxcbiAgLyoqXFxuICAgKiBNaW5pbXVtIHZhbHVlIGNoYW5nZSBwZXIgY2hhbmdlIGV2ZW50LlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge251bWJlcn1cXG4gICAqIEBkZWZhdWx0IDFcXG4gICAqL1xcbiAgc3RlcDogMSxcXG4gIC8qKlxcbiAgICogVmFsdWUgYXQgd2hpY2ggdGhlIGhhbmRsZS9pbnB1dCAqKGxlZnQgaGFuZGxlL2ZpcnN0IGlucHV0KSogc2hvdWxkIGJlIHNldCB0byBvbiBpbml0aWFsaXphdGlvbi5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtudW1iZXJ9XFxuICAgKiBAZGVmYXVsdCAwXFxuICAgKi9cXG4gIGluaXRpYWxTdGFydDogMCxcXG4gIC8qKlxcbiAgICogVmFsdWUgYXQgd2hpY2ggdGhlIHJpZ2h0IGhhbmRsZS9zZWNvbmQgaW5wdXQgc2hvdWxkIGJlIHNldCB0byBvbiBpbml0aWFsaXphdGlvbi5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtudW1iZXJ9XFxuICAgKiBAZGVmYXVsdCAxMDBcXG4gICAqL1xcbiAgaW5pdGlhbEVuZDogMTAwLFxcbiAgLyoqXFxuICAgKiBBbGxvd3MgdGhlIGlucHV0IHRvIGJlIGxvY2F0ZWQgb3V0c2lkZSB0aGUgY29udGFpbmVyIGFuZCB2aXNpYmxlLiBTZXQgdG8gYnkgdGhlIEpTXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IGZhbHNlXFxuICAgKi9cXG4gIGJpbmRpbmc6IGZhbHNlLFxcbiAgLyoqXFxuICAgKiBBbGxvd3MgdGhlIHVzZXIgdG8gY2xpY2svdGFwIG9uIHRoZSBzbGlkZXIgYmFyIHRvIHNlbGVjdCBhIHZhbHVlLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge2Jvb2xlYW59XFxuICAgKiBAZGVmYXVsdCB0cnVlXFxuICAgKi9cXG4gIGNsaWNrU2VsZWN0OiB0cnVlLFxcbiAgLyoqXFxuICAgKiBTZXQgdG8gdHJ1ZSBhbmQgdXNlIHRoZSBgdmVydGljYWxgIGNsYXNzIHRvIGNoYW5nZSBhbGlnbm1lbnQgdG8gdmVydGljYWwuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IGZhbHNlXFxuICAgKi9cXG4gIHZlcnRpY2FsOiBmYWxzZSxcXG4gIC8qKlxcbiAgICogQWxsb3dzIHRoZSB1c2VyIHRvIGRyYWcgdGhlIHNsaWRlciBoYW5kbGUocykgdG8gc2VsZWN0IGEgdmFsdWUuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IHRydWVcXG4gICAqL1xcbiAgZHJhZ2dhYmxlOiB0cnVlLFxcbiAgLyoqXFxuICAgKiBEaXNhYmxlcyB0aGUgc2xpZGVyIGFuZCBwcmV2ZW50cyBldmVudCBsaXN0ZW5lcnMgZnJvbSBiZWluZyBhcHBsaWVkLiBEb3VibGUgY2hlY2tlZCBieSBKUyB3aXRoIGBkaXNhYmxlZENsYXNzYC5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtib29sZWFufVxcbiAgICogQGRlZmF1bHQgZmFsc2VcXG4gICAqL1xcbiAgZGlzYWJsZWQ6IGZhbHNlLFxcbiAgLyoqXFxuICAgKiBBbGxvd3MgdGhlIHVzZSBvZiB0d28gaGFuZGxlcy4gRG91YmxlIGNoZWNrZWQgYnkgdGhlIEpTLiBDaGFuZ2VzIHNvbWUgbG9naWMgaGFuZGxpbmcuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IGZhbHNlXFxuICAgKi9cXG4gIGRvdWJsZVNpZGVkOiBmYWxzZSxcXG4gIC8qKlxcbiAgICogUG90ZW50aWFsIGZ1dHVyZSBmZWF0dXJlLlxcbiAgICovXFxuICAvLyBzdGVwczogMTAwLFxcbiAgLyoqXFxuICAgKiBOdW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdGhlIHBsdWdpbiBzaG91bGQgZ28gdG8gZm9yIGZsb2F0aW5nIHBvaW50IHByZWNpc2lvbi5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtudW1iZXJ9XFxuICAgKiBAZGVmYXVsdCAyXFxuICAgKi9cXG4gIGRlY2ltYWw6IDIsXFxuICAvKipcXG4gICAqIFRpbWUgZGVsYXkgZm9yIGRyYWdnZWQgZWxlbWVudHMuXFxuICAgKi9cXG4gIC8vIGRyYWdEZWxheTogMCxcXG4gIC8qKlxcbiAgICogVGltZSwgaW4gbXMsIHRvIGFuaW1hdGUgdGhlIG1vdmVtZW50IG9mIGEgc2xpZGVyIGhhbmRsZSBpZiB1c2VyIGNsaWNrcy90YXBzIG9uIHRoZSBiYXIuIE5lZWRzIHRvIGJlIG1hbnVhbGx5IHNldCBpZiB1cGRhdGluZyB0aGUgdHJhbnNpdGlvbiB0aW1lIGluIHRoZSBTYXNzIHNldHRpbmdzLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge251bWJlcn1cXG4gICAqIEBkZWZhdWx0IDIwMFxcbiAgICovXFxuICBtb3ZlVGltZTogMjAwLCAvL3VwZGF0ZSB0aGlzIGlmIGNoYW5naW5nIHRoZSB0cmFuc2l0aW9uIHRpbWUgaW4gdGhlIHNhc3NcXG4gIC8qKlxcbiAgICogQ2xhc3MgYXBwbGllZCB0byBkaXNhYmxlZCBzbGlkZXJzLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge3N0cmluZ31cXG4gICAqIEBkZWZhdWx0ICdkaXNhYmxlZCdcXG4gICAqL1xcbiAgZGlzYWJsZWRDbGFzczogJ2Rpc2FibGVkJyxcXG4gIC8qKlxcbiAgICogV2lsbCBpbnZlcnQgdGhlIGRlZmF1bHQgbGF5b3V0IGZvciBhIHZlcnRpY2FsPHNwYW4gZGF0YS10b29sdGlwIHRpdGxlPVxcXCJ3aG8gd291bGQgZG8gdGhpcz8/P1xcXCI+IDwvc3Bhbj5zbGlkZXIuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IGZhbHNlXFxuICAgKi9cXG4gIGludmVydFZlcnRpY2FsOiBmYWxzZSxcXG4gIC8qKlxcbiAgICogTWlsbGlzZWNvbmRzIGJlZm9yZSB0aGUgYGNoYW5nZWQuemYtc2xpZGVyYCBldmVudCBpcyB0cmlnZ2VyZWQgYWZ0ZXIgdmFsdWUgY2hhbmdlLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge251bWJlcn1cXG4gICAqIEBkZWZhdWx0IDUwMFxcbiAgICovXFxuICBjaGFuZ2VkRGVsYXk6IDUwMCxcXG4gIC8qKlxcbiAgKiBCYXNldmFsdWUgZm9yIG5vbi1saW5lYXIgc2xpZGVyc1xcbiAgKiBAb3B0aW9uXFxuICAqIEB0eXBlIHtudW1iZXJ9XFxuICAqIEBkZWZhdWx0IDVcXG4gICovXFxuICBub25MaW5lYXJCYXNlOiA1LFxcbiAgLyoqXFxuICAqIEJhc2V2YWx1ZSBmb3Igbm9uLWxpbmVhciBzbGlkZXJzLCBwb3NzaWJsZSB2YWx1ZXMgYXJlOiBgJ2xpbmVhcidgLCBgJ3BvdydgICYgYCdsb2cnYC4gUG93IGFuZCBMb2cgdXNlIHRoZSBub25MaW5lYXJCYXNlIHNldHRpbmcuXFxuICAqIEBvcHRpb25cXG4gICogQHR5cGUge3N0cmluZ31cXG4gICogQGRlZmF1bHQgJ2xpbmVhcidcXG4gICovXFxuICBwb3NpdGlvblZhbHVlRnVuY3Rpb246ICdsaW5lYXInXFxufTtcXG5cXG5mdW5jdGlvbiBwZXJjZW50KGZyYWMsIG51bSkge1xcbiAgcmV0dXJuIGZyYWMgLyBudW07XFxufVxcbmZ1bmN0aW9uIGFic1Bvc2l0aW9uKCRoYW5kbGUsIGRpciwgY2xpY2tQb3MsIHBhcmFtKSB7XFxuICByZXR1cm4gTWF0aC5hYnMoJGhhbmRsZS5wb3NpdGlvbigpW2Rpcl0gKyAkaGFuZGxlW3BhcmFtXSgpIC8gMiAtIGNsaWNrUG9zKTtcXG59XFxuZnVuY3Rpb24gYmFzZUxvZyhiYXNlLCB2YWx1ZSkge1xcbiAgcmV0dXJuIE1hdGgubG9nKHZhbHVlKSAvIE1hdGgubG9nKGJhc2UpO1xcbn1cXG5cXG5cXG5cXG4vKioqLyB9KSxcXG4vKiAzMyAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXFwidXNlIHN0cmljdFxcXCI7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiYVxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gU3RpY2t5OyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLm4oX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19mb3VuZGF0aW9uX3V0aWxfY29yZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19mb3VuZGF0aW9uX3V0aWxfbWVkaWFRdWVyeV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19mb3VuZGF0aW9uX3BsdWdpbl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19mb3VuZGF0aW9uX3V0aWxfdHJpZ2dlcnNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XFxuXFxuXFxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcXFwidmFsdWVcXFwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XFxuXFxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTsgfSB9XFxuXFxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFxcXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcXFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFxcXCJvYmplY3RcXFwiIHx8IHR5cGVvZiBjYWxsID09PSBcXFwiZnVuY3Rpb25cXFwiKSA/IGNhbGwgOiBzZWxmOyB9XFxuXFxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXFxcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG4vKipcXG4gKiBTdGlja3kgbW9kdWxlLlxcbiAqIEBtb2R1bGUgZm91bmRhdGlvbi5zdGlja3lcXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLnRyaWdnZXJzXFxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5tZWRpYVF1ZXJ5XFxuICovXFxuXFxudmFyIFN0aWNreSA9IGZ1bmN0aW9uIChfUGx1Z2luKSB7XFxuICBfaW5oZXJpdHMoU3RpY2t5LCBfUGx1Z2luKTtcXG5cXG4gIGZ1bmN0aW9uIFN0aWNreSgpIHtcXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN0aWNreSk7XFxuXFxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoU3RpY2t5Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoU3RpY2t5KSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XFxuICB9XFxuXFxuICBfY3JlYXRlQ2xhc3MoU3RpY2t5LCBbe1xcbiAgICBrZXk6ICdfc2V0dXAnLFxcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBhIHN0aWNreSB0aGluZy5cXG4gICAgICogQGNsYXNzXFxuICAgICAqIEBuYW1lIFN0aWNreVxcbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gbWFrZSBzdGlja3kuXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gb3B0aW9ucyBvYmplY3QgcGFzc2VkIHdoZW4gY3JlYXRpbmcgdGhlIGVsZW1lbnQgcHJvZ3JhbW1hdGljYWxseS5cXG4gICAgICovXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0dXAoZWxlbWVudCwgb3B0aW9ucykge1xcbiAgICAgIHRoaXMuJGVsZW1lbnQgPSBlbGVtZW50O1xcbiAgICAgIHRoaXMub3B0aW9ucyA9IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0LmEuZXh0ZW5kKHt9LCBTdGlja3kuZGVmYXVsdHMsIHRoaXMuJGVsZW1lbnQuZGF0YSgpLCBvcHRpb25zKTtcXG4gICAgICB0aGlzLmNsYXNzTmFtZSA9ICdTdGlja3knOyAvLyBpZTkgYmFjayBjb21wYXRcXG5cXG4gICAgICAvLyBUcmlnZ2VycyBpbml0IGlzIGlkZW1wb3RlbnQsIGp1c3QgbmVlZCB0byBtYWtlIHN1cmUgaXQgaXMgaW5pdGlhbGl6ZWRcXG4gICAgICBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX2ZvdW5kYXRpb25fdXRpbF90cmlnZ2Vyc19fW1xcXCJhXFxcIiAvKiBUcmlnZ2VycyAqL10uaW5pdChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdC5hKTtcXG5cXG4gICAgICB0aGlzLl9pbml0KCk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIEluaXRpYWxpemVzIHRoZSBzdGlja3kgZWxlbWVudCBieSBhZGRpbmcgY2xhc3NlcywgZ2V0dGluZy9zZXR0aW5nIGRpbWVuc2lvbnMsIGJyZWFrcG9pbnRzIGFuZCBhdHRyaWJ1dGVzXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAnX2luaXQnLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXQoKSB7XFxuICAgICAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19mb3VuZGF0aW9uX3V0aWxfbWVkaWFRdWVyeV9fW1xcXCJhXFxcIiAvKiBNZWRpYVF1ZXJ5ICovXS5faW5pdCgpO1xcblxcbiAgICAgIHZhciAkcGFyZW50ID0gdGhpcy4kZWxlbWVudC5wYXJlbnQoJ1tkYXRhLXN0aWNreS1jb250YWluZXJdJyksXFxuICAgICAgICAgIGlkID0gdGhpcy4kZWxlbWVudFswXS5pZCB8fCBfX3dlYnBhY2tfcmVxdWlyZV9fLmkoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19mb3VuZGF0aW9uX3V0aWxfY29yZV9fW1xcXCJiXFxcIiAvKiBHZXRZb0RpZ2l0cyAqL10pKDYsICdzdGlja3knKSxcXG4gICAgICAgICAgX3RoaXMgPSB0aGlzO1xcblxcbiAgICAgIGlmICgkcGFyZW50Lmxlbmd0aCkge1xcbiAgICAgICAgdGhpcy4kY29udGFpbmVyID0gJHBhcmVudDtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdGhpcy53YXNXcmFwcGVkID0gdHJ1ZTtcXG4gICAgICAgIHRoaXMuJGVsZW1lbnQud3JhcCh0aGlzLm9wdGlvbnMuY29udGFpbmVyKTtcXG4gICAgICAgIHRoaXMuJGNvbnRhaW5lciA9IHRoaXMuJGVsZW1lbnQucGFyZW50KCk7XFxuICAgICAgfVxcbiAgICAgIHRoaXMuJGNvbnRhaW5lci5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuY29udGFpbmVyQ2xhc3MpO1xcblxcbiAgICAgIHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3ModGhpcy5vcHRpb25zLnN0aWNreUNsYXNzKS5hdHRyKHsgJ2RhdGEtcmVzaXplJzogaWQsICdkYXRhLW11dGF0ZSc6IGlkIH0pO1xcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuYW5jaG9yICE9PSAnJykge1xcbiAgICAgICAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSgnIycgKyBfdGhpcy5vcHRpb25zLmFuY2hvcikuYXR0cih7ICdkYXRhLW11dGF0ZSc6IGlkIH0pO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLnNjcm9sbENvdW50ID0gdGhpcy5vcHRpb25zLmNoZWNrRXZlcnk7XFxuICAgICAgdGhpcy5pc1N0dWNrID0gZmFsc2U7XFxuICAgICAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSh3aW5kb3cpLm9uZSgnbG9hZC56Zi5zdGlja3knLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAvL1dlIGNhbGN1bGF0ZSB0aGUgY29udGFpbmVyIGhlaWdodCB0byBoYXZlIGNvcnJlY3QgdmFsdWVzIGZvciBhbmNob3IgcG9pbnRzIG9mZnNldCBjYWxjdWxhdGlvbi5cXG4gICAgICAgIF90aGlzLmNvbnRhaW5lckhlaWdodCA9IF90aGlzLiRlbGVtZW50LmNzcyhcXFwiZGlzcGxheVxcXCIpID09IFxcXCJub25lXFxcIiA/IDAgOiBfdGhpcy4kZWxlbWVudFswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XFxuICAgICAgICBfdGhpcy4kY29udGFpbmVyLmNzcygnaGVpZ2h0JywgX3RoaXMuY29udGFpbmVySGVpZ2h0KTtcXG4gICAgICAgIF90aGlzLmVsZW1IZWlnaHQgPSBfdGhpcy5jb250YWluZXJIZWlnaHQ7XFxuICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy5hbmNob3IgIT09ICcnKSB7XFxuICAgICAgICAgIF90aGlzLiRhbmNob3IgPSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKCcjJyArIF90aGlzLm9wdGlvbnMuYW5jaG9yKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIF90aGlzLl9wYXJzZVBvaW50cygpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgX3RoaXMuX3NldFNpemVzKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgdmFyIHNjcm9sbCA9IHdpbmRvdy5wYWdlWU9mZnNldDtcXG4gICAgICAgICAgX3RoaXMuX2NhbGMoZmFsc2UsIHNjcm9sbCk7XFxuICAgICAgICAgIC8vVW5zdGljayB0aGUgZWxlbWVudCB3aWxsIGVuc3VyZSB0aGF0IHByb3BlciBjbGFzc2VzIGFyZSBzZXQuXFxuICAgICAgICAgIGlmICghX3RoaXMuaXNTdHVjaykge1xcbiAgICAgICAgICAgIF90aGlzLl9yZW1vdmVTdGlja3koc2Nyb2xsID49IF90aGlzLnRvcFBvaW50ID8gZmFsc2UgOiB0cnVlKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgICAgICBfdGhpcy5fZXZlbnRzKGlkLnNwbGl0KCctJykucmV2ZXJzZSgpLmpvaW4oJy0nKSk7XFxuICAgICAgfSk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIElmIHVzaW5nIG11bHRpcGxlIGVsZW1lbnRzIGFzIGFuY2hvcnMsIGNhbGN1bGF0ZXMgdGhlIHRvcCBhbmQgYm90dG9tIHBpeGVsIHZhbHVlcyB0aGUgc3RpY2t5IHRoaW5nIHNob3VsZCBzdGljayBhbmQgdW5zdGljayBvbi5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6ICdfcGFyc2VQb2ludHMnLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3BhcnNlUG9pbnRzKCkge1xcbiAgICAgIHZhciB0b3AgPSB0aGlzLm9wdGlvbnMudG9wQW5jaG9yID09IFxcXCJcXFwiID8gMSA6IHRoaXMub3B0aW9ucy50b3BBbmNob3IsXFxuICAgICAgICAgIGJ0bSA9IHRoaXMub3B0aW9ucy5idG1BbmNob3IgPT0gXFxcIlxcXCIgPyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0IDogdGhpcy5vcHRpb25zLmJ0bUFuY2hvcixcXG4gICAgICAgICAgcHRzID0gW3RvcCwgYnRtXSxcXG4gICAgICAgICAgYnJlYWtzID0ge307XFxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHB0cy5sZW5ndGg7IGkgPCBsZW4gJiYgcHRzW2ldOyBpKyspIHtcXG4gICAgICAgIHZhciBwdDtcXG4gICAgICAgIGlmICh0eXBlb2YgcHRzW2ldID09PSAnbnVtYmVyJykge1xcbiAgICAgICAgICBwdCA9IHB0c1tpXTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHZhciBwbGFjZSA9IHB0c1tpXS5zcGxpdCgnOicpLFxcbiAgICAgICAgICAgICAgYW5jaG9yID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSgnIycgKyBwbGFjZVswXSk7XFxuXFxuICAgICAgICAgIHB0ID0gYW5jaG9yLm9mZnNldCgpLnRvcDtcXG4gICAgICAgICAgaWYgKHBsYWNlWzFdICYmIHBsYWNlWzFdLnRvTG93ZXJDYXNlKCkgPT09ICdib3R0b20nKSB7XFxuICAgICAgICAgICAgcHQgKz0gYW5jaG9yWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgYnJlYWtzW2ldID0gcHQ7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMucG9pbnRzID0gYnJlYWtzO1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQWRkcyBldmVudCBoYW5kbGVycyBmb3IgdGhlIHNjcm9sbGluZyBlbGVtZW50LlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaWQgLSBwc2V1ZG8tcmFuZG9tIGlkIGZvciB1bmlxdWUgc2Nyb2xsIGV2ZW50IGxpc3RlbmVyLlxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAnX2V2ZW50cycsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZXZlbnRzKGlkKSB7XFxuICAgICAgdmFyIF90aGlzID0gdGhpcyxcXG4gICAgICAgICAgc2Nyb2xsTGlzdGVuZXIgPSB0aGlzLnNjcm9sbExpc3RlbmVyID0gJ3Njcm9sbC56Zi4nICsgaWQ7XFxuICAgICAgaWYgKHRoaXMuaXNPbikge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG4gICAgICBpZiAodGhpcy5jYW5TdGljaykge1xcbiAgICAgICAgdGhpcy5pc09uID0gdHJ1ZTtcXG4gICAgICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0KCkod2luZG93KS5vZmYoc2Nyb2xsTGlzdGVuZXIpLm9uKHNjcm9sbExpc3RlbmVyLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgICBpZiAoX3RoaXMuc2Nyb2xsQ291bnQgPT09IDApIHtcXG4gICAgICAgICAgICBfdGhpcy5zY3JvbGxDb3VudCA9IF90aGlzLm9wdGlvbnMuY2hlY2tFdmVyeTtcXG4gICAgICAgICAgICBfdGhpcy5fc2V0U2l6ZXMoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgX3RoaXMuX2NhbGMoZmFsc2UsIHdpbmRvdy5wYWdlWU9mZnNldCk7XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgX3RoaXMuc2Nyb2xsQ291bnQtLTtcXG4gICAgICAgICAgICBfdGhpcy5fY2FsYyhmYWxzZSwgd2luZG93LnBhZ2VZT2Zmc2V0KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKCdyZXNpemVtZS56Zi50cmlnZ2VyJykub24oJ3Jlc2l6ZW1lLnpmLnRyaWdnZXInLCBmdW5jdGlvbiAoZSwgZWwpIHtcXG4gICAgICAgIF90aGlzLl9ldmVudHNIYW5kbGVyKGlkKTtcXG4gICAgICB9KTtcXG5cXG4gICAgICB0aGlzLiRlbGVtZW50Lm9uKCdtdXRhdGVtZS56Zi50cmlnZ2VyJywgZnVuY3Rpb24gKGUsIGVsKSB7XFxuICAgICAgICBfdGhpcy5fZXZlbnRzSGFuZGxlcihpZCk7XFxuICAgICAgfSk7XFxuXFxuICAgICAgaWYgKHRoaXMuJGFuY2hvcikge1xcbiAgICAgICAgdGhpcy4kYW5jaG9yLm9uKCdtdXRhdGVtZS56Zi50cmlnZ2VyJywgZnVuY3Rpb24gKGUsIGVsKSB7XFxuICAgICAgICAgIF90aGlzLl9ldmVudHNIYW5kbGVyKGlkKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogSGFuZGxlciBmb3IgZXZlbnRzLlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaWQgLSBwc2V1ZG8tcmFuZG9tIGlkIGZvciB1bmlxdWUgc2Nyb2xsIGV2ZW50IGxpc3RlbmVyLlxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAnX2V2ZW50c0hhbmRsZXInLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2V2ZW50c0hhbmRsZXIoaWQpIHtcXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzLFxcbiAgICAgICAgICBzY3JvbGxMaXN0ZW5lciA9IHRoaXMuc2Nyb2xsTGlzdGVuZXIgPSAnc2Nyb2xsLnpmLicgKyBpZDtcXG5cXG4gICAgICBfdGhpcy5fc2V0U2l6ZXMoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgX3RoaXMuX2NhbGMoZmFsc2UpO1xcbiAgICAgICAgaWYgKF90aGlzLmNhblN0aWNrKSB7XFxuICAgICAgICAgIGlmICghX3RoaXMuaXNPbikge1xcbiAgICAgICAgICAgIF90aGlzLl9ldmVudHMoaWQpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9IGVsc2UgaWYgKF90aGlzLmlzT24pIHtcXG4gICAgICAgICAgX3RoaXMuX3BhdXNlTGlzdGVuZXJzKHNjcm9sbExpc3RlbmVyKTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogUmVtb3ZlcyBldmVudCBoYW5kbGVycyBmb3Igc2Nyb2xsIGFuZCBjaGFuZ2UgZXZlbnRzIG9uIGFuY2hvci5cXG4gICAgICogQGZpcmVzIFN0aWNreSNwYXVzZVxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2Nyb2xsTGlzdGVuZXIgLSB1bmlxdWUsIG5hbWVzcGFjZWQgc2Nyb2xsIGxpc3RlbmVyIGF0dGFjaGVkIHRvIGB3aW5kb3dgXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6ICdfcGF1c2VMaXN0ZW5lcnMnLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3BhdXNlTGlzdGVuZXJzKHNjcm9sbExpc3RlbmVyKSB7XFxuICAgICAgdGhpcy5pc09uID0gZmFsc2U7XFxuICAgICAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSh3aW5kb3cpLm9mZihzY3JvbGxMaXN0ZW5lcik7XFxuXFxuICAgICAgLyoqXFxuICAgICAgICogRmlyZXMgd2hlbiB0aGUgcGx1Z2luIGlzIHBhdXNlZCBkdWUgdG8gcmVzaXplIGV2ZW50IHNocmlua2luZyB0aGUgdmlldy5cXG4gICAgICAgKiBAZXZlbnQgU3RpY2t5I3BhdXNlXFxuICAgICAgICogQHByaXZhdGVcXG4gICAgICAgKi9cXG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ3BhdXNlLnpmLnN0aWNreScpO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDYWxsZWQgb24gZXZlcnkgYHNjcm9sbGAgZXZlbnQgYW5kIG9uIGBfaW5pdGBcXG4gICAgICogZmlyZXMgZnVuY3Rpb25zIGJhc2VkIG9uIGJvb2xlYW5zIGFuZCBjYWNoZWQgdmFsdWVzXFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gY2hlY2tTaXplcyAtIHRydWUgaWYgcGx1Z2luIHNob3VsZCByZWNhbGN1bGF0ZSBzaXplcyBhbmQgYnJlYWtwb2ludHMuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY3JvbGwgLSBjdXJyZW50IHNjcm9sbCBwb3NpdGlvbiBwYXNzZWQgZnJvbSBzY3JvbGwgZXZlbnQgY2IgZnVuY3Rpb24uIElmIG5vdCBwYXNzZWQsIGRlZmF1bHRzIHRvIGB3aW5kb3cucGFnZVlPZmZzZXRgLlxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAnX2NhbGMnLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NhbGMoY2hlY2tTaXplcywgc2Nyb2xsKSB7XFxuICAgICAgaWYgKGNoZWNrU2l6ZXMpIHtcXG4gICAgICAgIHRoaXMuX3NldFNpemVzKCk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghdGhpcy5jYW5TdGljaykge1xcbiAgICAgICAgaWYgKHRoaXMuaXNTdHVjaykge1xcbiAgICAgICAgICB0aGlzLl9yZW1vdmVTdGlja3kodHJ1ZSk7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghc2Nyb2xsKSB7XFxuICAgICAgICBzY3JvbGwgPSB3aW5kb3cucGFnZVlPZmZzZXQ7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChzY3JvbGwgPj0gdGhpcy50b3BQb2ludCkge1xcbiAgICAgICAgaWYgKHNjcm9sbCA8PSB0aGlzLmJvdHRvbVBvaW50KSB7XFxuICAgICAgICAgIGlmICghdGhpcy5pc1N0dWNrKSB7XFxuICAgICAgICAgICAgdGhpcy5fc2V0U3RpY2t5KCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIGlmICh0aGlzLmlzU3R1Y2spIHtcXG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVTdGlja3koZmFsc2UpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGlmICh0aGlzLmlzU3R1Y2spIHtcXG4gICAgICAgICAgdGhpcy5fcmVtb3ZlU3RpY2t5KHRydWUpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogQ2F1c2VzIHRoZSAkZWxlbWVudCB0byBiZWNvbWUgc3R1Y2suXFxuICAgICAqIEFkZHMgYHBvc2l0aW9uOiBmaXhlZDtgLCBhbmQgaGVscGVyIGNsYXNzZXMuXFxuICAgICAqIEBmaXJlcyBTdGlja3kjc3R1Y2t0b1xcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogJ19zZXRTdGlja3knLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldFN0aWNreSgpIHtcXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzLFxcbiAgICAgICAgICBzdGlja1RvID0gdGhpcy5vcHRpb25zLnN0aWNrVG8sXFxuICAgICAgICAgIG1yZ24gPSBzdGlja1RvID09PSAndG9wJyA/ICdtYXJnaW5Ub3AnIDogJ21hcmdpbkJvdHRvbScsXFxuICAgICAgICAgIG5vdFN0dWNrVG8gPSBzdGlja1RvID09PSAndG9wJyA/ICdib3R0b20nIDogJ3RvcCcsXFxuICAgICAgICAgIGNzcyA9IHt9O1xcblxcbiAgICAgIGNzc1ttcmduXSA9IHRoaXMub3B0aW9uc1ttcmduXSArICdlbSc7XFxuICAgICAgY3NzW3N0aWNrVG9dID0gMDtcXG4gICAgICBjc3Nbbm90U3R1Y2tUb10gPSAnYXV0byc7XFxuICAgICAgdGhpcy5pc1N0dWNrID0gdHJ1ZTtcXG4gICAgICB0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKCdpcy1hbmNob3JlZCBpcy1hdC0nICsgbm90U3R1Y2tUbykuYWRkQ2xhc3MoJ2lzLXN0dWNrIGlzLWF0LScgKyBzdGlja1RvKS5jc3MoY3NzKVxcbiAgICAgIC8qKlxcbiAgICAgICAqIEZpcmVzIHdoZW4gdGhlICRlbGVtZW50IGhhcyBiZWNvbWUgYHBvc2l0aW9uOiBmaXhlZDtgXFxuICAgICAgICogTmFtZXNwYWNlZCB0byBgdG9wYCBvciBgYm90dG9tYCwgZS5nLiBgc3RpY2t5LnpmLnN0dWNrdG86dG9wYFxcbiAgICAgICAqIEBldmVudCBTdGlja3kjc3R1Y2t0b1xcbiAgICAgICAqL1xcbiAgICAgIC50cmlnZ2VyKCdzdGlja3kuemYuc3R1Y2t0bzonICsgc3RpY2tUbyk7XFxuICAgICAgdGhpcy4kZWxlbWVudC5vbihcXFwidHJhbnNpdGlvbmVuZCB3ZWJraXRUcmFuc2l0aW9uRW5kIG9UcmFuc2l0aW9uRW5kIG90cmFuc2l0aW9uZW5kIE1TVHJhbnNpdGlvbkVuZFxcXCIsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIF90aGlzLl9zZXRTaXplcygpO1xcbiAgICAgIH0pO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDYXVzZXMgdGhlICRlbGVtZW50IHRvIGJlY29tZSB1bnN0dWNrLlxcbiAgICAgKiBSZW1vdmVzIGBwb3NpdGlvbjogZml4ZWQ7YCwgYW5kIGhlbHBlciBjbGFzc2VzLlxcbiAgICAgKiBBZGRzIG90aGVyIGhlbHBlciBjbGFzc2VzLlxcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzVG9wIC0gdGVsbHMgdGhlIGZ1bmN0aW9uIGlmIHRoZSAkZWxlbWVudCBzaG91bGQgYW5jaG9yIHRvIHRoZSB0b3Agb3IgYm90dG9tIG9mIGl0cyAkYW5jaG9yIGVsZW1lbnQuXFxuICAgICAqIEBmaXJlcyBTdGlja3kjdW5zdHVja2Zyb21cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogJ19yZW1vdmVTdGlja3knLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbW92ZVN0aWNreShpc1RvcCkge1xcbiAgICAgIHZhciBzdGlja1RvID0gdGhpcy5vcHRpb25zLnN0aWNrVG8sXFxuICAgICAgICAgIHN0aWNrVG9Ub3AgPSBzdGlja1RvID09PSAndG9wJyxcXG4gICAgICAgICAgY3NzID0ge30sXFxuICAgICAgICAgIGFuY2hvclB0ID0gKHRoaXMucG9pbnRzID8gdGhpcy5wb2ludHNbMV0gLSB0aGlzLnBvaW50c1swXSA6IHRoaXMuYW5jaG9ySGVpZ2h0KSAtIHRoaXMuZWxlbUhlaWdodCxcXG4gICAgICAgICAgbXJnbiA9IHN0aWNrVG9Ub3AgPyAnbWFyZ2luVG9wJyA6ICdtYXJnaW5Cb3R0b20nLFxcbiAgICAgICAgICBub3RTdHVja1RvID0gc3RpY2tUb1RvcCA/ICdib3R0b20nIDogJ3RvcCcsXFxuICAgICAgICAgIHRvcE9yQm90dG9tID0gaXNUb3AgPyAndG9wJyA6ICdib3R0b20nO1xcblxcbiAgICAgIGNzc1ttcmduXSA9IDA7XFxuXFxuICAgICAgY3NzWydib3R0b20nXSA9ICdhdXRvJztcXG4gICAgICBpZiAoaXNUb3ApIHtcXG4gICAgICAgIGNzc1sndG9wJ10gPSAwO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBjc3NbJ3RvcCddID0gYW5jaG9yUHQ7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuaXNTdHVjayA9IGZhbHNlO1xcbiAgICAgIHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3MoJ2lzLXN0dWNrIGlzLWF0LScgKyBzdGlja1RvKS5hZGRDbGFzcygnaXMtYW5jaG9yZWQgaXMtYXQtJyArIHRvcE9yQm90dG9tKS5jc3MoY3NzKVxcbiAgICAgIC8qKlxcbiAgICAgICAqIEZpcmVzIHdoZW4gdGhlICRlbGVtZW50IGhhcyBiZWNvbWUgYW5jaG9yZWQuXFxuICAgICAgICogTmFtZXNwYWNlZCB0byBgdG9wYCBvciBgYm90dG9tYCwgZS5nLiBgc3RpY2t5LnpmLnVuc3R1Y2tmcm9tOmJvdHRvbWBcXG4gICAgICAgKiBAZXZlbnQgU3RpY2t5I3Vuc3R1Y2tmcm9tXFxuICAgICAgICovXFxuICAgICAgLnRyaWdnZXIoJ3N0aWNreS56Zi51bnN0dWNrZnJvbTonICsgdG9wT3JCb3R0b20pO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBTZXRzIHRoZSAkZWxlbWVudCBhbmQgJGNvbnRhaW5lciBzaXplcyBmb3IgcGx1Z2luLlxcbiAgICAgKiBDYWxscyBgX3NldEJyZWFrUG9pbnRzYC5cXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgLSBvcHRpb25hbCBjYWxsYmFjayBmdW5jdGlvbiB0byBmaXJlIG9uIGNvbXBsZXRpb24gb2YgYF9zZXRCcmVha1BvaW50c2AuXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6ICdfc2V0U2l6ZXMnLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldFNpemVzKGNiKSB7XFxuICAgICAgdGhpcy5jYW5TdGljayA9IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fZm91bmRhdGlvbl91dGlsX21lZGlhUXVlcnlfX1tcXFwiYVxcXCIgLyogTWVkaWFRdWVyeSAqL10uaXModGhpcy5vcHRpb25zLnN0aWNreU9uKTtcXG4gICAgICBpZiAoIXRoaXMuY2FuU3RpY2spIHtcXG4gICAgICAgIGlmIChjYiAmJiB0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICAgICAgY2IoKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgdmFyIF90aGlzID0gdGhpcyxcXG4gICAgICAgICAgbmV3RWxlbVdpZHRoID0gdGhpcy4kY29udGFpbmVyWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoLFxcbiAgICAgICAgICBjb21wID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy4kY29udGFpbmVyWzBdKSxcXG4gICAgICAgICAgcGRuZ2wgPSBwYXJzZUludChjb21wWydwYWRkaW5nLWxlZnQnXSwgMTApLFxcbiAgICAgICAgICBwZG5nciA9IHBhcnNlSW50KGNvbXBbJ3BhZGRpbmctcmlnaHQnXSwgMTApO1xcblxcbiAgICAgIGlmICh0aGlzLiRhbmNob3IgJiYgdGhpcy4kYW5jaG9yLmxlbmd0aCkge1xcbiAgICAgICAgdGhpcy5hbmNob3JIZWlnaHQgPSB0aGlzLiRhbmNob3JbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB0aGlzLl9wYXJzZVBvaW50cygpO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLiRlbGVtZW50LmNzcyh7XFxuICAgICAgICAnbWF4LXdpZHRoJzogbmV3RWxlbVdpZHRoIC0gcGRuZ2wgLSBwZG5nciArICdweCdcXG4gICAgICB9KTtcXG5cXG4gICAgICB2YXIgbmV3Q29udGFpbmVySGVpZ2h0ID0gdGhpcy4kZWxlbWVudFswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQgfHwgdGhpcy5jb250YWluZXJIZWlnaHQ7XFxuICAgICAgaWYgKHRoaXMuJGVsZW1lbnQuY3NzKFxcXCJkaXNwbGF5XFxcIikgPT0gXFxcIm5vbmVcXFwiKSB7XFxuICAgICAgICBuZXdDb250YWluZXJIZWlnaHQgPSAwO1xcbiAgICAgIH1cXG4gICAgICB0aGlzLmNvbnRhaW5lckhlaWdodCA9IG5ld0NvbnRhaW5lckhlaWdodDtcXG4gICAgICB0aGlzLiRjb250YWluZXIuY3NzKHtcXG4gICAgICAgIGhlaWdodDogbmV3Q29udGFpbmVySGVpZ2h0XFxuICAgICAgfSk7XFxuICAgICAgdGhpcy5lbGVtSGVpZ2h0ID0gbmV3Q29udGFpbmVySGVpZ2h0O1xcblxcbiAgICAgIGlmICghdGhpcy5pc1N0dWNrKSB7XFxuICAgICAgICBpZiAodGhpcy4kZWxlbWVudC5oYXNDbGFzcygnaXMtYXQtYm90dG9tJykpIHtcXG4gICAgICAgICAgdmFyIGFuY2hvclB0ID0gKHRoaXMucG9pbnRzID8gdGhpcy5wb2ludHNbMV0gLSB0aGlzLiRjb250YWluZXIub2Zmc2V0KCkudG9wIDogdGhpcy5hbmNob3JIZWlnaHQpIC0gdGhpcy5lbGVtSGVpZ2h0O1xcbiAgICAgICAgICB0aGlzLiRlbGVtZW50LmNzcygndG9wJywgYW5jaG9yUHQpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9zZXRCcmVha1BvaW50cyhuZXdDb250YWluZXJIZWlnaHQsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGlmIChjYiAmJiB0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICAgICAgY2IoKTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogU2V0cyB0aGUgdXBwZXIgYW5kIGxvd2VyIGJyZWFrcG9pbnRzIGZvciB0aGUgZWxlbWVudCB0byBiZWNvbWUgc3RpY2t5L3Vuc3RpY2t5LlxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZWxlbUhlaWdodCAtIHB4IHZhbHVlIGZvciBzdGlja3kuJGVsZW1lbnQgaGVpZ2h0LCBjYWxjdWxhdGVkIGJ5IGBfc2V0U2l6ZXNgLlxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiAtIG9wdGlvbmFsIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbiBjb21wbGV0aW9uLlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAnX3NldEJyZWFrUG9pbnRzJyxcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRCcmVha1BvaW50cyhlbGVtSGVpZ2h0LCBjYikge1xcbiAgICAgIGlmICghdGhpcy5jYW5TdGljaykge1xcbiAgICAgICAgaWYgKGNiICYmIHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgICAgICBjYigpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICB2YXIgbVRvcCA9IGVtQ2FsYyh0aGlzLm9wdGlvbnMubWFyZ2luVG9wKSxcXG4gICAgICAgICAgbUJ0bSA9IGVtQ2FsYyh0aGlzLm9wdGlvbnMubWFyZ2luQm90dG9tKSxcXG4gICAgICAgICAgdG9wUG9pbnQgPSB0aGlzLnBvaW50cyA/IHRoaXMucG9pbnRzWzBdIDogdGhpcy4kYW5jaG9yLm9mZnNldCgpLnRvcCxcXG4gICAgICAgICAgYm90dG9tUG9pbnQgPSB0aGlzLnBvaW50cyA/IHRoaXMucG9pbnRzWzFdIDogdG9wUG9pbnQgKyB0aGlzLmFuY2hvckhlaWdodCxcXG5cXG4gICAgICAvLyB0b3BQb2ludCA9IHRoaXMuJGFuY2hvci5vZmZzZXQoKS50b3AgfHwgdGhpcy5wb2ludHNbMF0sXFxuICAgICAgLy8gYm90dG9tUG9pbnQgPSB0b3BQb2ludCArIHRoaXMuYW5jaG9ySGVpZ2h0IHx8IHRoaXMucG9pbnRzWzFdLFxcbiAgICAgIHdpbkhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnN0aWNrVG8gPT09ICd0b3AnKSB7XFxuICAgICAgICB0b3BQb2ludCAtPSBtVG9wO1xcbiAgICAgICAgYm90dG9tUG9pbnQgLT0gZWxlbUhlaWdodCArIG1Ub3A7XFxuICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuc3RpY2tUbyA9PT0gJ2JvdHRvbScpIHtcXG4gICAgICAgIHRvcFBvaW50IC09IHdpbkhlaWdodCAtIChlbGVtSGVpZ2h0ICsgbUJ0bSk7XFxuICAgICAgICBib3R0b21Qb2ludCAtPSB3aW5IZWlnaHQgLSBtQnRtO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICAvL3RoaXMgd291bGQgYmUgdGhlIHN0aWNrVG86IGJvdGggb3B0aW9uLi4uIHRyaWNreVxcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLnRvcFBvaW50ID0gdG9wUG9pbnQ7XFxuICAgICAgdGhpcy5ib3R0b21Qb2ludCA9IGJvdHRvbVBvaW50O1xcblxcbiAgICAgIGlmIChjYiAmJiB0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICAgIGNiKCk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBEZXN0cm95cyB0aGUgY3VycmVudCBzdGlja3kgZWxlbWVudC5cXG4gICAgICogUmVzZXRzIHRoZSBlbGVtZW50IHRvIHRoZSB0b3AgcG9zaXRpb24gZmlyc3QuXFxuICAgICAqIFJlbW92ZXMgZXZlbnQgbGlzdGVuZXJzLCBKUy1hZGRlZCBjc3MgcHJvcGVydGllcyBhbmQgY2xhc3NlcywgYW5kIHVud3JhcHMgdGhlICRlbGVtZW50IGlmIHRoZSBKUyBhZGRlZCB0aGUgJGNvbnRhaW5lci5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6ICdfZGVzdHJveScsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVzdHJveSgpIHtcXG4gICAgICB0aGlzLl9yZW1vdmVTdGlja3kodHJ1ZSk7XFxuXFxuICAgICAgdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuc3RpY2t5Q2xhc3MgKyAnIGlzLWFuY2hvcmVkIGlzLWF0LXRvcCcpLmNzcyh7XFxuICAgICAgICBoZWlnaHQ6ICcnLFxcbiAgICAgICAgdG9wOiAnJyxcXG4gICAgICAgIGJvdHRvbTogJycsXFxuICAgICAgICAnbWF4LXdpZHRoJzogJydcXG4gICAgICB9KS5vZmYoJ3Jlc2l6ZW1lLnpmLnRyaWdnZXInKS5vZmYoJ211dGF0ZW1lLnpmLnRyaWdnZXInKTtcXG4gICAgICBpZiAodGhpcy4kYW5jaG9yICYmIHRoaXMuJGFuY2hvci5sZW5ndGgpIHtcXG4gICAgICAgIHRoaXMuJGFuY2hvci5vZmYoJ2NoYW5nZS56Zi5zdGlja3knKTtcXG4gICAgICB9XFxuICAgICAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSh3aW5kb3cpLm9mZih0aGlzLnNjcm9sbExpc3RlbmVyKTtcXG5cXG4gICAgICBpZiAodGhpcy53YXNXcmFwcGVkKSB7XFxuICAgICAgICB0aGlzLiRlbGVtZW50LnVud3JhcCgpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB0aGlzLiRjb250YWluZXIucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmNvbnRhaW5lckNsYXNzKS5jc3Moe1xcbiAgICAgICAgICBoZWlnaHQ6ICcnXFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1dKTtcXG5cXG4gIHJldHVybiBTdGlja3k7XFxufShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX2ZvdW5kYXRpb25fcGx1Z2luX19bXFxcImFcXFwiIC8qIFBsdWdpbiAqL10pO1xcblxcblN0aWNreS5kZWZhdWx0cyA9IHtcXG4gIC8qKlxcbiAgICogQ3VzdG9taXphYmxlIGNvbnRhaW5lciB0ZW1wbGF0ZS4gQWRkIHlvdXIgb3duIGNsYXNzZXMgZm9yIHN0eWxpbmcgYW5kIHNpemluZy5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtzdHJpbmd9XFxuICAgKiBAZGVmYXVsdCAnJmx0O2RpdiBkYXRhLXN0aWNreS1jb250YWluZXImZ3Q7Jmx0Oy9kaXYmZ3Q7J1xcbiAgICovXFxuICBjb250YWluZXI6ICc8ZGl2IGRhdGEtc3RpY2t5LWNvbnRhaW5lcj48L2Rpdj4nLFxcbiAgLyoqXFxuICAgKiBMb2NhdGlvbiBpbiB0aGUgdmlldyB0aGUgZWxlbWVudCBzdGlja3MgdG8uIENhbiBiZSBgJ3RvcCdgIG9yIGAnYm90dG9tJ2AuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7c3RyaW5nfVxcbiAgICogQGRlZmF1bHQgJ3RvcCdcXG4gICAqL1xcbiAgc3RpY2tUbzogJ3RvcCcsXFxuICAvKipcXG4gICAqIElmIGFuY2hvcmVkIHRvIGEgc2luZ2xlIGVsZW1lbnQsIHRoZSBpZCBvZiB0aGF0IGVsZW1lbnQuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7c3RyaW5nfVxcbiAgICogQGRlZmF1bHQgJydcXG4gICAqL1xcbiAgYW5jaG9yOiAnJyxcXG4gIC8qKlxcbiAgICogSWYgdXNpbmcgbW9yZSB0aGFuIG9uZSBlbGVtZW50IGFzIGFuY2hvciBwb2ludHMsIHRoZSBpZCBvZiB0aGUgdG9wIGFuY2hvci5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtzdHJpbmd9XFxuICAgKiBAZGVmYXVsdCAnJ1xcbiAgICovXFxuICB0b3BBbmNob3I6ICcnLFxcbiAgLyoqXFxuICAgKiBJZiB1c2luZyBtb3JlIHRoYW4gb25lIGVsZW1lbnQgYXMgYW5jaG9yIHBvaW50cywgdGhlIGlkIG9mIHRoZSBib3R0b20gYW5jaG9yLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge3N0cmluZ31cXG4gICAqIEBkZWZhdWx0ICcnXFxuICAgKi9cXG4gIGJ0bUFuY2hvcjogJycsXFxuICAvKipcXG4gICAqIE1hcmdpbiwgaW4gYGVtYCdzIHRvIGFwcGx5IHRvIHRoZSB0b3Agb2YgdGhlIGVsZW1lbnQgd2hlbiBpdCBiZWNvbWVzIHN0aWNreS5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtudW1iZXJ9XFxuICAgKiBAZGVmYXVsdCAxXFxuICAgKi9cXG4gIG1hcmdpblRvcDogMSxcXG4gIC8qKlxcbiAgICogTWFyZ2luLCBpbiBgZW1gJ3MgdG8gYXBwbHkgdG8gdGhlIGJvdHRvbSBvZiB0aGUgZWxlbWVudCB3aGVuIGl0IGJlY29tZXMgc3RpY2t5LlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge251bWJlcn1cXG4gICAqIEBkZWZhdWx0IDFcXG4gICAqL1xcbiAgbWFyZ2luQm90dG9tOiAxLFxcbiAgLyoqXFxuICAgKiBCcmVha3BvaW50IHN0cmluZyB0aGF0IGlzIHRoZSBtaW5pbXVtIHNjcmVlbiBzaXplIGFuIGVsZW1lbnQgc2hvdWxkIGJlY29tZSBzdGlja3kuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7c3RyaW5nfVxcbiAgICogQGRlZmF1bHQgJ21lZGl1bSdcXG4gICAqL1xcbiAgc3RpY2t5T246ICdtZWRpdW0nLFxcbiAgLyoqXFxuICAgKiBDbGFzcyBhcHBsaWVkIHRvIHN0aWNreSBlbGVtZW50LCBhbmQgcmVtb3ZlZCBvbiBkZXN0cnVjdGlvbi4gRm91bmRhdGlvbiBkZWZhdWx0cyB0byBgc3RpY2t5YC5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtzdHJpbmd9XFxuICAgKiBAZGVmYXVsdCAnc3RpY2t5J1xcbiAgICovXFxuICBzdGlja3lDbGFzczogJ3N0aWNreScsXFxuICAvKipcXG4gICAqIENsYXNzIGFwcGxpZWQgdG8gc3RpY2t5IGNvbnRhaW5lci4gRm91bmRhdGlvbiBkZWZhdWx0cyB0byBgc3RpY2t5LWNvbnRhaW5lcmAuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7c3RyaW5nfVxcbiAgICogQGRlZmF1bHQgJ3N0aWNreS1jb250YWluZXInXFxuICAgKi9cXG4gIGNvbnRhaW5lckNsYXNzOiAnc3RpY2t5LWNvbnRhaW5lcicsXFxuICAvKipcXG4gICAqIE51bWJlciBvZiBzY3JvbGwgZXZlbnRzIGJldHdlZW4gdGhlIHBsdWdpbidzIHJlY2FsY3VsYXRpbmcgc3RpY2t5IHBvaW50cy4gU2V0dGluZyBpdCB0byBgMGAgd2lsbCBjYXVzZSBpdCB0byByZWNhbGMgZXZlcnkgc2Nyb2xsIGV2ZW50LCBzZXR0aW5nIGl0IHRvIGAtMWAgd2lsbCBwcmV2ZW50IHJlY2FsYyBvbiBzY3JvbGwuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7bnVtYmVyfVxcbiAgICogQGRlZmF1bHQgLTFcXG4gICAqL1xcbiAgY2hlY2tFdmVyeTogLTFcXG59O1xcblxcbi8qKlxcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBjYWxjdWxhdGUgZW0gdmFsdWVzXFxuICogQHBhcmFtIE51bWJlciB7ZW19IC0gbnVtYmVyIG9mIGVtJ3MgdG8gY2FsY3VsYXRlIGludG8gcGl4ZWxzXFxuICovXFxuZnVuY3Rpb24gZW1DYWxjKGVtKSB7XFxuICByZXR1cm4gcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuYm9keSwgbnVsbCkuZm9udFNpemUsIDEwKSAqIGVtO1xcbn1cXG5cXG5cXG5cXG4vKioqLyB9KSxcXG4vKiAzNCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXFwidXNlIHN0cmljdFxcXCI7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiYVxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gVG9nZ2xlcjsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0ID0gX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfXyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fZm91bmRhdGlvbl91dGlsX21vdGlvbl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19mb3VuZGF0aW9uX3BsdWdpbl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19mb3VuZGF0aW9uX3V0aWxfdHJpZ2dlcnNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XFxuXFxuXFxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcXFwidmFsdWVcXFwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XFxuXFxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTsgfSB9XFxuXFxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFxcXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcXFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFxcXCJvYmplY3RcXFwiIHx8IHR5cGVvZiBjYWxsID09PSBcXFwiZnVuY3Rpb25cXFwiKSA/IGNhbGwgOiBzZWxmOyB9XFxuXFxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXFxcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cXG5cXG5cXG5cXG5cXG5cXG5cXG4vKipcXG4gKiBUb2dnbGVyIG1vZHVsZS5cXG4gKiBAbW9kdWxlIGZvdW5kYXRpb24udG9nZ2xlclxcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwubW90aW9uXFxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC50cmlnZ2Vyc1xcbiAqL1xcblxcbnZhciBUb2dnbGVyID0gZnVuY3Rpb24gKF9QbHVnaW4pIHtcXG4gIF9pbmhlcml0cyhUb2dnbGVyLCBfUGx1Z2luKTtcXG5cXG4gIGZ1bmN0aW9uIFRvZ2dsZXIoKSB7XFxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUb2dnbGVyKTtcXG5cXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChUb2dnbGVyLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVG9nZ2xlcikpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xcbiAgfVxcblxcbiAgX2NyZWF0ZUNsYXNzKFRvZ2dsZXIsIFt7XFxuICAgIGtleTogJ19zZXR1cCcsXFxuXFxuICAgIC8qKlxcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIFRvZ2dsZXIuXFxuICAgICAqIEBjbGFzc1xcbiAgICAgKiBAbmFtZSBUb2dnbGVyXFxuICAgICAqIEBmaXJlcyBUb2dnbGVyI2luaXRcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIGFkZCB0aGUgdHJpZ2dlciB0by5cXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZXMgdG8gdGhlIGRlZmF1bHQgcGx1Z2luIHNldHRpbmdzLlxcbiAgICAgKi9cXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cChlbGVtZW50LCBvcHRpb25zKSB7XFxuICAgICAgdGhpcy4kZWxlbWVudCA9IGVsZW1lbnQ7XFxuICAgICAgdGhpcy5vcHRpb25zID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQuYS5leHRlbmQoe30sIFRvZ2dsZXIuZGVmYXVsdHMsIGVsZW1lbnQuZGF0YSgpLCBvcHRpb25zKTtcXG4gICAgICB0aGlzLmNsYXNzTmFtZSA9ICcnO1xcbiAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ1RvZ2dsZXInOyAvLyBpZTkgYmFjayBjb21wYXRcXG5cXG4gICAgICAvLyBUcmlnZ2VycyBpbml0IGlzIGlkZW1wb3RlbnQsIGp1c3QgbmVlZCB0byBtYWtlIHN1cmUgaXQgaXMgaW5pdGlhbGl6ZWRcXG4gICAgICBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX2ZvdW5kYXRpb25fdXRpbF90cmlnZ2Vyc19fW1xcXCJhXFxcIiAvKiBUcmlnZ2VycyAqL10uaW5pdChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdC5hKTtcXG5cXG4gICAgICB0aGlzLl9pbml0KCk7XFxuICAgICAgdGhpcy5fZXZlbnRzKCk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIEluaXRpYWxpemVzIHRoZSBUb2dnbGVyIHBsdWdpbiBieSBwYXJzaW5nIHRoZSB0b2dnbGUgY2xhc3MgZnJvbSBkYXRhLXRvZ2dsZXIsIG9yIGFuaW1hdGlvbiBjbGFzc2VzIGZyb20gZGF0YS1hbmltYXRlLlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogJ19pbml0JyxcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0KCkge1xcbiAgICAgIHZhciBpbnB1dDtcXG4gICAgICAvLyBQYXJzZSBhbmltYXRpb24gY2xhc3NlcyBpZiB0aGV5IHdlcmUgc2V0XFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5hbmltYXRlKSB7XFxuICAgICAgICBpbnB1dCA9IHRoaXMub3B0aW9ucy5hbmltYXRlLnNwbGl0KCcgJyk7XFxuXFxuICAgICAgICB0aGlzLmFuaW1hdGlvbkluID0gaW5wdXRbMF07XFxuICAgICAgICB0aGlzLmFuaW1hdGlvbk91dCA9IGlucHV0WzFdIHx8IG51bGw7XFxuICAgICAgfVxcbiAgICAgIC8vIE90aGVyd2lzZSwgcGFyc2UgdG9nZ2xlIGNsYXNzXFxuICAgICAgZWxzZSB7XFxuICAgICAgICAgIGlucHV0ID0gdGhpcy4kZWxlbWVudC5kYXRhKCd0b2dnbGVyJyk7XFxuICAgICAgICAgIC8vIEFsbG93IGZvciBhIC4gYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgc3RyaW5nXFxuICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gaW5wdXRbMF0gPT09ICcuJyA/IGlucHV0LnNsaWNlKDEpIDogaW5wdXQ7XFxuICAgICAgICB9XFxuXFxuICAgICAgLy8gQWRkIEFSSUEgYXR0cmlidXRlcyB0byB0cmlnZ2Vyc1xcbiAgICAgIHZhciBpZCA9IHRoaXMuJGVsZW1lbnRbMF0uaWQ7XFxuICAgICAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQoKSgnW2RhdGEtb3Blbj1cXFwiJyArIGlkICsgJ1xcXCJdLCBbZGF0YS1jbG9zZT1cXFwiJyArIGlkICsgJ1xcXCJdLCBbZGF0YS10b2dnbGU9XFxcIicgKyBpZCArICdcXFwiXScpLmF0dHIoJ2FyaWEtY29udHJvbHMnLCBpZCk7XFxuICAgICAgLy8gSWYgdGhlIHRhcmdldCBpcyBoaWRkZW4sIGFkZCBhcmlhLWhpZGRlblxcbiAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cignYXJpYS1leHBhbmRlZCcsIHRoaXMuJGVsZW1lbnQuaXMoJzpoaWRkZW4nKSA/IGZhbHNlIDogdHJ1ZSk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIEluaXRpYWxpemVzIGV2ZW50cyBmb3IgdGhlIHRvZ2dsZSB0cmlnZ2VyLlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogJ19ldmVudHMnLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2V2ZW50cygpIHtcXG4gICAgICB0aGlzLiRlbGVtZW50Lm9mZigndG9nZ2xlLnpmLnRyaWdnZXInKS5vbigndG9nZ2xlLnpmLnRyaWdnZXInLCB0aGlzLnRvZ2dsZS5iaW5kKHRoaXMpKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogVG9nZ2xlcyB0aGUgdGFyZ2V0IGNsYXNzIG9uIHRoZSB0YXJnZXQgZWxlbWVudC4gQW4gZXZlbnQgaXMgZmlyZWQgZnJvbSB0aGUgb3JpZ2luYWwgdHJpZ2dlciBkZXBlbmRpbmcgb24gaWYgdGhlIHJlc3VsdGFudCBzdGF0ZSB3YXMgXFxcIm9uXFxcIiBvciBcXFwib2ZmXFxcIi5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBmaXJlcyBUb2dnbGVyI29uXFxuICAgICAqIEBmaXJlcyBUb2dnbGVyI29mZlxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAndG9nZ2xlJyxcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvZ2dsZSgpIHtcXG4gICAgICB0aGlzW3RoaXMub3B0aW9ucy5hbmltYXRlID8gJ190b2dnbGVBbmltYXRlJyA6ICdfdG9nZ2xlQ2xhc3MnXSgpO1xcbiAgICB9XFxuICB9LCB7XFxuICAgIGtleTogJ190b2dnbGVDbGFzcycsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdG9nZ2xlQ2xhc3MoKSB7XFxuICAgICAgdGhpcy4kZWxlbWVudC50b2dnbGVDbGFzcyh0aGlzLmNsYXNzTmFtZSk7XFxuXFxuICAgICAgdmFyIGlzT24gPSB0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKHRoaXMuY2xhc3NOYW1lKTtcXG4gICAgICBpZiAoaXNPbikge1xcbiAgICAgICAgLyoqXFxuICAgICAgICAgKiBGaXJlcyBpZiB0aGUgdGFyZ2V0IGVsZW1lbnQgaGFzIHRoZSBjbGFzcyBhZnRlciBhIHRvZ2dsZS5cXG4gICAgICAgICAqIEBldmVudCBUb2dnbGVyI29uXFxuICAgICAgICAgKi9cXG4gICAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignb24uemYudG9nZ2xlcicpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICAvKipcXG4gICAgICAgICAqIEZpcmVzIGlmIHRoZSB0YXJnZXQgZWxlbWVudCBkb2VzIG5vdCBoYXZlIHRoZSBjbGFzcyBhZnRlciBhIHRvZ2dsZS5cXG4gICAgICAgICAqIEBldmVudCBUb2dnbGVyI29mZlxcbiAgICAgICAgICovXFxuICAgICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ29mZi56Zi50b2dnbGVyJyk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX3VwZGF0ZUFSSUEoaXNPbik7XFxuICAgICAgdGhpcy4kZWxlbWVudC5maW5kKCdbZGF0YS1tdXRhdGVdJykudHJpZ2dlcignbXV0YXRlbWUuemYudHJpZ2dlcicpO1xcbiAgICB9XFxuICB9LCB7XFxuICAgIGtleTogJ190b2dnbGVBbmltYXRlJyxcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF90b2dnbGVBbmltYXRlKCkge1xcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuXFxuICAgICAgaWYgKHRoaXMuJGVsZW1lbnQuaXMoJzpoaWRkZW4nKSkge1xcbiAgICAgICAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19mb3VuZGF0aW9uX3V0aWxfbW90aW9uX19bXFxcImFcXFwiIC8qIE1vdGlvbiAqL10uYW5pbWF0ZUluKHRoaXMuJGVsZW1lbnQsIHRoaXMuYW5pbWF0aW9uSW4sIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgX3RoaXMuX3VwZGF0ZUFSSUEodHJ1ZSk7XFxuICAgICAgICAgIHRoaXMudHJpZ2dlcignb24uemYudG9nZ2xlcicpO1xcbiAgICAgICAgICB0aGlzLmZpbmQoJ1tkYXRhLW11dGF0ZV0nKS50cmlnZ2VyKCdtdXRhdGVtZS56Zi50cmlnZ2VyJyk7XFxuICAgICAgICB9KTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19mb3VuZGF0aW9uX3V0aWxfbW90aW9uX19bXFxcImFcXFwiIC8qIE1vdGlvbiAqL10uYW5pbWF0ZU91dCh0aGlzLiRlbGVtZW50LCB0aGlzLmFuaW1hdGlvbk91dCwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICBfdGhpcy5fdXBkYXRlQVJJQShmYWxzZSk7XFxuICAgICAgICAgIHRoaXMudHJpZ2dlcignb2ZmLnpmLnRvZ2dsZXInKTtcXG4gICAgICAgICAgdGhpcy5maW5kKCdbZGF0YS1tdXRhdGVdJykudHJpZ2dlcignbXV0YXRlbWUuemYudHJpZ2dlcicpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9LCB7XFxuICAgIGtleTogJ191cGRhdGVBUklBJyxcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVBUklBKGlzT24pIHtcXG4gICAgICB0aGlzLiRlbGVtZW50LmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCBpc09uID8gdHJ1ZSA6IGZhbHNlKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogRGVzdHJveXMgdGhlIGluc3RhbmNlIG9mIFRvZ2dsZXIgb24gdGhlIGVsZW1lbnQuXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAnX2Rlc3Ryb3knLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Rlc3Ryb3koKSB7XFxuICAgICAgdGhpcy4kZWxlbWVudC5vZmYoJy56Zi50b2dnbGVyJyk7XFxuICAgIH1cXG4gIH1dKTtcXG5cXG4gIHJldHVybiBUb2dnbGVyO1xcbn0oX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19mb3VuZGF0aW9uX3BsdWdpbl9fW1xcXCJhXFxcIiAvKiBQbHVnaW4gKi9dKTtcXG5cXG5Ub2dnbGVyLmRlZmF1bHRzID0ge1xcbiAgLyoqXFxuICAgKiBUZWxscyB0aGUgcGx1Z2luIGlmIHRoZSBlbGVtZW50IHNob3VsZCBhbmltYXRlZCB3aGVuIHRvZ2dsZWQuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IGZhbHNlXFxuICAgKi9cXG4gIGFuaW1hdGU6IGZhbHNlXFxufTtcXG5cXG5cXG5cXG4vKioqLyB9KSxcXG4vKiAzNSAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXFwidXNlIHN0cmljdFxcXCI7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiYVxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gVG9vbHRpcDsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0ID0gX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfXyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fZm91bmRhdGlvbl91dGlsX2NvcmVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fZm91bmRhdGlvbl91dGlsX21lZGlhUXVlcnlfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fZm91bmRhdGlvbl91dGlsX3RyaWdnZXJzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX2ZvdW5kYXRpb25fcG9zaXRpb25hYmxlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcXG5cXG5cXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFxcXCJ2YWx1ZVxcXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcXG5cXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7IH0gfSBlbHNlIGlmIChcXFwidmFsdWVcXFwiIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9O1xcblxcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7IH0gfVxcblxcbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcXFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXFxcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcXFwib2JqZWN0XFxcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXFxcImZ1bmN0aW9uXFxcIikgPyBjYWxsIDogc2VsZjsgfVxcblxcbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFxcXCJmdW5jdGlvblxcXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFxcXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuLyoqXFxuICogVG9vbHRpcCBtb2R1bGUuXFxuICogQG1vZHVsZSBmb3VuZGF0aW9uLnRvb2x0aXBcXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLmJveFxcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwubWVkaWFRdWVyeVxcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwudHJpZ2dlcnNcXG4gKi9cXG5cXG52YXIgVG9vbHRpcCA9IGZ1bmN0aW9uIChfUG9zaXRpb25hYmxlKSB7XFxuICBfaW5oZXJpdHMoVG9vbHRpcCwgX1Bvc2l0aW9uYWJsZSk7XFxuXFxuICBmdW5jdGlvbiBUb29sdGlwKCkge1xcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVG9vbHRpcCk7XFxuXFxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoVG9vbHRpcC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFRvb2x0aXApKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcXG4gIH1cXG5cXG4gIF9jcmVhdGVDbGFzcyhUb29sdGlwLCBbe1xcbiAgICBrZXk6ICdfc2V0dXAnLFxcblxcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBhIFRvb2x0aXAuXFxuICAgICAqIEBjbGFzc1xcbiAgICAgKiBAbmFtZSBUb29sdGlwXFxuICAgICAqIEBmaXJlcyBUb29sdGlwI2luaXRcXG4gICAgICogQHBhcmFtIHtqUXVlcnl9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIGF0dGFjaCBhIHRvb2x0aXAgdG8uXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gb2JqZWN0IHRvIGV4dGVuZCB0aGUgZGVmYXVsdCBjb25maWd1cmF0aW9uLlxcbiAgICAgKi9cXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cChlbGVtZW50LCBvcHRpb25zKSB7XFxuICAgICAgdGhpcy4kZWxlbWVudCA9IGVsZW1lbnQ7XFxuICAgICAgdGhpcy5vcHRpb25zID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2pxdWVyeV9fX2RlZmF1bHQuYS5leHRlbmQoe30sIFRvb2x0aXAuZGVmYXVsdHMsIHRoaXMuJGVsZW1lbnQuZGF0YSgpLCBvcHRpb25zKTtcXG4gICAgICB0aGlzLmNsYXNzTmFtZSA9ICdUb29sdGlwJzsgLy8gaWU5IGJhY2sgY29tcGF0XFxuXFxuICAgICAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xcbiAgICAgIHRoaXMuaXNDbGljayA9IGZhbHNlO1xcblxcbiAgICAgIC8vIFRyaWdnZXJzIGluaXQgaXMgaWRlbXBvdGVudCwganVzdCBuZWVkIHRvIG1ha2Ugc3VyZSBpdCBpcyBpbml0aWFsaXplZFxcbiAgICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fZm91bmRhdGlvbl91dGlsX3RyaWdnZXJzX19bXFxcImFcXFwiIC8qIFRyaWdnZXJzICovXS5pbml0KF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0LmEpO1xcblxcbiAgICAgIHRoaXMuX2luaXQoKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIHRvb2x0aXAgYnkgc2V0dGluZyB0aGUgY3JlYXRpbmcgdGhlIHRpcCBlbGVtZW50LCBhZGRpbmcgaXQncyB0ZXh0LCBzZXR0aW5nIHByaXZhdGUgdmFyaWFibGVzIGFuZCBzZXR0aW5nIGF0dHJpYnV0ZXMgb24gdGhlIGFuY2hvci5cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogJ19pbml0JyxcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0KCkge1xcbiAgICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fZm91bmRhdGlvbl91dGlsX21lZGlhUXVlcnlfX1tcXFwiYVxcXCIgLyogTWVkaWFRdWVyeSAqL10uX2luaXQoKTtcXG4gICAgICB2YXIgZWxlbUlkID0gdGhpcy4kZWxlbWVudC5hdHRyKCdhcmlhLWRlc2NyaWJlZGJ5JykgfHwgX193ZWJwYWNrX3JlcXVpcmVfXy5pKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fZm91bmRhdGlvbl91dGlsX2NvcmVfX1tcXFwiYlxcXCIgLyogR2V0WW9EaWdpdHMgKi9dKSg2LCAndG9vbHRpcCcpO1xcblxcbiAgICAgIHRoaXMub3B0aW9ucy50aXBUZXh0ID0gdGhpcy5vcHRpb25zLnRpcFRleHQgfHwgdGhpcy4kZWxlbWVudC5hdHRyKCd0aXRsZScpO1xcbiAgICAgIHRoaXMudGVtcGxhdGUgPSB0aGlzLm9wdGlvbnMudGVtcGxhdGUgPyBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfanF1ZXJ5X19fZGVmYXVsdCgpKHRoaXMub3B0aW9ucy50ZW1wbGF0ZSkgOiB0aGlzLl9idWlsZFRlbXBsYXRlKGVsZW1JZCk7XFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5hbGxvd0h0bWwpIHtcXG4gICAgICAgIHRoaXMudGVtcGxhdGUuYXBwZW5kVG8oZG9jdW1lbnQuYm9keSkuaHRtbCh0aGlzLm9wdGlvbnMudGlwVGV4dCkuaGlkZSgpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB0aGlzLnRlbXBsYXRlLmFwcGVuZFRvKGRvY3VtZW50LmJvZHkpLnRleHQodGhpcy5vcHRpb25zLnRpcFRleHQpLmhpZGUoKTtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy4kZWxlbWVudC5hdHRyKHtcXG4gICAgICAgICd0aXRsZSc6ICcnLFxcbiAgICAgICAgJ2FyaWEtZGVzY3JpYmVkYnknOiBlbGVtSWQsXFxuICAgICAgICAnZGF0YS15ZXRpLWJveCc6IGVsZW1JZCxcXG4gICAgICAgICdkYXRhLXRvZ2dsZSc6IGVsZW1JZCxcXG4gICAgICAgICdkYXRhLXJlc2l6ZSc6IGVsZW1JZFxcbiAgICAgIH0pLmFkZENsYXNzKHRoaXMub3B0aW9ucy50cmlnZ2VyQ2xhc3MpO1xcblxcbiAgICAgIF9nZXQoVG9vbHRpcC5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihUb29sdGlwLnByb3RvdHlwZSksICdfaW5pdCcsIHRoaXMpLmNhbGwodGhpcyk7XFxuICAgICAgdGhpcy5fZXZlbnRzKCk7XFxuICAgIH1cXG4gIH0sIHtcXG4gICAga2V5OiAnX2dldERlZmF1bHRQb3NpdGlvbicsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0RGVmYXVsdFBvc2l0aW9uKCkge1xcbiAgICAgIC8vIGhhbmRsZSBsZWdhY3kgY2xhc3NuYW1lc1xcbiAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuJGVsZW1lbnRbMF0uY2xhc3NOYW1lLm1hdGNoKC9cXFxcYih0b3B8bGVmdHxyaWdodHxib3R0b20pXFxcXGIvZyk7XFxuICAgICAgcmV0dXJuIHBvc2l0aW9uID8gcG9zaXRpb25bMF0gOiAndG9wJztcXG4gICAgfVxcbiAgfSwge1xcbiAgICBrZXk6ICdfZ2V0RGVmYXVsdEFsaWdubWVudCcsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0RGVmYXVsdEFsaWdubWVudCgpIHtcXG4gICAgICByZXR1cm4gJ2NlbnRlcic7XFxuICAgIH1cXG4gIH0sIHtcXG4gICAga2V5OiAnX2dldEhPZmZzZXQnLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEhPZmZzZXQoKSB7XFxuICAgICAgaWYgKHRoaXMucG9zaXRpb24gPT09ICdsZWZ0JyB8fCB0aGlzLnBvc2l0aW9uID09PSAncmlnaHQnKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmhPZmZzZXQgKyB0aGlzLm9wdGlvbnMudG9vbHRpcFdpZHRoO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmhPZmZzZXQ7XFxuICAgICAgfVxcbiAgICB9XFxuICB9LCB7XFxuICAgIGtleTogJ19nZXRWT2Zmc2V0JyxcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRWT2Zmc2V0KCkge1xcbiAgICAgIGlmICh0aGlzLnBvc2l0aW9uID09PSAndG9wJyB8fCB0aGlzLnBvc2l0aW9uID09PSAnYm90dG9tJykge1xcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy52T2Zmc2V0ICsgdGhpcy5vcHRpb25zLnRvb2x0aXBIZWlnaHQ7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMudk9mZnNldDtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIGJ1aWxkcyB0aGUgdG9vbHRpcCBlbGVtZW50LCBhZGRzIGF0dHJpYnV0ZXMsIGFuZCByZXR1cm5zIHRoZSB0ZW1wbGF0ZS5cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogJ19idWlsZFRlbXBsYXRlJyxcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9idWlsZFRlbXBsYXRlKGlkKSB7XFxuICAgICAgdmFyIHRlbXBsYXRlQ2xhc3NlcyA9ICh0aGlzLm9wdGlvbnMudG9vbHRpcENsYXNzICsgJyAnICsgdGhpcy5vcHRpb25zLnBvc2l0aW9uQ2xhc3MgKyAnICcgKyB0aGlzLm9wdGlvbnMudGVtcGxhdGVDbGFzc2VzKS50cmltKCk7XFxuICAgICAgdmFyICR0ZW1wbGF0ZSA9IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9qcXVlcnlfX19kZWZhdWx0KCkoJzxkaXY+PC9kaXY+JykuYWRkQ2xhc3ModGVtcGxhdGVDbGFzc2VzKS5hdHRyKHtcXG4gICAgICAgICdyb2xlJzogJ3Rvb2x0aXAnLFxcbiAgICAgICAgJ2FyaWEtaGlkZGVuJzogdHJ1ZSxcXG4gICAgICAgICdkYXRhLWlzLWFjdGl2ZSc6IGZhbHNlLFxcbiAgICAgICAgJ2RhdGEtaXMtZm9jdXMnOiBmYWxzZSxcXG4gICAgICAgICdpZCc6IGlkXFxuICAgICAgfSk7XFxuICAgICAgcmV0dXJuICR0ZW1wbGF0ZTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogc2V0cyB0aGUgcG9zaXRpb24gY2xhc3Mgb2YgYW4gZWxlbWVudCBhbmQgcmVjdXJzaXZlbHkgY2FsbHMgaXRzZWxmIHVudGlsIHRoZXJlIGFyZSBubyBtb3JlIHBvc3NpYmxlIHBvc2l0aW9ucyB0byBhdHRlbXB0LCBvciB0aGUgdG9vbHRpcCBlbGVtZW50IGlzIG5vIGxvbmdlciBjb2xsaWRpbmcuXFxuICAgICAqIGlmIHRoZSB0b29sdGlwIGlzIGxhcmdlciB0aGFuIHRoZSBzY3JlZW4gd2lkdGgsIGRlZmF1bHQgdG8gZnVsbCB3aWR0aCAtIGFueSB1c2VyIHNlbGVjdGVkIG1hcmdpblxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAnX3NldFBvc2l0aW9uJyxcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRQb3NpdGlvbigpIHtcXG4gICAgICBfZ2V0KFRvb2x0aXAucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVG9vbHRpcC5wcm90b3R5cGUpLCAnX3NldFBvc2l0aW9uJywgdGhpcykuY2FsbCh0aGlzLCB0aGlzLiRlbGVtZW50LCB0aGlzLnRlbXBsYXRlKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogcmV2ZWFscyB0aGUgdG9vbHRpcCwgYW5kIGZpcmVzIGFuIGV2ZW50IHRvIGNsb3NlIGFueSBvdGhlciBvcGVuIHRvb2x0aXBzIG9uIHRoZSBwYWdlXFxuICAgICAqIEBmaXJlcyBUb29sdGlwI2Nsb3NlbWVcXG4gICAgICogQGZpcmVzIFRvb2x0aXAjc2hvd1xcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogJ3Nob3cnLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2hvdygpIHtcXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnNob3dPbiAhPT0gJ2FsbCcgJiYgIV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fZm91bmRhdGlvbl91dGlsX21lZGlhUXVlcnlfX1tcXFwiYVxcXCIgLyogTWVkaWFRdWVyeSAqL10uaXModGhpcy5vcHRpb25zLnNob3dPbikpIHtcXG4gICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJ1RoZSBzY3JlZW4gaXMgdG9vIHNtYWxsIHRvIGRpc3BsYXkgdGhpcyB0b29sdGlwJyk7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuICAgICAgdGhpcy50ZW1wbGF0ZS5jc3MoJ3Zpc2liaWxpdHknLCAnaGlkZGVuJykuc2hvdygpO1xcbiAgICAgIHRoaXMuX3NldFBvc2l0aW9uKCk7XFxuICAgICAgdGhpcy50ZW1wbGF0ZS5yZW1vdmVDbGFzcygndG9wIGJvdHRvbSBsZWZ0IHJpZ2h0JykuYWRkQ2xhc3ModGhpcy5wb3NpdGlvbik7XFxuICAgICAgdGhpcy50ZW1wbGF0ZS5yZW1vdmVDbGFzcygnYWxpZ24tdG9wIGFsaWduLWJvdHRvbSBhbGlnbi1sZWZ0IGFsaWduLXJpZ2h0IGFsaWduLWNlbnRlcicpLmFkZENsYXNzKCdhbGlnbi0nICsgdGhpcy5hbGlnbm1lbnQpO1xcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIEZpcmVzIHRvIGNsb3NlIGFsbCBvdGhlciBvcGVuIHRvb2x0aXBzIG9uIHRoZSBwYWdlXFxuICAgICAgICogQGV2ZW50IENsb3NlbWUjdG9vbHRpcFxcbiAgICAgICAqL1xcbiAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignY2xvc2VtZS56Zi50b29sdGlwJywgdGhpcy50ZW1wbGF0ZS5hdHRyKCdpZCcpKTtcXG5cXG4gICAgICB0aGlzLnRlbXBsYXRlLmF0dHIoe1xcbiAgICAgICAgJ2RhdGEtaXMtYWN0aXZlJzogdHJ1ZSxcXG4gICAgICAgICdhcmlhLWhpZGRlbic6IGZhbHNlXFxuICAgICAgfSk7XFxuICAgICAgX3RoaXMuaXNBY3RpdmUgPSB0cnVlO1xcbiAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMudGVtcGxhdGUpO1xcbiAgICAgIHRoaXMudGVtcGxhdGUuc3RvcCgpLmhpZGUoKS5jc3MoJ3Zpc2liaWxpdHknLCAnJykuZmFkZUluKHRoaXMub3B0aW9ucy5mYWRlSW5EdXJhdGlvbiwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgLy9tYXliZSBkbyBzdHVmZj9cXG4gICAgICB9KTtcXG4gICAgICAvKipcXG4gICAgICAgKiBGaXJlcyB3aGVuIHRoZSB0b29sdGlwIGlzIHNob3duXFxuICAgICAgICogQGV2ZW50IFRvb2x0aXAjc2hvd1xcbiAgICAgICAqL1xcbiAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignc2hvdy56Zi50b29sdGlwJyk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIEhpZGVzIHRoZSBjdXJyZW50IHRvb2x0aXAsIGFuZCByZXNldHMgdGhlIHBvc2l0aW9uaW5nIGNsYXNzIGlmIGl0IHdhcyBjaGFuZ2VkIGR1ZSB0byBjb2xsaXNpb25cXG4gICAgICogQGZpcmVzIFRvb2x0aXAjaGlkZVxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogJ2hpZGUnLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGlkZSgpIHtcXG4gICAgICAvLyBjb25zb2xlLmxvZygnaGlkaW5nJywgdGhpcy4kZWxlbWVudC5kYXRhKCd5ZXRpLWJveCcpKTtcXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xcbiAgICAgIHRoaXMudGVtcGxhdGUuc3RvcCgpLmF0dHIoe1xcbiAgICAgICAgJ2FyaWEtaGlkZGVuJzogdHJ1ZSxcXG4gICAgICAgICdkYXRhLWlzLWFjdGl2ZSc6IGZhbHNlXFxuICAgICAgfSkuZmFkZU91dCh0aGlzLm9wdGlvbnMuZmFkZU91dER1cmF0aW9uLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICBfdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xcbiAgICAgICAgX3RoaXMuaXNDbGljayA9IGZhbHNlO1xcbiAgICAgIH0pO1xcbiAgICAgIC8qKlxcbiAgICAgICAqIGZpcmVzIHdoZW4gdGhlIHRvb2x0aXAgaXMgaGlkZGVuXFxuICAgICAgICogQGV2ZW50IFRvb2x0aXAjaGlkZVxcbiAgICAgICAqL1xcbiAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignaGlkZS56Zi50b29sdGlwJyk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIGFkZHMgZXZlbnQgbGlzdGVuZXJzIGZvciB0aGUgdG9vbHRpcCBhbmQgaXRzIGFuY2hvclxcbiAgICAgKiBUT0RPIGNvbWJpbmUgc29tZSBvZiB0aGUgbGlzdGVuZXJzIGxpa2UgZm9jdXMgYW5kIG1vdXNlZW50ZXIsIGV0Yy5cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogJ19ldmVudHMnLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2V2ZW50cygpIHtcXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xcbiAgICAgIHZhciAkdGVtcGxhdGUgPSB0aGlzLnRlbXBsYXRlO1xcbiAgICAgIHZhciBpc0ZvY3VzID0gZmFsc2U7XFxuXFxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuZGlzYWJsZUhvdmVyKSB7XFxuXFxuICAgICAgICB0aGlzLiRlbGVtZW50Lm9uKCdtb3VzZWVudGVyLnpmLnRvb2x0aXAnLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgICBpZiAoIV90aGlzLmlzQWN0aXZlKSB7XFxuICAgICAgICAgICAgX3RoaXMudGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgX3RoaXMuc2hvdygpO1xcbiAgICAgICAgICAgIH0sIF90aGlzLm9wdGlvbnMuaG92ZXJEZWxheSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0pLm9uKCdtb3VzZWxlYXZlLnpmLnRvb2x0aXAnLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgICBjbGVhclRpbWVvdXQoX3RoaXMudGltZW91dCk7XFxuICAgICAgICAgIGlmICghaXNGb2N1cyB8fCBfdGhpcy5pc0NsaWNrICYmICFfdGhpcy5vcHRpb25zLmNsaWNrT3Blbikge1xcbiAgICAgICAgICAgIF90aGlzLmhpZGUoKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuY2xpY2tPcGVuKSB7XFxuICAgICAgICB0aGlzLiRlbGVtZW50Lm9uKCdtb3VzZWRvd24uemYudG9vbHRpcCcsIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XFxuICAgICAgICAgIGlmIChfdGhpcy5pc0NsaWNrKSB7XFxuICAgICAgICAgICAgLy9fdGhpcy5oaWRlKCk7XFxuICAgICAgICAgICAgLy8gX3RoaXMuaXNDbGljayA9IGZhbHNlO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIF90aGlzLmlzQ2xpY2sgPSB0cnVlO1xcbiAgICAgICAgICAgIGlmICgoX3RoaXMub3B0aW9ucy5kaXNhYmxlSG92ZXIgfHwgIV90aGlzLiRlbGVtZW50LmF0dHIoJ3RhYmluZGV4JykpICYmICFfdGhpcy5pc0FjdGl2ZSkge1xcbiAgICAgICAgICAgICAgX3RoaXMuc2hvdygpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHRoaXMuJGVsZW1lbnQub24oJ21vdXNlZG93bi56Zi50b29sdGlwJywgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcXG4gICAgICAgICAgX3RoaXMuaXNDbGljayA9IHRydWU7XFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuZGlzYWJsZUZvclRvdWNoKSB7XFxuICAgICAgICB0aGlzLiRlbGVtZW50Lm9uKCd0YXAuemYudG9vbHRpcCB0b3VjaGVuZC56Zi50b29sdGlwJywgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgICAgX3RoaXMuaXNBY3RpdmUgPyBfdGhpcy5oaWRlKCkgOiBfdGhpcy5zaG93KCk7XFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy4kZWxlbWVudC5vbih7XFxuICAgICAgICAvLyAndG9nZ2xlLnpmLnRyaWdnZXInOiB0aGlzLnRvZ2dsZS5iaW5kKHRoaXMpLFxcbiAgICAgICAgLy8gJ2Nsb3NlLnpmLnRyaWdnZXInOiB0aGlzLmhpZGUuYmluZCh0aGlzKVxcbiAgICAgICAgJ2Nsb3NlLnpmLnRyaWdnZXInOiB0aGlzLmhpZGUuYmluZCh0aGlzKVxcbiAgICAgIH0pO1xcblxcbiAgICAgIHRoaXMuJGVsZW1lbnQub24oJ2ZvY3VzLnpmLnRvb2x0aXAnLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgaXNGb2N1cyA9IHRydWU7XFxuICAgICAgICBpZiAoX3RoaXMuaXNDbGljaykge1xcbiAgICAgICAgICAvLyBJZiB3ZSdyZSBub3Qgc2hvd2luZyBvcGVuIG9uIGNsaWNrcywgd2UgbmVlZCB0byBwcmV0ZW5kIGEgY2xpY2stbGF1bmNoZWQgZm9jdXMgaXNuJ3RcXG4gICAgICAgICAgLy8gYSByZWFsIGZvY3VzLCBvdGhlcndpc2Ugb24gaG92ZXIgYW5kIGNvbWUgYmFjayB3ZSBnZXQgYmFkIGJlaGF2aW9yXFxuICAgICAgICAgIGlmICghX3RoaXMub3B0aW9ucy5jbGlja09wZW4pIHtcXG4gICAgICAgICAgICBpc0ZvY3VzID0gZmFsc2U7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgX3RoaXMuc2hvdygpO1xcbiAgICAgICAgfVxcbiAgICAgIH0pLm9uKCdmb2N1c291dC56Zi50b29sdGlwJywgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgIGlzRm9jdXMgPSBmYWxzZTtcXG4gICAgICAgIF90aGlzLmlzQ2xpY2sgPSBmYWxzZTtcXG4gICAgICAgIF90aGlzLmhpZGUoKTtcXG4gICAgICB9KS5vbigncmVzaXplbWUuemYudHJpZ2dlcicsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGlmIChfdGhpcy5pc0FjdGl2ZSkge1xcbiAgICAgICAgICBfdGhpcy5fc2V0UG9zaXRpb24oKTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogYWRkcyBhIHRvZ2dsZSBtZXRob2QsIGluIGFkZGl0aW9uIHRvIHRoZSBzdGF0aWMgc2hvdygpICYgaGlkZSgpIGZ1bmN0aW9uc1xcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogJ3RvZ2dsZScsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b2dnbGUoKSB7XFxuICAgICAgaWYgKHRoaXMuaXNBY3RpdmUpIHtcXG4gICAgICAgIHRoaXMuaGlkZSgpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB0aGlzLnNob3coKTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIERlc3Ryb3lzIGFuIGluc3RhbmNlIG9mIHRvb2x0aXAsIHJlbW92ZXMgdGVtcGxhdGUgZWxlbWVudCBmcm9tIHRoZSB2aWV3LlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogJ19kZXN0cm95JyxcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZXN0cm95KCkge1xcbiAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cigndGl0bGUnLCB0aGlzLnRlbXBsYXRlLnRleHQoKSkub2ZmKCcuemYudHJpZ2dlciAuemYudG9vbHRpcCcpLnJlbW92ZUNsYXNzKCdoYXMtdGlwIHRvcCByaWdodCBsZWZ0JykucmVtb3ZlQXR0cignYXJpYS1kZXNjcmliZWRieSBhcmlhLWhhc3BvcHVwIGRhdGEtZGlzYWJsZS1ob3ZlciBkYXRhLXJlc2l6ZSBkYXRhLXRvZ2dsZSBkYXRhLXRvb2x0aXAgZGF0YS15ZXRpLWJveCcpO1xcblxcbiAgICAgIHRoaXMudGVtcGxhdGUucmVtb3ZlKCk7XFxuICAgIH1cXG4gIH1dKTtcXG5cXG4gIHJldHVybiBUb29sdGlwO1xcbn0oX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19mb3VuZGF0aW9uX3Bvc2l0aW9uYWJsZV9fW1xcXCJhXFxcIiAvKiBQb3NpdGlvbmFibGUgKi9dKTtcXG5cXG5Ub29sdGlwLmRlZmF1bHRzID0ge1xcbiAgZGlzYWJsZUZvclRvdWNoOiBmYWxzZSxcXG4gIC8qKlxcbiAgICogVGltZSwgaW4gbXMsIGJlZm9yZSBhIHRvb2x0aXAgc2hvdWxkIG9wZW4gb24gaG92ZXIuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7bnVtYmVyfVxcbiAgICogQGRlZmF1bHQgMjAwXFxuICAgKi9cXG4gIGhvdmVyRGVsYXk6IDIwMCxcXG4gIC8qKlxcbiAgICogVGltZSwgaW4gbXMsIGEgdG9vbHRpcCBzaG91bGQgdGFrZSB0byBmYWRlIGludG8gdmlldy5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtudW1iZXJ9XFxuICAgKiBAZGVmYXVsdCAxNTBcXG4gICAqL1xcbiAgZmFkZUluRHVyYXRpb246IDE1MCxcXG4gIC8qKlxcbiAgICogVGltZSwgaW4gbXMsIGEgdG9vbHRpcCBzaG91bGQgdGFrZSB0byBmYWRlIG91dCBvZiB2aWV3LlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge251bWJlcn1cXG4gICAqIEBkZWZhdWx0IDE1MFxcbiAgICovXFxuICBmYWRlT3V0RHVyYXRpb246IDE1MCxcXG4gIC8qKlxcbiAgICogRGlzYWJsZXMgaG92ZXIgZXZlbnRzIGZyb20gb3BlbmluZyB0aGUgdG9vbHRpcCBpZiBzZXQgdG8gdHJ1ZVxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge2Jvb2xlYW59XFxuICAgKiBAZGVmYXVsdCBmYWxzZVxcbiAgICovXFxuICBkaXNhYmxlSG92ZXI6IGZhbHNlLFxcbiAgLyoqXFxuICAgKiBPcHRpb25hbCBhZGR0aW9uYWwgY2xhc3NlcyB0byBhcHBseSB0byB0aGUgdG9vbHRpcCB0ZW1wbGF0ZSBvbiBpbml0LlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge3N0cmluZ31cXG4gICAqIEBkZWZhdWx0ICcnXFxuICAgKi9cXG4gIHRlbXBsYXRlQ2xhc3NlczogJycsXFxuICAvKipcXG4gICAqIE5vbi1vcHRpb25hbCBjbGFzcyBhZGRlZCB0byB0b29sdGlwIHRlbXBsYXRlcy4gRm91bmRhdGlvbiBkZWZhdWx0IGlzICd0b29sdGlwJy5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtzdHJpbmd9XFxuICAgKiBAZGVmYXVsdCAndG9vbHRpcCdcXG4gICAqL1xcbiAgdG9vbHRpcENsYXNzOiAndG9vbHRpcCcsXFxuICAvKipcXG4gICAqIENsYXNzIGFwcGxpZWQgdG8gdGhlIHRvb2x0aXAgYW5jaG9yIGVsZW1lbnQuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7c3RyaW5nfVxcbiAgICogQGRlZmF1bHQgJ2hhcy10aXAnXFxuICAgKi9cXG4gIHRyaWdnZXJDbGFzczogJ2hhcy10aXAnLFxcbiAgLyoqXFxuICAgKiBNaW5pbXVtIGJyZWFrcG9pbnQgc2l6ZSBhdCB3aGljaCB0byBvcGVuIHRoZSB0b29sdGlwLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge3N0cmluZ31cXG4gICAqIEBkZWZhdWx0ICdzbWFsbCdcXG4gICAqL1xcbiAgc2hvd09uOiAnc21hbGwnLFxcbiAgLyoqXFxuICAgKiBDdXN0b20gdGVtcGxhdGUgdG8gYmUgdXNlZCB0byBnZW5lcmF0ZSBtYXJrdXAgZm9yIHRvb2x0aXAuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7c3RyaW5nfVxcbiAgICogQGRlZmF1bHQgJydcXG4gICAqL1xcbiAgdGVtcGxhdGU6ICcnLFxcbiAgLyoqXFxuICAgKiBUZXh0IGRpc3BsYXllZCBpbiB0aGUgdG9vbHRpcCB0ZW1wbGF0ZSBvbiBvcGVuLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge3N0cmluZ31cXG4gICAqIEBkZWZhdWx0ICcnXFxuICAgKi9cXG4gIHRpcFRleHQ6ICcnLFxcbiAgdG91Y2hDbG9zZVRleHQ6ICdUYXAgdG8gY2xvc2UuJyxcXG4gIC8qKlxcbiAgICogQWxsb3dzIHRoZSB0b29sdGlwIHRvIHJlbWFpbiBvcGVuIGlmIHRyaWdnZXJlZCB3aXRoIGEgY2xpY2sgb3IgdG91Y2ggZXZlbnQuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IHRydWVcXG4gICAqL1xcbiAgY2xpY2tPcGVuOiB0cnVlLFxcbiAgLyoqXFxuICAgKiBERVBSRUNBVEVEIEFkZGl0aW9uYWwgcG9zaXRpb25pbmcgY2xhc3Nlcywgc2V0IGJ5IHRoZSBKU1xcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge3N0cmluZ31cXG4gICAqIEBkZWZhdWx0ICcnXFxuICAgKi9cXG4gIHBvc2l0aW9uQ2xhc3M6ICcnLFxcbiAgLyoqXFxuICAgKiBQb3NpdGlvbiBvZiB0b29sdGlwLiBDYW4gYmUgbGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBvciBhdXRvLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge3N0cmluZ31cXG4gICAqIEBkZWZhdWx0ICdhdXRvJ1xcbiAgICovXFxuICBwb3NpdGlvbjogJ2F1dG8nLFxcbiAgLyoqXFxuICAgKiBBbGlnbm1lbnQgb2YgdG9vbHRpcCByZWxhdGl2ZSB0byBhbmNob3IuIENhbiBiZSBsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIGNlbnRlciwgb3IgYXV0by5cXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtzdHJpbmd9XFxuICAgKiBAZGVmYXVsdCAnYXV0bydcXG4gICAqL1xcbiAgYWxpZ25tZW50OiAnYXV0bycsXFxuICAvKipcXG4gICAqIEFsbG93IG92ZXJsYXAgb2YgY29udGFpbmVyL3dpbmRvdy4gSWYgZmFsc2UsIHRvb2x0aXAgd2lsbCBmaXJzdCB0cnkgdG9cXG4gICAqIHBvc2l0aW9uIGFzIGRlZmluZWQgYnkgZGF0YS1wb3NpdGlvbiBhbmQgZGF0YS1hbGlnbm1lbnQsIGJ1dCByZXBvc2l0aW9uIGlmXFxuICAgKiBpdCB3b3VsZCBjYXVzZSBhbiBvdmVyZmxvdy4gIEBvcHRpb25cXG4gICAqIEB0eXBlIHtib29sZWFufVxcbiAgICogQGRlZmF1bHQgZmFsc2VcXG4gICAqL1xcbiAgYWxsb3dPdmVybGFwOiBmYWxzZSxcXG4gIC8qKlxcbiAgICogQWxsb3cgb3ZlcmxhcCBvZiBvbmx5IHRoZSBib3R0b20gb2YgdGhlIGNvbnRhaW5lci4gVGhpcyBpcyB0aGUgbW9zdCBjb21tb25cXG4gICAqIGJlaGF2aW9yIGZvciBkcm9wZG93bnMsIGFsbG93aW5nIHRoZSBkcm9wZG93biB0byBleHRlbmQgdGhlIGJvdHRvbSBvZiB0aGVcXG4gICAqIHNjcmVlbiBidXQgbm90IG90aGVyd2lzZSBpbmZsdWVuY2Ugb3IgYnJlYWsgb3V0IG9mIHRoZSBjb250YWluZXIuXFxuICAgKiBMZXNzIGNvbW1vbiBmb3IgdG9vbHRpcHMuXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cXG4gICAqIEBkZWZhdWx0IGZhbHNlXFxuICAgKi9cXG4gIGFsbG93Qm90dG9tT3ZlcmxhcDogZmFsc2UsXFxuICAvKipcXG4gICAqIERpc3RhbmNlLCBpbiBwaXhlbHMsIHRoZSB0ZW1wbGF0ZSBzaG91bGQgcHVzaCBhd2F5IGZyb20gdGhlIGFuY2hvciBvbiB0aGUgWSBheGlzLlxcbiAgICogQG9wdGlvblxcbiAgICogQHR5cGUge251bWJlcn1cXG4gICAqIEBkZWZhdWx0IDBcXG4gICAqL1xcbiAgdk9mZnNldDogMCxcXG4gIC8qKlxcbiAgICogRGlzdGFuY2UsIGluIHBpeGVscywgdGhlIHRlbXBsYXRlIHNob3VsZCBwdXNoIGF3YXkgZnJvbSB0aGUgYW5jaG9yIG9uIHRoZSBYIGF4aXNcXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtudW1iZXJ9XFxuICAgKiBAZGVmYXVsdCAwXFxuICAgKi9cXG4gIGhPZmZzZXQ6IDAsXFxuICAvKipcXG4gICAqIERpc3RhbmNlLCBpbiBwaXhlbHMsIHRoZSB0ZW1wbGF0ZSBzcGFjaW5nIGF1dG8tYWRqdXN0IGZvciBhIHZlcnRpY2FsIHRvb2x0aXBcXG4gICAqIEBvcHRpb25cXG4gICAqIEB0eXBlIHtudW1iZXJ9XFxuICAgKiBAZGVmYXVsdCAxNFxcbiAgICovXFxuICB0b29sdGlwSGVpZ2h0OiAxNCxcXG4gIC8qKlxcbiAgICogRGlzdGFuY2UsIGluIHBpeGVscywgdGhlIHRlbXBsYXRlIHNwYWNpbmcgYXV0by1hZGp1c3QgZm9yIGEgaG9yaXpvbnRhbCB0b29sdGlwXFxuICAgKiBAb3B0aW9uXFxuICAgKiBAdHlwZSB7bnVtYmVyfVxcbiAgICogQGRlZmF1bHQgMTJcXG4gICAqL1xcbiAgdG9vbHRpcFdpZHRoOiAxMixcXG4gIC8qKlxcbiAgKiBBbGxvdyBIVE1MIGluIHRvb2x0aXAuIFdhcm5pbmc6IElmIHlvdSBhcmUgbG9hZGluZyB1c2VyLWdlbmVyYXRlZCBjb250ZW50IGludG8gdG9vbHRpcHMsXFxuICAqIGFsbG93aW5nIEhUTUwgbWF5IG9wZW4geW91cnNlbGYgdXAgdG8gWFNTIGF0dGFja3MuXFxuICAqIEBvcHRpb25cXG4gICogQHR5cGUge2Jvb2xlYW59XFxuICAqIEBkZWZhdWx0IGZhbHNlXFxuICAqL1xcbiAgYWxsb3dIdG1sOiBmYWxzZVxcbn07XFxuXFxuLyoqXFxuICogVE9ETyB1dGlsaXplIHJlc2l6ZSBldmVudCB0cmlnZ2VyXFxuICovXFxuXFxuXFxuXFxuLyoqKi8gfSksXFxuLyogMzYgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcXG5cXG5cXG4vKioqLyB9KVxcbi8qKioqKiovIF0pO1wiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmF3LWxvYWRlciEuL25vZGVfbW9kdWxlcy9mb3VuZGF0aW9uLXNpdGVzL2Rpc3QvanMvZm91bmRhdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5\n");

/***/ }),
/* 6 */
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zY3NzL2FwcC5zY3NzPzdiOTAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiNi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zY3NzL2FwcC5zY3NzXG4vLyBtb2R1bGUgaWQgPSA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6\n");

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("$(function(){'use strict';console.log('header');});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9tb2R1bGVzL19oZWFkZXIuanM/OWMxOCJdLCJuYW1lcyI6WyIkIiwiY29uc29sZSIsImxvZyJdLCJtYXBwaW5ncyI6IkFBQUFBLEVBQUUsVUFBVyxDQUNYLGFBRUFDLFFBQVFDLEdBQVIsQ0FBWSxRQUFaLEVBQ0QsQ0FKRCIsImZpbGUiOiI3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJChmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnXG5cbiAgY29uc29sZS5sb2coJ2hlYWRlcicpXG59KVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2pzL21vZHVsZXMvX2hlYWRlci5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7\n");

/***/ })
/******/ ]);